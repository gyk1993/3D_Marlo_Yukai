/*
 * Walking01_withElmos.c
 *
 * Code generation for model "Walking01_withElmos".
 *
 * Model version              : 1.1128
 * Simulink Coder version : 8.7 (R2014b) 08-Sep-2014
 * C source code generated on : Mon Jun 08 18:00:32 2015
 *
 * Target selection: slrt.tlc
 * Note: GRT includes extra infrastructure and instrumentation for prototyping
 * Embedded hardware selection: Generic->32-bit x86 compatible
 * Code generation objectives: Unspecified
 * Validation result: Not run
 */
#include "rt_logging_mmi.h"
#include "Walking01_withElmos_capi.h"
#include "Walking01_withElmos.h"
#include "Walking01_withElmos_private.h"
#include "Walking01_withElmos_dt.h"

/* Named constants for Chart: '<S24>/AnomalyDetection' */
#define Walking01_wi_IN_NO_ACTIVE_CHILD ((uint8_T)0U)
#define Walking01_withE_IN_MissedPacket ((uint8_T)2U)
#define Walking01_withElmo_CALL_EVENT_i (-1)
#define Walking01_withElmos_IN_Error   ((uint8_T)1U)
#define Walking01_withElmos_IN_Init    ((uint8_T)1U)
#define Walking01_withElmos_IN_Nominal ((uint8_T)3U)
#define Walking01_withElmos_IN_Run     ((uint8_T)2U)

/* Named constants for Chart: '<S35>/Chart' */
#define Walking01__IN_NO_ACTIVE_CHILD_b ((uint8_T)0U)
#define Walking01_w_IN_SwitchOnDisabled ((uint8_T)3U)
#define Walking01_wi_IN_ReadyToSwitchOn ((uint8_T)2U)
#define Walking01_wit_IN_Initialization ((uint8_T)2U)
#define Walking01_withE_IN_FaultRunning ((uint8_T)1U)
#define Walking01_withElmo_CALL_EVENT_k (-1)
#define Walking01_withElmos_IN_Fault   ((uint8_T)1U)
#define Walking01_withElmos_IN_Running ((uint8_T)3U)
#define Walking01_withElmos_IN_Start1  ((uint8_T)4U)

/* Named constants for Chart: '<S117>/AnomalyDetection' */
#define Walking01__IN_NO_ACTIVE_CHILD_f ((uint8_T)0U)
#define Walking01_withElmo_CALL_EVENT_e (-1)
#define Walking01_withElmo_IN_Nominal_c ((uint8_T)2U)
#define Walking01_withElmos_IN_Error_e ((uint8_T)1U)
#define Walking01_withElmos_IN_Init_j  ((uint8_T)1U)
#define Walking01_withElmos_IN_Run_c   ((uint8_T)2U)

/* Named constants for Chart: '<S34>/Chart' */
#define Walking01_IN_SwitchOnDisabled_e ((uint8_T)3U)
#define Walking01__IN_NO_ACTIVE_CHILD_j ((uint8_T)0U)
#define Walking01__IN_ReadyToSwitchOn_n ((uint8_T)2U)
#define Walking01_w_IN_Initialization_e ((uint8_T)2U)
#define Walking01_wit_IN_FaultRunning_g ((uint8_T)1U)
#define Walking01_withElmo_IN_Running_j ((uint8_T)3U)
#define Walking01_withElmos_IN_Fault_d ((uint8_T)1U)
#define Walking01_withElmos_IN_Start1_d ((uint8_T)4U)

/* Named constants for Chart: '<S202>/StateLogic' */
#define Walking01_w_event_ControlUpdate (1)
#define Walking01_withE_event_LegImpact (2)
#define Walking01_withEl_IN_RightDouble ((uint8_T)4U)
#define Walking01_withEl_IN_RightSingle ((uint8_T)5U)
#define Walking01_withElm_IN_LeftDouble ((uint8_T)1U)
#define Walking01_withElm_IN_LeftSingle ((uint8_T)2U)
#define Walking01_withElm_IN_Transition ((uint8_T)3U)
#define Walking01_withElm_event_LegSwap (0)
#define Walking01_withElmo_IN_Injection ((uint8_T)1U)
#define Walking01_withElmo_IN_RightWait ((uint8_T)6U)
#define Walking01_withElmo_IN_Running_e ((uint8_T)2U)
#define Walking01_withElmo_IN_Unchanged ((uint8_T)2U)
#define Walking01_withElmos_IN_Changed ((uint8_T)1U)
#define Walking01_withElmos_IN_Early   ((uint8_T)1U)
#define Walking01_withElmos_IN_Error_a ((uint8_T)1U)
#define Walking01_withElmos_IN_Idle    ((uint8_T)1U)
#define Walking01_withElmos_IN_Late    ((uint8_T)2U)
#define Walking01_withElmos_IN_LeftWait ((uint8_T)3U)
#define Walking01_withElmos_IN_Mid     ((uint8_T)3U)
#define Walking01_withElmos_IN_Posing  ((uint8_T)2U)
#define Walking01_withElmos_IN_Reset   ((uint8_T)2U)
#define Walking01_withElmos_IN_Run_k   ((uint8_T)3U)
#define Walking01_withElmos_IN_Wait    ((uint8_T)4U)
#define Walking01_withElmos_IN_Walking ((uint8_T)4U)

const DiscreteParamsBus Walking01_withElmos_rtZDiscreteParamsBus = {
  0.0,                                 /* TLastUpdate */
  0.0,                                 /* VelocityControlLADelta */
  0.0,                                 /* VelocityControlTorsoDelta */
  0.0,                                 /* VelocityControlHipDistCur */
  0.0,                                 /* VelocityControlHipDistPrev */
  0.0,                                 /* VirtualSpringMode */
  0.0,                                 /* VirtualSpringStiffness */
  0.0,                                 /* VirtualSpringDamping */
  0.0,                                 /* VirtualSpringModAmplitude */
  0.0,                                 /* VirtualSpringModRate */
  0.0                                  /* VirtualSpringRestPos */
} ;                                    /* DiscreteParamsBus ground */

/* Block signals (auto storage) */
B_Walking01_withElmos_T Walking01_withElmos_B;

/* Block states (auto storage) */
DW_Walking01_withElmos_T Walking01_withElmos_DW;

/* External outputs (root outports fed by signals with auto storage) */
ExtY_Walking01_withElmos_T Walking01_withElmos_Y;

/* Real-time model */
RT_MODEL_Walking01_withElmos_T Walking01_withElmos_M_;
RT_MODEL_Walking01_withElmos_T *const Walking01_withElmos_M =
  &Walking01_withElmos_M_;

/* Forward declaration for local functions */
static boolean_T Walking01_withElmos_check_error(real_T rtu_q, const real_T
  rtu_q_limits[2], real_T rtu_Threshold, B_AnomalyDetection_Walking01__T *localB);

/* Forward declaration for local functions */
static boolean_T Walking01_withElm_check_error_g(real_T rtu_q, const real_T
  rtu_q_limits[2], real_T rtu_Threshold, B_AnomalyDetection_Walking0_h_T *localB);

/* Forward declaration for local functions */
static void Walking01_withElmos_eml_li_find(const boolean_T x[2], int32_T
  y_data[], int32_T *y_sizes);
static void Walking01_withElm_eml_li_find_k(const boolean_T x[9], int32_T
  y_data[], int32_T *y_sizes);
static void Walking01_with_ATRIAS3D_ZD_s6_b(real_T t, const real_T q[13], const
  real_T dq[13], const real_T theta_limits[2], const real_T c[15], real_T *s,
  real_T *ds, real_T dsdq[13], real_T *th, real_T *dth, real_T *delta_theta);
static void Walking01_withEl_eml_li_find_en(boolean_T x, int32_T y_data[],
  int32_T y_sizes[2]);
static void Walking01_withElmos_updateS(real_T t);
static real_T Walking01_withElmo_checkSupport(real_T WhichLeg);
static void Walkin_enter_atomic_RightSingle(void);
static boolean_T Walking01_withElmos_checkMode(void);
static boolean_T Walking01_withElmos_checkImpact(void);
static boolean_T Walking01_withE_checkTransition(void);
static void Walking01_wi_applyGaitTweaks2_p(real_T ControlState_ControllerMode,
  const real_T ControlParams_Supervisory_GaitT[5], const real_T
  ControlParams_Output_H0[78], real_T HAlpha[36]);
static void Walking01_withElmos_elevate1(const real_T alpha_data[], const
  int32_T alpha_sizes[2], real_T M, real_T alpha_out_data[], int32_T
  alpha_out_sizes[2]);
static void Walking01_computeLateralControl(const real_T q[13], real_T
  stance_leg, real_T h_alpha[36], real_T ControlState_StepCount, real_T
  ControlParams_Supervisory_Torso, real_T ControlParams_Feedback_kp_lat, real_T
  ControlParams_Feedback_q3d_min_, real_T ControlParams_Feedback_q3d_max_,
  real_T ControlParams_Feedback_w_torso_, real_T ControlParams_Feedback_LateralC,
  real_T ControlParams_Feedback_lat_bias, real_T ControlParams_Feedback_lat_bi_0);
static void Walking01_withE_eml_li_find_enu(const boolean_T x[6], int32_T
  y_data[], int32_T *y_sizes);
static void Walking01_withElmos_bezierv_a(const real_T alpha[36], real_T s,
  real_T value[6]);
static void Walking01_withElmos_sat_iu(const real_T x[6], const real_T lo[6],
  const real_T hi[6], real_T y[6]);
static void Walking01_withElmos_polyv_d(const real_T poly_cor[30], real_T s,
  real_T s_corr_max, real_T value[6]);
static void Walking0_ATRIAS3D_ZD_Output02_j(real_T t, const real_T q[13], const
  real_T dq[13], real_T ControlState_StanceLeg, const real_T Output_H0[78],
  const real_T Output_HAlpha[36], const real_T Output_ThetaLimits[2], real_T
  Output_Theta_c0, real_T Output_Theta_ct, const real_T Output_Theta_cq[13],
  real_T Output_SaturateS, real_T Output_UseCorrection, real_T
  Output_SMaxCorrection, const real_T Output_HAlphaCorrection[30], real_T *s,
  real_T *ds, real_T h0[6], real_T y[6]);
static void Walking01_withElmos_beziervd_k(const real_T afra[36], real_T s,
  real_T value[6]);
static real_T Walking01_withElmos_bezier_f(const real_T afra[20], real_T s);
static void Walking01_withElmos_polyvd_l(const real_T poly_cor[30], real_T s,
  real_T s_corr_max, real_T value[6]);
static void Walking01_withElmos_sat_i(const real_T x[6], const real_T lo[6],
  const real_T hi[6], real_T y[6]);
static boolean_T Walking01_withElmos_any_d(boolean_T x);
static void Walking0_ATRIAS3D_ZD_Output03_c(real_T t, const real_T q[13], const
  real_T dq[13], real_T ControlState_StanceLeg, const OutputParamsBus
  *ControlParams_Output, real_T *s, real_T *ds, real_T h0[6], real_T y[6],
  real_T dy[6], real_T jacob_h0[78], real_T jacob_h[78], real_T *s_unsaturated,
  real_T *theta);
static void Walking_beziertableinterpolate2(real_T spPlusCurrent, real_T
  controlNum, real_T halphaInterpolated[24]);
static void Walking01_updateVelocityControl(real_T t, const real_T q[13], real_T
  ControlState_StanceLeg, real_T ControlParams_Supervisory_Veloc, real_T
  ControlParams_Supervisory_Vel_0, real_T ControlParams_Supervisory_Vel_1,
  real_T ControlParams_Supervisory_Vel_2, const DiscreteParamsBus
  *ControlParams_Discrete, DiscreteParamsBus *Discrete);
static void Walking_ATRIAS3D_ZD_Output03_c0(real_T t, const real_T q[13], const
  real_T dq[13], real_T ControlState_StanceLeg, const real_T
  ControlParams_Output_ThetaLimit[2], real_T ControlParams_Output_Theta_c0,
  real_T ControlParams_Output_Theta_ct, const real_T
  ControlParams_Output_Theta_cq[13], real_T ControlParams_Output_Theta_t0,
  real_T ControlParams_Output_SaturateS, const real_T
  ControlParams_Output_SLimits[2], real_T ControlParams_Output_EnforceInc,
  real_T *s, real_T *ds);
static void Walking01__ATRIAS3D_ZD_Output02(real_T t, const real_T q[13], const
  real_T dq[13], real_T ControlState_StanceLeg, const real_T Output_H0[78],
  const real_T Output_HAlpha[36], const real_T Output_ThetaLimits[2], real_T
  Output_Theta_c0, real_T Output_Theta_ct, const real_T Output_Theta_cq[13],
  real_T Output_SaturateS, real_T Output_UseCorrection, real_T
  Output_SMaxCorrection, const real_T Output_HAlphaCorrection[30], real_T *s,
  real_T *ds, real_T h0[6], real_T y[6], real_T dy[6], real_T jacob_h0[78],
  real_T jacob_h[78], real_T *s_unsaturated, real_T *theta);
static void Wal_updateBasicWalkingControl04(real_T t, const real_T q[13], const
  real_T dq[13], real_T ControlState_ControllerMode, real_T
  ControlState_StanceLeg, real_T ControlState_InDoubleSupport, real_T
  ControlState_StepCount, const ControlParamsBus *ControlParams, const
  OutputParamsBus AllOutputs[5], real_T ControlStatePrev_ControllerMode, real_T
  ControlStatePrev_StanceLeg, const ControlParamsBus *ControlParamsPrev,
  OutputParamsBus *Output, DiscreteParamsBus *Discrete);
static void Walking01_withElm_updateControl(real_T t);
static void Walki_serializeControlParamsBus(const ControlParamsBus *S, real_T A
  [476]);
static void Walking01_withElmos_initSerial(real_T t);
static void Walking01_withElmos_sendSerial(real_T t);
static void Walking01_withElmos_Serialize(void);
static real_T Walkin_ATRIAS3D_ZD_Output03_c0j(real_T t, const real_T q[13],
  const real_T dq[13], real_T ControlState_StanceLeg, const ControlParamsBus
  *ControlParams);
static boolean_T Walking01_withElmos_checkError(real_T t);
static void Walking01_withEl_ControllerMode(void);
static void Walking01_withE_updateLegAngles(real_T t, real_T phase);
static void Walking01_withElmos_Run(void);
static void Walking_enter_atomic_LeftSingle(void);
static void Walking01_with_applyGaitTweaks2(real_T ControlState_ControllerMode,
  const real_T ControlParams_Supervisory_GaitT[5], const real_T
  ControlParams_Output_H0[78], const real_T ControlParams_Output_HAlpha[36],
  real_T HAlpha[36]);
static void Walking01_withEl_ATRIAS3D_ZD_s6(real_T t, const real_T q[13], const
  real_T dq[13], const real_T theta_limits[2], const real_T c[15], real_T *s,
  real_T *ds, real_T dsdq[13], real_T *th, real_T *dth, real_T *delta_theta);
static void Walking01_withElm_eml_li_find_e(boolean_T x, int32_T y_data[],
  int32_T y_sizes[2]);
static void Walking01_withEl_eml_li_find_eu(const boolean_T x[6], int32_T
  y_data[], int32_T *y_sizes);
static void Walking01_withElmos_beziervd(const real_T afra[36], real_T s, real_T
  value[6]);
static real_T Walking01_withElmos_bezier(const real_T afra[20], real_T s);
static void Walking01_withElmos_polyvd(const real_T poly_cor[30], real_T s,
  real_T s_corr_max, real_T value[6]);
static void Walking01_withElmos_polyva(const real_T poly_cor[30], real_T s,
  real_T s_corr_max, real_T value[6]);
static void Walking01_withElmos_polyv(const real_T poly_cor[30], real_T s,
  real_T s_corr_max, real_T value[6]);
static void Walking01_withElmos_sat(const real_T x[6], const real_T lo[6], const
  real_T hi[6], real_T y[6]);
static void Walking01_withElmos_bezierva(const real_T alpha[36], real_T s,
  real_T value[6]);
static void Walking01_withElmos_bezierv(const real_T alpha[36], real_T s, real_T
  value[6]);
static boolean_T Walking01_withElmos_any_o(boolean_T x);
static void Walking01__ATRIAS3D_ZD_Output03(real_T t, const real_T q[13], const
  real_T dq[13], real_T ControlState_StanceLeg, const OutputParamsBus
  *ControlParams_Output, real_T sprev, real_T *s, real_T *ds, real_T h0[6],
  real_T y[6], real_T dy[6], real_T jacob_h0[78], real_T jacob_h[78], real_T
  *s_unsaturated, real_T *theta, real_T *dtheta, real_T *delta_theta, real_T
  dsdq[13], real_T jacob_jacobhdqdq[6], real_T *phi, real_T *r, real_T *dr,
  real_T hdbar[6]);
static void Walking01_withElmos_mldivide_p(const real_T A[36], real_T B[6]);
static void LA_LS_Revised_Saturation_Case_1(real_T u_LS, real_T u_LA, real_T w,
  real_T u_opt[2], real_T L_opt[4]);
static void LA_LS_Revised_Saturation_Case_2(real_T u_LS, real_T u_LA, real_T w,
  real_T u1_min, real_T u_opt[2], real_T L_opt[4]);
static void LA_LS_Revised_Saturation_Case_3(real_T u_LS, real_T u_LA, real_T w,
  real_T u1_max, real_T u_opt[2], real_T L_opt[4]);
static void LA_LS_Revised_Saturation_Case_4(real_T u_LS, real_T u_LA, real_T w,
  real_T u2_min, real_T u_opt[2], real_T L_opt[4]);
static void LA_LS_Revised_Saturation_Case_5(real_T u_LS, real_T u_LA, real_T w,
  real_T u2_max, real_T u_opt[2], real_T L_opt[4]);
static void LA_LS_Revised_Saturation_Case_6(real_T u_LS, real_T u_LA, real_T w,
  real_T u1_min, real_T u2_min, real_T u_opt[2], real_T L_opt[4]);
static void LA_LS_Revised_Saturation_Case_7(real_T u_LS, real_T u_LA, real_T w,
  real_T u1_min, real_T u2_max, real_T u_opt[2], real_T L_opt[4]);
static void LA_LS_Revised_Saturation_Case_8(real_T u_LS, real_T u_LA, real_T w,
  real_T u1_max, real_T u2_min, real_T u_opt[2], real_T L_opt[4]);
static void LA_LS_Revised_Saturation_Case_9(real_T u_LS, real_T u_LA, real_T w,
  real_T u1_max, real_T u2_max, real_T u_opt[2], real_T L_opt[4]);
static void Walkin_LA_LS_Revised_Saturation(real_T u_LS, real_T u_LA, real_T w,
  real_T u1_min, real_T u1_max, real_T u2_min, real_T u2_max, real_T u_opt[2]);
static void Walking01_withElmos_mldivide(const real_T A[36], real_T B[6]);
static void Walking_MARLOBasicSafetyLimits2(const real_T q[13], const real_T dq
  [13], boolean_T violation[34]);
static boolean_T Walking01_withElmos_any(const boolean_T x[6]);
static real_T Walking01_withElmos_norm(const real_T x[3]);
static void rate_monotonic_scheduler(void);
time_T rt_SimUpdateDiscreteEvents(
  int_T rtmNumSampTimes, void *rtmTimingData, int_T *rtmSampleHitPtr, int_T
  *rtmPerTaskSampleHits )
{
  rtmSampleHitPtr[1] = rtmStepTask(Walking01_withElmos_M, 1);
  rtmSampleHitPtr[2] = rtmStepTask(Walking01_withElmos_M, 2);
  UNUSED_PARAMETER(rtmNumSampTimes);
  UNUSED_PARAMETER(rtmTimingData);
  UNUSED_PARAMETER(rtmPerTaskSampleHits);
  return(-1);
}

/*
 *   This function updates active task flag for each subrate
 * and rate transition flags for tasks that exchange data.
 * The function assumes rate-monotonic multitasking scheduler.
 * The function must be called at model base rate so that
 * the generated code self-manages all its subrates and rate
 * transition flags.
 */
static void rate_monotonic_scheduler(void)
{
  /* To ensure a deterministic data transfer between two rates,
   * data is transferred at the priority of a fast task and the frequency
   * of the slow task.  The following flags indicate when the data transfer
   * happens.  That is, a rate interaction flag is set true when both rates
   * will run, and false otherwise.
   */

  /* tid 0 shares data with slower tid rates: 1, 2 */
  Walking01_withElmos_M->Timing.RateInteraction.TID0_1 =
    (Walking01_withElmos_M->Timing.TaskCounters.TID[1] == 0);

  /* update PerTaskSampleHits matrix for non-inline sfcn */
  Walking01_withElmos_M->Timing.perTaskSampleHits[1] =
    Walking01_withElmos_M->Timing.RateInteraction.TID0_1;
  Walking01_withElmos_M->Timing.RateInteraction.TID0_2 =
    (Walking01_withElmos_M->Timing.TaskCounters.TID[2] == 0);

  /* update PerTaskSampleHits matrix for non-inline sfcn */
  Walking01_withElmos_M->Timing.perTaskSampleHits[2] =
    Walking01_withElmos_M->Timing.RateInteraction.TID0_2;

  /* Compute which subrates run during the next base time step.  Subrates
   * are an integer multiple of the base rate counter.  Therefore, the subtask
   * counter is reset when it reaches its limit (zero means run).
   */
  (Walking01_withElmos_M->Timing.TaskCounters.TID[1])++;
  if ((Walking01_withElmos_M->Timing.TaskCounters.TID[1]) > 1) {/* Sample time: [0.001s, 0.0s] */
    Walking01_withElmos_M->Timing.TaskCounters.TID[1] = 0;
  }

  (Walking01_withElmos_M->Timing.TaskCounters.TID[2])++;
  if ((Walking01_withElmos_M->Timing.TaskCounters.TID[2]) > 3) {/* Sample time: [0.002s, 0.0s] */
    Walking01_withElmos_M->Timing.TaskCounters.TID[2] = 0;
  }
}

real_T rt_atan2d_snf(real_T u0, real_T u1)
{
  real_T y;
  int32_T u0_0;
  int32_T u1_0;
  if (rtIsNaN(u0) || rtIsNaN(u1)) {
    y = (rtNaN);
  } else if (rtIsInf(u0) && rtIsInf(u1)) {
    if (u0 > 0.0) {
      u0_0 = 1;
    } else {
      u0_0 = -1;
    }

    if (u1 > 0.0) {
      u1_0 = 1;
    } else {
      u1_0 = -1;
    }

    y = atan2(u0_0, u1_0);
  } else if (u1 == 0.0) {
    if (u0 > 0.0) {
      y = RT_PI / 2.0;
    } else if (u0 < 0.0) {
      y = -(RT_PI / 2.0);
    } else {
      y = 0.0;
    }
  } else {
    y = atan2(u0, u1);
  }

  return y;
}

/*
 * Output and update for atomic system:
 *    '<S13>/ComputeEulerAngles'
 *    '<S124>/ComputeEulerAngles'
 */
void Walking01_wi_ComputeEulerAngles(const real_T rtu_RkIn[9], const real_T
  rtu_wk[3], const real_T rtu_RCal[9], boolean_T rtu_Reset, const real_T
  rtu_R0In[9], const real_T rtu_YawRolloverIn[2],
  B_ComputeEulerAngles_Walking0_T *localB)
{
  real_T YawRolloverCount;
  real_T CurrentYaw;
  real_T y[9];
  real_T b_y[3];
  int32_T r2;
  int32_T r3;
  real_T tmp[9];

  /* MATLAB Function 'DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/ComputeEulerAngles': '<S17>:1' */
  /*  Convert from IMU frame to robot frame and compute Euler angles. The */
  /*  yaw angle is zeroed whenever (Reset) is true. */
  /* '<S17>:1:5' if (Reset) */
  if (rtu_Reset) {
    /*  Compute the rotation matrix which zeroes the initial yaw */
    /* '<S17>:1:7' qT0 = M_to_ZYX(RkIn*RCal); */
    for (r2 = 0; r2 < 3; r2++) {
      for (r3 = 0; r3 < 3; r3++) {
        y[r2 + 3 * r3] = 0.0;
        y[r2 + 3 * r3] += rtu_RCal[3 * r3] * rtu_RkIn[r2];
        y[r2 + 3 * r3] += rtu_RCal[3 * r3 + 1] * rtu_RkIn[r2 + 3];
        y[r2 + 3 * r3] += rtu_RCal[3 * r3 + 2] * rtu_RkIn[r2 + 6];
      }
    }

    /*  M_to_ZYX.m */
    /*  Author: Kevin Galloway */
    /*  Date: 29AUG12 */
    /*  */
    /*  Summary: This function takes a matrix (or array of matrices) M_RW_in and */
    /*  returns the Euler angles based on the ZYX convention. AngX refers to */
    /*  rotation around the X axis, AngY refers to rotation about the Y axis, and */
    /*  AngZ refers to rotation about the Z axis. If M_RW_in is an array of */
    /*  matrices (i.e. a multidimensional array), then AngX, AngY and AngZ */
    /*  will be vectors. */
    /* 'M_to_ZYX:13' qY = asin(-M(3,1,:)); */
    /* 'M_to_ZYX:14' qX = atan2(M(3,2,:), M(3,3,:)); */
    /* 'M_to_ZYX:15' qZ = atan2(M(2,1,:), M(1,1,:)); */
    /* 'M_to_ZYX:16' EulerAngles = [squeeze(qZ)'; squeeze(qY)'; squeeze(qX)']; */
    /* '<S17>:1:8' R0  = Rz(-qT0(1)); */
    CurrentYaw = -rt_atan2d_snf(y[1], y[0]);

    /* '<S17>:1:39' R = [cos(t) -sin(t) 0; sin(t) cos(t) 0; 0 0 1]; */
    localB->R0[0] = cos(CurrentYaw);
    localB->R0[3] = -sin(CurrentYaw);
    localB->R0[6] = 0.0;
    localB->R0[1] = sin(CurrentYaw);
    localB->R0[4] = cos(CurrentYaw);
    localB->R0[7] = 0.0;
    localB->R0[2] = 0.0;
    localB->R0[5] = 0.0;
    localB->R0[8] = 1.0;
  } else {
    /* '<S17>:1:9' else */
    /* '<S17>:1:10' R0 = R0In; */
    memcpy(&localB->R0[0], &rtu_R0In[0], 9U * sizeof(real_T));
  }

  /*  Transform from IMU to robot frame and zero initial yaw */
  /* '<S17>:1:14' Rk = R0*RkIn*RCal; */
  for (r2 = 0; r2 < 3; r2++) {
    for (r3 = 0; r3 < 3; r3++) {
      tmp[r2 + 3 * r3] = 0.0;
      tmp[r2 + 3 * r3] += rtu_RkIn[3 * r3] * localB->R0[r2];
      tmp[r2 + 3 * r3] += rtu_RkIn[3 * r3 + 1] * localB->R0[r2 + 3];
      tmp[r2 + 3 * r3] += rtu_RkIn[3 * r3 + 2] * localB->R0[r2 + 6];
    }
  }

  for (r2 = 0; r2 < 3; r2++) {
    for (r3 = 0; r3 < 3; r3++) {
      localB->Rk[r2 + 3 * r3] = 0.0;
      localB->Rk[r2 + 3 * r3] += rtu_RCal[3 * r3] * tmp[r2];
      localB->Rk[r2 + 3 * r3] += rtu_RCal[3 * r3 + 1] * tmp[r2 + 3];
      localB->Rk[r2 + 3 * r3] += rtu_RCal[3 * r3 + 2] * tmp[r2 + 6];
    }
  }

  /*  Convert Rk to ZYX Euler angles */
  /* '<S17>:1:17' ZYX = M_to_ZYX(Rk); */
  /*  M_to_ZYX.m */
  /*  Author: Kevin Galloway */
  /*  Date: 29AUG12 */
  /*  */
  /*  Summary: This function takes a matrix (or array of matrices) M_RW_in and */
  /*  returns the Euler angles based on the ZYX convention. AngX refers to */
  /*  rotation around the X axis, AngY refers to rotation about the Y axis, and */
  /*  AngZ refers to rotation about the Z axis. If M_RW_in is an array of */
  /*  matrices (i.e. a multidimensional array), then AngX, AngY and AngZ */
  /*  will be vectors. */
  /* 'M_to_ZYX:13' qY = asin(-M(3,1,:)); */
  /* 'M_to_ZYX:14' qX = atan2(M(3,2,:), M(3,3,:)); */
  /* 'M_to_ZYX:15' qZ = atan2(M(2,1,:), M(1,1,:)); */
  /* 'M_to_ZYX:16' EulerAngles = [squeeze(qZ)'; squeeze(qY)'; squeeze(qX)']; */
  localB->ZYX[0] = rt_atan2d_snf(localB->Rk[1], localB->Rk[0]);
  localB->ZYX[1] = asin(-localB->Rk[2]);
  localB->ZYX[2] = rt_atan2d_snf(localB->Rk[5], localB->Rk[8]);

  /*  Unroll yaw */
  /* '<S17>:1:20' YawRolloverCount = YawRolloverIn(1); */
  /* '<S17>:1:21' PreviousYaw      = YawRolloverIn(2); */
  /* '<S17>:1:22' CurrentYaw       = ZYX(1); */
  CurrentYaw = localB->ZYX[0];

  /* '<S17>:1:23' YawRolloverCount = YawRolloverCount + getYawRollover(CurrentYaw, PreviousYaw); */
  /*  Determine if a rollover has occurred on yaw angle If a rollover is */
  /*  detected, the output Rollover is either +1 or -1, depending on the */
  /*  direction of the rollover. */
  /* '<S17>:1:47' if (PreviousYaw>0 && CurrentYaw < (PreviousYaw-pi)) */
  if ((rtu_YawRolloverIn[1] > 0.0) && (localB->ZYX[0] < rtu_YawRolloverIn[1] -
       3.1415926535897931)) {
    /* '<S17>:1:48' Rollover = 1; */
    r2 = 1;
  } else if ((rtu_YawRolloverIn[1] < 0.0) && (localB->ZYX[0] >
              rtu_YawRolloverIn[1] + 3.1415926535897931)) {
    /* '<S17>:1:49' elseif (PreviousYaw<0 && CurrentYaw > (PreviousYaw+pi)) */
    /* '<S17>:1:50' Rollover = -1; */
    r2 = -1;
  } else {
    /* '<S17>:1:51' else */
    /* '<S17>:1:52' Rollover = 0; */
    r2 = 0;
  }

  YawRolloverCount = rtu_YawRolloverIn[0] + (real_T)r2;

  /* '<S17>:1:24' YawRollover      = [YawRolloverCount; CurrentYaw]; */
  /* '<S17>:1:25' ZYX(1)           = ZYX(1) + 2*pi*YawRolloverCount; */
  localB->ZYX[0] += 6.2831853071795862 * YawRolloverCount;

  /*  Compute Euler angle derivatives */
  /* '<S17>:1:28' qzT = ZYX(1); */
  /* '<S17>:1:29' qyT = ZYX(2); */
  /* '<S17>:1:31' if cos(qyT)>1e-3 */
  if (cos(localB->ZYX[1]) > 0.001) {
    /* '<S17>:1:32' dZYX = [0 -sin(qzT) cos(qzT)*cos(qyT); 0 cos(qzT) sin(qzT)*cos(qyT); 1 0 -sin(qyT)]\(R0*RkIn*wk); */
    for (r2 = 0; r2 < 3; r2++) {
      for (r3 = 0; r3 < 3; r3++) {
        tmp[r2 + 3 * r3] = 0.0;
        tmp[r2 + 3 * r3] += rtu_RkIn[3 * r3] * localB->R0[r2];
        tmp[r2 + 3 * r3] += rtu_RkIn[3 * r3 + 1] * localB->R0[r2 + 3];
        tmp[r2 + 3 * r3] += rtu_RkIn[3 * r3 + 2] * localB->R0[r2 + 6];
      }
    }

    for (r2 = 0; r2 < 3; r2++) {
      b_y[r2] = tmp[r2 + 6] * rtu_wk[2] + (tmp[r2 + 3] * rtu_wk[1] + tmp[r2] *
        rtu_wk[0]);
    }

    y[3] = -sin(localB->ZYX[0]);
    y[6] = cos(localB->ZYX[0]) * cos(localB->ZYX[1]);
    y[4] = cos(localB->ZYX[0]);
    y[7] = sin(localB->ZYX[0]) * cos(localB->ZYX[1]);
    y[2] = 1.0;
    y[5] = 0.0;
    y[8] = -sin(localB->ZYX[1]);
    r2 = 1;
    r3 = 0;
    y[1] = 0.0;
    y[0] = 0.0;
    y[7] -= 0.0 * y[8];
    y[6] -= 0.0 * y[8];
    if (fabs(y[3]) > fabs(y[4])) {
      r2 = 0;
      r3 = 1;
    }

    y[3 + r3] /= y[3 + r2];
    y[6 + r3] -= y[3 + r3] * y[6 + r2];
    localB->dZYX[0] = b_y[2];
    localB->dZYX[1] = b_y[r2] - localB->dZYX[0] * y[r2];
    localB->dZYX[2] = (b_y[r3] - localB->dZYX[0] * y[r3]) - y[3 + r3] *
      localB->dZYX[1];
    localB->dZYX[2] /= y[6 + r3];
    localB->dZYX[0] -= localB->dZYX[2] * y[8];
    localB->dZYX[1] -= y[6 + r2] * localB->dZYX[2];
    localB->dZYX[1] /= y[3 + r2];
    localB->dZYX[0] -= localB->dZYX[1] * y[5];
    localB->dZYX[0] /= y[2];
  } else {
    /* '<S17>:1:33' else */
    /* '<S17>:1:34' dZYX = [0; 0; 0]; */
    localB->dZYX[0] = 0.0;
    localB->dZYX[1] = 0.0;
    localB->dZYX[2] = 0.0;
  }

  localB->YawRollover[0] = YawRolloverCount;
  localB->YawRollover[1] = CurrentYaw;
}

/*
 * Function for Chart: '<S24>/AnomalyDetection'
 * function err = check_error
 */
static boolean_T Walking01_withElmos_check_error(real_T rtu_q, const real_T
  rtu_q_limits[2], real_T rtu_Threshold, B_AnomalyDetection_Walking01__T *localB)
{
  /* MATLAB Function 'check_error': '<S25>:11' */
  /* '<S25>:11:3' err = (q<q_limits(1)) || (q>q_limits(2)) ... */
  /* '<S25>:11:4'         || (abs(q - q_clean) > (ErrorCount+1)*Threshold); */
  return (rtu_q < rtu_q_limits[0]) || (rtu_q > rtu_q_limits[1]) || (fabs(rtu_q -
    localB->q_clean) > (localB->ErrorCount + 1.0) * rtu_Threshold);
}

/* Initial conditions for atomic system: '<S24>/AnomalyDetection' */
void Walking01_AnomalyDetection_Init(B_AnomalyDetection_Walking01__T *localB,
  DW_AnomalyDetection_Walking01_T *localDW)
{
  localDW->sfEvent = Walking01_withElmo_CALL_EVENT_i;
  localDW->temporalCounter_i1 = 0U;
  localDW->is_Run = Walking01_wi_IN_NO_ACTIVE_CHILD;
  localDW->is_active_c9_Walking01_withElmo = 0U;
  localDW->is_c9_Walking01_withElmos = Walking01_wi_IN_NO_ACTIVE_CHILD;
  localDW->q_last = 0.0;
  localDW->dq_last = 0.0;
  localDW->Counter_last = 0.0;
  localB->q_clean = 0.0;
  localB->ErrorCount = 0.0;
}

/* Start for atomic system: '<S24>/AnomalyDetection' */
void Walking0_AnomalyDetection_Start(B_AnomalyDetection_Walking01__T *localB)
{
  localB->q_clean = 0.0;
  localB->ErrorCount = 0.0;
}

/* Output and update for atomic system: '<S24>/AnomalyDetection' */
void Walking01_with_AnomalyDetection(real_T rtu_q, real_T rtu_dq, real_T
  rtu_Counter, const real_T rtu_q_limits[2], real_T rtu_Threshold, boolean_T
  rtu_Reset, real_T rtu_ANOMALY_DT, B_AnomalyDetection_Walking01__T *localB,
  DW_AnomalyDetection_Walking01_T *localDW)
{
  /* Gateway: DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EncoderFilters/CheckAndFilterEncoder/AnomalyDetection */
  localDW->sfEvent = Walking01_withElmo_CALL_EVENT_i;
  if (localDW->temporalCounter_i1 < MAX_uint32_T) {
    localDW->temporalCounter_i1++;
  }

  /* During: DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EncoderFilters/CheckAndFilterEncoder/AnomalyDetection */
  if (localDW->is_active_c9_Walking01_withElmo == 0U) {
    /* Entry: DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EncoderFilters/CheckAndFilterEncoder/AnomalyDetection */
    localDW->is_active_c9_Walking01_withElmo = 1U;

    /* Entry Internal: DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EncoderFilters/CheckAndFilterEncoder/AnomalyDetection */
    /* Transition: '<S25>:10' */
    localDW->is_c9_Walking01_withElmos = Walking01_withElmos_IN_Init;
    localDW->temporalCounter_i1 = 0U;

    /* Entry 'Init': '<S25>:20' */
    localB->q_clean = rtu_q;
    localDW->q_last = rtu_q;
    localDW->dq_last = rtu_dq;
    localB->ErrorCount = 0.0;
  } else if (localDW->is_c9_Walking01_withElmos == Walking01_withElmos_IN_Init)
  {
    /* During 'Init': '<S25>:20' */
    if ((!rtu_Reset) && (localDW->temporalCounter_i1 >= (uint32_T)10.0)) {
      /* Transition: '<S25>:21' */
      localDW->is_c9_Walking01_withElmos = Walking01_withElmos_IN_Run;

      /* Entry Internal 'Run': '<S25>:27' */
      /* Transition: '<S25>:29' */
      localDW->is_Run = Walking01_withElmos_IN_Nominal;

      /* Entry 'Nominal': '<S25>:4' */
      localB->q_clean = rtu_q;
      localDW->q_last = rtu_q;
      localDW->dq_last = rtu_dq;
      localDW->Counter_last = rtu_Counter;
      localB->ErrorCount = 0.0;
    } else {
      localB->q_clean = rtu_q;
      localDW->q_last = rtu_q;
      localDW->dq_last = rtu_dq;
      localB->ErrorCount = 0.0;
    }
  } else {
    /* During 'Run': '<S25>:27' */
    if (rtu_Reset) {
      /* Transition: '<S25>:28' */
      /* Exit Internal 'Run': '<S25>:27' */
      localDW->is_Run = Walking01_wi_IN_NO_ACTIVE_CHILD;
      localDW->is_c9_Walking01_withElmos = Walking01_withElmos_IN_Init;
      localDW->temporalCounter_i1 = 0U;

      /* Entry 'Init': '<S25>:20' */
      localB->q_clean = rtu_q;
      localDW->q_last = rtu_q;
      localDW->dq_last = rtu_dq;
      localB->ErrorCount = 0.0;
    } else {
      switch (localDW->is_Run) {
       case Walking01_withElmos_IN_Error:
        /* During 'Error': '<S25>:5' */
        if (localB->ErrorCount > 30.0) {
          /* Transition: '<S25>:3' */
          localDW->is_Run = Walking01_wi_IN_NO_ACTIVE_CHILD;
          localDW->is_c9_Walking01_withElmos = Walking01_withElmos_IN_Init;
          localDW->temporalCounter_i1 = 0U;

          /* Entry 'Init': '<S25>:20' */
          localB->q_clean = rtu_q;
          localDW->q_last = rtu_q;
          localDW->dq_last = rtu_dq;
          localB->ErrorCount = 0.0;
        } else {
          if (!Walking01_withElmos_check_error(rtu_q, rtu_q_limits,
               rtu_Threshold, localB)) {
            /* Transition: '<S25>:30' */
            localDW->is_Run = Walking01_withElmos_IN_Nominal;

            /* Entry 'Nominal': '<S25>:4' */
            localB->q_clean = rtu_q;
            localDW->q_last = rtu_q;
            localDW->dq_last = rtu_dq;
            localDW->Counter_last = rtu_Counter;
            localB->ErrorCount = 0.0;
          } else {
            /* dq is delayed to prevent algebraic loops */
            localB->ErrorCount++;
            localB->q_clean = localB->ErrorCount * localDW->dq_last *
              rtu_ANOMALY_DT + localDW->q_last;
          }
        }
        break;

       case Walking01_withE_IN_MissedPacket:
        /* During 'MissedPacket': '<S25>:35' */
        /* Transition: '<S25>:37' */
        localDW->is_Run = Walking01_withElmos_IN_Nominal;

        /* Entry 'Nominal': '<S25>:4' */
        localB->q_clean = rtu_q;
        localDW->q_last = rtu_q;
        localDW->dq_last = rtu_dq;
        localDW->Counter_last = rtu_Counter;
        localB->ErrorCount = 0.0;
        break;

       default:
        /* During 'Nominal': '<S25>:4' */
        if (Walking01_withElmos_check_error(rtu_q, rtu_q_limits, rtu_Threshold,
             localB)) {
          /* Transition: '<S25>:2' */
          localDW->is_Run = Walking01_withElmos_IN_Error;

          /* Entry 'Error': '<S25>:5' */
          localDW->dq_last = rtu_dq;

          /* dq is delayed to prevent algebraic loops */
          localB->ErrorCount++;
          localB->q_clean = localB->ErrorCount * localDW->dq_last *
            rtu_ANOMALY_DT + localDW->q_last;
        } else {
          localB->q_clean = rtu_q;
          localDW->q_last = rtu_q;
          localDW->dq_last = rtu_dq;
          localDW->Counter_last = rtu_Counter;
          localB->ErrorCount = 0.0;
        }
        break;
      }
    }
  }
}

/*
 * Output and update for atomic system:
 *    '<S33>/TypecastAndCast1'
 *    '<S33>/TypecastAndCast2'
 */
void Walking01_with_TypecastAndCast1(uint32_T rtu_u, uint32_T rtu_u_f, uint32_T
  rtu_u_a, B_TypecastAndCast1_Walking01__T *localB)
{
  real32_T ys[3];
  uint32_T rtb_TmpSignalConversionAtSFun_d[3];

  /* SignalConversion: '<S43>/TmpSignal ConversionAt SFunction Inport1' */
  rtb_TmpSignalConversionAtSFun_d[0] = rtu_u;
  rtb_TmpSignalConversionAtSFun_d[1] = rtu_u_f;
  rtb_TmpSignalConversionAtSFun_d[2] = rtu_u_a;

  /* MATLAB Function 'DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/TypecastAndCast1': '<S43>:1' */
  /* '<S43>:1:3' ys = typecast(u, 'single'); */
  memcpy(&ys[0], &rtb_TmpSignalConversionAtSFun_d[0], (size_t)3 * sizeof
         (real32_T));

  /* '<S43>:1:4' y  = double(ys); */
  localB->y[0] = ys[0];
  localB->y[1] = ys[1];
  localB->y[2] = ys[2];
}

/*
 * Output and update for action system:
 *    '<S48>/ShutdownControlWord'
 *    '<S66>/ShutdownControlWord'
 *    '<S84>/ShutdownControlWord'
 *    '<S102>/ShutdownControlWord'
 */
void Walking01_w_ShutdownControlWord(uint16_T *rty_ControlWord)
{
  /* SignalConversion: '<S58>/OutportBufferForControlWord' incorporates:
   *  Constant: '<S58>/Constant'
   */
  *rty_ControlWord = ((uint16_T)6U);
}

/*
 * Output and update for action system:
 *    '<S48>/EnableControlWord'
 *    '<S66>/EnableControlWord'
 *    '<S84>/EnableControlWord'
 *    '<S102>/EnableControlWord'
 */
void Walking01_wit_EnableControlWord(uint16_T *rty_ControlWord)
{
  /* SignalConversion: '<S55>/OutportBufferForControlWord' incorporates:
   *  Constant: '<S55>/Constant'
   */
  *rty_ControlWord = ((uint16_T)15U);
}

/*
 * Output and update for action system:
 *    '<S48>/FaultReset'
 *    '<S66>/FaultReset'
 *    '<S84>/FaultReset'
 *    '<S102>/FaultReset'
 */
void Walking01_withElmos_FaultReset(uint16_T *rty_ControlWord)
{
  /* SignalConversion: '<S56>/OutportBufferForControlWord' incorporates:
   *  Constant: '<S56>/Constant'
   */
  *rty_ControlWord = ((uint16_T)128U);
}

/*
 * Output and update for action system:
 *    '<S48>/NothingControlWord'
 *    '<S66>/NothingControlWord'
 *    '<S84>/NothingControlWord'
 *    '<S102>/NothingControlWord'
 */
void Walking01_wi_NothingControlWord(uint16_T *rty_ControlWord)
{
  /* SignalConversion: '<S57>/OutportBufferForControlWord' incorporates:
   *  Constant: '<S57>/Constant'
   */
  *rty_ControlWord = ((uint16_T)0U);
}

/*
 * Initial conditions for atomic system:
 *    '<S35>/Chart'
 *    '<S37>/Chart'
 */
void Walking01_withElmos_Chart_Init(DW_Chart_Walking01_withElmos_T *localDW)
{
  localDW->sfEvent = Walking01_withElmo_CALL_EVENT_k;
  localDW->is_Initialization = Walking01__IN_NO_ACTIVE_CHILD_b;
  localDW->is_active_c22_Walking01_withElm = 0U;
  localDW->is_c22_Walking01_withElmos = Walking01__IN_NO_ACTIVE_CHILD_b;
}

/*
 * Output and update for atomic system:
 *    '<S35>/Chart'
 *    '<S37>/Chart'
 */
void Walking01_withElmos_Chart(boolean_T rtu_SwitchOnDisabledMode, boolean_T
  rtu_ReadyToSwitchOnMode, boolean_T rtu_FaultMode, real_T rtu_MedullaCommand,
  B_Chart_Walking01_withElmos_T *localB, DW_Chart_Walking01_withElmos_T *localDW)
{
  /* Gateway: DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1R/Chart */
  localDW->sfEvent = Walking01_withElmo_CALL_EVENT_k;

  /* During: DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1R/Chart */
  if (localDW->is_active_c22_Walking01_withElm == 0U) {
    /* Entry: DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1R/Chart */
    localDW->is_active_c22_Walking01_withElm = 1U;

    /* Entry Internal: DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1R/Chart */
    /* Transition: '<S63>:102' */
    localDW->is_c22_Walking01_withElmos = Walking01_withElmos_IN_Start1;

    /* Entry 'Start1': '<S63>:103' */
    /* '<S63>:103:1' ControlWordIndex = 0; */
    localB->ControlWordIndex = 0.0;

    /* '<S63>:103:1' EnableTargetTorque = 0; */
    localB->EnableTargetTorque = 0.0;

    /* '<S63>:103:3' FaultDetected = 0; */
    localB->FaultDetected = 0.0;
  } else {
    switch (localDW->is_c22_Walking01_withElmos) {
     case Walking01_withE_IN_FaultRunning:
      /* During 'FaultRunning': '<S63>:105' */
      break;

     case Walking01_wit_IN_Initialization:
      /* During 'Initialization': '<S63>:111' */
      /* '<S63>:95:1' sf_internal_predicateOutput = ... */
      /* '<S63>:95:1' MedullaCommand == 4 || MedullaCommand == 5; */
      if ((rtu_MedullaCommand == 4.0) || (rtu_MedullaCommand == 5.0)) {
        /* Transition: '<S63>:95' */
        /* Exit Internal 'Initialization': '<S63>:111' */
        localDW->is_Initialization = Walking01__IN_NO_ACTIVE_CHILD_b;
        localDW->is_c22_Walking01_withElmos = Walking01_withE_IN_FaultRunning;

        /* Entry 'FaultRunning': '<S63>:105' */
        /* '<S63>:105:1' ControlWordIndex = 1; */
        localB->ControlWordIndex = 1.0;

        /* '<S63>:105:1' EnableTargetTorque = 0; */
        localB->EnableTargetTorque = 0.0;

        /* '<S63>:105:3' FaultDetected = 1; */
        localB->FaultDetected = 1.0;
      } else {
        switch (localDW->is_Initialization) {
         case Walking01_withElmos_IN_Fault:
          /* During 'Fault': '<S63>:96' */
          /* '<S63>:107:1' sf_internal_predicateOutput = ... */
          /* '<S63>:107:1' Timeout >=20; */
          if (localDW->Timeout >= 20.0) {
            /* Transition: '<S63>:107' */
            localDW->is_Initialization = Walking01_withElmos_IN_Fault;

            /* Entry 'Fault': '<S63>:96' */
            /* '<S63>:96:1' ControlWordIndex = 3; */
            localB->ControlWordIndex = 3.0;

            /* '<S63>:96:1' EnableTargetTorque = 0; */
            localB->EnableTargetTorque = 0.0;

            /* '<S63>:96:3' Timeout = 0; */
            localDW->Timeout = 0.0;
          } else {
            /* '<S63>:116:1' sf_internal_predicateOutput = ... */
            /* '<S63>:116:1' SwitchOnDisabledMode == 1; */
            if (rtu_SwitchOnDisabledMode == 1) {
              /* Transition: '<S63>:116' */
              localDW->is_Initialization = Walking01_w_IN_SwitchOnDisabled;

              /* Entry 'SwitchOnDisabled': '<S63>:97' */
              /* '<S63>:97:1' ControlWordIndex = 1; */
              localB->ControlWordIndex = 1.0;

              /* '<S63>:97:1' Timeout = 0; */
              localDW->Timeout = 0.0;

              /* '<S63>:97:3' EnableTargetTorque = 0; */
              localB->EnableTargetTorque = 0.0;
            } else {
              /* '<S63>:96:4' Timeout = Timeout + 1; */
              localDW->Timeout++;

              /* '<S63>:96:5' ControlWordIndex = 0; */
              localB->ControlWordIndex = 0.0;
            }
          }
          break;

         case Walking01_wi_IN_ReadyToSwitchOn:
          /* During 'ReadyToSwitchOn': '<S63>:115' */
          /* '<S63>:114:1' sf_internal_predicateOutput = ... */
          /* '<S63>:114:1' FaultMode == 1; */
          if (rtu_FaultMode == 1) {
            /* Transition: '<S63>:114' */
            localDW->is_Initialization = Walking01_withElmos_IN_Fault;

            /* Entry 'Fault': '<S63>:96' */
            /* '<S63>:96:1' ControlWordIndex = 3; */
            localB->ControlWordIndex = 3.0;

            /* '<S63>:96:1' EnableTargetTorque = 0; */
            localB->EnableTargetTorque = 0.0;

            /* '<S63>:96:3' Timeout = 0; */
            localDW->Timeout = 0.0;
          } else {
            /* '<S63>:118:1' sf_internal_predicateOutput = ... */
            /* '<S63>:118:1' SwitchOnDisabledMode == 1; */
            if (rtu_SwitchOnDisabledMode == 1) {
              /* Transition: '<S63>:118' */
              localDW->is_Initialization = Walking01_w_IN_SwitchOnDisabled;

              /* Entry 'SwitchOnDisabled': '<S63>:97' */
              /* '<S63>:97:1' ControlWordIndex = 1; */
              localB->ControlWordIndex = 1.0;

              /* '<S63>:97:1' Timeout = 0; */
              localDW->Timeout = 0.0;

              /* '<S63>:97:3' EnableTargetTorque = 0; */
              localB->EnableTargetTorque = 0.0;
            } else {
              /* Transition: '<S63>:98' */
              localDW->is_Initialization = Walking01__IN_NO_ACTIVE_CHILD_b;
              localDW->is_c22_Walking01_withElmos =
                Walking01_withElmos_IN_Running;

              /* Entry 'Running': '<S63>:100' */
              /* '<S63>:100:1' ControlWordIndex = 2; */
              localB->ControlWordIndex = 2.0;

              /* '<S63>:100:1' EnableTargetTorque = 1; */
              localB->EnableTargetTorque = 1.0;
            }
          }
          break;

         default:
          /* During 'SwitchOnDisabled': '<S63>:97' */
          /* '<S63>:99:1' sf_internal_predicateOutput = ... */
          /* '<S63>:99:1' ReadyToSwitchOnMode == 1; */
          if (rtu_ReadyToSwitchOnMode == 1) {
            /* Transition: '<S63>:99' */
            localDW->is_Initialization = Walking01_wi_IN_ReadyToSwitchOn;

            /* Entry 'ReadyToSwitchOn': '<S63>:115' */
            /* '<S63>:115:1' ControlWordIndex = 2; */
            localB->ControlWordIndex = 2.0;

            /* '<S63>:115:1' Timeout = 0; */
            localDW->Timeout = 0.0;

            /* '<S63>:115:3' EnableTargetTorque = 0; */
            localB->EnableTargetTorque = 0.0;
          } else {
            /* '<S63>:110:1' sf_internal_predicateOutput = ... */
            /* '<S63>:110:1' FaultMode == 1; */
            if (rtu_FaultMode == 1) {
              /* Transition: '<S63>:110' */
              localDW->is_Initialization = Walking01_withElmos_IN_Fault;

              /* Entry 'Fault': '<S63>:96' */
              /* '<S63>:96:1' ControlWordIndex = 3; */
              localB->ControlWordIndex = 3.0;

              /* '<S63>:96:1' EnableTargetTorque = 0; */
              localB->EnableTargetTorque = 0.0;

              /* '<S63>:96:3' Timeout = 0; */
              localDW->Timeout = 0.0;
            } else {
              /* '<S63>:97:3' Timeout = Timeout + 1; */
              localDW->Timeout++;
            }
          }
          break;
        }
      }
      break;

     case Walking01_withElmos_IN_Running:
      /* During 'Running': '<S63>:100' */
      /* '<S63>:101:1' sf_internal_predicateOutput = ... */
      /* '<S63>:101:1' FaultMode == 1; */
      if (rtu_FaultMode == 1) {
        /* Transition: '<S63>:101' */
        localDW->is_c22_Walking01_withElmos = Walking01_withE_IN_FaultRunning;

        /* Entry 'FaultRunning': '<S63>:105' */
        /* '<S63>:105:1' ControlWordIndex = 1; */
        localB->ControlWordIndex = 1.0;

        /* '<S63>:105:1' EnableTargetTorque = 0; */
        localB->EnableTargetTorque = 0.0;

        /* '<S63>:105:3' FaultDetected = 1; */
        localB->FaultDetected = 1.0;
      } else {
        /* '<S63>:113:1' sf_internal_predicateOutput = ... */
        /* '<S63>:113:1' MedullaCommand == 4 || MedullaCommand == 5; */
        if ((rtu_MedullaCommand == 4.0) || (rtu_MedullaCommand == 5.0)) {
          /* Transition: '<S63>:113' */
          localDW->is_c22_Walking01_withElmos = Walking01_withE_IN_FaultRunning;

          /* Entry 'FaultRunning': '<S63>:105' */
          /* '<S63>:105:1' ControlWordIndex = 1; */
          localB->ControlWordIndex = 1.0;

          /* '<S63>:105:1' EnableTargetTorque = 0; */
          localB->EnableTargetTorque = 0.0;

          /* '<S63>:105:3' FaultDetected = 1; */
          localB->FaultDetected = 1.0;
        }
      }
      break;

     default:
      /* During 'Start1': '<S63>:103' */
      /* '<S63>:117:1' sf_internal_predicateOutput = ... */
      /* '<S63>:117:1' MedullaCommand == 4 || MedullaCommand == 5; */
      if ((rtu_MedullaCommand == 4.0) || (rtu_MedullaCommand == 5.0)) {
        /* Transition: '<S63>:117' */
        localDW->is_c22_Walking01_withElmos = Walking01_withE_IN_FaultRunning;

        /* Entry 'FaultRunning': '<S63>:105' */
        /* '<S63>:105:1' ControlWordIndex = 1; */
        localB->ControlWordIndex = 1.0;

        /* '<S63>:105:1' EnableTargetTorque = 0; */
        localB->EnableTargetTorque = 0.0;

        /* '<S63>:105:3' FaultDetected = 1; */
        localB->FaultDetected = 1.0;
      } else {
        /* '<S63>:109:1' sf_internal_predicateOutput = ... */
        /* '<S63>:109:1' MedullaCommand == 2; */
        if (rtu_MedullaCommand == 2.0) {
          /* Transition: '<S63>:109' */
          localDW->is_c22_Walking01_withElmos = Walking01_wit_IN_Initialization;

          /* Entry Internal 'Initialization': '<S63>:111' */
          /* Transition: '<S63>:112' */
          localDW->is_Initialization = Walking01_w_IN_SwitchOnDisabled;

          /* Entry 'SwitchOnDisabled': '<S63>:97' */
          /* '<S63>:97:1' ControlWordIndex = 1; */
          localB->ControlWordIndex = 1.0;

          /* '<S63>:97:1' Timeout = 0; */
          localDW->Timeout = 0.0;

          /* '<S63>:97:3' EnableTargetTorque = 0; */
          localB->EnableTargetTorque = 0.0;
        }
      }
      break;
    }
  }
}

/*
 * Function for Chart: '<S117>/AnomalyDetection'
 * function err = check_error
 */
static boolean_T Walking01_withElm_check_error_g(real_T rtu_q, const real_T
  rtu_q_limits[2], real_T rtu_Threshold, B_AnomalyDetection_Walking0_h_T *localB)
{
  /* MATLAB Function 'check_error': '<S118>:11' */
  /* '<S118>:11:3' err = (q<q_limits(1)) || (q>q_limits(2)) || (abs(q - q_clean) > (ErrorCount+1)*Threshold); */
  return (rtu_q < rtu_q_limits[0]) || (rtu_q > rtu_q_limits[1]) || (fabs(rtu_q -
    localB->q_clean) > (localB->ErrorCount + 1.0) * rtu_Threshold);
}

/* Initial conditions for atomic system: '<S117>/AnomalyDetection' */
void Walking_AnomalyDetection_h_Init(B_AnomalyDetection_Walking0_h_T *localB,
  DW_AnomalyDetection_Walking_m_T *localDW)
{
  localDW->sfEvent = Walking01_withElmo_CALL_EVENT_e;
  localDW->temporalCounter_i1 = 0U;
  localDW->is_Run = Walking01__IN_NO_ACTIVE_CHILD_f;
  localDW->is_active_c3_Walking01_withElmo = 0U;
  localDW->is_c3_Walking01_withElmos = Walking01__IN_NO_ACTIVE_CHILD_f;
  localDW->q_last = 0.0;
  localDW->dq_last = 0.0;
  localB->q_clean = 0.0;
  localB->ErrorCount = 0.0;
}

/* Start for atomic system: '<S117>/AnomalyDetection' */
void Walkin_AnomalyDetection_g_Start(B_AnomalyDetection_Walking0_h_T *localB)
{
  localB->q_clean = 0.0;
  localB->ErrorCount = 0.0;
}

/* Output and update for atomic system: '<S117>/AnomalyDetection' */
void Walking01_wi_AnomalyDetection_h(real_T rtu_q, real_T rtu_dq, const real_T
  rtu_q_limits[2], real_T rtu_Threshold, boolean_T rtu_Reset, real_T
  rtu_ANOMALY_DT, B_AnomalyDetection_Walking0_h_T *localB,
  DW_AnomalyDetection_Walking_m_T *localDW)
{
  /* Gateway: DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/IMUFilters/CheckAndFilterIMU/AnomalyDetection */
  localDW->sfEvent = Walking01_withElmo_CALL_EVENT_e;
  if (localDW->temporalCounter_i1 < MAX_uint32_T) {
    localDW->temporalCounter_i1++;
  }

  /* During: DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/IMUFilters/CheckAndFilterIMU/AnomalyDetection */
  if (localDW->is_active_c3_Walking01_withElmo == 0U) {
    /* Entry: DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/IMUFilters/CheckAndFilterIMU/AnomalyDetection */
    localDW->is_active_c3_Walking01_withElmo = 1U;

    /* Entry Internal: DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/IMUFilters/CheckAndFilterIMU/AnomalyDetection */
    /* Transition: '<S118>:10' */
    localDW->is_c3_Walking01_withElmos = Walking01_withElmos_IN_Init_j;
    localDW->temporalCounter_i1 = 0U;

    /* Entry 'Init': '<S118>:20' */
    localB->q_clean = rtu_q;
    localDW->q_last = rtu_q;
    localDW->dq_last = rtu_dq;
    localB->ErrorCount = 0.0;
  } else if (localDW->is_c3_Walking01_withElmos == Walking01_withElmos_IN_Init_j)
  {
    /* During 'Init': '<S118>:20' */
    if ((!rtu_Reset) && (localDW->temporalCounter_i1 >= (uint32_T)10.0)) {
      /* Transition: '<S118>:21' */
      localDW->is_c3_Walking01_withElmos = Walking01_withElmos_IN_Run_c;

      /* Entry Internal 'Run': '<S118>:27' */
      /* Transition: '<S118>:29' */
      localDW->is_Run = Walking01_withElmo_IN_Nominal_c;

      /* Entry 'Nominal': '<S118>:4' */
      localB->q_clean = rtu_q;
      localDW->q_last = rtu_q;
      localDW->dq_last = rtu_dq;
      localB->ErrorCount = 0.0;
    } else {
      localB->q_clean = rtu_q;
      localDW->q_last = rtu_q;
      localDW->dq_last = rtu_dq;
      localB->ErrorCount = 0.0;
    }
  } else {
    /* During 'Run': '<S118>:27' */
    if (rtu_Reset) {
      /* Transition: '<S118>:28' */
      /* Exit Internal 'Run': '<S118>:27' */
      localDW->is_Run = Walking01__IN_NO_ACTIVE_CHILD_f;
      localDW->is_c3_Walking01_withElmos = Walking01_withElmos_IN_Init_j;
      localDW->temporalCounter_i1 = 0U;

      /* Entry 'Init': '<S118>:20' */
      localB->q_clean = rtu_q;
      localDW->q_last = rtu_q;
      localDW->dq_last = rtu_dq;
      localB->ErrorCount = 0.0;
    } else if (localDW->is_Run == Walking01_withElmos_IN_Error_e) {
      /* During 'Error': '<S118>:5' */
      if (localB->ErrorCount > 30.0) {
        /* Transition: '<S118>:3' */
        localDW->is_Run = Walking01__IN_NO_ACTIVE_CHILD_f;
        localDW->is_c3_Walking01_withElmos = Walking01_withElmos_IN_Init_j;
        localDW->temporalCounter_i1 = 0U;

        /* Entry 'Init': '<S118>:20' */
        localB->q_clean = rtu_q;
        localDW->q_last = rtu_q;
        localDW->dq_last = rtu_dq;
        localB->ErrorCount = 0.0;
      } else {
        if (!Walking01_withElm_check_error_g(rtu_q, rtu_q_limits, rtu_Threshold,
             localB)) {
          /* Transition: '<S118>:30' */
          localDW->is_Run = Walking01_withElmo_IN_Nominal_c;

          /* Entry 'Nominal': '<S118>:4' */
          localB->q_clean = rtu_q;
          localDW->q_last = rtu_q;
          localDW->dq_last = rtu_dq;
          localB->ErrorCount = 0.0;
        } else {
          /* dq is delayed to prevent algebraic loops */
          localB->ErrorCount++;
          localB->q_clean = localB->ErrorCount * localDW->dq_last *
            rtu_ANOMALY_DT + localDW->q_last;
        }
      }
    } else {
      /* During 'Nominal': '<S118>:4' */
      if (Walking01_withElm_check_error_g(rtu_q, rtu_q_limits, rtu_Threshold,
           localB)) {
        /* Transition: '<S118>:2' */
        localDW->is_Run = Walking01_withElmos_IN_Error_e;

        /* Entry 'Error': '<S118>:5' */
        localDW->dq_last = rtu_dq;

        /* dq is delayed to prevent algebraic loops */
        localB->ErrorCount++;
        localB->q_clean = localB->ErrorCount * localDW->dq_last * rtu_ANOMALY_DT
          + localDW->q_last;
      } else {
        localB->q_clean = rtu_q;
        localDW->q_last = rtu_q;
        localDW->dq_last = rtu_dq;
        localB->ErrorCount = 0.0;
      }
    }
  }
}

/* Function for MATLAB Function: '<S13>/calibrate' */
static void Walking01_withElmos_eml_li_find(const boolean_T x[2], int32_T
  y_data[], int32_T *y_sizes)
{
  int32_T j;
  *y_sizes = 0;
  if (x[0]) {
    *y_sizes = 1;
  }

  if (x[1]) {
    (*y_sizes)++;
  }

  j = 0;
  if (x[0]) {
    y_data[0] = 1;
    j = 1;
  }

  if (x[1]) {
    y_data[j] = 2;
  }
}

/* Function for MATLAB Function: '<S13>/calibrate' */
static void Walking01_withElm_eml_li_find_k(const boolean_T x[9], int32_T
  y_data[], int32_T *y_sizes)
{
  int32_T j;
  int32_T i;
  *y_sizes = 0;
  for (j = 0; j < 9; j++) {
    if (x[j]) {
      (*y_sizes)++;
    }
  }

  j = 0;
  for (i = 0; i < 9; i++) {
    if (x[i]) {
      y_data[j] = i + 1;
      j++;
    }
  }
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function [s,ds,dsdq,th,dth,delta_theta,c]=ATRIAS3D_ZD_s6(t,q,dq,theta_limits,c)
 */
static void Walking01_with_ATRIAS3D_ZD_s6_b(real_T t, const real_T q[13], const
  real_T dq[13], const real_T theta_limits[2], const real_T c[15], real_T *s,
  real_T *ds, real_T dsdq[13], real_T *th, real_T *dth, real_T *delta_theta)
{
  real_T tmp[15];
  int32_T i;

  /*  NOTE: This function should work both with scalar and vector s. */
  /*  It should also work for both the full q and the zero dynamics qz. */
  /* 'ATRIAS3D_ZD_s6:5' if nargin<5 */
  /* 'ATRIAS3D_ZD_s6:11' if numel(theta_limits)==2 && iscolumn(theta_limits) */
  /* 'ATRIAS3D_ZD_s6:15' th  = c*[1; t; q]; */
  tmp[0] = 1.0;
  tmp[1] = t;
  memcpy(&tmp[2], &q[0], 13U * sizeof(real_T));
  *th = 0.0;
  for (i = 0; i < 15; i++) {
    *th += c[i] * tmp[i];
  }

  /* check offset */
  /* 'ATRIAS3D_ZD_s6:16' dth = c*[0; 1; dq]; */
  tmp[0] = 0.0;
  tmp[1] = 1.0;
  memcpy(&tmp[2], &dq[0], 13U * sizeof(real_T));
  *dth = 0.0;
  for (i = 0; i < 15; i++) {
    *dth += c[i] * tmp[i];
  }

  /* 'ATRIAS3D_ZD_s6:17' delta_theta = theta_limits(:,2)-theta_limits(:,1); */
  *delta_theta = theta_limits[1] - theta_limits[0];

  /* 'ATRIAS3D_ZD_s6:18' s    = (th-theta_limits(:,1))./delta_theta; */
  *s = (*th - theta_limits[0]) / *delta_theta;

  /* 'ATRIAS3D_ZD_s6:19' ds   = dth./delta_theta; */
  *ds = *dth / *delta_theta;

  /* 'ATRIAS3D_ZD_s6:20' dsdq = c(:,3:end)./(delta_theta*ones(1,length(q))); */
  for (i = 0; i < 13; i++) {
    dsdq[i] = c[2 + i] / *delta_theta;
  }
}

/* Function for Chart: '<S202>/StateLogic' */
static void Walking01_withEl_eml_li_find_en(boolean_T x, int32_T y_data[],
  int32_T y_sizes[2])
{
  int32_T k;
  k = 0;
  if (x) {
    k = 1;
  }

  y_sizes[0] = 1;
  y_sizes[1] = k;
  if (x) {
    y_data[0] = 1;
  }
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function updateS(t)
 */
static void Walking01_withElmos_updateS(real_T t)
{
  real_T c[15];
  real_T ds;
  real_T dsdq[13];
  real_T dtheta;
  real_T delta_theta;
  real_T b;
  real_T e;
  static const int8_T g[13] = { 0, 1, 2, 5, 6, 3, 4, 10, 11, 12, 7, 8, 9 };

  int32_T i;
  int32_T loop_ub;
  int32_T d_data;
  int32_T d_sizes[2];

  /* MATLAB Function 'updateS': '<S215>:39' */
  /* '<S215>:39:3' sprev = -inf; */
  /* '<S215>:39:4' [s,~,~,~,~,~,~,~,theta] = ATRIAS3D_ZD_Output03(t, q, dq, ControlState, ControlParams, sprev); */
  /* 'ATRIAS3D_ZD_Output03:4' Output = ControlParams.Output; */
  /*  Define matrix to convert between motor and standard actuated coordinates */
  /*  [uLAst; uLAsw; uKAst; uKAsw; u3st; u3sw] = T0*[u1R; u2R; u3R; u1L; u2L; u3L] */
  /* 'ATRIAS3D_ZD_Output03:8' T0 = [0.5 0.5 0 0 0 0; 0 0 0 0.5 0.5 0; -1 1 0 0 0 0; 0 0 0 -1 1 0; 0 0 1 0 0 0; 0 0 0 0 0 1]; */
  /* 'ATRIAS3D_ZD_Output03:9' if (ControlState.StanceLeg==1) */
  /* 'ATRIAS3D_ZD_Output03:12' T1 = [zeros(6,7) T0]; */
  /*     %% Compute s and modify Bezier parameters to extend outside 0 <= s <= 1 */
  /* [Sy,Sq] = SymmetryMatrices(); */
  /* 'ATRIAS3D_ZD_Output03:16' if (ControlState.StanceLeg==0) */
  if (Walking01_withElmos_B.ControlState.StanceLeg == 0.0) {
    /* 'ATRIAS3D_ZD_Output03:17' c = [Output.Theta.c0 Output.Theta.ct Output.Theta.cq]; */
    c[0] = Walking01_withElmos_B.ControlParams.Output.Theta.c0;
    c[1] = Walking01_withElmos_B.ControlParams.Output.Theta.ct;
    for (i = 0; i < 13; i++) {
      c[i + 2] = Walking01_withElmos_B.ControlParams.Output.Theta.cq[i];
    }

    /* 'ATRIAS3D_ZD_Output03:18' jacob_h0 = Output.H0; */
  } else {
    /* 'ATRIAS3D_ZD_Output03:19' else */
    /* 'ATRIAS3D_ZD_Output03:20' c = [Output.Theta.c0 Output.Theta.ct Output.Theta.cq(:,[1 2 3 6 7 4 5 11 12 13 8 9 10])]; */
    c[0] = Walking01_withElmos_B.ControlParams.Output.Theta.c0;
    c[1] = Walking01_withElmos_B.ControlParams.Output.Theta.ct;
    for (i = 0; i < 13; i++) {
      c[i + 2] = Walking01_withElmos_B.ControlParams.Output.Theta.cq[g[i]];
    }

    /* 'ATRIAS3D_ZD_Output03:21' c(:,3:4) = -c(:,3:4); */
    c[2] = -c[2];
    c[3] = -c[3];

    /* 'ATRIAS3D_ZD_Output03:22' jacob_h0 = Output.H0(:,[1 2 3 6 7 4 5 11 12 13 8 9 10]); */
    /* 'ATRIAS3D_ZD_Output03:23' jacob_h0(:,1:2) = -jacob_h0(:,1:2); */
  }

  /* 'ATRIAS3D_ZD_Output03:27' [s,ds,dsdq,theta,dtheta,delta_theta] = ATRIAS3D_ZD_s6(t-Output.Theta.t0, q, dq, Output.ThetaLimits, c); */
  Walking01_with_ATRIAS3D_ZD_s6_b(t -
    Walking01_withElmos_B.ControlParams.Output.Theta.t0, Walking01_withElmos_B.q,
    Walking01_withElmos_B.dq_clean,
    Walking01_withElmos_B.ControlParams.Output.ThetaLimits, c,
    &Walking01_withElmos_DW.s, &ds, dsdq, &Walking01_withElmos_DW.theta, &dtheta,
    &delta_theta);

  /* 'ATRIAS3D_ZD_Output03:28' s_unsaturated = s; */
  /* 'ATRIAS3D_ZD_Output03:30' if (Output.EnforceIncreasingS) */
  if ((Walking01_withElmos_B.ControlParams.Output.EnforceIncreasingS != 0.0) &&
      (!(Walking01_withElmos_DW.s >= (rtMinusInf)))) {
    /* 'ATRIAS3D_ZD_Output03:31' s = max(s, sprev); */
    Walking01_withElmos_DW.s = (rtMinusInf);
  }

  /* 'ATRIAS3D_ZD_Output03:34' h_alpha = Output.HAlpha; */
  /* 'ATRIAS3D_ZD_Output03:35' if (ControlState.StanceLeg==1) */
  /* 'ATRIAS3D_ZD_Output03:39' if Output.SaturateS==1 */
  if (Walking01_withElmos_B.ControlParams.Output.SaturateS == 1.0) {
    /* delta = 0.2; */
    /* p = [0.2  -0.4  0.2  0]; % coefficients of transition poly */
    /* [s, ds] = softsaturate(s, ds, delta, p); */
    /*  Modified Feb. 4th, 2014 for interpolative bezier table bounds. */
    /* 'ATRIAS3D_ZD_Output03:44' delta = 0.1; */
    /* 'ATRIAS3D_ZD_Output03:45' ds(s>1+delta) = 0; */
    /* 'ATRIAS3D_ZD_Output03:46' s(s>1+delta) = 1+delta; */
    b = Walking01_withElmos_DW.s;
    Walking01_withEl_eml_li_find_en(Walking01_withElmos_DW.s > 1.1, &d_data,
      d_sizes);
    loop_ub = d_sizes[0] * d_sizes[1];
    for (i = 0; i < loop_ub; i++) {
      b = 1.1;
    }

    /* 'ATRIAS3D_ZD_Output03:47' ds(s<-delta) = 0; */
    /* 'ATRIAS3D_ZD_Output03:48' s(s<-delta) = -delta; */
    e = b;
    Walking01_withEl_eml_li_find_en(b < -0.1, &d_data, d_sizes);
    loop_ub = d_sizes[0] * d_sizes[1];
    for (i = 0; i < loop_ub; i++) {
      e = -0.1;
    }

    Walking01_withElmos_DW.s = e;
  } else if ((!(Walking01_withElmos_B.ControlParams.Output.SaturateS == 2.0)) &&
             (Walking01_withElmos_B.ControlParams.Output.SaturateS == 3.0)) {
    /* 'ATRIAS3D_ZD_Output03:70' elseif Output.SaturateS==3 */
    /* 'ATRIAS3D_ZD_Output03:71' smin = Output.SLimits(1); */
    /* 'ATRIAS3D_ZD_Output03:72' smax = Output.SLimits(2); */
    /* 'ATRIAS3D_ZD_Output03:73' ds(s>smax) = 0; */
    /* 'ATRIAS3D_ZD_Output03:74' s(s>smax)  = smax; */
    b = Walking01_withElmos_DW.s;
    Walking01_withEl_eml_li_find_en(Walking01_withElmos_DW.s >
      Walking01_withElmos_B.ControlParams.Output.SLimits[1], &d_data, d_sizes);
    loop_ub = d_sizes[0] * d_sizes[1];
    for (i = 0; i < loop_ub; i++) {
      b = Walking01_withElmos_B.ControlParams.Output.SLimits[1];
    }

    /* 'ATRIAS3D_ZD_Output03:75' ds(s<smin) = 0; */
    /* 'ATRIAS3D_ZD_Output03:76' s(s<smin)  = smin; */
    e = b;
    Walking01_withEl_eml_li_find_en(b <
      Walking01_withElmos_B.ControlParams.Output.SLimits[0], &d_data, d_sizes);
    loop_ub = d_sizes[0] * d_sizes[1];
    for (i = 0; i < loop_ub; i++) {
      e = Walking01_withElmos_B.ControlParams.Output.SLimits[0];
    }

    Walking01_withElmos_DW.s = e;
  } else {
    /* 'ATRIAS3D_ZD_Output03:64' h_alpha(s6>1,:) = h_alpha_high(s6>1,:); */
    /*  If (s<0), hold all desired angles constant */
    /* 'ATRIAS3D_ZD_Output03:67' h_alpha_low = h_alpha(:,1)*[1 1 1 1 1 1]; */
    /* 'ATRIAS3D_ZD_Output03:68' h_alpha(s6<0,:) = h_alpha_low(s6<0,:); */
    /* 'ATRIAS3D_ZD_Output03:50' elseif Output.SaturateS==2 */
    /* 'ATRIAS3D_ZD_Output03:51' if (length(s)>1) */
    /* 'ATRIAS3D_ZD_Output03:54' else */
    /* 'ATRIAS3D_ZD_Output03:55' dqyTds = repmat((c(1,5)*delta_theta), 2, 1); */
    /* 'ATRIAS3D_ZD_Output03:56' s6 = repmat(s, 6, 1); */
    /*  If (s>1), hold the desired knee angles constant and keep the */
    /*  torso angle fixed by decreasing the desired leg angles */
    /* 'ATRIAS3D_ZD_Output03:61' h_alpha_high = h_alpha(:,end)*[1 1 1 1 1 1]; */
    /* 'ATRIAS3D_ZD_Output03:62' h_alpha_high(1:2,:) = h_alpha_high(1:2,:)+dqyTds*(-1:0.2:0); */
    /* 'ATRIAS3D_ZD_Output03:63' h_alpha_high(1:2) = max(150*pi/180, h_alpha_high(1:2)); */
  }

  /*     %% Compute terms in controller */
  /* 'ATRIAS3D_ZD_Output03:80' qmod = q; */
  /* 'ATRIAS3D_ZD_Output03:81' qmod(1) = sat(qmod(1), -Output.YawLimit, Output.YawLimit); */
  /* 'ATRIAS3D_ZD_Output03:168' y = max(lo, min(x, hi)); */
  /* 'ATRIAS3D_ZD_Output03:82' h0 = jacob_h0*qmod; */
  /* 'ATRIAS3D_ZD_Output03:83' hd = bezierv(h_alpha, s); */
  /* 'ATRIAS3D_ZD_Output03:84' jacob_hd  = beziervd(h_alpha,s); */
  /* 'ATRIAS3D_ZD_Output03:85' jacob2_hd = bezierva(h_alpha,s); */
  /* 'ATRIAS3D_ZD_Output03:86' dhd = jacob_hd.*ds; */
  /* 'ATRIAS3D_ZD_Output03:88' jacob_h = jacob_h0 - jacob_hd*dsdq; */
  /* 'ATRIAS3D_ZD_Output03:89' jacob_jacobhdqdq = -jacob2_hd.*(ds.*ds); */
  /*     %% Stabilizing output term */
  /*  Allow outputs of the form */
  /*    y = H0*q - hd(s(theta(q)), h_alpha) - hStabilizing(phi - phid(s(theta(q))), StabilizingHAlpha) */
  /* 'ATRIAS3D_ZD_Output03:95' phi    = Output.Phi.cq * q; */
  /* 'ATRIAS3D_ZD_Output03:96' dphi   = Output.Phi.cq * dq; */
  /* 'ATRIAS3D_ZD_Output03:98' phid   = bezier(Output.PhiAlpha, s); */
  /* 'ATRIAS3D_ZD_Output03:99' jacob_phid = bezierd(Output.PhiAlpha, s); */
  /* 'ATRIAS3D_ZD_Output03:100' jacob2_phid = beziera(Output.PhiAlpha, s); */
  /* 'ATRIAS3D_ZD_Output03:102' r      = phi - phid; */
  /* 'ATRIAS3D_ZD_Output03:103' dr     = dphi - jacob_phid * ds; */
  /* 'ATRIAS3D_ZD_Output03:104' RSaturated = false; */
  /* 'ATRIAS3D_ZD_Output03:105' if Output.SaturateR */
  /* 'ATRIAS3D_ZD_Output03:117' hdbar  = polyv(Output.HBarAlpha, r, inf); */
  /* 'ATRIAS3D_ZD_Output03:118' if ~RSaturated */
  /* 'ATRIAS3D_ZD_Output03:126' hdbar = sat(hdbar, Output.HBarLimits(:,1), Output.HBarLimits(:,2)); */
  /* 'ATRIAS3D_ZD_Output03:127' idxsat = (hdbar == Output.HBarLimits(:,1)) | (hdbar == Output.HBarLimits(:,2)); */
  /* 'ATRIAS3D_ZD_Output03:128' jacob_hdbar(idxsat,:) = 0; */
  /* 'ATRIAS3D_ZD_Output03:129' jacob2_hdbar(idxsat,:) = 0; */
  /* 'ATRIAS3D_ZD_Output03:131' hd = hd + hdbar; */
  /* 'ATRIAS3D_ZD_Output03:132' jacob_h = jacob_h - jacob_hdbar * (Output.Phi.cq - jacob_phid * dsdq); */
  /* 'ATRIAS3D_ZD_Output03:133' jacob_jacobhdqdq = jacob_jacobhdqdq ... */
  /* 'ATRIAS3D_ZD_Output03:134'         + jacob_hdbar * jacob2_phid * ds^2 ... */
  /* 'ATRIAS3D_ZD_Output03:135'         + jacob2_hdbar * (-jacob_phid^2 * ds^2 - dphi^2 + jacob_phid * dphi * ds); */
  /*     %% Saturate the desired leg/knee/hip angles */
  /* 'ATRIAS3D_ZD_Output03:138' hd_min = [150; 150;  15;  15; -20; -20]*pi/180; */
  /* 'ATRIAS3D_ZD_Output03:139' hd_max = [220; 220; 120; 120;  20;  20]*pi/180; */
  /* 'ATRIAS3D_ZD_Output03:140' sat_correction = (jacob_h0 - T1)*q; */
  /* 'ATRIAS3D_ZD_Output03:141' hd = sat(hd, hd_min + sat_correction, hd_max + sat_correction); */
  /* 'ATRIAS3D_ZD_Output03:142' idxsat = (hd == hd_min + sat_correction) | (hd == hd_max + sat_correction); */
  /* 'ATRIAS3D_ZD_Output03:143' dhd(idxsat) = 0; */
  /* 'ATRIAS3D_ZD_Output03:144' jacob_h(idxsat) = jacob_h0(idxsat); */
  /*  jacob_hd(idxsat) = 0; */
  /*     %% */
  /* 'ATRIAS3D_ZD_Output03:147' y  = h0-hd; */
  /* 'ATRIAS3D_ZD_Output03:148' dy = jacob_h0*dq - dhd; */
  /*  Correction */
  /* 'ATRIAS3D_ZD_Output03:152' h_alpha_corr = Output.HAlphaCorrection; */
  /* 'ATRIAS3D_ZD_Output03:153' s_corr_max = Output.SMaxCorrection; */
  /* 'ATRIAS3D_ZD_Output03:154' if Output.UseCorrection && any(s <= s_corr_max) */
  /* '<S215>:39:4' ~ */
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function support = checkSupport(WhichLeg)
 */
static real_T Walking01_withElmo_checkSupport(real_T WhichLeg)
{
  real_T support;
  real_T qSpringKA[2];
  static const int8_T a[26] = { 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 1, 0, -1, -1,
    0, 1, 0, 0, 0, 0, -1, 0, 1, 0, 0 };

  int32_T i;
  int32_T i_0;
  real_T qSpringKA_idx_1;

  /* MATLAB Function 'checkSupport': '<S215>:42' */
  /*  CHECK_SUPPORT checks the spring deflections to determine how much */
  /*  support the selected leg provides. It returns 0 if the selected leg */
  /*  does not appear to be on the ground, 1 if it is on the ground but not */
  /*  bearing a preponderance of the weight, and 2 otherwise. */
  /* '<S215>:42:8' qSpringKA = [0 0 0  1 -1  0  0 -1 1 0  0 0 0; */
  /* '<S215>:42:9'                  0 0 0  0  0  1 -1  0 0 0 -1 1 0]*q; */
  /* '<S215>:42:10' qSpringKA = qSpringKA + KASpringOffsets; */
  for (i = 0; i < 2; i++) {
    qSpringKA_idx_1 = 0.0;
    for (i_0 = 0; i_0 < 13; i_0++) {
      qSpringKA_idx_1 += (real_T)a[(i_0 << 1) + i] * Walking01_withElmos_B.q[i_0];
    }

    qSpringKA[i] = qSpringKA_idx_1 + Walking01_withElmos_P.KASpringOffsets[i];
  }

  /* '<S215>:42:12' THRESH_KASPRING_DEFLECTION = ControlParams.Supervisory.ImpactThresholdKASpringAbs*pi/180; */
  /* '<S215>:42:13' THRESH_KASPRING_HYSTERESIS = ControlParams.Supervisory.ImpactThresholdKASpringRel*pi/180; */
  /*  Make the selected leg the first element */
  /* '<S215>:42:16' if (WhichLeg==1) */
  if (WhichLeg == 1.0) {
    /* '<S215>:42:17' qSpringKA = qSpringKA([2 1]); */
    qSpringKA_idx_1 = qSpringKA[0];
    qSpringKA[0] = qSpringKA[1];
    qSpringKA[1] = qSpringKA_idx_1;
  }

  /* '<S215>:42:20' support = 0; */
  support = 0.0;

  /* '<S215>:42:21' if (qSpringKA(1)<THRESH_KASPRING_DEFLECTION) */
  if (qSpringKA[0] <
      Walking01_withElmos_B.ControlParams.Supervisory.ImpactThresholdKASpringAbs
      * 3.1415926535897931 / 180.0) {
    /* '<S215>:42:22' if (qSpringKA(1)-qSpringKA(2)<THRESH_KASPRING_HYSTERESIS) */
    if (qSpringKA[0] - qSpringKA[1] <
        Walking01_withElmos_B.ControlParams.Supervisory.ImpactThresholdKASpringRel
        * 3.1415926535897931 / 180.0) {
      /* '<S215>:42:23' support = 2; */
      support = 2.0;
    } else {
      /* '<S215>:42:24' else */
      /* '<S215>:42:25' support = 1; */
      support = 1.0;
    }
  }

  return support;
}

/* Function for Chart: '<S202>/StateLogic' */
static void Walkin_enter_atomic_RightSingle(void)
{
  int32_T b_previousEvent;

  /* Entry 'RightSingle': '<S215>:32' */
  Walking01_withElmos_B.ControlState.SupportState = 1.0;
  Walking01_withElmos_B.ControlState.StanceLeg = 0.0;
  Walking01_withElmos_B.ControlState.InDoubleSupport = 0.0;
  b_previousEvent = Walking01_withElmos_DW.sfEvent;
  Walking01_withElmos_DW.sfEvent = Walking01_withElm_event_LegSwap;
  if (Walking01_withElmos_DW.is_Main == Walking01_withElmos_IN_Run_k) {
    Walking01_withElmos_Run();
  }

  Walking01_withElmos_DW.sfEvent = b_previousEvent;
}

/* Function for Chart: '<S202>/StateLogic' */
static boolean_T Walking01_withElmos_checkMode(void)
{
  boolean_T swap;

  /* Graphical Function 'checkMode': '<S215>:49' */
  /* Transition: '<S215>:51' */
  swap = false;
  if ((Walking01_withElmos_DW.is_Transition == Walking01_withElmos_IN_Late) ||
      ((Walking01_withElmos_DW.is_ControllerMode ==
        Walking01_withElmos_IN_Walking) &&
       (Walking01_withElmos_DW.WalkingStepCount < 2.0)) ||
      ((Walking01_withElmos_DW.is_ControllerMode ==
        Walking01_withElmos_IN_Walking) && (Walking01_withElmos_DW.s >= 0.35) &&
       (Walking01_withElmos_DW.s <= 0.65))) {
    /* Transition: '<S215>:56' */
    /* Transition: '<S215>:57' */
    swap = true;

    /* Transition: '<S215>:58' */
  } else {
    /* Transition: '<S215>:59' */
  }

  /* Transition: '<S215>:61' */
  return swap;
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function impact = checkImpact
 */
static boolean_T Walking01_withElmos_checkImpact(void)
{
  boolean_T impact;
  real_T qSpringKA[2];
  real_T THRESH_KA_ACCEL;
  real_T THRESH_KASPRING_DEFLECTION;
  real_T THRESH_KASPRING_HYSTERESIS;
  boolean_T b;
  static const int8_T a[26] = { 0, 0, 0, 0, 0, 0, 1, 0, -1, 0, 0, 1, 0, -1, -1,
    0, 1, 0, 0, 0, 0, -1, 0, 1, 0, 0 };

  int32_T i;
  int32_T i_0;

  /* MATLAB Function 'checkImpact': '<S215>:46' */
  /* '<S215>:46:3' qSpringKA = [0 0 0  1 -1  0  0 -1 1 0  0 0 0; */
  /* '<S215>:46:4'                  0 0 0  0  0  1 -1  0 0 0 -1 1 0]*q; */
  /* '<S215>:46:5' qSpringKA = qSpringKA + KASpringOffsets; */
  for (i = 0; i < 2; i++) {
    THRESH_KA_ACCEL = 0.0;
    for (i_0 = 0; i_0 < 13; i_0++) {
      THRESH_KA_ACCEL += (real_T)a[(i_0 << 1) + i] * Walking01_withElmos_B.q[i_0];
    }

    qSpringKA[i] = THRESH_KA_ACCEL + Walking01_withElmos_P.KASpringOffsets[i];
  }

  /* '<S215>:46:8' THRESH_KA_ACCEL            = ControlParams.Supervisory.ImpactThresholdKAAccel*pi/180; */
  THRESH_KA_ACCEL =
    Walking01_withElmos_B.ControlParams.Supervisory.ImpactThresholdKAAccel *
    3.1415926535897931 / 180.0;

  /* '<S215>:46:9' THRESH_KASPRING_DEFLECTION = ControlParams.Supervisory.ImpactThresholdKASpringAbs*pi/180; */
  THRESH_KASPRING_DEFLECTION =
    Walking01_withElmos_B.ControlParams.Supervisory.ImpactThresholdKASpringAbs *
    3.1415926535897931 / 180.0;

  /* '<S215>:46:10' THRESH_KASPRING_HYSTERESIS = ControlParams.Supervisory.ImpactThresholdKASpringRel*pi/180; */
  THRESH_KASPRING_HYSTERESIS =
    Walking01_withElmos_B.ControlParams.Supervisory.ImpactThresholdKASpringRel *
    3.1415926535897931 / 180.0;

  /* '<S215>:46:11' THRESH_S                   = ControlParams.Supervisory.SwapThresholdS; */
  /* '<S215>:46:14' impact = false; */
  impact = false;

  /* '<S215>:46:16' sCondition = (s>=THRESH_S) || ... */
  /* '<S215>:46:17'              ((s<1-THRESH_S) && ControlParams.Supervisory.EnableBackwardSwap); */
  b = ((Walking01_withElmos_DW.s >=
        Walking01_withElmos_B.ControlParams.Supervisory.SwapThresholdS) ||
       ((Walking01_withElmos_DW.s < 1.0 -
         Walking01_withElmos_B.ControlParams.Supervisory.SwapThresholdS) &&
        (Walking01_withElmos_B.ControlParams.Supervisory.EnableBackwardSwap !=
         0.0)));

  /* '<S215>:46:20' if ControlParams.Supervisory.EnableSwapOnKAAccel */
  if (Walking01_withElmos_B.ControlParams.Supervisory.EnableSwapOnKAAccel != 0.0)
  {
    /* '<S215>:46:21' impact = impact ... */
    /* '<S215>:46:22'             || (sCondition && (ControlState.StanceLeg==0) && (ddqKA(2)>THRESH_KA_ACCEL)) ... */
    /* '<S215>:46:23'             || (sCondition && (ControlState.StanceLeg==1) && (ddqKA(1)>THRESH_KA_ACCEL)); */
    impact = ((b && (Walking01_withElmos_B.ControlState.StanceLeg == 0.0) &&
               (Walking01_withElmos_B.VectorConcatenate_a[1] > THRESH_KA_ACCEL))
              || (b && (Walking01_withElmos_B.ControlState.StanceLeg == 1.0) &&
                  (Walking01_withElmos_B.VectorConcatenate_a[0] >
                   THRESH_KA_ACCEL)));
  }

  /* '<S215>:46:26' if ControlParams.Supervisory.EnableSwapOnKASpring */
  if (Walking01_withElmos_B.ControlParams.Supervisory.EnableSwapOnKASpring !=
      0.0) {
    /* '<S215>:46:27' impact = impact ... */
    /* '<S215>:46:28'             || (sCondition && (ControlState.StanceLeg==0) && (qSpringKA(2)-qSpringKA(1)<THRESH_KASPRING_HYSTERESIS) && (qSpringKA(2)<THRESH_KASPRING_DEFLECTION)) ... */
    /* '<S215>:46:29'             || (sCondition && (ControlState.StanceLeg==1) && (qSpringKA(1)-qSpringKA(2)<THRESH_KASPRING_HYSTERESIS) && (qSpringKA(1)<THRESH_KASPRING_DEFLECTION)); */
    impact = (impact || (b && (Walking01_withElmos_B.ControlState.StanceLeg ==
                0.0) && (qSpringKA[1] - qSpringKA[0] <
                         THRESH_KASPRING_HYSTERESIS) && (qSpringKA[1] <
                THRESH_KASPRING_DEFLECTION)) || (b &&
               (Walking01_withElmos_B.ControlState.StanceLeg == 1.0) &&
               (qSpringKA[0] - qSpringKA[1] < THRESH_KASPRING_HYSTERESIS) &&
               (qSpringKA[0] < THRESH_KASPRING_DEFLECTION)));
  }

  /* '<S215>:46:32' impact = impact || ManualSwap; */
  return impact || (Walking01_withElmos_B.DataTypeConversion1 != 0.0);
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function ok = checkTransition
 */
static boolean_T Walking01_withE_checkTransition(void)
{
  boolean_T ok;

  /* MATLAB Function 'checkTransition': '<S215>:110' */
  /* '<S215>:110:3' ok = false; */
  ok = false;

  /* '<S215>:110:4' if (ControlState.ControllerMode==1) */
  if (Walking01_withElmos_B.ControlState.ControllerMode == 1.0) {
    /* '<S215>:110:5' ok = (dq(3) < ControlParams.Supervisory.TransitionThresholdTorsoVel*pi/180); */
    ok = (Walking01_withElmos_B.dq_clean[2] <
          Walking01_withElmos_B.ControlParams.Supervisory.TransitionThresholdTorsoVel
          * 3.1415926535897931 / 180.0);
  } else {
    if ((Walking01_withElmos_B.ControlState.ControllerMode == 2.0) ||
        (Walking01_withElmos_B.ControlState.ControllerMode == 3.0)) {
      /* '<S215>:110:6' elseif (ControlState.ControllerMode==2) || (ControlState.ControllerMode==3) */
      /* '<S215>:110:7' ok = (TransitionStepCount >= ControlParams.Supervisory.NumTransitionSteps); */
      ok = (Walking01_withElmos_DW.TransitionStepCount >=
            Walking01_withElmos_B.ControlParams.Supervisory.NumTransitionSteps);
    }
  }

  return ok;
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function HAlpha = applyGaitTweaks2(ControlState, ControlParams, GetTweaks)
 */
static void Walking01_wi_applyGaitTweaks2_p(real_T ControlState_ControllerMode,
  const real_T ControlParams_Supervisory_GaitT[5], const real_T
  ControlParams_Output_H0[78], real_T HAlpha[36])
{
  real_T StanceKneeAngleBias;
  real_T SwingKneeAngleBias2;
  real_T TorsoBias;
  real_T QTweakVec[13];
  real_T QTweaks[78];
  int32_T ibtile;
  int32_T jtilecol;
  int32_T i;
  real_T SwingKeeAngleBias_idx_0;
  real_T SwingKeeAngleBias_idx_1;

  /*  APPLYGAITTWEAKS2 computes modified Bezier coefficients corresponding */
  /*  to a tweaked orbit. */
  /*  In order to handle different output definitions consistently, we */
  /*  create a matrix QTweak which represents Bezier coefficients for the */
  /*  desired modifications to the gait (i.e., there is one row for each */
  /*  coordinate in q). */
  /* 'applyGaitTweaks2:9' if nargin==2 */
  /* 'applyGaitTweaks2:13' StanceKneeAngleBias = ControlParams.Supervisory.GaitTweaks(1) * pi/180; */
  StanceKneeAngleBias = ControlParams_Supervisory_GaitT[0] * 3.1415926535897931 /
    180.0;

  /* 'applyGaitTweaks2:14' SwingKneeAngleBias1 = ControlParams.Supervisory.GaitTweaks(2) * pi/180; */
  /* 'applyGaitTweaks2:15' SwingKneeAngleBias2 = ControlParams.Supervisory.GaitTweaks(3) * pi/180; */
  SwingKneeAngleBias2 = ControlParams_Supervisory_GaitT[2] * 3.1415926535897931 /
    180.0;

  /* 'applyGaitTweaks2:16' SwingKneeAngleBias3 = ControlParams.Supervisory.GaitTweaks(4) * pi/180; */
  /* 'applyGaitTweaks2:17' TorsoBias           = ControlParams.Supervisory.GaitTweaks(5) * pi/180; */
  TorsoBias = ControlParams_Supervisory_GaitT[4] * 3.1415926535897931 / 180.0;

  /* 'applyGaitTweaks2:19' QTweakVec = [... */
  /* 'applyGaitTweaks2:20'         0; ... */
  /* 'applyGaitTweaks2:21'         0; ... */
  /* 'applyGaitTweaks2:22'         TorsoBias; ... */
  /* 'applyGaitTweaks2:23'         -StanceKneeAngleBias/2 - TorsoBias; ... */
  /* 'applyGaitTweaks2:24'         StanceKneeAngleBias/2 - TorsoBias; ... */
  /* 'applyGaitTweaks2:25'         -StanceKneeAngleBias/2 - TorsoBias; ... */
  /* 'applyGaitTweaks2:26'         StanceKneeAngleBias/2 - TorsoBias; ... */
  /* 'applyGaitTweaks2:27'         -StanceKneeAngleBias/2 - TorsoBias; ... */
  /* 'applyGaitTweaks2:28'         StanceKneeAngleBias/2 - TorsoBias; ... */
  /* 'applyGaitTweaks2:29'         0; ... */
  /* 'applyGaitTweaks2:30'         -StanceKneeAngleBias/2 - TorsoBias; ... */
  /* 'applyGaitTweaks2:31'         StanceKneeAngleBias/2 - TorsoBias; ... */
  /* 'applyGaitTweaks2:32'         0]; */
  QTweakVec[0] = 0.0;
  QTweakVec[1] = 0.0;
  QTweakVec[2] = TorsoBias;
  QTweakVec[3] = -StanceKneeAngleBias / 2.0 - TorsoBias;
  QTweakVec[4] = StanceKneeAngleBias / 2.0 - TorsoBias;
  QTweakVec[5] = -StanceKneeAngleBias / 2.0 - TorsoBias;
  QTweakVec[6] = StanceKneeAngleBias / 2.0 - TorsoBias;
  QTweakVec[7] = -StanceKneeAngleBias / 2.0 - TorsoBias;
  QTweakVec[8] = StanceKneeAngleBias / 2.0 - TorsoBias;
  QTweakVec[9] = 0.0;
  QTweakVec[10] = -StanceKneeAngleBias / 2.0 - TorsoBias;
  QTweakVec[11] = StanceKneeAngleBias / 2.0 - TorsoBias;
  QTweakVec[12] = 0.0;

  /* 'applyGaitTweaks2:33' QTweaks = repmat(QTweakVec, 1, 6); */
  for (jtilecol = 0; jtilecol < 6; jtilecol++) {
    ibtile = jtilecol * 13;
    memcpy(&QTweaks[ibtile], &QTweakVec[0], 13U * sizeof(real_T));
  }

  /* 'applyGaitTweaks2:35' if (ControlState.ControllerMode == 4) */
  if (ControlState_ControllerMode == 4.0) {
    /* 'applyGaitTweaks2:36' SwingKeeAngleBias = [SwingKneeAngleBias1 SwingKneeAngleBias2 SwingKneeAngleBias2 SwingKneeAngleBias3]/2; */
    SwingKeeAngleBias_idx_0 = ControlParams_Supervisory_GaitT[1] *
      3.1415926535897931 / 180.0 / 2.0;
    SwingKeeAngleBias_idx_1 = SwingKneeAngleBias2 / 2.0;
    StanceKneeAngleBias = SwingKneeAngleBias2 / 2.0;
    SwingKneeAngleBias2 = ControlParams_Supervisory_GaitT[3] *
      3.1415926535897931 / 180.0 / 2.0;

    /* 'applyGaitTweaks2:37' QTweaks(6,2:5)  = -SwingKeeAngleBias - TorsoBias; */
    QTweaks[18] = -SwingKeeAngleBias_idx_0 - TorsoBias;
    QTweaks[31] = -SwingKeeAngleBias_idx_1 - TorsoBias;
    QTweaks[44] = -StanceKneeAngleBias - TorsoBias;
    QTweaks[57] = -SwingKneeAngleBias2 - TorsoBias;

    /* 'applyGaitTweaks2:38' QTweaks(7,2:5)  =  SwingKeeAngleBias - TorsoBias; */
    QTweaks[19] = SwingKeeAngleBias_idx_0 - TorsoBias;
    QTweaks[32] = SwingKeeAngleBias_idx_1 - TorsoBias;
    QTweaks[45] = StanceKneeAngleBias - TorsoBias;
    QTweaks[58] = SwingKneeAngleBias2 - TorsoBias;

    /* 'applyGaitTweaks2:39' QTweaks(11,2:5) = -SwingKeeAngleBias - TorsoBias; */
    QTweaks[23] = -SwingKeeAngleBias_idx_0 - TorsoBias;
    QTweaks[36] = -SwingKeeAngleBias_idx_1 - TorsoBias;
    QTweaks[49] = -StanceKneeAngleBias - TorsoBias;
    QTweaks[62] = -SwingKneeAngleBias2 - TorsoBias;

    /* 'applyGaitTweaks2:40' QTweaks(12,2:5) =  SwingKeeAngleBias - TorsoBias; */
    QTweaks[24] = SwingKeeAngleBias_idx_0 - TorsoBias;
    QTweaks[37] = SwingKeeAngleBias_idx_1 - TorsoBias;
    QTweaks[50] = StanceKneeAngleBias - TorsoBias;
    QTweaks[63] = SwingKneeAngleBias2 - TorsoBias;
  }

  /* 'applyGaitTweaks2:43' HAlpha = ControlParams.Output.H0 * QTweaks; */
  for (jtilecol = 0; jtilecol < 6; jtilecol++) {
    for (ibtile = 0; ibtile < 6; ibtile++) {
      HAlpha[jtilecol + 6 * ibtile] = 0.0;
      for (i = 0; i < 13; i++) {
        HAlpha[jtilecol + 6 * ibtile] += ControlParams_Output_H0[6 * i +
          jtilecol] * QTweaks[13 * ibtile + i];
      }
    }
  }

  /* 'applyGaitTweaks2:44' if ~GetTweaks */
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function alpha_out = elevate1(alpha, M)
 */
static void Walking01_withElmos_elevate1(const real_T alpha_data[], const
  int32_T alpha_sizes[2], real_T M, real_T alpha_out_data[], int32_T
  alpha_out_sizes[2])
{
  int32_T nm1d2;
  real_T anew;
  int32_T k;
  real_T ndbl;
  real_T apnd;
  real_T cdiff;
  int32_T c_k;
  int32_T c_n;
  int32_T ar;
  int32_T ia;
  int32_T loop_ub;
  real_T y_data[5];
  real_T d_data[25];
  real_T b_d_data[25];
  real_T b_data[30];
  real_T d_data_0[30];
  real_T tmp_data[30];
  int32_T d_sizes_idx_0;
  int32_T b_sizes_idx_1;
  int8_T e_idx_0;
  int8_T e_idx_1;
  real_T u1;

  /*  From http://en.wikipedia.org/wiki/B%C3%A9zier_curve#Degree_elevation */
  /*  \mathbf{P'}_i = \frac{i}{n+1}\mathbf{P}_{i-1} + \frac{n+1-i}{n+1}\mathbf{P}_i,\quad i=0,\ldots, n+1.  */
  /* 'bezierelevate:23' alpha_out = alpha*([diag((M+1):-1:1)/(M+1) zeros(M+1,1)] + [zeros(M+1,1) diag(1:1:(M+1))/(M+1)]); */
  if (rtIsNaN(M + 1.0)) {
    ar = 1;
    anew = (rtNaN);
    apnd = 1.0;
  } else {
    anew = M + 1.0;
    ndbl = floor(-(1.0 - (M + 1.0)) + 0.5);
    apnd = (M + 1.0) + -ndbl;
    cdiff = fabs(M + 1.0);
    if (!(cdiff >= 1.0)) {
      cdiff = 1.0;
    }

    if (fabs(1.0 - apnd) < 4.4408920985006262E-16 * cdiff) {
      ndbl++;
      apnd = 1.0;
    } else if (1.0 - apnd > 0.0) {
      apnd = (M + 1.0) + -(ndbl - 1.0);
    } else {
      ndbl++;
    }

    ar = (int32_T)ndbl;
  }

  y_data[0] = anew;
  if (ar > 1) {
    y_data[ar - 1] = apnd;
    nm1d2 = (ar - 1) / 2;
    k = 1;
    while (k <= nm1d2 - 1) {
      y_data[1] = anew + -1.0;
      y_data[ar - 2] = apnd - -1.0;
      k = 2;
    }

    if (nm1d2 << 1 == ar - 1) {
      y_data[nm1d2] = (anew + apnd) / 2.0;
    } else {
      y_data[nm1d2] = anew + -(real_T)nm1d2;
      y_data[nm1d2 + 1] = apnd - (-(real_T)nm1d2);
    }
  }

  e_idx_0 = (int8_T)ar;
  e_idx_1 = (int8_T)ar;
  d_sizes_idx_0 = e_idx_0;
  c_n = e_idx_1;
  loop_ub = e_idx_0 * e_idx_1;
  for (ia = 0; ia < loop_ub; ia++) {
    d_data[ia] = 0.0;
  }

  for (nm1d2 = 0; nm1d2 + 1 <= ar; nm1d2++) {
    d_data[nm1d2 + e_idx_0 * nm1d2] = y_data[nm1d2];
  }

  if (rtIsNaN(M + 1.0)) {
    ar = 1;
    anew = (rtNaN);
    apnd = M + 1.0;
  } else {
    anew = 1.0;
    ndbl = floor(((M + 1.0) - 1.0) + 0.5);
    apnd = 1.0 + ndbl;
    cdiff = (1.0 + ndbl) - (M + 1.0);
    u1 = fabs(M + 1.0);
    if ((1.0 >= u1) || rtIsNaN(u1)) {
      u1 = 1.0;
    }

    if (fabs(cdiff) < 4.4408920985006262E-16 * u1) {
      ndbl++;
      apnd = M + 1.0;
    } else if (cdiff > 0.0) {
      apnd = (ndbl - 1.0) + 1.0;
    } else {
      ndbl++;
    }

    ar = (int32_T)ndbl;
  }

  y_data[0] = anew;
  if (ar > 1) {
    y_data[ar - 1] = apnd;
    nm1d2 = (ar - 1) / 2;
    k = 1;
    while (k <= nm1d2 - 1) {
      y_data[1] = anew + 1.0;
      y_data[ar - 2] = apnd - 1.0;
      k = 2;
    }

    if (nm1d2 << 1 == ar - 1) {
      y_data[nm1d2] = (anew + apnd) / 2.0;
    } else {
      y_data[nm1d2] = anew + (real_T)nm1d2;
      y_data[nm1d2 + 1] = apnd - (real_T)nm1d2;
    }
  }

  e_idx_0 = (int8_T)ar;
  e_idx_1 = (int8_T)ar;
  loop_ub = e_idx_0 * e_idx_1;
  for (ia = 0; ia < loop_ub; ia++) {
    b_d_data[ia] = 0.0;
  }

  for (nm1d2 = 0; nm1d2 + 1 <= ar; nm1d2++) {
    b_d_data[nm1d2 + e_idx_0 * nm1d2] = y_data[nm1d2];
  }

  b_sizes_idx_1 = c_n + 1;
  nm1d2 = (int32_T)(M + 1.0);
  k = (int32_T)(M + 1.0);
  ar = d_sizes_idx_0 * c_n + nm1d2;
  loop_ub = d_sizes_idx_0 * c_n;
  for (ia = 0; ia < loop_ub; ia++) {
    d_data_0[ia] = d_data[ia] / (M + 1.0);
  }

  for (ia = 0; ia < nm1d2; ia++) {
    d_data_0[ia + d_sizes_idx_0 * c_n] = 0.0;
  }

  for (ia = 0; ia < k; ia++) {
    tmp_data[ia] = 0.0;
  }

  loop_ub = e_idx_0 * e_idx_1;
  for (ia = 0; ia < loop_ub; ia++) {
    tmp_data[ia + k] = b_d_data[ia] / (M + 1.0);
  }

  for (ia = 0; ia < ar; ia++) {
    b_data[ia] = d_data_0[ia] + tmp_data[ia];
  }

  c_k = alpha_sizes[1];
  e_idx_1 = (int8_T)b_sizes_idx_1;
  c_n = b_sizes_idx_1 - 1;
  alpha_out_sizes[0] = 1;
  alpha_out_sizes[1] = e_idx_1;
  nm1d2 = e_idx_1;
  for (ia = 0; ia < nm1d2; ia++) {
    alpha_out_data[ia] = 0.0;
  }

  for (nm1d2 = 0; nm1d2 <= c_n; nm1d2++) {
    for (k = nm1d2; k + 1 <= nm1d2 + 1; k++) {
      alpha_out_data[k] = 0.0;
    }
  }

  nm1d2 = 0;
  for (k = 0; k <= c_n; k++) {
    ar = 0;
    b_sizes_idx_1 = nm1d2 + c_k;
    for (loop_ub = nm1d2; loop_ub + 1 <= b_sizes_idx_1; loop_ub++) {
      if (b_data[loop_ub] != 0.0) {
        ia = ar;
        for (d_sizes_idx_0 = k; d_sizes_idx_0 + 1 <= k + 1; d_sizes_idx_0++) {
          ia++;
          alpha_out_data[d_sizes_idx_0] += alpha_data[ia - 1] * b_data[loop_ub];
        }
      }

      ar++;
    }

    nm1d2 += c_k;
  }
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function [u_ff, h_alpha]   = computeLateralControl(q, dq, stance_leg, u_ff, h_alpha, ControlState, ControlParams, pcm, vcm)
 */
static void Walking01_computeLateralControl(const real_T q[13], real_T
  stance_leg, real_T h_alpha[36], real_T ControlState_StepCount, real_T
  ControlParams_Supervisory_Torso, real_T ControlParams_Feedback_kp_lat, real_T
  ControlParams_Feedback_q3d_min_, real_T ControlParams_Feedback_q3d_max_,
  real_T ControlParams_Feedback_w_torso_, real_T ControlParams_Feedback_LateralC,
  real_T ControlParams_Feedback_lat_bias, real_T ControlParams_Feedback_lat_bi_0)
{
  int32_T Ttorso;
  real_T q3st;
  real_T q3sw;
  real_T hd;
  real_T alpha_out[6];
  int32_T loop_ub;
  real_T alpha_out_data[5];
  int32_T alpha_out_sizes[2];
  real_T tmp_data[6];
  int32_T tmp_sizes[2];

  /* 'computeLateralControl:4' if (ControlParams.Feedback.LateralControlMode==1) || (ControlParams.Feedback.LateralControlMode==3) */
  if ((ControlParams_Feedback_LateralC == 1.0) ||
      (ControlParams_Feedback_LateralC == 3.0)) {
    /* 'computeLateralControl:6' PSI  = 9*pi/180; */
    /* 'computeLateralControl:7' phi0 = PSI; */
    /* 'computeLateralControl:9' if (stance_leg==0) */
    if (stance_leg == 0.0) {
      /* 'computeLateralControl:10' Ttorso = -1; */
      Ttorso = -1;

      /* ControlParams.Feedback.w_torso_lat; */
      /* 'computeLateralControl:11' q3st   = q(10); */
      q3st = q[9];

      /* 'computeLateralControl:12' dq3st  = dq(10); */
      /* 'computeLateralControl:13' q3sw   = q(13); */
      q3sw = q[12];
    } else {
      /* 'computeLateralControl:14' else */
      /* 'computeLateralControl:15' Ttorso = 1; */
      Ttorso = 1;

      /* ControlParams.Feedback.w_torso_lat; */
      /* 'computeLateralControl:16' q3st   = q(13); */
      q3st = q[12];

      /* 'computeLateralControl:17' dq3st  = dq(13); */
      /* 'computeLateralControl:18' q3sw   = q(10); */
      q3sw = q[9];
    }

    /*  Convert to absolute coordinates, where phi is the absolute angle */
    /*  (from vertical) of the line from the stance toe to the center of the */
    /*  hips. The sign is chosen so that phi>0 means that the center of mass */
    /*  is to the _inside_ of the stance leg. */
    /* 'computeLateralControl:25' phi  = Ttorso*q(2)-q3st+PSI; */
    /* 'computeLateralControl:26' dphi = Ttorso*dq(2)-dq3st; */
    /* 'computeLateralControl:28' if (ControlParams.Feedback.LateralControlMode==1) */
    /*  Convert back to body coordinates */
    /*  q3d = -Ttorso*q(2)-phiswd+PSI; */
    /* 'computeLateralControl:47' if (ControlState.StepCount > ControlParams.Supervisory.TorsoBackOnStep) */
    if (ControlState_StepCount > ControlParams_Supervisory_Torso) {
      /* 'computeLateralControl:48' q3d = -(1+ControlParams.Feedback.kp_lat+ControlParams.Feedback.w_torso_lat)*Ttorso*q(2) + ControlParams.Feedback.kp_lat*q3st + ControlParams.Feedback.lat_bias2*pi/180; */
      q3st = (-((1.0 + ControlParams_Feedback_kp_lat) +
                ControlParams_Feedback_w_torso_) * (real_T)Ttorso * q[1] +
              ControlParams_Feedback_kp_lat * q3st) +
        ControlParams_Feedback_lat_bi_0 * 3.1415926535897931 / 180.0;
    } else {
      /* 'computeLateralControl:49' else */
      /* 'computeLateralControl:50' q3d = -(1+ControlParams.Feedback.kp_lat+ControlParams.Feedback.w_torso_lat)*Ttorso*q(2) + ControlParams.Feedback.kp_lat*q3st + ControlParams.Feedback.lat_bias*pi/180; */
      q3st = (-((1.0 + ControlParams_Feedback_kp_lat) +
                ControlParams_Feedback_w_torso_) * (real_T)Ttorso * q[1] +
              ControlParams_Feedback_kp_lat * q3st) +
        ControlParams_Feedback_lat_bias * 3.1415926535897931 / 180.0;
    }

    /*  Saturate and use this angle as the desired setpoint */
    /* 'computeLateralControl:54' q3dmin       = ControlParams.Feedback.q3d_min_lat*pi/180; */
    /* 'computeLateralControl:55' q3dmax       = ControlParams.Feedback.q3d_max_lat*pi/180; */
    /* hd = sat(q3d-2*pi/180, q3dmin, q3dmax); */
    /* 'computeLateralControl:57' hd = sat(q3d, q3dmin, q3dmax); */
    /* 'sat:3' y = max(lo, min(x, hi)); */
    hd = ControlParams_Feedback_q3d_max_ * 3.1415926535897931 / 180.0;
    if ((q3st <= hd) || rtIsNaN(hd)) {
      hd = q3st;
    }

    q3st = ControlParams_Feedback_q3d_min_ * 3.1415926535897931 / 180.0;
    if ((q3st >= hd) || rtIsNaN(hd)) {
      hd = q3st;
    }

    /* s = (0:0.2:1); */
    /* h_alpha(6,:) = s*hd + (1-s)*q3sw; */
    /* h_alpha(6,:) = [q3sw q3sw hd hd hd q3sw]; */
    /* 'computeLateralControl:62' h_alpha(6,:) = bezierelevate([q3sw -8*pi/180 hd hd],5); */
    /* 'bezierelevate:3' M = size(alpha,2)-1; */
    /*  original M */
    /* 'bezierelevate:4' if nargin<2 */
    /* 'bezierelevate:8' if Mdes < M */
    /* 'bezierelevate:12' alpha_out = [alpha, zeros(size(alpha,1), Mdes-M)]; */
    alpha_out[0] = q3sw;
    alpha_out[1] = -0.13962634015954636;
    alpha_out[2] = hd;
    alpha_out[3] = hd;
    alpha_out[4] = 0.0;
    alpha_out[5] = 0.0;

    /* 'bezierelevate:13' while (M < Mdes) */
    /* 'bezierelevate:14' alpha_out(:,1:M+2) = elevate1(alpha_out(:,1:M+1), M); */
    alpha_out_sizes[0] = 1;
    alpha_out_sizes[1] = 4;
    for (Ttorso = 0; Ttorso < 4; Ttorso++) {
      alpha_out_data[Ttorso] = alpha_out[Ttorso];
    }

    Walking01_withElmos_elevate1(alpha_out_data, alpha_out_sizes, 3.0, tmp_data,
      tmp_sizes);
    loop_ub = tmp_sizes[1];
    for (Ttorso = 0; Ttorso < loop_ub; Ttorso++) {
      alpha_out[Ttorso] = tmp_data[tmp_sizes[0] * Ttorso];
    }

    /* 'bezierelevate:15' M = M+1; */
    /* 'bezierelevate:14' alpha_out(:,1:M+2) = elevate1(alpha_out(:,1:M+1), M); */
    alpha_out_sizes[0] = 1;
    alpha_out_sizes[1] = 5;
    for (Ttorso = 0; Ttorso < 5; Ttorso++) {
      alpha_out_data[Ttorso] = alpha_out[Ttorso];
    }

    Walking01_withElmos_elevate1(alpha_out_data, alpha_out_sizes, 4.0, tmp_data,
      tmp_sizes);
    loop_ub = tmp_sizes[1];
    for (Ttorso = 0; Ttorso < loop_ub; Ttorso++) {
      alpha_out[Ttorso] = tmp_data[tmp_sizes[0] * Ttorso];
    }

    /* 'bezierelevate:15' M = M+1; */
    for (Ttorso = 0; Ttorso < 6; Ttorso++) {
      h_alpha[5 + 6 * Ttorso] = alpha_out[Ttorso];
    }

    /* h_alpha(6,:) = bezierelevate([q3  hd],5); */
  }
}

/* Function for Chart: '<S202>/StateLogic' */
static void Walking01_withE_eml_li_find_enu(const boolean_T x[6], int32_T
  y_data[], int32_T *y_sizes)
{
  int32_T j;
  int32_T i;
  *y_sizes = 0;
  for (j = 0; j < 6; j++) {
    if (x[j]) {
      (*y_sizes)++;
    }
  }

  j = 0;
  for (i = 0; i < 6; i++) {
    if (x[i]) {
      y_data[j] = i + 1;
      j++;
    }
  }
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function value = bezierv( alpha, s )
 */
static void Walking01_withElmos_bezierv_a(const real_T alpha[36], real_T s,
  real_T value[6])
{
  real_T x[6];
  real_T y[6];
  int32_T j;
  static const int8_T b[6] = { 1, 5, 10, 10, 5, 1 };

  int32_T i;

  /* 'bezierv:2' [n, m] = size(alpha); */
  /* 'bezierv:3' ns = size(s,1); */
  /* 'bezierv:4' value=zeros(n,1); */
  /* 'bezierv:5' M = m-1; */
  /* 'bezierv:6' if M==3 */
  /* 'bezierv:10' elseif M==5 */
  /* 'bezierv:11' k=[1 5 10 10 5 1]; */
  /* % */
  /* 'bezierv:24' x = ones(ns, M+1); */
  /* 'bezierv:25' y = ones(ns, M+1); */
  for (i = 0; i < 6; i++) {
    value[i] = 0.0;
    x[i] = 1.0;
    y[i] = 1.0;
  }

  /* 'bezierv:26' for i=1:M */
  for (i = 0; i < 5; i++) {
    /* 'bezierv:27' x(:,i+1)=s.*x(:,i); */
    x[1 + i] = s * x[i];

    /* 'bezierv:28' y(:,i+1)=(1-s).*y(:,i); */
    y[1 + i] = (1.0 - s) * y[i];
  }

  /* 'bezierv:30' idx = 1; */
  /* 'bezierv:31' for i=1:n */
  for (i = 0; i < 6; i++) {
    /* 'bezierv:32' value(i) = 0; */
    value[i] = 0.0;

    /* 'bezierv:33' for j=1:M+1 */
    for (j = 0; j < 6; j++) {
      /* 'bezierv:34' value(i) = value(i) + alpha(i, j)*k(j)*x(idx,j)*y(idx,M+2-j); */
      value[i] += alpha[6 * j + i] * (real_T)b[j] * x[j] * y[5 - j];
    }

    /* 'bezierv:36' idx = idx+(ns==n); */
  }
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function y = sat(x,lo,hi)
 */
static void Walking01_withElmos_sat_iu(const real_T x[6], const real_T lo[6],
  const real_T hi[6], real_T y[6])
{
  int32_T k;
  real_T minval;

  /* 'ATRIAS3D_ZD_Output02:114' y = max(lo, min(x, hi)); */
  for (k = 0; k < 6; k++) {
    if ((x[k] <= hi[k]) || rtIsNaN(hi[k])) {
      minval = x[k];
    } else {
      minval = hi[k];
    }

    if ((lo[k] >= minval) || rtIsNaN(minval)) {
      y[k] = lo[k];
    } else {
      y[k] = minval;
    }
  }
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function value = polyv( poly_cor,s,s_corr_max)
 */
static void Walking01_withElmos_polyv_d(const real_T poly_cor[30], real_T s,
  real_T s_corr_max, real_T value[6])
{
  int32_T s_0;
  int32_T i;

  /* 'polyv:2' if nargin<3 */
  /* 'polyv:5' a0=poly_cor(:,1); */
  /* 'polyv:6' a1=poly_cor(:,2); */
  /* 'polyv:7' a2=poly_cor(:,3); */
  /* 'polyv:8' a3=poly_cor(:,4); */
  /* 'polyv:9' a4=poly_cor(:,5); */
  /* 'polyv:10' value=a0+s.*(a1+s.*(a2+s.*(a3+s.*a4))); */
  /* 'polyv:11' value=value.*(s<=s_corr_max); */
  s_0 = (s <= s_corr_max);
  for (i = 0; i < 6; i++) {
    value[i] = ((((poly_cor[24 + i] * s + poly_cor[18 + i]) * s + poly_cor[12 +
                  i]) * s + poly_cor[6 + i]) * s + poly_cor[i]) * (real_T)s_0;
  }
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function [s,ds,h0,y,dy,jacob_h0,jacob_h,s_unsaturated,theta,dtheta,delta_theta,dsdq,jacob_jacobh0dq,d] = ATRIAS3D_ZD_Output02(t, q, dq, ControlState, Output)
 */
static void Walking0_ATRIAS3D_ZD_Output02_j(real_T t, const real_T q[13], const
  real_T dq[13], real_T ControlState_StanceLeg, const real_T Output_H0[78],
  const real_T Output_HAlpha[36], const real_T Output_ThetaLimits[2], real_T
  Output_Theta_c0, real_T Output_Theta_ct, const real_T Output_Theta_cq[13],
  real_T Output_SaturateS, real_T Output_UseCorrection, real_T
  Output_SMaxCorrection, const real_T Output_HAlphaCorrection[30], real_T *s,
  real_T *ds, real_T h0[6], real_T y[6])
{
  real_T T0[36];
  real_T c[15];
  real_T h_alpha[36];
  real_T h_alpha_high[36];
  real_T sat_correction[6];
  real_T dsdq[13];
  real_T theta;
  real_T dtheta;
  real_T delta_theta;
  real_T jacob_h0[78];
  real_T b;
  real_T d;
  real_T e;
  real_T g;
  int32_T k;
  static const real_T b_T0[36] = { 0.5, 0.0, -1.0, 0.0, 0.0, 0.0, 0.5, 0.0, 1.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.5, 0.0, -1.0, 0.0, 0.0,
    0.0, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 };

  static const real_T i[36] = { 0.0, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0, 0.5, 0.0,
    1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0,
    0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 };

  static const int8_T j[13] = { 0, 1, 2, 5, 6, 3, 4, 10, 11, 12, 7, 8, 9 };

  static const real_T b_b[6] = { -1.0, -0.8, -0.6, -0.4, -0.2, 0.0 };

  static const real_T hd_min[6] = { 2.6179938779914944, 2.6179938779914944,
    0.26179938779914941, 0.26179938779914941, -0.3490658503988659,
    -0.3490658503988659 };

  static const real_T hd_max[6] = { 3.839724354387525, 3.839724354387525,
    2.0943951023931953, 2.0943951023931953, 0.3490658503988659,
    0.3490658503988659 };

  real_T tmp[6];
  real_T hd_min_0[6];
  real_T hd_max_0[6];
  boolean_T b_s[6];
  boolean_T b_s_0[6];
  int32_T i_0;
  real_T tmp_0[78];
  real_T jacob_h0_0[78];
  int32_T tmp_data[6];
  int32_T tmp_sizes;
  int32_T tmp_data_0[6];
  real_T h_alpha_data[36];

  /*  Define matrix to convert between motor and standard actuated coordinates */
  /*  [uLAst; uLAsw; uKAst; uKAsw; u3st; u3sw] = T0*[u1R; u2R; u3R; u1L; u2L; u3L] */
  /* 'ATRIAS3D_ZD_Output02:6' T0 = [0.5 0.5 0 0 0 0; 0 0 0 0.5 0.5 0; -1 1 0 0 0 0; 0 0 0 -1 1 0; 0 0 1 0 0 0; 0 0 0 0 0 1]; */
  memcpy(&T0[0], &b_T0[0], 36U * sizeof(real_T));

  /* 'ATRIAS3D_ZD_Output02:7' if (ControlState.StanceLeg==1) */
  if (ControlState_StanceLeg == 1.0) {
    /* 'ATRIAS3D_ZD_Output02:8' T0 = T0([2 1 4 3 6 5],:); */
    memcpy(&T0[0], &i[0], 36U * sizeof(real_T));
  }

  /* 'ATRIAS3D_ZD_Output02:10' T1 = [zeros(6,7) T0]; */
  /*     %% Compute s and modify Bezier parameters to extend outside 0 <= s <= 1 */
  /* [Sy,Sq] = SymmetryMatrices(); */
  /* 'ATRIAS3D_ZD_Output02:14' if (ControlState.StanceLeg==0) */
  if (ControlState_StanceLeg == 0.0) {
    /* 'ATRIAS3D_ZD_Output02:15' c = [Output.Theta.c0 Output.Theta.ct Output.Theta.cq]; */
    c[0] = Output_Theta_c0;
    c[1] = Output_Theta_ct;
    memcpy(&c[2], &Output_Theta_cq[0], 13U * sizeof(real_T));

    /* 'ATRIAS3D_ZD_Output02:16' jacob_h0 = Output.H0; */
    memcpy(&jacob_h0[0], &Output_H0[0], 78U * sizeof(real_T));
  } else {
    /* 'ATRIAS3D_ZD_Output02:17' else */
    /* 'ATRIAS3D_ZD_Output02:18' c = [Output.Theta.c0 Output.Theta.ct Output.Theta.cq(:,[1 2 3 6 7 4 5 11 12 13 8 9 10])]; */
    c[0] = Output_Theta_c0;
    c[1] = Output_Theta_ct;
    for (i_0 = 0; i_0 < 13; i_0++) {
      c[i_0 + 2] = Output_Theta_cq[j[i_0]];
    }

    /* 'ATRIAS3D_ZD_Output02:19' c(:,3:4) = -c(:,3:4); */
    c[2] = -c[2];
    c[3] = -c[3];

    /* 'ATRIAS3D_ZD_Output02:20' jacob_h0 = Output.H0(:,[1 2 3 6 7 4 5 11 12 13 8 9 10]); */
    for (i_0 = 0; i_0 < 13; i_0++) {
      for (k = 0; k < 6; k++) {
        jacob_h0[k + 6 * i_0] = Output_H0[6 * j[i_0] + k];
      }
    }

    /* 'ATRIAS3D_ZD_Output02:21' jacob_h0(:,1:2) = -jacob_h0(:,1:2); */
    for (i_0 = 0; i_0 < 2; i_0++) {
      for (k = 0; k < 6; k++) {
        jacob_h0[k + 6 * i_0] = -Output_H0[6 * j[i_0] + k];
      }
    }

    /* jacob_h0 = Output.H0; */
    /* jacob_h0 = Sy*jacob_h0*Sq; */
  }

  /* 'ATRIAS3D_ZD_Output02:28' [s,ds,dsdq,theta,dtheta,delta_theta] = ATRIAS3D_ZD_s6(t, q, dq, Output.ThetaLimits, c); */
  Walking01_with_ATRIAS3D_ZD_s6_b(t, q, dq, Output_ThetaLimits, c, s, ds, dsdq,
    &theta, &dtheta, &delta_theta);

  /* 'ATRIAS3D_ZD_Output02:29' s_unsaturated = s; */
  /* 'ATRIAS3D_ZD_Output02:31' h_alpha = Output.HAlpha; */
  memcpy(&h_alpha[0], &Output_HAlpha[0], 36U * sizeof(real_T));

  /* 'ATRIAS3D_ZD_Output02:32' if (ControlState.StanceLeg==1) */
  /* 'ATRIAS3D_ZD_Output02:36' if Output.SaturateS==1 */
  if (Output_SaturateS == 1.0) {
    /* delta = 0.2; */
    /* p = [0.2  -0.4  0.2  0]; % coefficients of transition poly */
    /* [s, ds] = softsaturate(s, ds, delta, p); */
    /*  Modified Feb. 4th, 2014 for interpolative bezier table bounds. */
    /* 'ATRIAS3D_ZD_Output02:41' delta = 0.1; */
    /* 'ATRIAS3D_ZD_Output02:42' ds(s>1+delta) = 0; */
    e = *ds;
    k = 0;
    if (*s > 1.1) {
      k = 1;
    }

    for (i_0 = 0; i_0 < k; i_0++) {
      e = 0.0;
    }

    /* 'ATRIAS3D_ZD_Output02:43' s(s>1+delta) = 1+delta; */
    b = *s;
    k = 0;
    if (*s > 1.1) {
      k = 1;
    }

    for (i_0 = 0; i_0 < k; i_0++) {
      b = 1.1;
    }

    /* 'ATRIAS3D_ZD_Output02:44' ds(s<-delta) = 0; */
    g = e;
    k = 0;
    if (b < -0.1) {
      k = 1;
    }

    for (i_0 = 0; i_0 < k; i_0++) {
      g = 0.0;
    }

    *ds = g;

    /* 'ATRIAS3D_ZD_Output02:45' s(s<-delta) = -delta; */
    d = b;
    k = 0;
    if (b < -0.1) {
      k = 1;
    }

    for (i_0 = 0; i_0 < k; i_0++) {
      d = -0.1;
    }

    *s = d;
  } else if (Output_SaturateS == 2.0) {
    /* 'ATRIAS3D_ZD_Output02:47' elseif Output.SaturateS==2 */
    /* 'ATRIAS3D_ZD_Output02:48' if (length(s)>1) */
    /* 'ATRIAS3D_ZD_Output02:51' else */
    /* 'ATRIAS3D_ZD_Output02:52' dqyTds = repmat((c(1,5)*delta_theta), 2, 1); */
    theta = c[4] * delta_theta;

    /* 'ATRIAS3D_ZD_Output02:53' s6 = repmat(s, 6, 1); */
    /*  If (s>1), hold the desired knee angles constant and keep the */
    /*  torso angle fixed by decreasing the desired leg angles */
    /* 'ATRIAS3D_ZD_Output02:58' h_alpha_high = h_alpha(:,end)*[1 1 1 1 1 1]; */
    for (i_0 = 0; i_0 < 6; i_0++) {
      for (k = 0; k < 6; k++) {
        h_alpha_high[i_0 + 6 * k] = Output_HAlpha[30 + i_0];
      }
    }

    /* 'ATRIAS3D_ZD_Output02:59' h_alpha_high(1:2,:) = h_alpha_high(1:2,:)+dqyTds*(-1:0.2:0); */
    for (i_0 = 0; i_0 < 2; i_0++) {
      for (k = 0; k < 6; k++) {
        h_alpha_high[i_0 + 6 * k] += theta * b_b[k];
      }
    }

    /* 'ATRIAS3D_ZD_Output02:60' h_alpha_high(1:2) = max(150*pi/180, h_alpha_high(1:2)); */
    theta = h_alpha_high[1];
    if ((2.6179938779914944 >= h_alpha_high[0]) || rtIsNaN(h_alpha_high[0])) {
      h_alpha_high[0] = 2.6179938779914944;
    }

    if ((2.6179938779914944 >= theta) || rtIsNaN(theta)) {
      h_alpha_high[1] = 2.6179938779914944;
    } else {
      h_alpha_high[1] = theta;
    }

    /* 'ATRIAS3D_ZD_Output02:61' h_alpha(s6>1,:) = h_alpha_high(s6>1,:); */
    for (i_0 = 0; i_0 < 6; i_0++) {
      b_s[i_0] = (*s > 1.0);
      b_s_0[i_0] = (*s > 1.0);
    }

    Walking01_withE_eml_li_find_enu(b_s, tmp_data, &tmp_sizes);
    Walking01_withE_eml_li_find_enu(b_s_0, tmp_data_0, &tmp_sizes);
    for (i_0 = 0; i_0 < 6; i_0++) {
      for (k = 0; k < tmp_sizes; k++) {
        h_alpha[(tmp_data[k] + 6 * i_0) - 1] = h_alpha_high[(6 * i_0 +
          tmp_data_0[k]) - 1];
      }
    }

    /*  If (s<0), hold all desired angles constant */
    /* 'ATRIAS3D_ZD_Output02:64' h_alpha_low = h_alpha(:,1)*[1 1 1 1 1 1]; */
    /* 'ATRIAS3D_ZD_Output02:65' h_alpha(s6<0,:) = h_alpha_low(s6<0,:); */
    for (i_0 = 0; i_0 < 6; i_0++) {
      b_s[i_0] = (*s < 0.0);
      b_s_0[i_0] = (*s < 0.0);
    }

    Walking01_withE_eml_li_find_enu(b_s, tmp_data, &tmp_sizes);
    Walking01_withE_eml_li_find_enu(b_s_0, tmp_data_0, &tmp_sizes);
    for (i_0 = 0; i_0 < 6; i_0++) {
      for (k = 0; k < 6; k++) {
        h_alpha_high[i_0 + 6 * k] = h_alpha[i_0];
      }
    }

    for (i_0 = 0; i_0 < 6; i_0++) {
      for (k = 0; k < tmp_sizes; k++) {
        h_alpha_data[k + tmp_sizes * i_0] = h_alpha_high[(6 * i_0 + tmp_data_0[k])
          - 1];
      }
    }

    for (i_0 = 0; i_0 < 6; i_0++) {
      for (k = 0; k < tmp_sizes; k++) {
        h_alpha[(tmp_data[k] + 6 * i_0) - 1] = h_alpha_data[tmp_sizes * i_0 + k];
      }
    }
  } else {
    if (Output_SaturateS == 3.0) {
      /* 'ATRIAS3D_ZD_Output02:67' elseif Output.SaturateS==3 */
      /* 'ATRIAS3D_ZD_Output02:68' delta = 0.02; */
      /* 'ATRIAS3D_ZD_Output02:69' ds(s>1+delta) = 0; */
      e = *ds;
      k = 0;
      if (*s > 1.02) {
        k = 1;
      }

      for (i_0 = 0; i_0 < k; i_0++) {
        e = 0.0;
      }

      /* 'ATRIAS3D_ZD_Output02:70' s(s>1+delta)  = 1+delta; */
      b = *s;
      k = 0;
      if (*s > 1.02) {
        k = 1;
      }

      for (i_0 = 0; i_0 < k; i_0++) {
        b = 1.02;
      }

      /* 'ATRIAS3D_ZD_Output02:71' ds(s<-delta)  = 0; */
      g = e;
      k = 0;
      if (b < -0.02) {
        k = 1;
      }

      for (i_0 = 0; i_0 < k; i_0++) {
        g = 0.0;
      }

      *ds = g;

      /* 'ATRIAS3D_ZD_Output02:72' s(s<-delta)   = -delta; */
      d = b;
      k = 0;
      if (b < -0.02) {
        k = 1;
      }

      for (i_0 = 0; i_0 < k; i_0++) {
        d = -0.02;
      }

      *s = d;
    }
  }

  /*     %% Compute terms in controller */
  /* 'ATRIAS3D_ZD_Output02:76' hd_min = [150; 150;  15;  15; -20; -20]*pi/180; */
  /* 'ATRIAS3D_ZD_Output02:77' hd_max = [220; 220; 120; 120;  20;  20]*pi/180; */
  /*  FOR MIRROR-LAW INSPIRED OUTPUTS! */
  /* hd_min = [110; 306;  24;  -2;  -5;  -4]*pi/180; */
  /* hd_max = [155; 415;  42;  41;   0;   7]*pi/180; */
  /* 'ATRIAS3D_ZD_Output02:83' h0 = jacob_h0*q; */
  for (i_0 = 0; i_0 < 6; i_0++) {
    h0[i_0] = 0.0;
    for (k = 0; k < 13; k++) {
      h0[i_0] += jacob_h0[6 * k + i_0] * q[k];
    }
  }

  /* 'ATRIAS3D_ZD_Output02:84' hd = bezierv(h_alpha, s); */
  /* 'ATRIAS3D_ZD_Output02:86' sat_correction = (jacob_h0 - T1)*q; */
  for (i_0 = 0; i_0 < 7; i_0++) {
    for (k = 0; k < 6; k++) {
      tmp_0[k + 6 * i_0] = 0.0;
    }
  }

  for (i_0 = 0; i_0 < 6; i_0++) {
    for (k = 0; k < 6; k++) {
      tmp_0[k + 6 * (i_0 + 7)] = T0[6 * i_0 + k];
    }
  }

  for (i_0 = 0; i_0 < 13; i_0++) {
    for (k = 0; k < 6; k++) {
      jacob_h0_0[k + 6 * i_0] = jacob_h0[6 * i_0 + k] - tmp_0[6 * i_0 + k];
    }
  }

  /* 'ATRIAS3D_ZD_Output02:87' hd = sat(hd, hd_min + sat_correction, hd_max + sat_correction); */
  /* 'ATRIAS3D_ZD_Output02:88' y  = h0-hd; */
  Walking01_withElmos_bezierv_a(h_alpha, *s, tmp);
  for (i_0 = 0; i_0 < 6; i_0++) {
    sat_correction[i_0] = 0.0;
    for (k = 0; k < 13; k++) {
      sat_correction[i_0] += jacob_h0_0[6 * k + i_0] * q[k];
    }

    hd_min_0[i_0] = hd_min[i_0] + sat_correction[i_0];
    hd_max_0[i_0] = hd_max[i_0] + sat_correction[i_0];
  }

  Walking01_withElmos_sat_iu(tmp, hd_min_0, hd_max_0, sat_correction);
  for (i_0 = 0; i_0 < 6; i_0++) {
    y[i_0] = h0[i_0] - sat_correction[i_0];
  }

  /* 'ATRIAS3D_ZD_Output02:89' dy = jacob_h0*dq-beziervd(h_alpha,s).*ds; */
  /* 'ATRIAS3D_ZD_Output02:90' d  = bezierva(h_alpha, s).*(ds.*ds); */
  /* 'ATRIAS3D_ZD_Output02:91' if (length(s)>1) */
  /* 'ATRIAS3D_ZD_Output02:93' else */
  /* 'ATRIAS3D_ZD_Output02:94' jacob_h = jacob_h0 - beziervd(h_alpha, s)*dsdq; */
  /*  Correction */
  /* 'ATRIAS3D_ZD_Output02:98' h_alpha_corr = Output.HAlphaCorrection; */
  /* 'ATRIAS3D_ZD_Output02:99' s_corr_max = Output.SMaxCorrection; */
  /* 'ATRIAS3D_ZD_Output02:100' if Output.UseCorrection && any(s <= s_corr_max) */
  if ((Output_UseCorrection != 0.0) && (!((*s <= Output_SMaxCorrection) == 0)))
  {
    /* 'ATRIAS3D_ZD_Output02:101' y       = y       -  polyv( h_alpha_corr, s, s_corr_max); */
    Walking01_withElmos_polyv_d(Output_HAlphaCorrection, *s,
      Output_SMaxCorrection, tmp);
    for (i_0 = 0; i_0 < 6; i_0++) {
      y[i_0] -= tmp[i_0];
    }

    /* 'ATRIAS3D_ZD_Output02:102' dy      = dy      -  polyvd(h_alpha_corr, s, s_corr_max).*ds; */
    /* 'ATRIAS3D_ZD_Output02:103' d       = d       +  polyva(h_alpha_corr, s, s_corr_max).*(ds.*ds); */
    /* 'ATRIAS3D_ZD_Output02:104' if (length(s)>1) */
    /* 'ATRIAS3D_ZD_Output02:106' else */
    /* 'ATRIAS3D_ZD_Output02:107' jacob_h = jacob_h - polyvd(h_alpha_corr, s, s_corr_max)*dsdq; */
  }

  /* 'ATRIAS3D_ZD_Output02:110' jacob_jacobh0dq = zeros(6,13); */
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function value = beziervd( afra, s )
 */
static void Walking01_withElmos_beziervd_k(const real_T afra[36], real_T s,
  real_T value[6])
{
  real_T x[5];
  real_T y[5];
  int32_T j;
  static const int8_T b[5] = { 5, 20, 30, 20, 5 };

  int32_T i;

  /* 'beziervd:2' [n, m] = size(afra); */
  /* 'beziervd:3' ns = size(s,1); */
  /* 'beziervd:4' value=zeros(n,1); */
  for (i = 0; i < 6; i++) {
    value[i] = 0.0;
  }

  /* 'beziervd:5' M = m-1; */
  /* 'beziervd:6' if M==3 */
  /* 'beziervd:10' elseif M==5 */
  /* 'beziervd:11' k=[5 20 30 20 5]; */
  /* % */
  /* 'beziervd:24' x = ones(ns, M); */
  /* 'beziervd:25' y = ones(ns, M); */
  for (i = 0; i < 5; i++) {
    x[i] = 1.0;
    y[i] = 1.0;
  }

  /* 'beziervd:26' for i=1:M-1 */
  /* 'beziervd:27' x(:,i+1)=s.*x(:,i); */
  x[1] = s;

  /* 'beziervd:28' y(:,i+1)=(1-s).*y(:,i); */
  y[1] = 1.0 - s;

  /* 'beziervd:27' x(:,i+1)=s.*x(:,i); */
  x[2] = s * s;

  /* 'beziervd:28' y(:,i+1)=(1-s).*y(:,i); */
  y[2] = (1.0 - s) * (1.0 - s);

  /* 'beziervd:27' x(:,i+1)=s.*x(:,i); */
  x[3] = s * x[2];

  /* 'beziervd:28' y(:,i+1)=(1-s).*y(:,i); */
  y[3] = (1.0 - s) * y[2];

  /* 'beziervd:27' x(:,i+1)=s.*x(:,i); */
  x[4] = s * x[3];

  /* 'beziervd:28' y(:,i+1)=(1-s).*y(:,i); */
  y[4] = (1.0 - s) * y[3];

  /* 'beziervd:30' idx = 1; */
  /* 'beziervd:31' for i=1:n */
  for (i = 0; i < 6; i++) {
    /* 'beziervd:32' value(i) = 0; */
    value[i] = 0.0;

    /* 'beziervd:33' for j=1:M */
    for (j = 0; j < 5; j++) {
      /* 'beziervd:34' value(i) = value(i) + (afra(i,j+1)-afra(i,j))*k(j)*x(idx,j)*y(idx,M+1-j); */
      value[i] += (afra[(1 + j) * 6 + i] - afra[6 * j + i]) * (real_T)b[j] * x[j]
        * y[4 - j];
    }

    /* 'beziervd:36' idx = idx+(ns==n); */
  }
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function value = bezier( afra, s )
 */
static real_T Walking01_withElmos_bezier_f(const real_T afra[20], real_T s)
{
  real_T value;
  real_T x[20];
  real_T y[20];
  int32_T i;
  static const int32_T b[20] = { 1, 19, 171, 969, 3876, 11628, 27132, 50388,
    75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1 };

  /* 'bezier:2' [n, m] = size(afra); */
  /* 'bezier:3' value=zeros(n,1); */
  /* 'bezier:4' M = m-1; */
  /* 'bezier:5' if M==3 */
  /* 'bezier:23' else */
  /* 'bezier:24' k = binom(M); */
  /* %     */
  /* 'bezier:27' x = ones(1, M+1); */
  /* 'bezier:28' y = ones(1, M+1); */
  for (i = 0; i < 20; i++) {
    x[i] = 1.0;
    y[i] = 1.0;
  }

  /* 'bezier:29' for i=1:M */
  for (i = 0; i < 19; i++) {
    /* 'bezier:30' x(i+1)=s*x(i); */
    x[1 + i] = s * x[i];

    /* 'bezier:31' y(i+1)=(1-s)*y(i); */
    y[1 + i] = (1.0 - s) * y[i];
  }

  /* 'bezier:33' for i=1:n */
  /* 'bezier:34' value(i) = 0; */
  value = 0.0;

  /* 'bezier:35' for j=1:M+1 */
  for (i = 0; i < 20; i++) {
    /* 'bezier:36' value(i) = value(i) + afra(i, j)*k(j)*x(j)*y(M+2-j); */
    value += afra[i] * (real_T)b[i] * x[i] * y[19 - i];
  }

  return value;
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function value = polyvd( poly_cor, s, s_corr_max)
 */
static void Walking01_withElmos_polyvd_l(const real_T poly_cor[30], real_T s,
  real_T s_corr_max, real_T value[6])
{
  real_T tmp;
  int32_T s_0;
  int32_T i;

  /* 'polyvd:2' if nargin<3 */
  /* 'polyvd:5' a1=poly_cor(:,2); */
  /* 'polyvd:6' a2=poly_cor(:,3); */
  /* 'polyvd:7' a3=poly_cor(:,4); */
  /* 'polyvd:8' a4=poly_cor(:,5); */
  /* 'polyvd:9' value=a1+s.*(2*a2+s.*(3*a3+4*s.*a4)); */
  /* 'polyvd:10' value=value.*(s<=s_corr_max); */
  tmp = 4.0 * s;
  s_0 = (s <= s_corr_max);
  for (i = 0; i < 6; i++) {
    value[i] = (((poly_cor[18 + i] * 3.0 + poly_cor[24 + i] * tmp) * s +
                 poly_cor[12 + i] * 2.0) * s + poly_cor[6 + i]) * (real_T)s_0;
  }
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function y = sat(x,lo,hi)
 */
static void Walking01_withElmos_sat_i(const real_T x[6], const real_T lo[6],
  const real_T hi[6], real_T y[6])
{
  int32_T k;
  real_T minval;

  /* 'ATRIAS3D_ZD_Output03:168' y = max(lo, min(x, hi)); */
  for (k = 0; k < 6; k++) {
    if ((x[k] <= hi[k]) || rtIsNaN(hi[k])) {
      minval = x[k];
    } else {
      minval = hi[k];
    }

    if ((lo[k] >= minval) || rtIsNaN(minval)) {
      y[k] = lo[k];
    } else {
      y[k] = minval;
    }
  }
}

/* Function for Chart: '<S202>/StateLogic' */
static boolean_T Walking01_withElmos_any_d(boolean_T x)
{
  return !(x == 0);
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function [s,ds,h0,y,dy,jacob_h0,jacob_h,s_unsaturated,theta,dtheta,delta_theta,dsdq,jacob_jacobhdqdq,phi,r,dr,hdbar] = ATRIAS3D_ZD_Output03(t, q, dq, ControlState, ControlParams, sprev)
 */
static void Walking0_ATRIAS3D_ZD_Output03_c(real_T t, const real_T q[13], const
  real_T dq[13], real_T ControlState_StanceLeg, const OutputParamsBus
  *ControlParams_Output, real_T *s, real_T *ds, real_T h0[6], real_T y[6],
  real_T dy[6], real_T jacob_h0[78], real_T jacob_h[78], real_T *s_unsaturated,
  real_T *theta)
{
  real_T T0[36];
  real_T c[15];
  real_T h_alpha[36];
  real_T h_alpha_high[36];
  real_T qmod[13];
  real_T jacob_hd[6];
  real_T dhd[6];
  boolean_T RSaturated;
  real_T jacob_hdbar[6];
  boolean_T idxsat[6];
  real_T dsdq[13];
  real_T delta_theta;
  real_T r;
  real_T hdbar[6];
  real_T b;
  real_T d;
  real_T e;
  real_T g;
  static const real_T hd_min[6] = { 2.6179938779914944, 2.6179938779914944,
    0.26179938779914941, 0.26179938779914941, -0.3490658503988659,
    -0.3490658503988659 };

  static const real_T hd_max[6] = { 3.839724354387525, 3.839724354387525,
    2.0943951023931953, 2.0943951023931953, 0.3490658503988659,
    0.3490658503988659 };

  static const real_T b_T0[36] = { 0.5, 0.0, -1.0, 0.0, 0.0, 0.0, 0.5, 0.0, 1.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.5, 0.0, -1.0, 0.0, 0.0,
    0.0, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 };

  static const real_T h[36] = { 0.0, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0, 0.5, 0.0,
    1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0,
    0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 };

  static const int8_T i[13] = { 0, 1, 2, 5, 6, 3, 4, 10, 11, 12, 7, 8, 9 };

  static const real_T b_b[6] = { -1.0, -0.8, -0.6, -0.4, -0.2, 0.0 };

  int32_T i_0;
  real_T tmp[6];
  real_T hd_max_0[6];
  real_T tmp_0[6];
  boolean_T s_0[6];
  int32_T i_1;
  real_T jacob_h0_0[78];
  real_T jacob_hdbar_0[78];
  int32_T f_data;
  int32_T f_sizes[2];
  int32_T tmp_data[6];
  int32_T tmp_sizes;
  int32_T tmp_data_0[6];
  real_T h_alpha_data[36];

  /* 'ATRIAS3D_ZD_Output03:4' Output = ControlParams.Output; */
  /*  Define matrix to convert between motor and standard actuated coordinates */
  /*  [uLAst; uLAsw; uKAst; uKAsw; u3st; u3sw] = T0*[u1R; u2R; u3R; u1L; u2L; u3L] */
  /* 'ATRIAS3D_ZD_Output03:8' T0 = [0.5 0.5 0 0 0 0; 0 0 0 0.5 0.5 0; -1 1 0 0 0 0; 0 0 0 -1 1 0; 0 0 1 0 0 0; 0 0 0 0 0 1]; */
  memcpy(&T0[0], &b_T0[0], 36U * sizeof(real_T));

  /* 'ATRIAS3D_ZD_Output03:9' if (ControlState.StanceLeg==1) */
  if (ControlState_StanceLeg == 1.0) {
    /* 'ATRIAS3D_ZD_Output03:10' T0 = T0([2 1 4 3 6 5],:); */
    memcpy(&T0[0], &h[0], 36U * sizeof(real_T));
  }

  /* 'ATRIAS3D_ZD_Output03:12' T1 = [zeros(6,7) T0]; */
  /*     %% Compute s and modify Bezier parameters to extend outside 0 <= s <= 1 */
  /* [Sy,Sq] = SymmetryMatrices(); */
  /* 'ATRIAS3D_ZD_Output03:16' if (ControlState.StanceLeg==0) */
  if (ControlState_StanceLeg == 0.0) {
    /* 'ATRIAS3D_ZD_Output03:17' c = [Output.Theta.c0 Output.Theta.ct Output.Theta.cq]; */
    c[0] = ControlParams_Output->Theta.c0;
    c[1] = ControlParams_Output->Theta.ct;
    for (i_1 = 0; i_1 < 13; i_1++) {
      c[i_1 + 2] = ControlParams_Output->Theta.cq[i_1];
    }

    /* 'ATRIAS3D_ZD_Output03:18' jacob_h0 = Output.H0; */
    for (i_1 = 0; i_1 < 78; i_1++) {
      jacob_h0[i_1] = ControlParams_Output->H0[i_1];
    }
  } else {
    /* 'ATRIAS3D_ZD_Output03:19' else */
    /* 'ATRIAS3D_ZD_Output03:20' c = [Output.Theta.c0 Output.Theta.ct Output.Theta.cq(:,[1 2 3 6 7 4 5 11 12 13 8 9 10])]; */
    c[0] = ControlParams_Output->Theta.c0;
    c[1] = ControlParams_Output->Theta.ct;
    for (i_1 = 0; i_1 < 13; i_1++) {
      c[i_1 + 2] = ControlParams_Output->Theta.cq[i[i_1]];
    }

    /* 'ATRIAS3D_ZD_Output03:21' c(:,3:4) = -c(:,3:4); */
    c[2] = -c[2];
    c[3] = -c[3];

    /* 'ATRIAS3D_ZD_Output03:22' jacob_h0 = Output.H0(:,[1 2 3 6 7 4 5 11 12 13 8 9 10]); */
    for (i_1 = 0; i_1 < 13; i_1++) {
      for (i_0 = 0; i_0 < 6; i_0++) {
        jacob_h0[i_0 + 6 * i_1] = ControlParams_Output->H0[6 * i[i_1] + i_0];
      }
    }

    /* 'ATRIAS3D_ZD_Output03:23' jacob_h0(:,1:2) = -jacob_h0(:,1:2); */
    for (i_1 = 0; i_1 < 2; i_1++) {
      for (i_0 = 0; i_0 < 6; i_0++) {
        jacob_h0[i_0 + 6 * i_1] = -ControlParams_Output->H0[6 * i[i_1] + i_0];
      }
    }
  }

  /* 'ATRIAS3D_ZD_Output03:27' [s,ds,dsdq,theta,dtheta,delta_theta] = ATRIAS3D_ZD_s6(t-Output.Theta.t0, q, dq, Output.ThetaLimits, c); */
  Walking01_with_ATRIAS3D_ZD_s6_b(t - ControlParams_Output->Theta.t0, q, dq,
    ControlParams_Output->ThetaLimits, c, s, ds, dsdq, theta, &r, &delta_theta);

  /* 'ATRIAS3D_ZD_Output03:28' s_unsaturated = s; */
  *s_unsaturated = *s;

  /* 'ATRIAS3D_ZD_Output03:30' if (Output.EnforceIncreasingS) */
  if ((ControlParams_Output->EnforceIncreasingS != 0.0) && (!(*s >= -1000.0))) {
    /* 'ATRIAS3D_ZD_Output03:31' s = max(s, sprev); */
    *s = -1000.0;
  }

  /* 'ATRIAS3D_ZD_Output03:34' h_alpha = Output.HAlpha; */
  for (i_1 = 0; i_1 < 36; i_1++) {
    h_alpha[i_1] = ControlParams_Output->HAlpha[i_1];
  }

  /* 'ATRIAS3D_ZD_Output03:35' if (ControlState.StanceLeg==1) */
  /* 'ATRIAS3D_ZD_Output03:39' if Output.SaturateS==1 */
  if (ControlParams_Output->SaturateS == 1.0) {
    /* delta = 0.2; */
    /* p = [0.2  -0.4  0.2  0]; % coefficients of transition poly */
    /* [s, ds] = softsaturate(s, ds, delta, p); */
    /*  Modified Feb. 4th, 2014 for interpolative bezier table bounds. */
    /* 'ATRIAS3D_ZD_Output03:44' delta = 0.1; */
    /* 'ATRIAS3D_ZD_Output03:45' ds(s>1+delta) = 0; */
    e = *ds;
    Walking01_withEl_eml_li_find_en(*s > 1.1, &f_data, f_sizes);
    i_0 = f_sizes[0] * f_sizes[1];
    for (i_1 = 0; i_1 < i_0; i_1++) {
      e = 0.0;
    }

    /* 'ATRIAS3D_ZD_Output03:46' s(s>1+delta) = 1+delta; */
    b = *s;
    Walking01_withEl_eml_li_find_en(*s > 1.1, &f_data, f_sizes);
    i_0 = f_sizes[0] * f_sizes[1];
    for (i_1 = 0; i_1 < i_0; i_1++) {
      b = 1.1;
    }

    /* 'ATRIAS3D_ZD_Output03:47' ds(s<-delta) = 0; */
    g = e;
    Walking01_withEl_eml_li_find_en(b < -0.1, &f_data, f_sizes);
    i_0 = f_sizes[0] * f_sizes[1];
    for (i_1 = 0; i_1 < i_0; i_1++) {
      g = 0.0;
    }

    *ds = g;

    /* 'ATRIAS3D_ZD_Output03:48' s(s<-delta) = -delta; */
    d = b;
    Walking01_withEl_eml_li_find_en(b < -0.1, &f_data, f_sizes);
    i_0 = f_sizes[0] * f_sizes[1];
    for (i_1 = 0; i_1 < i_0; i_1++) {
      d = -0.1;
    }

    *s = d;
  } else if (ControlParams_Output->SaturateS == 2.0) {
    /* 'ATRIAS3D_ZD_Output03:50' elseif Output.SaturateS==2 */
    /* 'ATRIAS3D_ZD_Output03:51' if (length(s)>1) */
    /* 'ATRIAS3D_ZD_Output03:54' else */
    /* 'ATRIAS3D_ZD_Output03:55' dqyTds = repmat((c(1,5)*delta_theta), 2, 1); */
    r = c[4] * delta_theta;

    /* 'ATRIAS3D_ZD_Output03:56' s6 = repmat(s, 6, 1); */
    /*  If (s>1), hold the desired knee angles constant and keep the */
    /*  torso angle fixed by decreasing the desired leg angles */
    /* 'ATRIAS3D_ZD_Output03:61' h_alpha_high = h_alpha(:,end)*[1 1 1 1 1 1]; */
    for (i_1 = 0; i_1 < 6; i_1++) {
      for (i_0 = 0; i_0 < 6; i_0++) {
        h_alpha_high[i_1 + 6 * i_0] = ControlParams_Output->HAlpha[30 + i_1];
      }
    }

    /* 'ATRIAS3D_ZD_Output03:62' h_alpha_high(1:2,:) = h_alpha_high(1:2,:)+dqyTds*(-1:0.2:0); */
    for (i_1 = 0; i_1 < 2; i_1++) {
      for (i_0 = 0; i_0 < 6; i_0++) {
        h_alpha_high[i_1 + 6 * i_0] += r * b_b[i_0];
      }
    }

    /* 'ATRIAS3D_ZD_Output03:63' h_alpha_high(1:2) = max(150*pi/180, h_alpha_high(1:2)); */
    r = h_alpha_high[1];
    if ((2.6179938779914944 >= h_alpha_high[0]) || rtIsNaN(h_alpha_high[0])) {
      h_alpha_high[0] = 2.6179938779914944;
    }

    if ((2.6179938779914944 >= r) || rtIsNaN(r)) {
      h_alpha_high[1] = 2.6179938779914944;
    } else {
      h_alpha_high[1] = r;
    }

    /* 'ATRIAS3D_ZD_Output03:64' h_alpha(s6>1,:) = h_alpha_high(s6>1,:); */
    for (i_1 = 0; i_1 < 6; i_1++) {
      idxsat[i_1] = (*s > 1.0);
      s_0[i_1] = (*s > 1.0);
    }

    Walking01_withE_eml_li_find_enu(idxsat, tmp_data, &tmp_sizes);
    Walking01_withE_eml_li_find_enu(s_0, tmp_data_0, &tmp_sizes);
    for (i_1 = 0; i_1 < 6; i_1++) {
      for (i_0 = 0; i_0 < tmp_sizes; i_0++) {
        h_alpha[(tmp_data[i_0] + 6 * i_1) - 1] = h_alpha_high[(6 * i_1 +
          tmp_data_0[i_0]) - 1];
      }
    }

    /*  If (s<0), hold all desired angles constant */
    /* 'ATRIAS3D_ZD_Output03:67' h_alpha_low = h_alpha(:,1)*[1 1 1 1 1 1]; */
    /* 'ATRIAS3D_ZD_Output03:68' h_alpha(s6<0,:) = h_alpha_low(s6<0,:); */
    for (i_1 = 0; i_1 < 6; i_1++) {
      idxsat[i_1] = (*s < 0.0);
      s_0[i_1] = (*s < 0.0);
    }

    Walking01_withE_eml_li_find_enu(idxsat, tmp_data, &tmp_sizes);
    Walking01_withE_eml_li_find_enu(s_0, tmp_data_0, &tmp_sizes);
    for (i_1 = 0; i_1 < 6; i_1++) {
      for (i_0 = 0; i_0 < 6; i_0++) {
        h_alpha_high[i_1 + 6 * i_0] = h_alpha[i_1];
      }
    }

    for (i_1 = 0; i_1 < 6; i_1++) {
      for (i_0 = 0; i_0 < tmp_sizes; i_0++) {
        h_alpha_data[i_0 + tmp_sizes * i_1] = h_alpha_high[(6 * i_1 +
          tmp_data_0[i_0]) - 1];
      }
    }

    for (i_1 = 0; i_1 < 6; i_1++) {
      for (i_0 = 0; i_0 < tmp_sizes; i_0++) {
        h_alpha[(tmp_data[i_0] + 6 * i_1) - 1] = h_alpha_data[tmp_sizes * i_1 +
          i_0];
      }
    }
  } else {
    if (ControlParams_Output->SaturateS == 3.0) {
      /* 'ATRIAS3D_ZD_Output03:70' elseif Output.SaturateS==3 */
      /* 'ATRIAS3D_ZD_Output03:71' smin = Output.SLimits(1); */
      /* 'ATRIAS3D_ZD_Output03:72' smax = Output.SLimits(2); */
      /* 'ATRIAS3D_ZD_Output03:73' ds(s>smax) = 0; */
      e = *ds;
      Walking01_withEl_eml_li_find_en(*s > ControlParams_Output->SLimits[1],
        &f_data, f_sizes);
      i_0 = f_sizes[0] * f_sizes[1];
      for (i_1 = 0; i_1 < i_0; i_1++) {
        e = 0.0;
      }

      /* 'ATRIAS3D_ZD_Output03:74' s(s>smax)  = smax; */
      b = *s;
      Walking01_withEl_eml_li_find_en(*s > ControlParams_Output->SLimits[1],
        &f_data, f_sizes);
      i_0 = f_sizes[0] * f_sizes[1];
      for (i_1 = 0; i_1 < i_0; i_1++) {
        b = ControlParams_Output->SLimits[1];
      }

      /* 'ATRIAS3D_ZD_Output03:75' ds(s<smin) = 0; */
      g = e;
      Walking01_withEl_eml_li_find_en(b < ControlParams_Output->SLimits[0],
        &f_data, f_sizes);
      i_0 = f_sizes[0] * f_sizes[1];
      for (i_1 = 0; i_1 < i_0; i_1++) {
        g = 0.0;
      }

      *ds = g;

      /* 'ATRIAS3D_ZD_Output03:76' s(s<smin)  = smin; */
      d = b;
      Walking01_withEl_eml_li_find_en(b < ControlParams_Output->SLimits[0],
        &f_data, f_sizes);
      i_0 = f_sizes[0] * f_sizes[1];
      for (i_1 = 0; i_1 < i_0; i_1++) {
        d = ControlParams_Output->SLimits[0];
      }

      *s = d;
    }
  }

  /*     %% Compute terms in controller */
  /* 'ATRIAS3D_ZD_Output03:80' qmod = q; */
  memcpy(&qmod[0], &q[0], 13U * sizeof(real_T));

  /* 'ATRIAS3D_ZD_Output03:81' qmod(1) = sat(qmod(1), -Output.YawLimit, Output.YawLimit); */
  /* 'ATRIAS3D_ZD_Output03:168' y = max(lo, min(x, hi)); */
  if ((q[0] <= ControlParams_Output->YawLimit) || rtIsNaN
      (ControlParams_Output->YawLimit)) {
    r = q[0];
  } else {
    r = ControlParams_Output->YawLimit;
  }

  if ((-ControlParams_Output->YawLimit >= r) || rtIsNaN(r)) {
    qmod[0] = -ControlParams_Output->YawLimit;
  } else {
    qmod[0] = r;
  }

  /* 'ATRIAS3D_ZD_Output03:82' h0 = jacob_h0*qmod; */
  /* 'ATRIAS3D_ZD_Output03:83' hd = bezierv(h_alpha, s); */
  /* 'ATRIAS3D_ZD_Output03:84' jacob_hd  = beziervd(h_alpha,s); */
  Walking01_withElmos_beziervd_k(h_alpha, *s, jacob_hd);

  /* 'ATRIAS3D_ZD_Output03:85' jacob2_hd = bezierva(h_alpha,s); */
  /* 'ATRIAS3D_ZD_Output03:86' dhd = jacob_hd.*ds; */
  for (i_1 = 0; i_1 < 6; i_1++) {
    h0[i_1] = 0.0;
    for (i_0 = 0; i_0 < 13; i_0++) {
      h0[i_1] += jacob_h0[6 * i_0 + i_1] * qmod[i_0];
    }

    dhd[i_1] = jacob_hd[i_1] * *ds;
  }

  /* 'ATRIAS3D_ZD_Output03:88' jacob_h = jacob_h0 - jacob_hd*dsdq; */
  /* 'ATRIAS3D_ZD_Output03:89' jacob_jacobhdqdq = -jacob2_hd.*(ds.*ds); */
  /*     %% Stabilizing output term */
  /*  Allow outputs of the form */
  /*    y = H0*q - hd(s(theta(q)), h_alpha) - hStabilizing(phi - phid(s(theta(q))), StabilizingHAlpha) */
  /* 'ATRIAS3D_ZD_Output03:95' phi    = Output.Phi.cq * q; */
  /* 'ATRIAS3D_ZD_Output03:96' dphi   = Output.Phi.cq * dq; */
  /* 'ATRIAS3D_ZD_Output03:98' phid   = bezier(Output.PhiAlpha, s); */
  /* 'ATRIAS3D_ZD_Output03:99' jacob_phid = bezierd(Output.PhiAlpha, s); */
  /* 'ATRIAS3D_ZD_Output03:100' jacob2_phid = beziera(Output.PhiAlpha, s); */
  /* 'ATRIAS3D_ZD_Output03:102' r      = phi - phid; */
  r = 0.0;
  for (i_1 = 0; i_1 < 13; i_1++) {
    r += ControlParams_Output->Phi.cq[i_1] * q[i_1];
  }

  r -= Walking01_withElmos_bezier_f(ControlParams_Output->PhiAlpha, *s);

  /* 'ATRIAS3D_ZD_Output03:103' dr     = dphi - jacob_phid * ds; */
  /* 'ATRIAS3D_ZD_Output03:104' RSaturated = false; */
  RSaturated = false;

  /* 'ATRIAS3D_ZD_Output03:105' if Output.SaturateR */
  if (ControlParams_Output->SaturateR != 0.0) {
    /* 'ATRIAS3D_ZD_Output03:106' if (r > Output.RLimits(2)) */
    if (r > ControlParams_Output->RLimits[1]) {
      /* 'ATRIAS3D_ZD_Output03:107' r = Output.RLimits(2); */
      r = ControlParams_Output->RLimits[1];

      /* 'ATRIAS3D_ZD_Output03:108' dr = 0; */
      /* 'ATRIAS3D_ZD_Output03:109' RSaturated = true; */
      RSaturated = true;
    } else {
      if (r < ControlParams_Output->RLimits[0]) {
        /* 'ATRIAS3D_ZD_Output03:110' elseif (r < Output.RLimits(1)) */
        /* 'ATRIAS3D_ZD_Output03:111' r = Output.RLimits(1); */
        r = ControlParams_Output->RLimits[0];

        /* 'ATRIAS3D_ZD_Output03:112' dr = 0; */
        /* 'ATRIAS3D_ZD_Output03:113' RSaturated = true; */
        RSaturated = true;
      }
    }
  }

  /* 'ATRIAS3D_ZD_Output03:117' hdbar  = polyv(Output.HBarAlpha, r, inf); */
  /* 'ATRIAS3D_ZD_Output03:118' if ~RSaturated */
  if (!RSaturated) {
    /* 'ATRIAS3D_ZD_Output03:119' jacob_hdbar = polyvd(Output.HBarAlpha, r, inf); */
    Walking01_withElmos_polyvd_l(ControlParams_Output->HBarAlpha, r, (rtInf),
      jacob_hdbar);

    /* 'ATRIAS3D_ZD_Output03:120' jacob2_hdbar = polyva(Output.HBarAlpha, r, inf); */
  } else {
    /* 'ATRIAS3D_ZD_Output03:121' else */
    /* 'ATRIAS3D_ZD_Output03:122' jacob_hdbar = zeros(6,1); */
    for (i_0 = 0; i_0 < 6; i_0++) {
      jacob_hdbar[i_0] = 0.0;
    }

    /* 'ATRIAS3D_ZD_Output03:123' jacob2_hdbar = zeros(6,1); */
  }

  /* 'ATRIAS3D_ZD_Output03:126' hdbar = sat(hdbar, Output.HBarLimits(:,1), Output.HBarLimits(:,2)); */
  Walking01_withElmos_polyv_d(ControlParams_Output->HBarAlpha, r, (rtInf), tmp_0);
  Walking01_withElmos_sat_i(tmp_0, *(real_T (*)[6])&
    ControlParams_Output->HBarLimits[0], *(real_T (*)[6])&
    ControlParams_Output->HBarLimits[6], hdbar);

  /* 'ATRIAS3D_ZD_Output03:127' idxsat = (hdbar == Output.HBarLimits(:,1)) | (hdbar == Output.HBarLimits(:,2)); */
  /* 'ATRIAS3D_ZD_Output03:128' jacob_hdbar(idxsat,:) = 0; */
  for (i_1 = 0; i_1 < 6; i_1++) {
    idxsat[i_1] = ((hdbar[i_1] == ControlParams_Output->HBarLimits[i_1]) ||
                   (ControlParams_Output->HBarLimits[6 + i_1] == hdbar[i_1]));
  }

  Walking01_withE_eml_li_find_enu(idxsat, tmp_data, &i_0);
  for (i_1 = 0; i_1 < i_0; i_1++) {
    jacob_hdbar[tmp_data[i_1] - 1] = 0.0;
  }

  /* 'ATRIAS3D_ZD_Output03:129' jacob2_hdbar(idxsat,:) = 0; */
  /* 'ATRIAS3D_ZD_Output03:131' hd = hd + hdbar; */
  /* 'ATRIAS3D_ZD_Output03:132' jacob_h = jacob_h - jacob_hdbar * (Output.Phi.cq - jacob_phid * dsdq); */
  for (i_1 = 0; i_1 < 13; i_1++) {
    qmod[i_1] = ControlParams_Output->Phi.cq[i_1] - 0.0 * dsdq[i_1];
  }

  for (i_1 = 0; i_1 < 6; i_1++) {
    for (i_0 = 0; i_0 < 13; i_0++) {
      jacob_h0_0[i_1 + 6 * i_0] = jacob_h0[6 * i_0 + i_1] - jacob_hd[i_1] *
        dsdq[i_0];
    }
  }

  for (i_1 = 0; i_1 < 6; i_1++) {
    for (i_0 = 0; i_0 < 13; i_0++) {
      jacob_hdbar_0[i_1 + 6 * i_0] = jacob_hdbar[i_1] * qmod[i_0];
    }
  }

  for (i_1 = 0; i_1 < 13; i_1++) {
    for (i_0 = 0; i_0 < 6; i_0++) {
      jacob_h[i_0 + 6 * i_1] = jacob_h0_0[6 * i_1 + i_0] - jacob_hdbar_0[6 * i_1
        + i_0];
    }
  }

  /* 'ATRIAS3D_ZD_Output03:133' jacob_jacobhdqdq = jacob_jacobhdqdq ... */
  /* 'ATRIAS3D_ZD_Output03:134'         + jacob_hdbar * jacob2_phid * ds^2 ... */
  /* 'ATRIAS3D_ZD_Output03:135'         + jacob2_hdbar * (-jacob_phid^2 * ds^2 - dphi^2 + jacob_phid * dphi * ds); */
  /*     %% Saturate the desired leg/knee/hip angles */
  /* 'ATRIAS3D_ZD_Output03:138' hd_min = [150; 150;  15;  15; -20; -20]*pi/180; */
  /* 'ATRIAS3D_ZD_Output03:139' hd_max = [220; 220; 120; 120;  20;  20]*pi/180; */
  /* 'ATRIAS3D_ZD_Output03:140' sat_correction = (jacob_h0 - T1)*q; */
  for (i_1 = 0; i_1 < 7; i_1++) {
    for (i_0 = 0; i_0 < 6; i_0++) {
      jacob_hdbar_0[i_0 + 6 * i_1] = 0.0;
    }
  }

  for (i_1 = 0; i_1 < 6; i_1++) {
    for (i_0 = 0; i_0 < 6; i_0++) {
      jacob_hdbar_0[i_0 + 6 * (i_1 + 7)] = T0[6 * i_1 + i_0];
    }
  }

  for (i_1 = 0; i_1 < 13; i_1++) {
    for (i_0 = 0; i_0 < 6; i_0++) {
      jacob_h0_0[i_0 + 6 * i_1] = jacob_h0[6 * i_1 + i_0] - jacob_hdbar_0[6 *
        i_1 + i_0];
    }
  }

  /* 'ATRIAS3D_ZD_Output03:141' hd = sat(hd, hd_min + sat_correction, hd_max + sat_correction); */
  Walking01_withElmos_bezierv_a(h_alpha, *s, tmp_0);
  for (i_1 = 0; i_1 < 6; i_1++) {
    jacob_hd[i_1] = 0.0;
    for (i_0 = 0; i_0 < 13; i_0++) {
      jacob_hd[i_1] += jacob_h0_0[6 * i_0 + i_1] * q[i_0];
    }

    tmp[i_1] = tmp_0[i_1] + hdbar[i_1];
    jacob_hdbar[i_1] = hd_min[i_1] + jacob_hd[i_1];
    hd_max_0[i_1] = hd_max[i_1] + jacob_hd[i_1];
  }

  Walking01_withElmos_sat_i(tmp, jacob_hdbar, hd_max_0, y);

  /* 'ATRIAS3D_ZD_Output03:142' idxsat = (hd == hd_min + sat_correction) | (hd == hd_max + sat_correction); */
  for (i_0 = 0; i_0 < 6; i_0++) {
    idxsat[i_0] = ((hd_min[i_0] + jacob_hd[i_0] == y[i_0]) || (hd_max[i_0] +
      jacob_hd[i_0] == y[i_0]));
  }

  /* 'ATRIAS3D_ZD_Output03:143' dhd(idxsat) = 0; */
  Walking01_withE_eml_li_find_enu(idxsat, tmp_data, &i_0);
  for (i_1 = 0; i_1 < i_0; i_1++) {
    dhd[tmp_data[i_1] - 1] = 0.0;
  }

  /* 'ATRIAS3D_ZD_Output03:144' jacob_h(idxsat) = jacob_h0(idxsat); */
  Walking01_withE_eml_li_find_enu(idxsat, tmp_data, &tmp_sizes);
  Walking01_withE_eml_li_find_enu(idxsat, tmp_data_0, &tmp_sizes);
  for (i_1 = 0; i_1 < tmp_sizes; i_1++) {
    jacob_h[tmp_data[i_1] - 1] = jacob_h0[tmp_data_0[i_1] - 1];
  }

  /*  jacob_hd(idxsat) = 0; */
  /*     %% */
  /* 'ATRIAS3D_ZD_Output03:147' y  = h0-hd; */
  for (i_1 = 0; i_1 < 6; i_1++) {
    y[i_1] = h0[i_1] - y[i_1];
  }

  /* 'ATRIAS3D_ZD_Output03:148' dy = jacob_h0*dq - dhd; */
  for (i_1 = 0; i_1 < 6; i_1++) {
    r = 0.0;
    for (i_0 = 0; i_0 < 13; i_0++) {
      r += jacob_h0[6 * i_0 + i_1] * dq[i_0];
    }

    dy[i_1] = r - dhd[i_1];
  }

  /*  Correction */
  /* 'ATRIAS3D_ZD_Output03:152' h_alpha_corr = Output.HAlphaCorrection; */
  /* 'ATRIAS3D_ZD_Output03:153' s_corr_max = Output.SMaxCorrection; */
  /* 'ATRIAS3D_ZD_Output03:154' if Output.UseCorrection && any(s <= s_corr_max) */
  if ((ControlParams_Output->UseCorrection != 0.0) && Walking01_withElmos_any_d(*
       s <= ControlParams_Output->SMaxCorrection)) {
    /* 'ATRIAS3D_ZD_Output03:155' y       = y       -  polyv( h_alpha_corr, s, s_corr_max); */
    Walking01_withElmos_polyv_d(ControlParams_Output->HAlphaCorrection, *s,
      ControlParams_Output->SMaxCorrection, tmp_0);

    /* 'ATRIAS3D_ZD_Output03:156' dy      = dy      -  polyvd(h_alpha_corr, s, s_corr_max).*ds; */
    Walking01_withElmos_polyvd_l(ControlParams_Output->HAlphaCorrection, *s,
      ControlParams_Output->SMaxCorrection, tmp);
    for (i_1 = 0; i_1 < 6; i_1++) {
      y[i_1] -= tmp_0[i_1];
      dy[i_1] -= tmp[i_1] * *ds;
    }

    /* 'ATRIAS3D_ZD_Output03:157' jacob_jacobhdqdq = jacob_jacobhdqdq +  polyva(h_alpha_corr, s, s_corr_max).*(ds.*ds); */
    /* 'ATRIAS3D_ZD_Output03:158' if (length(s)>1) */
    /* 'ATRIAS3D_ZD_Output03:160' else */
    /* 'ATRIAS3D_ZD_Output03:161' jacob_h = jacob_h - polyvd(h_alpha_corr, s, s_corr_max)*dsdq; */
    Walking01_withElmos_polyvd_l(ControlParams_Output->HAlphaCorrection, *s,
      ControlParams_Output->SMaxCorrection, tmp_0);
    for (i_1 = 0; i_1 < 6; i_1++) {
      for (i_0 = 0; i_0 < 13; i_0++) {
        jacob_h[i_1 + 6 * i_0] -= tmp_0[i_1] * dsdq[i_0];
      }
    }
  }
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function [ halphaInterpolated ] = beziertableinterpolate2( spPlusCurrent, controlNum)
 */
static void Walking_beziertableinterpolate2(real_T spPlusCurrent, real_T
  controlNum, real_T halphaInterpolated[24])
{
  sHmAB4PxSQg3wmqo1saFKWH_Walki_T stepBezier[6];
  real_T spPlusSet[5];
  real_T halphaColumnSetTemp[20];
  int32_T b_i;
  static const char_T msg[98] = { 'E', 'r', 'r', 'o', 'r', '!', ' ', 'C', 'o',
    'n', 't', 'r', 'o', 'l', 'P', 'a', 'r', 'a', 'm', 's', '.', 'F', 'e', 'e',
    'd', 'b', 'a', 'c', 'k', '.', 'R', 'I', 'O', ' ', '%', 'g', ' ', 'n', 'o',
    't', ' ', 'r', 'e', 'c', 'o', 'g', 'n', 'i', 'z', 'e', 'd', ' ', 'a', 's',
    ' ', 'v', 'a', 'l', 'i', 'd', ' ', 's', 'e', 'l', 'e', 'c', 't', 'i', 'o',
    'n', ' ', 'f', 'o', 'r', ' ', 'i', 'n', 't', 'e', 'r', 'p', 'o', 'l', 'a',
    't', 'i', 'v', 'e', ' ', 'b', 'e', 'z', 'i', 'e', 'r', '!', '\x0a', '\x00' };

  static const char_T msg2[33] = { 'A', 's', 's', 'i', 'g', 'n', 'i', 'n', 'g',
    ' ', '4', 'c', 'm', 'S', ' ', 'c', 'o', 'n', 't', 'r', 'o', 'l', ' ', 'i',
    'n', ' ', 'p', 'l', 'a', 'c', 'e', '\x0a', '\x00' };

  real_T x[5];
  real_T xtmp;
  int32_T low_ip1;
  int32_T high_i;
  int32_T mid_i;
  static const real_T b[24] = { 3.5454950400599, 3.15417848729336,
    0.254667358003798, 0.414903362656048, 3.46582412603665, 2.74830688442457,
    0.70272514063489, 1.116921494399, 3.39354, 2.87796, 0.596111, 1.04437,
    3.37945, 4.02207, 0.482812, 0.855403, 3.23236, 3.74049, 0.391096, 0.696856,
    3.09154, 3.56994, 0.550965, 0.487677 };

  static const real_T c[24] = { 3.57012901044516, 3.11747975862252,
    0.381878616323664, 0.513345597891921, 3.42533172199634, 2.8603731111819,
    0.6681269522852, 0.836641218766406, 3.39354, 2.87796, 0.596111, 1.04437,
    3.37945, 4.02207, 0.482812, 0.855403, 3.23236, 3.74049, 0.391096, 0.696856,
    3.09154, 3.56994, 0.550965, 0.487677 };

  static const real_T d[24] = { 3.56994000000004, 3.09154000000035,
    0.487676999998248, 0.550964999999577, 3.43187740968973, 2.9140538164357,
    0.675564721751326, 0.756845637687275, 3.39354, 2.87796, 0.596111, 1.04437,
    3.37945, 4.02207, 0.482812, 0.855403, 3.23236, 3.74049, 0.391096, 0.696856,
    3.09154, 3.56994, 0.550965, 0.487677 };

  static const real_T e[24] = { 3.56974644932167, 3.07297747728139,
    0.570731240644985, 0.569144465667379, 3.44779894067081, 2.91055825087636,
    0.688178841141528, 0.752778052509281, 3.39354, 2.87796, 0.596111, 1.04437,
    3.37945, 4.02207, 0.482812, 0.855403, 3.23236, 3.74049, 0.391096, 0.696856,
    3.09154, 3.56994, 0.550965, 0.487677 };

  static const real_T f[24] = { 3.57551259902854, 3.04667193071562,
    0.634463432692027, 0.58531247536492, 3.46423541019452, 2.87138223188993,
    0.699022833492717, 0.772425342485748, 3.39354, 2.87796, 0.596111, 1.04437,
    3.37945, 4.02207, 0.482812, 0.855403, 3.23236, 3.74049, 0.391096, 0.696856,
    3.09154, 3.56994, 0.550965, 0.487677 };

  static const real_T g[24] = { 3.46035041455478, 3.08124803329452,
    0.304356574836397, 0.317889619949311, 3.46022307370201, 2.69439468861378,
    0.635686846329621, 1.35681641873216, 3.38125, 2.95019, 0.532315, 0.947235,
    3.15038, 3.99772, 0.608682, 0.797885, 3.10332, 3.63566, 0.350348, 0.796106,
    3.01329, 3.49056, 0.526534, 0.515658 };

  static const real_T h[24] = { 3.48558960603127, 3.03665552105148,
    0.413994301094, 0.471714708678728, 3.40902426998661, 2.83498642672937,
    0.650645821206378, 0.895163833268652, 3.38125, 2.95019, 0.532315, 0.947235,
    3.15038, 3.99772, 0.608682, 0.797885, 3.10332, 3.63566, 0.350348, 0.796106,
    3.01329, 3.49056, 0.526534, 0.515658 };

  static const real_T l[24] = { 3.49055999999997, 3.01329000000027,
    0.515657999998245, 0.526533999999455, 3.40433567035172, 2.90531812733559,
    0.672309596090129, 0.741853575881061, 3.38125, 2.95019, 0.532315, 0.947235,
    3.15038, 3.99772, 0.608682, 0.797885, 3.10332, 3.63566, 0.350348, 0.796106,
    3.01329, 3.49056, 0.526534, 0.515658 };

  static const real_T m[24] = { 3.49309376307264, 2.99949560968401,
    0.596582661823303, 0.546406257179468, 3.41728718615845, 2.91161558102436,
    0.678330695118829, 0.709688203116856, 3.38125, 2.95019, 0.532315, 0.947235,
    3.15038, 3.99772, 0.608682, 0.797885, 3.10332, 3.63566, 0.350348, 0.796106,
    3.01329, 3.49056, 0.526534, 0.515658 };

  static const real_T n[24] = { 3.50148776216125, 2.96935894288884,
    0.651044268024143, 0.565477036421621, 3.43754353868782, 2.86740195339426,
    0.670429464935497, 0.725971337612633, 3.38125, 2.95019, 0.532315, 0.947235,
    3.15038, 3.99772, 0.608682, 0.797885, 3.10332, 3.63566, 0.350348, 0.796106,
    3.01329, 3.49056, 0.526534, 0.515658 };

  static const real_T o[24] = { 3.57785705069653, 3.26272479765068,
    0.229131524549162, 0.287962554931851, 3.37832999558392, 2.47576802652352,
    0.712895463164868, 1.34172271688962, 3.63492, 3.79718, 0.284129, 0.746367,
    3.22031, 3.77154, 0.661957, 0.834272, 3.17686, 3.6834, 0.387404, 0.765084,
    3.08939, 3.56118, 0.560108, 0.489272 };

  static const real_T p[24] = { 3.56187906680849, 3.13304426873421,
    0.380990655598159, 0.496880714901298, 3.44000310360732, 2.75917426306341,
    0.671739960465328, 0.976124079486289, 3.63492, 3.79718, 0.284129, 0.746367,
    3.22031, 3.77154, 0.661957, 0.834272, 3.17686, 3.6834, 0.387404, 0.765084,
    3.08939, 3.56118, 0.560108, 0.489272 };

  static const real_T q[24] = { 3.5611799999999, 3.08939000000021,
    0.489271999998361, 0.560107999999545, 3.49301211082539, 2.98050504908016,
    0.639998133894733, 0.784441877204877, 3.63492, 3.79718, 0.284129, 0.746367,
    3.22031, 3.77154, 0.661957, 0.834272, 3.17686, 3.6834, 0.387404, 0.765084,
    3.08939, 3.56118, 0.560108, 0.489272 };

  static const real_T s[24] = { 3.57202155464132, 3.10076860527039,
    0.56292574708373, 0.566793376146665, 3.54194918513446, 3.15181478258618,
    0.603373973702065, 0.687961818026883, 3.63492, 3.79718, 0.284129, 0.746367,
    3.22031, 3.77154, 0.661957, 0.834272, 3.17686, 3.6834, 0.387404, 0.765084,
    3.08939, 3.56118, 0.560108, 0.489272 };

  static const real_T t[24] = { 3.59265421324105, 3.14258626125961,
    0.605401288255448, 0.55790407966053, 3.58812915385993, 3.28175954372438,
    0.560030488059349, 0.643276999369453, 3.63492, 3.79718, 0.284129, 0.746367,
    3.22031, 3.77154, 0.661957, 0.834272, 3.17686, 3.6834, 0.387404, 0.765084,
    3.08939, 3.56118, 0.560108, 0.489272 };

  static const sHmAB4PxSQg3wmqo1saFKWH_Walki_T u[6] = { { { 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0 }, 0.0 }, { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0 }, 0.0 }, { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0 }, 0.0 }, { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },
      0.0 }, { { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 }, 0.0 }, { { 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 }, 0.0 } };

  int32_T i;
  real_T Vq_idx_0;
  real_T Vq_idx_1;
  real_T Vq_idx_2;
  real_T Vq_idx_3;

  /* codegen */
  /*  Updated to handle a case statement to choose which controller to use for */
  /*  updating bezier parameters. April 3rd, 2014 BAG. */
  /*  The idea behind this function is to return a set of bezier parameters  */
  /*  (h_alpha), corresponding to sPlus corresponding to a new step after */
  /*  impact. The motivation for this function is to have a set of bezier */
  /*  parameters corresponding to varying perturbed next step initial */
  /*  conditions that can be interpolated via s to generate a new set of bezier */
  /*  parameters appropriate for the current initial conditions of the walking */
  /*  robot post-impact. Ideally, if ending conditions match on all of the */
  /*  bezier parameters used for this function (currently hard coded), then the */
  /*  robot should always return to the nominal gait given the absence of more */
  /*  disturbances. */
  /*  BAG August 29th, 2013. */
  /*  January 30th, 2014 BAG. Made changes to make compatible with simulink. */
  /*  stepBezier2 = robusthalphafielddefault; */
  /* 'beziertableinterpolate2:20' stepBezier = bezierTableCurrent2(controlNum); */
  /*  Updated to handle a case statement to choose which controller to use for */
  /*  updating bezier parameters. April 3rd, 2014 BAG. */
  /* 'bezierTableCurrent2:5' st = struct('halpha',zeros(4,6),'spPlus',0); */
  /* 'bezierTableCurrent2:6' stepBezier = repmat(st,6,1); */
  for (i = 0; i < 6; i++) {
    stepBezier[i] = u[i];
  }

  /*  January 30th, 2014. BAG */
  /*  Added Bezier tables from Quals II research. */
  /*  Messages used if case does not match any pre-defined controller. */
  /* 'bezierTableCurrent2:12' msg = ['Error! ControlParams.Feedback.RIO %g not recognized as valid selection for interpolative bezier!' char([10 0]) ]; */
  /* 'bezierTableCurrent2:13' msg2 = ['Assigning 4cmS control in place' char([10 0]) ]; */
  /* 'bezierTableCurrent2:15' switch controlNum */
  switch ((int32_T)controlNum) {
   case 1:
    /* 'bezierTableCurrent2:16' case 1 */
    /*  4cmS */
    /*  4cm control disturbance max */
    /*  2 cm S -> 4 cm S */
    /*  Z0 = [1.33568; 3.39354; 3.37945; 3.23236; 3.09154; 2.87796; 4.02207; 3.74049; 3.56994; 0.596111; 0.482812; 0.391096; 0.550965; 1.04437; 0.855403; 0.696856; 0.487677]; */
    /*  ThetaLimits [1.31436093861886,1.79276093861886;]; */
    /* 'bezierTableCurrent2:24' stepBezier(2).spPlus = [-0.112709212511353;]; */
    stepBezier[1].spPlus = -0.112709212511353;

    /* 'bezierTableCurrent2:25' stepBezier(2).halpha = [3.57551259902854,3.46423541019452,3.39354000000000,3.37945000000000,3.23236000000000,3.09154000000000; */
    /* 'bezierTableCurrent2:26'             3.04667193071562,2.87138223188993,2.87796000000000,4.02207000000000,3.74049000000000,3.56994000000000; */
    /* 'bezierTableCurrent2:27'             0.634463432692027,0.699022833492717,0.596111000000000,0.482812000000000,0.391096000000000,0.550965000000000; */
    /* 'bezierTableCurrent2:28'             0.585312475364920,0.772425342485748,1.04437000000000,0.855403000000000,0.696856000000000,0.487677000000000;]; */
    for (i = 0; i < 24; i++) {
      stepBezier[1].halpha[i] = f[i];
    }

    /* 'bezierTableCurrent2:30' stepBezier(3).spPlus = [-0.0565185420256428;]; */
    stepBezier[2].spPlus = -0.0565185420256428;

    /* 'bezierTableCurrent2:31' stepBezier(3).halpha = [3.56974644932167,3.44779894067081,3.39354000000000,3.37945000000000,3.23236000000000,3.09154000000000; */
    /* 'bezierTableCurrent2:32'             3.07297747728139,2.91055825087636,2.87796000000000,4.02207000000000,3.74049000000000,3.56994000000000; */
    /* 'bezierTableCurrent2:33'             0.570731240644985,0.688178841141528,0.596111000000000,0.482812000000000,0.391096000000000,0.550965000000000; */
    /* 'bezierTableCurrent2:34'             0.569144465667379,0.752778052509281,1.04437000000000,0.855403000000000,0.696856000000000,0.487677000000000;]; */
    for (i = 0; i < 24; i++) {
      stepBezier[2].halpha[i] = e[i];
    }

    /* 'bezierTableCurrent2:36' stepBezier(4).spPlus = 0; */
    stepBezier[3].spPlus = 0.0;

    /* 'bezierTableCurrent2:37' stepBezier(4).halpha = [3.56994000000004,3.43187740968973,3.39354000000000,3.37945000000000,3.23236000000000,3.09154000000000; */
    /* 'bezierTableCurrent2:38'             3.09154000000035,2.91405381643570,2.87796000000000,4.02207000000000,3.74049000000000,3.56994000000000; */
    /* 'bezierTableCurrent2:39'             0.487676999998248,0.675564721751326,0.596111000000000,0.482812000000000,0.391096000000000,0.550965000000000; */
    /* 'bezierTableCurrent2:40'             0.550964999999577,0.756845637687275,1.04437000000000,0.855403000000000,0.696856000000000,0.487677000000000;]; */
    for (i = 0; i < 24; i++) {
      stepBezier[3].halpha[i] = d[i];
    }

    /* 'bezierTableCurrent2:42' stepBezier(5).spPlus = [0.0485070021484834;]; */
    stepBezier[4].spPlus = 0.0485070021484834;

    /* 'bezierTableCurrent2:43' stepBezier(5).halpha = [3.57012901044516,3.42533172199634,3.39354000000000,3.37945000000000,3.23236000000000,3.09154000000000;3.11747975862252,2.86037311118190,2.87796000000000,4.02207000000000,3.74049000000000,3.56994000000000;0.381878616323664,0.668126952285200,0.596111000000000,0.482812000000000,0.391096000000000,0.550965000000000;0.513345597891921,0.836641218766406,1.04437000000000,0.855403000000000,0.696856000000000,0.487677000000000;]; */
    for (i = 0; i < 24; i++) {
      stepBezier[4].halpha[i] = c[i];
    }

    /* 'bezierTableCurrent2:45' stepBezier(6).spPlus = [0.0755116545848371;]; */
    stepBezier[5].spPlus = 0.0755116545848371;

    /* 'bezierTableCurrent2:46' stepBezier(6).halpha = [3.54549504005990,3.46582412603665,3.39354000000000,3.37945000000000,3.23236000000000,3.09154000000000; */
    /* 'bezierTableCurrent2:47'             3.15417848729336,2.74830688442457,2.87796000000000,4.02207000000000,3.74049000000000,3.56994000000000; */
    /* 'bezierTableCurrent2:48'             0.254667358003798,0.702725140634890,0.596111000000000,0.482812000000000,0.391096000000000,0.550965000000000; */
    /* 'bezierTableCurrent2:49'             0.414903362656048,1.11692149439900,1.04437000000000,0.855403000000000,0.696856000000000,0.487677000000000;]; */
    for (i = 0; i < 24; i++) {
      stepBezier[5].halpha[i] = b[i];
    }
    break;

   case 2:
    /* 'bezierTableCurrent2:52' case 2 */
    /*  Periodic */
    /*  4cm control disturbance max */
    /*  Z0 = [1.01681; 3.63492; 3.22031; 3.17686; 3.08939; 3.79718; 3.77154; 3.6834; 3.56118; 0.284129; 0.661957; 0.387404; 0.560108; 0.746367; 0.834272; 0.765084; 0.489272]; */
    /*  ThetaLimits [1.31511790024505,1.78690790024505;]; */
    /* 'bezierTableCurrent2:59' stepBezier(2).spPlus =  -0.109426147959518; */
    stepBezier[1].spPlus = -0.109426147959518;

    /* 'bezierTableCurrent2:60' stepBezier(2).halpha = [3.59265421324105,3.58812915385993,3.63492000000000,3.22031000000000,3.17686000000000,3.08939000000000; */
    /* 'bezierTableCurrent2:61'             3.14258626125961,3.28175954372438,3.79718000000000,3.77154000000000,3.68340000000000,3.56118000000000; */
    /* 'bezierTableCurrent2:62'             0.605401288255448,0.560030488059349,0.284129000000000,0.661957000000000,0.387404000000000,0.560108000000000; */
    /* 'bezierTableCurrent2:63'             0.557904079660530,0.643276999369453,0.746367000000000,0.834272000000000,0.765084000000000,0.489272000000000;]; */
    for (i = 0; i < 24; i++) {
      stepBezier[1].halpha[i] = t[i];
    }

    /* 'bezierTableCurrent2:65' stepBezier(3).spPlus = [-0.0533909140488557;]; */
    stepBezier[2].spPlus = -0.0533909140488557;

    /* 'bezierTableCurrent2:66' stepBezier(3).halpha = [3.57202155464132,3.54194918513446,3.63492000000000,3.22031000000000,3.17686000000000,3.08939000000000; */
    /* 'bezierTableCurrent2:67'             3.10076860527039,3.15181478258618,3.79718000000000,3.77154000000000,3.68340000000000,3.56118000000000; */
    /* 'bezierTableCurrent2:68'             0.562925747083730,0.603373973702065,0.284129000000000,0.661957000000000,0.387404000000000,0.560108000000000; */
    /* 'bezierTableCurrent2:69'             0.566793376146665,0.687961818026883,0.746367000000000,0.834272000000000,0.765084000000000,0.489272000000000;]; */
    for (i = 0; i < 24; i++) {
      stepBezier[2].halpha[i] = s[i];
    }

    /* 'bezierTableCurrent2:71' stepBezier(4).spPlus =  0; */
    stepBezier[3].spPlus = 0.0;

    /* 'bezierTableCurrent2:72' stepBezier(4).halpha = [3.56117999999990,3.49301211082539,3.63492000000000,3.22031000000000,3.17686000000000,3.08939000000000; */
    /* 'bezierTableCurrent2:73'             3.08939000000021,2.98050504908016,3.79718000000000,3.77154000000000,3.68340000000000,3.56118000000000; */
    /* 'bezierTableCurrent2:74'             0.489271999998361,0.639998133894733,0.284129000000000,0.661957000000000,0.387404000000000,0.560108000000000; */
    /* 'bezierTableCurrent2:75'             0.560107999999545,0.784441877204877,0.746367000000000,0.834272000000000,0.765084000000000,0.489272000000000;]; */
    for (i = 0; i < 24; i++) {
      stepBezier[3].halpha[i] = q[i];
    }

    /* 'bezierTableCurrent2:77' stepBezier(5).spPlus =   [0.0484310931123467;]; */
    stepBezier[4].spPlus = 0.0484310931123467;

    /* 'bezierTableCurrent2:78' stepBezier(5).halpha = [3.56187906680849,3.44000310360732,3.63492000000000,3.22031000000000,3.17686000000000,3.08939000000000; */
    /* 'bezierTableCurrent2:79'             3.13304426873421,2.75917426306341,3.79718000000000,3.77154000000000,3.68340000000000,3.56118000000000; */
    /* 'bezierTableCurrent2:80'             0.380990655598159,0.671739960465328,0.284129000000000,0.661957000000000,0.387404000000000,0.560108000000000; */
    /* 'bezierTableCurrent2:81'             0.496880714901298,0.976124079486289,0.746367000000000,0.834272000000000,0.765084000000000,0.489272000000000;]; */
    for (i = 0; i < 24; i++) {
      stepBezier[4].halpha[i] = p[i];
    }

    /* 'bezierTableCurrent2:83' stepBezier(6).spPlus =  [0.0900164728211668;]; */
    stepBezier[5].spPlus = 0.0900164728211668;

    /* 'bezierTableCurrent2:84' stepBezier(6).halpha = [3.57785705069653,3.37832999558392,3.63492000000000,3.22031000000000,3.17686000000000,3.08939000000000; */
    /* 'bezierTableCurrent2:85'             3.26272479765068,2.47576802652352,3.79718000000000,3.77154000000000,3.68340000000000,3.56118000000000; */
    /* 'bezierTableCurrent2:86'             0.229131524549162,0.712895463164868,0.284129000000000,0.661957000000000,0.387404000000000,0.560108000000000; */
    /* 'bezierTableCurrent2:87'             0.287962554931851,1.34172271688962,0.746367000000000,0.834272000000000,0.765084000000000,0.489272000000000;]; */
    for (i = 0; i < 24; i++) {
      stepBezier[5].halpha[i] = o[i];
    }
    break;

   case 3:
    /* 'bezierTableCurrent2:89' case 3 */
    /*  4cmNS */
    /*  4cm control disturbance max */
    /*  Periodic -> 4 cm NS */
    /*  Z0 = [1.0344; 3.38125; 3.15038; 3.10332; 3.01329; 2.95019; 3.99772; 3.63566; 3.49056; 0.532315; 0.608682; 0.350348; 0.526534; 0.947235; 0.797885; 0.796106; 0.515658]; */
    /*  ThetaLimits [1.32918148303917,1.80645148303917;]; */
    /* 'bezierTableCurrent2:97' stepBezier(2).spPlus = [-0.128304460757538;]; */
    stepBezier[1].spPlus = -0.128304460757538;

    /* 'bezierTableCurrent2:98' stepBezier(2).halpha = [3.50148776216125,3.43754353868782,3.38125000000000,3.15038000000000,3.10332000000000,3.01329000000000; */
    /* 'bezierTableCurrent2:99'             2.96935894288884,2.86740195339426,2.95019000000000,3.99772000000000,3.63566000000000,3.49056000000000; */
    /* 'bezierTableCurrent2:100'             0.651044268024143,0.670429464935497,0.532315000000000,0.608682000000000,0.350348000000000,0.526534000000000; */
    /* 'bezierTableCurrent2:101'             0.565477036421621,0.725971337612633,0.947235000000000,0.797885000000000,0.796106000000000,0.515658000000000;]; */
    for (i = 0; i < 24; i++) {
      stepBezier[1].halpha[i] = n[i];
    }

    /* 'bezierTableCurrent2:103' stepBezier(3).spPlus = [-0.0610666951879475;]; */
    stepBezier[2].spPlus = -0.0610666951879475;

    /* 'bezierTableCurrent2:104' stepBezier(3).halpha = [3.49309376307264,3.41728718615845,3.38125000000000,3.15038000000000,3.10332000000000,3.01329000000000; */
    /* 'bezierTableCurrent2:105'             2.99949560968401,2.91161558102436,2.95019000000000,3.99772000000000,3.63566000000000,3.49056000000000; */
    /* 'bezierTableCurrent2:106'             0.596582661823303,0.678330695118829,0.532315000000000,0.608682000000000,0.350348000000000,0.526534000000000; */
    /* 'bezierTableCurrent2:107'             0.546406257179468,0.709688203116856,0.947235000000000,0.797885000000000,0.796106000000000,0.515658000000000;]; */
    for (i = 0; i < 24; i++) {
      stepBezier[2].halpha[i] = m[i];
    }

    /* 'bezierTableCurrent2:109' stepBezier(4).spPlus = 0; */
    stepBezier[3].spPlus = 0.0;

    /* 'bezierTableCurrent2:110' stepBezier(4).halpha = [3.49055999999997,3.40433567035172,3.38125000000000,3.15038000000000,3.10332000000000,3.01329000000000; */
    /* 'bezierTableCurrent2:111'             3.01329000000027,2.90531812733559,2.95019000000000,3.99772000000000,3.63566000000000,3.49056000000000; */
    /* 'bezierTableCurrent2:112'             0.515657999998245,0.672309596090129,0.532315000000000,0.608682000000000,0.350348000000000,0.526534000000000; */
    /* 'bezierTableCurrent2:113'             0.526533999999455,0.741853575881061,0.947235000000000,0.797885000000000,0.796106000000000,0.515658000000000;]; */
    for (i = 0; i < 24; i++) {
      stepBezier[3].halpha[i] = l[i];
    }

    /* 'bezierTableCurrent2:115' stepBezier(5).spPlus = [0.0471342686437857;]; */
    stepBezier[4].spPlus = 0.0471342686437857;

    /* 'bezierTableCurrent2:116' stepBezier(5).halpha = [3.48558960603127,3.40902426998661,3.38125000000000,3.15038000000000,3.10332000000000,3.01329000000000; */
    /* 'bezierTableCurrent2:117'             3.03665552105148,2.83498642672937,2.95019000000000,3.99772000000000,3.63566000000000,3.49056000000000; */
    /* 'bezierTableCurrent2:118'             0.413994301094000,0.650645821206378,0.532315000000000,0.608682000000000,0.350348000000000,0.526534000000000; */
    /* 'bezierTableCurrent2:119'             0.471714708678728,0.895163833268652,0.947235000000000,0.797885000000000,0.796106000000000,0.515658000000000;]; */
    for (i = 0; i < 24; i++) {
      stepBezier[4].halpha[i] = h[i];
    }

    /* 'bezierTableCurrent2:121' stepBezier(6).spPlus = [0.0693694437364348;]; */
    stepBezier[5].spPlus = 0.0693694437364348;

    /* 'bezierTableCurrent2:122' stepBezier(6).halpha = [3.46035041455478,3.46022307370201,3.38125000000000,3.15038000000000,3.10332000000000,3.01329000000000; */
    /* 'bezierTableCurrent2:123'             3.08124803329452,2.69439468861378,2.95019000000000,3.99772000000000,3.63566000000000,3.49056000000000; */
    /* 'bezierTableCurrent2:124'             0.304356574836397,0.635686846329621,0.532315000000000,0.608682000000000,0.350348000000000,0.526534000000000; */
    /* 'bezierTableCurrent2:125'             0.317889619949311,1.35681641873216,0.947235000000000,0.797885000000000,0.796106000000000,0.515658000000000;]; */
    for (i = 0; i < 24; i++) {
      stepBezier[5].halpha[i] = g[i];
    }
    break;

   default:
    /* 'bezierTableCurrent2:127' otherwise */
    /*  fprintf(' Error! ControlParams.Feedback.RIO %g not recognized as valid selection for interpolative bezier!\n', controlNum) */
    /* 'bezierTableCurrent2:129' coder.ceval('printf', coder.rref(msg), controlNum); */
    printf(msg, controlNum);

    /*  fprintf(' Assigning 4cmS control in place\n') */
    /* 'bezierTableCurrent2:131' coder.ceval('printf', coder.rref(msg2), controlNum); */
    printf(msg2, controlNum);

    /* 'bezierTableCurrent2:133' stepBezier(2).spPlus = [-0.112709212511353;]; */
    stepBezier[1].spPlus = -0.112709212511353;

    /* 'bezierTableCurrent2:134' stepBezier(2).halpha = [3.57551259902854,3.46423541019452,3.39354000000000,3.37945000000000,3.23236000000000,3.09154000000000; */
    /* 'bezierTableCurrent2:135'             3.04667193071562,2.87138223188993,2.87796000000000,4.02207000000000,3.74049000000000,3.56994000000000; */
    /* 'bezierTableCurrent2:136'             0.634463432692027,0.699022833492717,0.596111000000000,0.482812000000000,0.391096000000000,0.550965000000000; */
    /* 'bezierTableCurrent2:137'             0.585312475364920,0.772425342485748,1.04437000000000,0.855403000000000,0.696856000000000,0.487677000000000;]; */
    for (i = 0; i < 24; i++) {
      stepBezier[1].halpha[i] = f[i];
    }

    /* 'bezierTableCurrent2:139' stepBezier(3).spPlus = [-0.0565185420256428;]; */
    stepBezier[2].spPlus = -0.0565185420256428;

    /* 'bezierTableCurrent2:140' stepBezier(3).halpha = [3.56974644932167,3.44779894067081,3.39354000000000,3.37945000000000,3.23236000000000,3.09154000000000; */
    /* 'bezierTableCurrent2:141'             3.07297747728139,2.91055825087636,2.87796000000000,4.02207000000000,3.74049000000000,3.56994000000000; */
    /* 'bezierTableCurrent2:142'             0.570731240644985,0.688178841141528,0.596111000000000,0.482812000000000,0.391096000000000,0.550965000000000; */
    /* 'bezierTableCurrent2:143'             0.569144465667379,0.752778052509281,1.04437000000000,0.855403000000000,0.696856000000000,0.487677000000000;]; */
    for (i = 0; i < 24; i++) {
      stepBezier[2].halpha[i] = e[i];
    }

    /* 'bezierTableCurrent2:145' stepBezier(4).spPlus = 0; */
    stepBezier[3].spPlus = 0.0;

    /* 'bezierTableCurrent2:146' stepBezier(4).halpha = [3.56994000000004,3.43187740968973,3.39354000000000,3.37945000000000,3.23236000000000,3.09154000000000; */
    /* 'bezierTableCurrent2:147'             3.09154000000035,2.91405381643570,2.87796000000000,4.02207000000000,3.74049000000000,3.56994000000000; */
    /* 'bezierTableCurrent2:148'             0.487676999998248,0.675564721751326,0.596111000000000,0.482812000000000,0.391096000000000,0.550965000000000; */
    /* 'bezierTableCurrent2:149'             0.550964999999577,0.756845637687275,1.04437000000000,0.855403000000000,0.696856000000000,0.487677000000000;]; */
    for (i = 0; i < 24; i++) {
      stepBezier[3].halpha[i] = d[i];
    }

    /* 'bezierTableCurrent2:151' stepBezier(5).spPlus = [0.0485070021484834;]; */
    stepBezier[4].spPlus = 0.0485070021484834;

    /* 'bezierTableCurrent2:152' stepBezier(5).halpha = [3.57012901044516,3.42533172199634,3.39354000000000,3.37945000000000,3.23236000000000,3.09154000000000;3.11747975862252,2.86037311118190,2.87796000000000,4.02207000000000,3.74049000000000,3.56994000000000;0.381878616323664,0.668126952285200,0.596111000000000,0.482812000000000,0.391096000000000,0.550965000000000;0.513345597891921,0.836641218766406,1.04437000000000,0.855403000000000,0.696856000000000,0.487677000000000;]; */
    for (i = 0; i < 24; i++) {
      stepBezier[4].halpha[i] = c[i];
    }

    /* 'bezierTableCurrent2:154' stepBezier(6).spPlus = [0.0755116545848371;]; */
    stepBezier[5].spPlus = 0.0755116545848371;

    /* 'bezierTableCurrent2:155' stepBezier(6).halpha = [3.54549504005990,3.46582412603665,3.39354000000000,3.37945000000000,3.23236000000000,3.09154000000000; */
    /* 'bezierTableCurrent2:156'             3.15417848729336,2.74830688442457,2.87796000000000,4.02207000000000,3.74049000000000,3.56994000000000; */
    /* 'bezierTableCurrent2:157'             0.254667358003798,0.702725140634890,0.596111000000000,0.482812000000000,0.391096000000000,0.550965000000000; */
    /* 'bezierTableCurrent2:158'             0.414903362656048,1.11692149439900,1.04437000000000,0.855403000000000,0.696856000000000,0.487677000000000;]; */
    for (i = 0; i < 24; i++) {
      stepBezier[5].halpha[i] = b[i];
    }
    break;
  }

  /* 'beziertableinterpolate2:22' n = length(stepBezier); */
  /*  Build up set of spPlus values corresponding to individual halphas */
  /* 'beziertableinterpolate2:25' spPlusSet = zeros(n-1,1); */
  /* 'beziertableinterpolate2:26' for i = 2:n */
  for (i = 0; i < 5; i++) {
    /* 'beziertableinterpolate2:27' spPlusSet(i-1) = stepBezier(i).spPlus; */
    spPlusSet[i] = stepBezier[i + 1].spPlus;
  }

  /*  If spPlusCurrent is outside of min and max of set, use end point */
  /* 'beziertableinterpolate2:31' if (spPlusCurrent < stepBezier(2).spPlus) */
  if (spPlusCurrent < stepBezier[1].spPlus) {
    /* 'beziertableinterpolate2:32' halphaInterpolated = stepBezier(2).halpha; */
    for (i = 0; i < 24; i++) {
      halphaInterpolated[i] = stepBezier[1].halpha[i];
    }

    /* fprintf('\nerror, spPlusCurrent: %g is less than minimum of set: %g, using closest value\n\n', spPlusCurrent, stepBezier2(2).spPlus) */
  } else {
    /* 'beziertableinterpolate2:35' else */
    /* 'beziertableinterpolate2:35' if (spPlusCurrent > stepBezier(n).spPlus) */
    if (spPlusCurrent > stepBezier[5].spPlus) {
      /* 'beziertableinterpolate2:36' halphaInterpolated = stepBezier(n).halpha; */
      for (i = 0; i < 24; i++) {
        halphaInterpolated[i] = stepBezier[5].halpha[i];
      }

      /* fprintf('\nerror, spPlusCurrent: %g is more than maximum of set: %g, using closest value\n\n', spPlusCurrent, stepBezier2(n).spPlus) */
    } else {
      /*  Build new interpolated halpha */
      /* 'beziertableinterpolate2:43' halphaInterpolated = zeros(4,6); */
      /* 'beziertableinterpolate2:44' halphaColumnSetTemp = zeros(5,4); */
      /* 'beziertableinterpolate2:45' for i = 1:6 */
      for (b_i = 0; b_i < 6; b_i++) {
        /* 'beziertableinterpolate2:47' for j = 2:n */
        for (i = 0; i < 5; i++) {
          /* 'beziertableinterpolate2:48' halphaColumnSetTemp(j-1,:) = stepBezier(j).halpha(:,i)'; */
          halphaColumnSetTemp[i] = stepBezier[i + 1].halpha[b_i << 2];
          halphaColumnSetTemp[i + 5] = stepBezier[i + 1].halpha[(b_i << 2) + 1];
          halphaColumnSetTemp[i + 10] = stepBezier[i + 1].halpha[(b_i << 2) + 2];
          halphaColumnSetTemp[i + 15] = stepBezier[i + 1].halpha[(b_i << 2) + 3];
        }

        /* 'beziertableinterpolate2:51' halphaInterpolated(:,i) = interp1(spPlusSet,halphaColumnSetTemp,spPlusCurrent)'; */
        for (i = 0; i < 5; i++) {
          x[i] = spPlusSet[i];
        }

        Vq_idx_0 = (rtNaN);
        Vq_idx_1 = (rtNaN);
        Vq_idx_2 = (rtNaN);
        Vq_idx_3 = (rtNaN);
        if (spPlusSet[1] < spPlusSet[0]) {
          xtmp = x[0];
          x[0] = x[4];
          x[4] = xtmp;
          xtmp = x[1];
          x[1] = x[3];
          x[3] = xtmp;
          for (i = 0; i < 4; i++) {
            low_ip1 = i * 5;
            xtmp = halphaColumnSetTemp[low_ip1];
            halphaColumnSetTemp[low_ip1] = halphaColumnSetTemp[low_ip1 + 4];
            halphaColumnSetTemp[low_ip1 + 4] = xtmp;
            xtmp = halphaColumnSetTemp[low_ip1 + 1];
            halphaColumnSetTemp[low_ip1 + 1] = halphaColumnSetTemp[low_ip1 + 3];
            halphaColumnSetTemp[low_ip1 + 3] = xtmp;
          }
        }

        if ((!rtIsNaN(spPlusCurrent)) && (!((spPlusCurrent > x[4]) ||
              (spPlusCurrent < x[0])))) {
          i = 1;
          low_ip1 = 2;
          high_i = 5;
          while (high_i > low_ip1) {
            mid_i = (i + high_i) >> 1;
            if (spPlusCurrent >= x[mid_i - 1]) {
              i = mid_i;
              low_ip1 = mid_i + 1;
            } else {
              high_i = mid_i;
            }
          }

          xtmp = (spPlusCurrent - x[i - 1]) / (x[i] - x[i - 1]);
          if (halphaColumnSetTemp[i - 1] == halphaColumnSetTemp[i]) {
            Vq_idx_0 = halphaColumnSetTemp[i - 1];
          } else {
            Vq_idx_0 = (1.0 - xtmp) * halphaColumnSetTemp[i - 1] + xtmp *
              halphaColumnSetTemp[i];
          }

          if (halphaColumnSetTemp[i + 4] == halphaColumnSetTemp[i + 5]) {
            Vq_idx_1 = halphaColumnSetTemp[i + 4];
          } else {
            Vq_idx_1 = (1.0 - xtmp) * halphaColumnSetTemp[i + 4] +
              halphaColumnSetTemp[i + 5] * xtmp;
          }

          if (halphaColumnSetTemp[i + 9] == halphaColumnSetTemp[i + 10]) {
            Vq_idx_2 = halphaColumnSetTemp[i + 9];
          } else {
            Vq_idx_2 = (1.0 - xtmp) * halphaColumnSetTemp[i + 9] +
              halphaColumnSetTemp[i + 10] * xtmp;
          }

          if (halphaColumnSetTemp[i + 14] == halphaColumnSetTemp[i + 15]) {
            Vq_idx_3 = halphaColumnSetTemp[i + 14];
          } else {
            Vq_idx_3 = (1.0 - xtmp) * halphaColumnSetTemp[i + 14] +
              halphaColumnSetTemp[i + 15] * xtmp;
          }
        }

        halphaInterpolated[b_i << 2] = Vq_idx_0;
        halphaInterpolated[1 + (b_i << 2)] = Vq_idx_1;
        halphaInterpolated[2 + (b_i << 2)] = Vq_idx_2;
        halphaInterpolated[3 + (b_i << 2)] = Vq_idx_3;
      }
    }
  }
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function [Discrete,v] = updateVelocityControl(t, q, ControlState, ControlParams)
 */
static void Walking01_updateVelocityControl(real_T t, const real_T q[13], real_T
  ControlState_StanceLeg, real_T ControlParams_Supervisory_Veloc, real_T
  ControlParams_Supervisory_Vel_0, real_T ControlParams_Supervisory_Vel_1,
  real_T ControlParams_Supervisory_Vel_2, const DiscreteParamsBus
  *ControlParams_Discrete, DiscreteParamsBus *Discrete)
{
  real_T HipDistCur;
  real_T b_q[13];
  static const int8_T b[13] = { 0, 1, 2, 5, 6, 3, 4, 10, 11, 12, 7, 8, 9 };

  int32_T i;

  /* 'updateVelocityControl:4' Discrete = ControlParams.Discrete; */
  *Discrete = *ControlParams_Discrete;

  /*  Compute velocity estimate */
  /* 'updateVelocityControl:7' HipDistCur = computeHipDist(q, 1 - ControlState.StanceLeg); */
  memcpy(&b_q[0], &q[0], 13U * sizeof(real_T));

  /* 'updateVelocityControl:25' if (StanceLeg==1) */
  if (1.0 - ControlState_StanceLeg == 1.0) {
    /* 'updateVelocityControl:26' q = q([1 2 3 6 7 4 5 11 12 13 8 9 10]); */
    for (i = 0; i < 13; i++) {
      b_q[i] = q[b[i]];
    }
  }

  /* 'updateVelocityControl:29' KA = q(5)-q(4); */
  /* 'updateVelocityControl:30' L  = cos(KA/2); */
  /* 'updateVelocityControl:31' theta = pi - q(3) - (q(5)+q(4))/2; */
  /* 'updateVelocityControl:33' hipDist = L*sin(theta); */
  HipDistCur = sin((3.1415926535897931 - b_q[2]) - (b_q[4] + b_q[3]) / 2.0) *
    cos((b_q[4] - b_q[3]) / 2.0);

  /* 'updateVelocityControl:8' dt = t - Discrete.TLastUpdate; */
  /* 'updateVelocityControl:9' dx = HipDistCur - Discrete.VelocityControlHipDistPrev; */
  /* 'updateVelocityControl:10' v  = dx/dt; */
  /*  Compute update */
  /* 'updateVelocityControl:13' DeltaTorso = ControlParams.Discrete.VelocityControlTorsoDelta; */
  /* 'updateVelocityControl:14' DeltaTorso = DeltaTorso - ControlParams.Supervisory.VelocityControlTorsoGain*(v - ControlParams.Supervisory.VelocityControlTorsoV0); */
  /* 'updateVelocityControl:15' DeltaTorso = sat(DeltaTorso, ControlParams.Supervisory.VelocityControlTorsoMin, ControlParams.Supervisory.VelocityControlTorsoMax); */
  /* 'sat:3' y = max(lo, min(x, hi)); */
  /*  Update */
  /* 'updateVelocityControl:18' Discrete.TLastUpdate = t; */
  Discrete->TLastUpdate = t;

  /* 'updateVelocityControl:19' Discrete.VelocityControlHipDistCur = HipDistCur; */
  Discrete->VelocityControlHipDistCur = HipDistCur;

  /* 'updateVelocityControl:20' Discrete.VelocityControlHipDistPrev = computeHipDist(q, ControlState.StanceLeg); */
  memcpy(&b_q[0], &q[0], 13U * sizeof(real_T));

  /* 'updateVelocityControl:25' if (StanceLeg==1) */
  if (ControlState_StanceLeg == 1.0) {
    /* 'updateVelocityControl:26' q = q([1 2 3 6 7 4 5 11 12 13 8 9 10]); */
    for (i = 0; i < 13; i++) {
      b_q[i] = q[b[i]];
    }
  }

  /* 'updateVelocityControl:29' KA = q(5)-q(4); */
  /* 'updateVelocityControl:30' L  = cos(KA/2); */
  /* 'updateVelocityControl:31' theta = pi - q(3) - (q(5)+q(4))/2; */
  /* 'updateVelocityControl:33' hipDist = L*sin(theta); */
  Discrete->VelocityControlHipDistPrev = sin((3.1415926535897931 - b_q[2]) -
    (b_q[4] + b_q[3]) / 2.0) * cos((b_q[4] - b_q[3]) / 2.0);

  /* 'updateVelocityControl:21' Discrete.VelocityControlTorsoDelta = DeltaTorso; */
  HipDistCur = ControlParams_Discrete->VelocityControlTorsoDelta - ((HipDistCur
    - ControlParams_Discrete->VelocityControlHipDistPrev) / (t -
    ControlParams_Discrete->TLastUpdate) - ControlParams_Supervisory_Vel_2) *
    ControlParams_Supervisory_Vel_1;
  if (!((HipDistCur <= ControlParams_Supervisory_Veloc) || rtIsNaN
        (ControlParams_Supervisory_Veloc))) {
    HipDistCur = ControlParams_Supervisory_Veloc;
  }

  if ((ControlParams_Supervisory_Vel_0 >= HipDistCur) || rtIsNaN(HipDistCur)) {
    Discrete->VelocityControlTorsoDelta = ControlParams_Supervisory_Vel_0;
  } else {
    Discrete->VelocityControlTorsoDelta = HipDistCur;
  }
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function [s,ds,h0,y,dy,jacob_h0,jacob_h,s_unsaturated,theta,dtheta,delta_theta,dsdq,jacob_jacobhdqdq,phi,r,dr,hdbar] = ATRIAS3D_ZD_Output03(t, q, dq, ControlState, ControlParams, sprev)
 */
static void Walking_ATRIAS3D_ZD_Output03_c0(real_T t, const real_T q[13], const
  real_T dq[13], real_T ControlState_StanceLeg, const real_T
  ControlParams_Output_ThetaLimit[2], real_T ControlParams_Output_Theta_c0,
  real_T ControlParams_Output_Theta_ct, const real_T
  ControlParams_Output_Theta_cq[13], real_T ControlParams_Output_Theta_t0,
  real_T ControlParams_Output_SaturateS, const real_T
  ControlParams_Output_SLimits[2], real_T ControlParams_Output_EnforceInc,
  real_T *s, real_T *ds)
{
  real_T c[15];
  real_T dsdq[13];
  real_T theta;
  real_T dtheta;
  real_T delta_theta;
  real_T b;
  real_T d;
  real_T e;
  real_T g;
  static const int8_T i[13] = { 0, 1, 2, 5, 6, 3, 4, 10, 11, 12, 7, 8, 9 };

  int32_T i_0;
  int32_T loop_ub;
  int32_T f_data;
  int32_T f_sizes[2];

  /* 'ATRIAS3D_ZD_Output03:4' Output = ControlParams.Output; */
  /*  Define matrix to convert between motor and standard actuated coordinates */
  /*  [uLAst; uLAsw; uKAst; uKAsw; u3st; u3sw] = T0*[u1R; u2R; u3R; u1L; u2L; u3L] */
  /* 'ATRIAS3D_ZD_Output03:8' T0 = [0.5 0.5 0 0 0 0; 0 0 0 0.5 0.5 0; -1 1 0 0 0 0; 0 0 0 -1 1 0; 0 0 1 0 0 0; 0 0 0 0 0 1]; */
  /* 'ATRIAS3D_ZD_Output03:9' if (ControlState.StanceLeg==1) */
  /* 'ATRIAS3D_ZD_Output03:12' T1 = [zeros(6,7) T0]; */
  /*     %% Compute s and modify Bezier parameters to extend outside 0 <= s <= 1 */
  /* [Sy,Sq] = SymmetryMatrices(); */
  /* 'ATRIAS3D_ZD_Output03:16' if (ControlState.StanceLeg==0) */
  if (ControlState_StanceLeg == 0.0) {
    /* 'ATRIAS3D_ZD_Output03:17' c = [Output.Theta.c0 Output.Theta.ct Output.Theta.cq]; */
    c[0] = ControlParams_Output_Theta_c0;
    c[1] = ControlParams_Output_Theta_ct;
    memcpy(&c[2], &ControlParams_Output_Theta_cq[0], 13U * sizeof(real_T));

    /* 'ATRIAS3D_ZD_Output03:18' jacob_h0 = Output.H0; */
  } else {
    /* 'ATRIAS3D_ZD_Output03:19' else */
    /* 'ATRIAS3D_ZD_Output03:20' c = [Output.Theta.c0 Output.Theta.ct Output.Theta.cq(:,[1 2 3 6 7 4 5 11 12 13 8 9 10])]; */
    c[0] = ControlParams_Output_Theta_c0;
    c[1] = ControlParams_Output_Theta_ct;
    for (i_0 = 0; i_0 < 13; i_0++) {
      c[i_0 + 2] = ControlParams_Output_Theta_cq[i[i_0]];
    }

    /* 'ATRIAS3D_ZD_Output03:21' c(:,3:4) = -c(:,3:4); */
    c[2] = -c[2];
    c[3] = -c[3];

    /* 'ATRIAS3D_ZD_Output03:22' jacob_h0 = Output.H0(:,[1 2 3 6 7 4 5 11 12 13 8 9 10]); */
    /* 'ATRIAS3D_ZD_Output03:23' jacob_h0(:,1:2) = -jacob_h0(:,1:2); */
  }

  /* 'ATRIAS3D_ZD_Output03:27' [s,ds,dsdq,theta,dtheta,delta_theta] = ATRIAS3D_ZD_s6(t-Output.Theta.t0, q, dq, Output.ThetaLimits, c); */
  Walking01_with_ATRIAS3D_ZD_s6_b(t - ControlParams_Output_Theta_t0, q, dq,
    ControlParams_Output_ThetaLimit, c, s, ds, dsdq, &theta, &dtheta,
    &delta_theta);

  /* 'ATRIAS3D_ZD_Output03:28' s_unsaturated = s; */
  /* 'ATRIAS3D_ZD_Output03:30' if (Output.EnforceIncreasingS) */
  if ((ControlParams_Output_EnforceInc != 0.0) && (!(*s >= -1000.0))) {
    /* 'ATRIAS3D_ZD_Output03:31' s = max(s, sprev); */
    *s = -1000.0;
  }

  /* 'ATRIAS3D_ZD_Output03:34' h_alpha = Output.HAlpha; */
  /* 'ATRIAS3D_ZD_Output03:35' if (ControlState.StanceLeg==1) */
  /* 'ATRIAS3D_ZD_Output03:39' if Output.SaturateS==1 */
  if (ControlParams_Output_SaturateS == 1.0) {
    /* delta = 0.2; */
    /* p = [0.2  -0.4  0.2  0]; % coefficients of transition poly */
    /* [s, ds] = softsaturate(s, ds, delta, p); */
    /*  Modified Feb. 4th, 2014 for interpolative bezier table bounds. */
    /* 'ATRIAS3D_ZD_Output03:44' delta = 0.1; */
    /* 'ATRIAS3D_ZD_Output03:45' ds(s>1+delta) = 0; */
    e = *ds;
    Walking01_withEl_eml_li_find_en(*s > 1.1, &f_data, f_sizes);
    loop_ub = f_sizes[0] * f_sizes[1];
    for (i_0 = 0; i_0 < loop_ub; i_0++) {
      e = 0.0;
    }

    /* 'ATRIAS3D_ZD_Output03:46' s(s>1+delta) = 1+delta; */
    b = *s;
    Walking01_withEl_eml_li_find_en(*s > 1.1, &f_data, f_sizes);
    loop_ub = f_sizes[0] * f_sizes[1];
    for (i_0 = 0; i_0 < loop_ub; i_0++) {
      b = 1.1;
    }

    /* 'ATRIAS3D_ZD_Output03:47' ds(s<-delta) = 0; */
    g = e;
    Walking01_withEl_eml_li_find_en(b < -0.1, &f_data, f_sizes);
    loop_ub = f_sizes[0] * f_sizes[1];
    for (i_0 = 0; i_0 < loop_ub; i_0++) {
      g = 0.0;
    }

    *ds = g;

    /* 'ATRIAS3D_ZD_Output03:48' s(s<-delta) = -delta; */
    d = b;
    Walking01_withEl_eml_li_find_en(b < -0.1, &f_data, f_sizes);
    loop_ub = f_sizes[0] * f_sizes[1];
    for (i_0 = 0; i_0 < loop_ub; i_0++) {
      d = -0.1;
    }

    *s = d;
  } else if ((!(ControlParams_Output_SaturateS == 2.0)) &&
             (ControlParams_Output_SaturateS == 3.0)) {
    /* 'ATRIAS3D_ZD_Output03:70' elseif Output.SaturateS==3 */
    /* 'ATRIAS3D_ZD_Output03:71' smin = Output.SLimits(1); */
    /* 'ATRIAS3D_ZD_Output03:72' smax = Output.SLimits(2); */
    /* 'ATRIAS3D_ZD_Output03:73' ds(s>smax) = 0; */
    e = *ds;
    Walking01_withEl_eml_li_find_en(*s > ControlParams_Output_SLimits[1],
      &f_data, f_sizes);
    loop_ub = f_sizes[0] * f_sizes[1];
    for (i_0 = 0; i_0 < loop_ub; i_0++) {
      e = 0.0;
    }

    /* 'ATRIAS3D_ZD_Output03:74' s(s>smax)  = smax; */
    b = *s;
    Walking01_withEl_eml_li_find_en(*s > ControlParams_Output_SLimits[1],
      &f_data, f_sizes);
    loop_ub = f_sizes[0] * f_sizes[1];
    for (i_0 = 0; i_0 < loop_ub; i_0++) {
      b = ControlParams_Output_SLimits[1];
    }

    /* 'ATRIAS3D_ZD_Output03:75' ds(s<smin) = 0; */
    g = e;
    Walking01_withEl_eml_li_find_en(b < ControlParams_Output_SLimits[0], &f_data,
      f_sizes);
    loop_ub = f_sizes[0] * f_sizes[1];
    for (i_0 = 0; i_0 < loop_ub; i_0++) {
      g = 0.0;
    }

    *ds = g;

    /* 'ATRIAS3D_ZD_Output03:76' s(s<smin)  = smin; */
    d = b;
    Walking01_withEl_eml_li_find_en(b < ControlParams_Output_SLimits[0], &f_data,
      f_sizes);
    loop_ub = f_sizes[0] * f_sizes[1];
    for (i_0 = 0; i_0 < loop_ub; i_0++) {
      d = ControlParams_Output_SLimits[0];
    }

    *s = d;
  } else {
    /* 'ATRIAS3D_ZD_Output03:64' h_alpha(s6>1,:) = h_alpha_high(s6>1,:); */
    /*  If (s<0), hold all desired angles constant */
    /* 'ATRIAS3D_ZD_Output03:67' h_alpha_low = h_alpha(:,1)*[1 1 1 1 1 1]; */
    /* 'ATRIAS3D_ZD_Output03:68' h_alpha(s6<0,:) = h_alpha_low(s6<0,:); */
    /* 'ATRIAS3D_ZD_Output03:50' elseif Output.SaturateS==2 */
    /* 'ATRIAS3D_ZD_Output03:51' if (length(s)>1) */
    /* 'ATRIAS3D_ZD_Output03:54' else */
    /* 'ATRIAS3D_ZD_Output03:55' dqyTds = repmat((c(1,5)*delta_theta), 2, 1); */
    /* 'ATRIAS3D_ZD_Output03:56' s6 = repmat(s, 6, 1); */
    /*  If (s>1), hold the desired knee angles constant and keep the */
    /*  torso angle fixed by decreasing the desired leg angles */
    /* 'ATRIAS3D_ZD_Output03:61' h_alpha_high = h_alpha(:,end)*[1 1 1 1 1 1]; */
    /* 'ATRIAS3D_ZD_Output03:62' h_alpha_high(1:2,:) = h_alpha_high(1:2,:)+dqyTds*(-1:0.2:0); */
    /* 'ATRIAS3D_ZD_Output03:63' h_alpha_high(1:2) = max(150*pi/180, h_alpha_high(1:2)); */
  }

  /*     %% Compute terms in controller */
  /* 'ATRIAS3D_ZD_Output03:80' qmod = q; */
  /* 'ATRIAS3D_ZD_Output03:81' qmod(1) = sat(qmod(1), -Output.YawLimit, Output.YawLimit); */
  /* 'ATRIAS3D_ZD_Output03:82' h0 = jacob_h0*qmod; */
  /* 'ATRIAS3D_ZD_Output03:83' hd = bezierv(h_alpha, s); */
  /* 'ATRIAS3D_ZD_Output03:84' jacob_hd  = beziervd(h_alpha,s); */
  /* 'ATRIAS3D_ZD_Output03:85' jacob2_hd = bezierva(h_alpha,s); */
  /* 'ATRIAS3D_ZD_Output03:86' dhd = jacob_hd.*ds; */
  /* 'ATRIAS3D_ZD_Output03:88' jacob_h = jacob_h0 - jacob_hd*dsdq; */
  /* 'ATRIAS3D_ZD_Output03:89' jacob_jacobhdqdq = -jacob2_hd.*(ds.*ds); */
  /*     %% Stabilizing output term */
  /*  Allow outputs of the form */
  /*    y = H0*q - hd(s(theta(q)), h_alpha) - hStabilizing(phi - phid(s(theta(q))), StabilizingHAlpha) */
  /* 'ATRIAS3D_ZD_Output03:95' phi    = Output.Phi.cq * q; */
  /* 'ATRIAS3D_ZD_Output03:96' dphi   = Output.Phi.cq * dq; */
  /* 'ATRIAS3D_ZD_Output03:98' phid   = bezier(Output.PhiAlpha, s); */
  /* 'ATRIAS3D_ZD_Output03:99' jacob_phid = bezierd(Output.PhiAlpha, s); */
  /* 'ATRIAS3D_ZD_Output03:100' jacob2_phid = beziera(Output.PhiAlpha, s); */
  /* 'ATRIAS3D_ZD_Output03:102' r      = phi - phid; */
  /* 'ATRIAS3D_ZD_Output03:103' dr     = dphi - jacob_phid * ds; */
  /* 'ATRIAS3D_ZD_Output03:104' RSaturated = false; */
  /* 'ATRIAS3D_ZD_Output03:105' if Output.SaturateR */
  /* 'ATRIAS3D_ZD_Output03:117' hdbar  = polyv(Output.HBarAlpha, r, inf); */
  /* 'ATRIAS3D_ZD_Output03:118' if ~RSaturated */
  /* 'ATRIAS3D_ZD_Output03:126' hdbar = sat(hdbar, Output.HBarLimits(:,1), Output.HBarLimits(:,2)); */
  /* 'ATRIAS3D_ZD_Output03:127' idxsat = (hdbar == Output.HBarLimits(:,1)) | (hdbar == Output.HBarLimits(:,2)); */
  /* 'ATRIAS3D_ZD_Output03:128' jacob_hdbar(idxsat,:) = 0; */
  /* 'ATRIAS3D_ZD_Output03:129' jacob2_hdbar(idxsat,:) = 0; */
  /* 'ATRIAS3D_ZD_Output03:131' hd = hd + hdbar; */
  /* 'ATRIAS3D_ZD_Output03:132' jacob_h = jacob_h - jacob_hdbar * (Output.Phi.cq - jacob_phid * dsdq); */
  /* 'ATRIAS3D_ZD_Output03:133' jacob_jacobhdqdq = jacob_jacobhdqdq ... */
  /* 'ATRIAS3D_ZD_Output03:134'         + jacob_hdbar * jacob2_phid * ds^2 ... */
  /* 'ATRIAS3D_ZD_Output03:135'         + jacob2_hdbar * (-jacob_phid^2 * ds^2 - dphi^2 + jacob_phid * dphi * ds); */
  /*     %% Saturate the desired leg/knee/hip angles */
  /* 'ATRIAS3D_ZD_Output03:138' hd_min = [150; 150;  15;  15; -20; -20]*pi/180; */
  /* 'ATRIAS3D_ZD_Output03:139' hd_max = [220; 220; 120; 120;  20;  20]*pi/180; */
  /* 'ATRIAS3D_ZD_Output03:140' sat_correction = (jacob_h0 - T1)*q; */
  /* 'ATRIAS3D_ZD_Output03:141' hd = sat(hd, hd_min + sat_correction, hd_max + sat_correction); */
  /* 'ATRIAS3D_ZD_Output03:142' idxsat = (hd == hd_min + sat_correction) | (hd == hd_max + sat_correction); */
  /* 'ATRIAS3D_ZD_Output03:143' dhd(idxsat) = 0; */
  /* 'ATRIAS3D_ZD_Output03:144' jacob_h(idxsat) = jacob_h0(idxsat); */
  /*  jacob_hd(idxsat) = 0; */
  /*     %% */
  /* 'ATRIAS3D_ZD_Output03:147' y  = h0-hd; */
  /* 'ATRIAS3D_ZD_Output03:148' dy = jacob_h0*dq - dhd; */
  /*  Correction */
  /* 'ATRIAS3D_ZD_Output03:152' h_alpha_corr = Output.HAlphaCorrection; */
  /* 'ATRIAS3D_ZD_Output03:153' s_corr_max = Output.SMaxCorrection; */
  /* 'ATRIAS3D_ZD_Output03:154' if Output.UseCorrection && any(s <= s_corr_max) */
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function [s,ds,h0,y,dy,jacob_h0,jacob_h,s_unsaturated,theta,dtheta,delta_theta,dsdq,jacob_jacobh0dq,d] = ATRIAS3D_ZD_Output02(t, q, dq, ControlState, Output)
 */
static void Walking01__ATRIAS3D_ZD_Output02(real_T t, const real_T q[13], const
  real_T dq[13], real_T ControlState_StanceLeg, const real_T Output_H0[78],
  const real_T Output_HAlpha[36], const real_T Output_ThetaLimits[2], real_T
  Output_Theta_c0, real_T Output_Theta_ct, const real_T Output_Theta_cq[13],
  real_T Output_SaturateS, real_T Output_UseCorrection, real_T
  Output_SMaxCorrection, const real_T Output_HAlphaCorrection[30], real_T *s,
  real_T *ds, real_T h0[6], real_T y[6], real_T dy[6], real_T jacob_h0[78],
  real_T jacob_h[78], real_T *s_unsaturated, real_T *theta)
{
  real_T T0[36];
  real_T c[15];
  real_T h_alpha[36];
  real_T h_alpha_high[36];
  real_T sat_correction[6];
  real_T dsdq[13];
  real_T dtheta;
  real_T delta_theta;
  real_T b;
  real_T d;
  real_T e;
  real_T g;
  int32_T k;
  static const real_T b_T0[36] = { 0.5, 0.0, -1.0, 0.0, 0.0, 0.0, 0.5, 0.0, 1.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.5, 0.0, -1.0, 0.0, 0.0,
    0.0, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 };

  static const real_T i[36] = { 0.0, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0, 0.5, 0.0,
    1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0,
    0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 };

  static const int8_T j[13] = { 0, 1, 2, 5, 6, 3, 4, 10, 11, 12, 7, 8, 9 };

  static const real_T b_b[6] = { -1.0, -0.8, -0.6, -0.4, -0.2, 0.0 };

  static const real_T hd_min[6] = { 2.6179938779914944, 2.6179938779914944,
    0.26179938779914941, 0.26179938779914941, -0.3490658503988659,
    -0.3490658503988659 };

  static const real_T hd_max[6] = { 3.839724354387525, 3.839724354387525,
    2.0943951023931953, 2.0943951023931953, 0.3490658503988659,
    0.3490658503988659 };

  real_T tmp[6];
  real_T hd_min_0[6];
  real_T hd_max_0[6];
  boolean_T b_s[6];
  boolean_T b_s_0[6];
  int32_T i_0;
  real_T tmp_0[78];
  real_T jacob_h0_0[78];
  int32_T s_0;
  int32_T tmp_data[6];
  int32_T tmp_sizes;
  int32_T tmp_data_0[6];
  real_T h_alpha_data[36];

  /*  Define matrix to convert between motor and standard actuated coordinates */
  /*  [uLAst; uLAsw; uKAst; uKAsw; u3st; u3sw] = T0*[u1R; u2R; u3R; u1L; u2L; u3L] */
  /* 'ATRIAS3D_ZD_Output02:6' T0 = [0.5 0.5 0 0 0 0; 0 0 0 0.5 0.5 0; -1 1 0 0 0 0; 0 0 0 -1 1 0; 0 0 1 0 0 0; 0 0 0 0 0 1]; */
  memcpy(&T0[0], &b_T0[0], 36U * sizeof(real_T));

  /* 'ATRIAS3D_ZD_Output02:7' if (ControlState.StanceLeg==1) */
  if (ControlState_StanceLeg == 1.0) {
    /* 'ATRIAS3D_ZD_Output02:8' T0 = T0([2 1 4 3 6 5],:); */
    memcpy(&T0[0], &i[0], 36U * sizeof(real_T));
  }

  /* 'ATRIAS3D_ZD_Output02:10' T1 = [zeros(6,7) T0]; */
  /*     %% Compute s and modify Bezier parameters to extend outside 0 <= s <= 1 */
  /* [Sy,Sq] = SymmetryMatrices(); */
  /* 'ATRIAS3D_ZD_Output02:14' if (ControlState.StanceLeg==0) */
  if (ControlState_StanceLeg == 0.0) {
    /* 'ATRIAS3D_ZD_Output02:15' c = [Output.Theta.c0 Output.Theta.ct Output.Theta.cq]; */
    c[0] = Output_Theta_c0;
    c[1] = Output_Theta_ct;
    memcpy(&c[2], &Output_Theta_cq[0], 13U * sizeof(real_T));

    /* 'ATRIAS3D_ZD_Output02:16' jacob_h0 = Output.H0; */
    memcpy(&jacob_h0[0], &Output_H0[0], 78U * sizeof(real_T));
  } else {
    /* 'ATRIAS3D_ZD_Output02:17' else */
    /* 'ATRIAS3D_ZD_Output02:18' c = [Output.Theta.c0 Output.Theta.ct Output.Theta.cq(:,[1 2 3 6 7 4 5 11 12 13 8 9 10])]; */
    c[0] = Output_Theta_c0;
    c[1] = Output_Theta_ct;
    for (i_0 = 0; i_0 < 13; i_0++) {
      c[i_0 + 2] = Output_Theta_cq[j[i_0]];
    }

    /* 'ATRIAS3D_ZD_Output02:19' c(:,3:4) = -c(:,3:4); */
    c[2] = -c[2];
    c[3] = -c[3];

    /* 'ATRIAS3D_ZD_Output02:20' jacob_h0 = Output.H0(:,[1 2 3 6 7 4 5 11 12 13 8 9 10]); */
    for (i_0 = 0; i_0 < 13; i_0++) {
      for (k = 0; k < 6; k++) {
        jacob_h0[k + 6 * i_0] = Output_H0[6 * j[i_0] + k];
      }
    }

    /* 'ATRIAS3D_ZD_Output02:21' jacob_h0(:,1:2) = -jacob_h0(:,1:2); */
    for (i_0 = 0; i_0 < 2; i_0++) {
      for (k = 0; k < 6; k++) {
        jacob_h0[k + 6 * i_0] = -Output_H0[6 * j[i_0] + k];
      }
    }

    /* jacob_h0 = Output.H0; */
    /* jacob_h0 = Sy*jacob_h0*Sq; */
  }

  /* 'ATRIAS3D_ZD_Output02:28' [s,ds,dsdq,theta,dtheta,delta_theta] = ATRIAS3D_ZD_s6(t, q, dq, Output.ThetaLimits, c); */
  Walking01_with_ATRIAS3D_ZD_s6_b(t, q, dq, Output_ThetaLimits, c, s, ds, dsdq,
    theta, &dtheta, &delta_theta);

  /* 'ATRIAS3D_ZD_Output02:29' s_unsaturated = s; */
  *s_unsaturated = *s;

  /* 'ATRIAS3D_ZD_Output02:31' h_alpha = Output.HAlpha; */
  memcpy(&h_alpha[0], &Output_HAlpha[0], 36U * sizeof(real_T));

  /* 'ATRIAS3D_ZD_Output02:32' if (ControlState.StanceLeg==1) */
  /* 'ATRIAS3D_ZD_Output02:36' if Output.SaturateS==1 */
  if (Output_SaturateS == 1.0) {
    /* delta = 0.2; */
    /* p = [0.2  -0.4  0.2  0]; % coefficients of transition poly */
    /* [s, ds] = softsaturate(s, ds, delta, p); */
    /*  Modified Feb. 4th, 2014 for interpolative bezier table bounds. */
    /* 'ATRIAS3D_ZD_Output02:41' delta = 0.1; */
    /* 'ATRIAS3D_ZD_Output02:42' ds(s>1+delta) = 0; */
    e = *ds;
    k = 0;
    if (*s > 1.1) {
      k = 1;
    }

    for (i_0 = 0; i_0 < k; i_0++) {
      e = 0.0;
    }

    /* 'ATRIAS3D_ZD_Output02:43' s(s>1+delta) = 1+delta; */
    b = *s;
    k = 0;
    if (*s > 1.1) {
      k = 1;
    }

    for (i_0 = 0; i_0 < k; i_0++) {
      b = 1.1;
    }

    /* 'ATRIAS3D_ZD_Output02:44' ds(s<-delta) = 0; */
    g = e;
    k = 0;
    if (b < -0.1) {
      k = 1;
    }

    for (i_0 = 0; i_0 < k; i_0++) {
      g = 0.0;
    }

    *ds = g;

    /* 'ATRIAS3D_ZD_Output02:45' s(s<-delta) = -delta; */
    d = b;
    k = 0;
    if (b < -0.1) {
      k = 1;
    }

    for (i_0 = 0; i_0 < k; i_0++) {
      d = -0.1;
    }

    *s = d;
  } else if (Output_SaturateS == 2.0) {
    /* 'ATRIAS3D_ZD_Output02:47' elseif Output.SaturateS==2 */
    /* 'ATRIAS3D_ZD_Output02:48' if (length(s)>1) */
    /* 'ATRIAS3D_ZD_Output02:51' else */
    /* 'ATRIAS3D_ZD_Output02:52' dqyTds = repmat((c(1,5)*delta_theta), 2, 1); */
    dtheta = c[4] * delta_theta;

    /* 'ATRIAS3D_ZD_Output02:53' s6 = repmat(s, 6, 1); */
    /*  If (s>1), hold the desired knee angles constant and keep the */
    /*  torso angle fixed by decreasing the desired leg angles */
    /* 'ATRIAS3D_ZD_Output02:58' h_alpha_high = h_alpha(:,end)*[1 1 1 1 1 1]; */
    for (i_0 = 0; i_0 < 6; i_0++) {
      for (k = 0; k < 6; k++) {
        h_alpha_high[i_0 + 6 * k] = Output_HAlpha[30 + i_0];
      }
    }

    /* 'ATRIAS3D_ZD_Output02:59' h_alpha_high(1:2,:) = h_alpha_high(1:2,:)+dqyTds*(-1:0.2:0); */
    for (i_0 = 0; i_0 < 2; i_0++) {
      for (k = 0; k < 6; k++) {
        h_alpha_high[i_0 + 6 * k] += dtheta * b_b[k];
      }
    }

    /* 'ATRIAS3D_ZD_Output02:60' h_alpha_high(1:2) = max(150*pi/180, h_alpha_high(1:2)); */
    dtheta = h_alpha_high[1];
    if ((2.6179938779914944 >= h_alpha_high[0]) || rtIsNaN(h_alpha_high[0])) {
      h_alpha_high[0] = 2.6179938779914944;
    }

    if ((2.6179938779914944 >= dtheta) || rtIsNaN(dtheta)) {
      h_alpha_high[1] = 2.6179938779914944;
    } else {
      h_alpha_high[1] = dtheta;
    }

    /* 'ATRIAS3D_ZD_Output02:61' h_alpha(s6>1,:) = h_alpha_high(s6>1,:); */
    for (i_0 = 0; i_0 < 6; i_0++) {
      b_s[i_0] = (*s > 1.0);
      b_s_0[i_0] = (*s > 1.0);
    }

    Walking01_withE_eml_li_find_enu(b_s, tmp_data, &tmp_sizes);
    Walking01_withE_eml_li_find_enu(b_s_0, tmp_data_0, &tmp_sizes);
    for (i_0 = 0; i_0 < 6; i_0++) {
      for (k = 0; k < tmp_sizes; k++) {
        h_alpha[(tmp_data[k] + 6 * i_0) - 1] = h_alpha_high[(6 * i_0 +
          tmp_data_0[k]) - 1];
      }
    }

    /*  If (s<0), hold all desired angles constant */
    /* 'ATRIAS3D_ZD_Output02:64' h_alpha_low = h_alpha(:,1)*[1 1 1 1 1 1]; */
    /* 'ATRIAS3D_ZD_Output02:65' h_alpha(s6<0,:) = h_alpha_low(s6<0,:); */
    for (i_0 = 0; i_0 < 6; i_0++) {
      b_s[i_0] = (*s < 0.0);
      b_s_0[i_0] = (*s < 0.0);
    }

    Walking01_withE_eml_li_find_enu(b_s, tmp_data, &tmp_sizes);
    Walking01_withE_eml_li_find_enu(b_s_0, tmp_data_0, &tmp_sizes);
    for (i_0 = 0; i_0 < 6; i_0++) {
      for (k = 0; k < 6; k++) {
        h_alpha_high[i_0 + 6 * k] = h_alpha[i_0];
      }
    }

    for (i_0 = 0; i_0 < 6; i_0++) {
      for (k = 0; k < tmp_sizes; k++) {
        h_alpha_data[k + tmp_sizes * i_0] = h_alpha_high[(6 * i_0 + tmp_data_0[k])
          - 1];
      }
    }

    for (i_0 = 0; i_0 < 6; i_0++) {
      for (k = 0; k < tmp_sizes; k++) {
        h_alpha[(tmp_data[k] + 6 * i_0) - 1] = h_alpha_data[tmp_sizes * i_0 + k];
      }
    }
  } else {
    if (Output_SaturateS == 3.0) {
      /* 'ATRIAS3D_ZD_Output02:67' elseif Output.SaturateS==3 */
      /* 'ATRIAS3D_ZD_Output02:68' delta = 0.02; */
      /* 'ATRIAS3D_ZD_Output02:69' ds(s>1+delta) = 0; */
      e = *ds;
      k = 0;
      if (*s > 1.02) {
        k = 1;
      }

      for (i_0 = 0; i_0 < k; i_0++) {
        e = 0.0;
      }

      /* 'ATRIAS3D_ZD_Output02:70' s(s>1+delta)  = 1+delta; */
      b = *s;
      k = 0;
      if (*s > 1.02) {
        k = 1;
      }

      for (i_0 = 0; i_0 < k; i_0++) {
        b = 1.02;
      }

      /* 'ATRIAS3D_ZD_Output02:71' ds(s<-delta)  = 0; */
      g = e;
      k = 0;
      if (b < -0.02) {
        k = 1;
      }

      for (i_0 = 0; i_0 < k; i_0++) {
        g = 0.0;
      }

      *ds = g;

      /* 'ATRIAS3D_ZD_Output02:72' s(s<-delta)   = -delta; */
      d = b;
      k = 0;
      if (b < -0.02) {
        k = 1;
      }

      for (i_0 = 0; i_0 < k; i_0++) {
        d = -0.02;
      }

      *s = d;
    }
  }

  /*     %% Compute terms in controller */
  /* 'ATRIAS3D_ZD_Output02:76' hd_min = [150; 150;  15;  15; -20; -20]*pi/180; */
  /* 'ATRIAS3D_ZD_Output02:77' hd_max = [220; 220; 120; 120;  20;  20]*pi/180; */
  /*  FOR MIRROR-LAW INSPIRED OUTPUTS! */
  /* hd_min = [110; 306;  24;  -2;  -5;  -4]*pi/180; */
  /* hd_max = [155; 415;  42;  41;   0;   7]*pi/180; */
  /* 'ATRIAS3D_ZD_Output02:83' h0 = jacob_h0*q; */
  for (i_0 = 0; i_0 < 6; i_0++) {
    h0[i_0] = 0.0;
    for (k = 0; k < 13; k++) {
      h0[i_0] += jacob_h0[6 * k + i_0] * q[k];
    }
  }

  /* 'ATRIAS3D_ZD_Output02:84' hd = bezierv(h_alpha, s); */
  /* 'ATRIAS3D_ZD_Output02:86' sat_correction = (jacob_h0 - T1)*q; */
  for (i_0 = 0; i_0 < 7; i_0++) {
    for (k = 0; k < 6; k++) {
      tmp_0[k + 6 * i_0] = 0.0;
    }
  }

  for (i_0 = 0; i_0 < 6; i_0++) {
    for (k = 0; k < 6; k++) {
      tmp_0[k + 6 * (i_0 + 7)] = T0[6 * i_0 + k];
    }
  }

  for (i_0 = 0; i_0 < 13; i_0++) {
    for (k = 0; k < 6; k++) {
      jacob_h0_0[k + 6 * i_0] = jacob_h0[6 * i_0 + k] - tmp_0[6 * i_0 + k];
    }
  }

  /* 'ATRIAS3D_ZD_Output02:87' hd = sat(hd, hd_min + sat_correction, hd_max + sat_correction); */
  /* 'ATRIAS3D_ZD_Output02:88' y  = h0-hd; */
  Walking01_withElmos_bezierv_a(h_alpha, *s, tmp);
  for (i_0 = 0; i_0 < 6; i_0++) {
    sat_correction[i_0] = 0.0;
    for (k = 0; k < 13; k++) {
      sat_correction[i_0] += jacob_h0_0[6 * k + i_0] * q[k];
    }

    hd_min_0[i_0] = hd_min[i_0] + sat_correction[i_0];
    hd_max_0[i_0] = hd_max[i_0] + sat_correction[i_0];
  }

  Walking01_withElmos_sat_iu(tmp, hd_min_0, hd_max_0, sat_correction);
  for (i_0 = 0; i_0 < 6; i_0++) {
    y[i_0] = h0[i_0] - sat_correction[i_0];
  }

  /* 'ATRIAS3D_ZD_Output02:89' dy = jacob_h0*dq-beziervd(h_alpha,s).*ds; */
  Walking01_withElmos_beziervd_k(h_alpha, *s, tmp);
  for (i_0 = 0; i_0 < 6; i_0++) {
    dtheta = 0.0;
    for (k = 0; k < 13; k++) {
      dtheta += jacob_h0[6 * k + i_0] * dq[k];
    }

    dy[i_0] = dtheta - tmp[i_0] * *ds;
  }

  /* 'ATRIAS3D_ZD_Output02:90' d  = bezierva(h_alpha, s).*(ds.*ds); */
  /* 'ATRIAS3D_ZD_Output02:91' if (length(s)>1) */
  /* 'ATRIAS3D_ZD_Output02:93' else */
  /* 'ATRIAS3D_ZD_Output02:94' jacob_h = jacob_h0 - beziervd(h_alpha, s)*dsdq; */
  Walking01_withElmos_beziervd_k(h_alpha, *s, tmp);
  for (i_0 = 0; i_0 < 6; i_0++) {
    for (k = 0; k < 13; k++) {
      jacob_h[i_0 + 6 * k] = jacob_h0[6 * k + i_0] - tmp[i_0] * dsdq[k];
    }
  }

  /*  Correction */
  /* 'ATRIAS3D_ZD_Output02:98' h_alpha_corr = Output.HAlphaCorrection; */
  /* 'ATRIAS3D_ZD_Output02:99' s_corr_max = Output.SMaxCorrection; */
  /* 'ATRIAS3D_ZD_Output02:100' if Output.UseCorrection && any(s <= s_corr_max) */
  if ((Output_UseCorrection != 0.0) && (!((*s <= Output_SMaxCorrection) == 0)))
  {
    /* 'ATRIAS3D_ZD_Output02:101' y       = y       -  polyv( h_alpha_corr, s, s_corr_max); */
    /* 'polyv:2' if nargin<3 */
    /* 'polyv:5' a0=poly_cor(:,1); */
    /* 'polyv:6' a1=poly_cor(:,2); */
    /* 'polyv:7' a2=poly_cor(:,3); */
    /* 'polyv:8' a3=poly_cor(:,4); */
    /* 'polyv:9' a4=poly_cor(:,5); */
    /* 'polyv:10' value=a0+s.*(a1+s.*(a2+s.*(a3+s.*a4))); */
    /* 'polyv:11' value=value.*(s<=s_corr_max); */
    k = (*s <= Output_SMaxCorrection);

    /* 'ATRIAS3D_ZD_Output02:102' dy      = dy      -  polyvd(h_alpha_corr, s, s_corr_max).*ds; */
    /* 'polyvd:2' if nargin<3 */
    /* 'polyvd:5' a1=poly_cor(:,2); */
    /* 'polyvd:6' a2=poly_cor(:,3); */
    /* 'polyvd:7' a3=poly_cor(:,4); */
    /* 'polyvd:8' a4=poly_cor(:,5); */
    /* 'polyvd:9' value=a1+s.*(2*a2+s.*(3*a3+4*s.*a4)); */
    /* 'polyvd:10' value=value.*(s<=s_corr_max); */
    dtheta = 4.0 * *s;
    tmp_sizes = (*s <= Output_SMaxCorrection);

    /* 'ATRIAS3D_ZD_Output02:103' d       = d       +  polyva(h_alpha_corr, s, s_corr_max).*(ds.*ds); */
    /* 'ATRIAS3D_ZD_Output02:104' if (length(s)>1) */
    /* 'ATRIAS3D_ZD_Output02:106' else */
    /* 'ATRIAS3D_ZD_Output02:107' jacob_h = jacob_h - polyvd(h_alpha_corr, s, s_corr_max)*dsdq; */
    /* 'polyvd:2' if nargin<3 */
    /* 'polyvd:5' a1=poly_cor(:,2); */
    /* 'polyvd:6' a2=poly_cor(:,3); */
    /* 'polyvd:7' a3=poly_cor(:,4); */
    /* 'polyvd:8' a4=poly_cor(:,5); */
    /* 'polyvd:9' value=a1+s.*(2*a2+s.*(3*a3+4*s.*a4)); */
    /* 'polyvd:10' value=value.*(s<=s_corr_max); */
    delta_theta = 4.0 * *s;
    s_0 = (*s <= Output_SMaxCorrection);
    for (i_0 = 0; i_0 < 6; i_0++) {
      sat_correction[i_0] = (((Output_HAlphaCorrection[18 + i_0] * 3.0 +
        Output_HAlphaCorrection[24 + i_0] * delta_theta) * *s +
        Output_HAlphaCorrection[12 + i_0] * 2.0) * *s + Output_HAlphaCorrection
        [6 + i_0]) * (real_T)s_0;
      y[i_0] -= ((((Output_HAlphaCorrection[24 + i_0] * *s +
                    Output_HAlphaCorrection[18 + i_0]) * *s +
                   Output_HAlphaCorrection[12 + i_0]) * *s +
                  Output_HAlphaCorrection[6 + i_0]) * *s +
                 Output_HAlphaCorrection[i_0]) * (real_T)k;
      dy[i_0] -= (((Output_HAlphaCorrection[18 + i_0] * 3.0 +
                    Output_HAlphaCorrection[24 + i_0] * dtheta) * *s +
                   Output_HAlphaCorrection[12 + i_0] * 2.0) * *s +
                  Output_HAlphaCorrection[6 + i_0]) * (real_T)tmp_sizes * *ds;
    }

    for (i_0 = 0; i_0 < 6; i_0++) {
      for (k = 0; k < 13; k++) {
        jacob_h[i_0 + 6 * k] -= sat_correction[i_0] * dsdq[k];
      }
    }
  }

  /* 'ATRIAS3D_ZD_Output02:110' jacob_jacobh0dq = zeros(6,13); */
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function [Output, Discrete] = updateBasicWalkingControl04(t, q, dq, ControlState, ControlParams, AllOutputs, ControlStatePrev, ControlParamsPrev)
 */
static void Wal_updateBasicWalkingControl04(real_T t, const real_T q[13], const
  real_T dq[13], real_T ControlState_ControllerMode, real_T
  ControlState_StanceLeg, real_T ControlState_InDoubleSupport, real_T
  ControlState_StepCount, const ControlParamsBus *ControlParams, const
  OutputParamsBus AllOutputs[5], real_T ControlStatePrev_ControllerMode, real_T
  ControlStatePrev_StanceLeg, const ControlParamsBus *ControlParamsPrev,
  OutputParamsBus *Output, DiscreteParamsBus *Discrete)
{
  real_T hd_posing[6];
  real_T h_alpha[36];
  real_T h_alpha_tweak[36];
  real_T HAlphaUpdate[36];
  real_T unusedU9;
  real_T unusedUa;
  real_T y_prev[6];
  real_T h0[6];
  real_T jacob_h0[78];
  real_T jacob_h[78];
  real_T s_unsaturated;
  real_T ThetaPlus;
  static const real_T b[6] = { 1.0, 0.8, 0.6, 0.4, 0.19999999999999996, 0.0 };

  static const real_T b_b[36] = { 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.8, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.4, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.19999999999999996, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };

  static const real_T c_b[36] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.6, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.8, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 };

  static const real_T d_b[6] = { 0.0, 0.2, 0.4, 0.6, 0.8, 1.0 };

  static const int8_T a[36] = { 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0,
    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1 };

  int32_T i;
  real_T tmp[24];
  real_T hd_posing_0[6];
  int32_T i_0;
  int32_T i_1;

  /*  BAG20141014 Updated to handle a symmetric start into transition. */
  /*  Updated to handle RIO and non-RIO operation based on */
  /*  ControlParams.Feedback.RIO. April 3rd, 2014 BAG. */
  /*  Updated to handle interpolative Bezier tables for RIO. January 30th, */
  /*  2014 BAG. */
  /*  Default discrete output */
  /* 'updateBasicWalkingControl04:10' Discrete = ControlParams.Discrete; */
  *Discrete = ControlParams->Discrete;

  /* 'updateBasicWalkingControl04:12' if (ControlState.ControllerMode==1) */
  if (ControlState_ControllerMode == 1.0) {
    /*  POSING */
    /* 'updateBasicWalkingControl04:13' Output = AllOutputs(1); */
    *Output = AllOutputs[0];

    /* 'updateBasicWalkingControl04:15' if ~ControlParams.Supervisory.UseGaitTransition */
    if (!(ControlParams->Supervisory.UseGaitTransition != 0.0)) {
      /* 'updateBasicWalkingControl04:16' Output.HAlpha = AllOutputs(4).HAlpha(:,1)*[1 1 1 1 1 1]; */
      for (i = 0; i < 6; i++) {
        for (i_0 = 0; i_0 < 6; i_0++) {
          Output->HAlpha[i + 6 * i_0] = AllOutputs[3].HAlpha[i];
        }
      }
    }

    /* 'updateBasicWalkingControl04:19' if 0 && (ControlParams.Supervisory.UsePosingControl) */
  } else if (ControlState_ControllerMode == 2.0) {
    /* 'updateBasicWalkingControl04:23' elseif (ControlState.ControllerMode==2) */
    /*  INITIATION */
    /*  The initiation control is a time-based control which starts at */
    /*  the posing configuration and injects energy to initiate motion. */
    /* 'updateBasicWalkingControl04:27' Output = AllOutputs(2); */
    *Output = AllOutputs[1];

    /* 'updateBasicWalkingControl04:28' Output.ThetaLimits = Output.Theta.ct*[0 ControlParams.Supervisory.TStepInitial]; */
    Output->ThetaLimits[0] = AllOutputs[1].Theta.ct * 0.0;
    Output->ThetaLimits[1] = AllOutputs[1].Theta.ct *
      ControlParams->Supervisory.TStepInitial;

    /* 'updateBasicWalkingControl04:29' Output.Theta.t0 = t; */
    Output->Theta.t0 = t;

    /* 'updateBasicWalkingControl04:31' KAInjection = ControlParams.Supervisory.KAInjection; */
    /* 'updateBasicWalkingControl04:32' s2 = 0:0.2:1; */
    /* 'updateBasicWalkingControl04:33' hd_posing = ControlParamsPrev.Output.HAlpha(:,1); */
    /* 'updateBasicWalkingControl04:34' hd_initiation = hd_posing + [0; 0; KAInjection; 0; 0]*pi/180; */
    /* 'updateBasicWalkingControl04:35' Output.HAlpha = hd_posing*(1-s2) + hd_initiation*s2; */
    hd_posing_0[0] = 0.0;
    hd_posing_0[1] = 0.0;
    hd_posing_0[2] = ControlParams->Supervisory.KAInjection[0];
    hd_posing_0[3] = ControlParams->Supervisory.KAInjection[1];
    hd_posing_0[4] = 0.0;
    hd_posing_0[5] = 0.0;
    for (i = 0; i < 6; i++) {
      hd_posing[i] = hd_posing_0[i] * 3.1415926535897931 / 180.0 +
        ControlParamsPrev->Output.HAlpha[i];
    }

    for (i = 0; i < 6; i++) {
      for (i_0 = 0; i_0 < 6; i_0++) {
        h_alpha_tweak[i + 6 * i_0] = ControlParamsPrev->Output.HAlpha[i] * b[i_0];
      }
    }

    for (i = 0; i < 6; i++) {
      for (i_0 = 0; i_0 < 6; i_0++) {
        h_alpha[i + 6 * i_0] = hd_posing[i] * d_b[i_0];
      }
    }

    for (i = 0; i < 6; i++) {
      for (i_0 = 0; i_0 < 6; i_0++) {
        Output->HAlpha[i_0 + 6 * i] = h_alpha_tweak[6 * i + i_0] + h_alpha[6 * i
          + i_0];
      }
    }

    /* 'updateBasicWalkingControl04:36' Discrete.TLastUpdate = t; */
    Discrete->TLastUpdate = t;
  } else if (ControlState_ControllerMode == 3.0) {
    /* 'updateBasicWalkingControl04:38' elseif (ControlState.ControllerMode==3) */
    /*  TRANSITION */
    /*  The transition control is a state-based control which is */
    /*  triggered when the robot has sufficient velocity. It is designed */
    /*  to take the robot toward the walking gait. */
    /* [s,ds,dsdq,theta,dtheta,delta_theta,sbar,y,dy,d,jacob_h,hd,jacob_jacobh0dq,swap] = ATRIAS3D_ZD_Output(t,q,dq,stance_leg,theta_limits_prev,h_alpha_prev,select_control); */
    /* 'updateBasicWalkingControl04:45' Output = AllOutputs(3); */
    *Output = AllOutputs[2];

    /* 'updateBasicWalkingControl04:46' [~,~,h0,~,~,~,~,~,theta] = ATRIAS3D_ZD_Output02(t, q, dq, ControlState, Output); */
    Walking01__ATRIAS3D_ZD_Output02(t, q, dq, ControlState_StanceLeg,
      AllOutputs[2].H0, AllOutputs[2].HAlpha, AllOutputs[2].ThetaLimits,
      AllOutputs[2].Theta.c0, AllOutputs[2].Theta.ct, AllOutputs[2].Theta.cq,
      AllOutputs[2].SaturateS, AllOutputs[2].UseCorrection, AllOutputs[2].
      SMaxCorrection, AllOutputs[2].HAlphaCorrection, &unusedU9, &unusedUa, h0,
      hd_posing, y_prev, jacob_h0, jacob_h, &s_unsaturated, &ThetaPlus);

    /* 'updateBasicWalkingControl04:46' ~ */
    /* 'updateBasicWalkingControl04:48' theta_max = max(Output.ThetaLimits(:,2), theta+ControlParams.Supervisory.MinDeltaThetaTransition*pi/180); */
    /* 'updateBasicWalkingControl04:49' Output.ThetaLimits = [theta theta_max]; */
    Output->ThetaLimits[0] = ThetaPlus;
    unusedU9 = ControlParams->Supervisory.MinDeltaThetaTransition *
      3.1415926535897931 / 180.0 + ThetaPlus;
    if ((AllOutputs[2].ThetaLimits[1] >= unusedU9) || rtIsNaN(unusedU9)) {
      Output->ThetaLimits[1] = AllOutputs[2].ThetaLimits[1];
    } else {
      Output->ThetaLimits[1] = unusedU9;
    }

    /* 'updateBasicWalkingControl04:51' s2 = 0:0.2:1; */
    /* 'updateBasicWalkingControl04:52' hd_injection = ControlParamsPrev.Output.HAlpha(:,end); */
    /* 'updateBasicWalkingControl04:53' hd_nom = AllOutputs(4).HAlpha(:,1); */
    /* 'updateBasicWalkingControl04:54' hd_nom(6) = Output.HAlpha(6,6); */
    /* 'updateBasicWalkingControl04:55' h_alpha = Output.HAlpha; */
    /* BGB 2014-06-06 */
    /* 'updateBasicWalkingControl04:58' h_update = diag([1 1 1 1 1 1])*(h0-h_alpha(:,1))*(1-s2); */
    /* h_update(3) = min(h_update(3), 0); */
    /* 'updateBasicWalkingControl04:60' h_alpha = h_alpha + h_update; */
    /*         %{ */
    /*         h_alpha(1:2,:) = h_alpha(1:2,:) + (h0(1:2)-h_alpha(1:2,1))*(1-s2); */
    /*         h_alpha(3:4,:) = h_alpha(3:4,:) + (h0(3:4)-h_alpha(3:4,1))*(1-s2); */
    /*         h_alpha(5:6,:) = hd_injection(5:6)*(1-s2) + hd_nom(5:6)*s2; */
    /*          */
    /*         h_alpha(5,:) = h_alpha(5,:) + (h0(5)-h_alpha(5,1))*(1-s2); */
    /*         %} */
    /* END BGB 2014-06-06 */
    /* 'updateBasicWalkingControl04:70' Output.HAlpha = h_alpha; */
    for (i = 0; i < 6; i++) {
      hd_posing[i] = h0[i] - AllOutputs[2].HAlpha[i];
    }

    for (i = 0; i < 6; i++) {
      hd_posing_0[i] = 0.0;
      for (i_0 = 0; i_0 < 6; i_0++) {
        hd_posing_0[i] += (real_T)a[6 * i_0 + i] * hd_posing[i_0];
      }
    }

    for (i = 0; i < 6; i++) {
      for (i_0 = 0; i_0 < 6; i_0++) {
        Output->HAlpha[i + 6 * i_0] = AllOutputs[2].HAlpha[6 * i_0 + i] +
          hd_posing_0[i] * b[i_0];
      }
    }

    /* 'updateBasicWalkingControl04:71' Discrete.TLastUpdate = t; */
    Discrete->TLastUpdate = t;
  } else {
    /* 'updateBasicWalkingControl04:73' else */
    /* if (ControlState.ControllerMode==4) % BASIC WALKING */
    /* 'updateBasicWalkingControl04:75' if (~ControlState.InDoubleSupport) */
    if (!(ControlState_InDoubleSupport != 0.0)) {
      /* 'updateBasicWalkingControl04:76' if (ControlState.StepCount < ControlParams.Supervisory.StartSecondGaitOnStep) */
      if (ControlState_StepCount <
          ControlParams->Supervisory.StartSecondGaitOnStep) {
        /* 'updateBasicWalkingControl04:77' Output = AllOutputs(4); */
        *Output = AllOutputs[3];

        /*  BASIC WALKING, SINGLE SUPPORT */
      } else {
        /* 'updateBasicWalkingControl04:78' else */
        /* 'updateBasicWalkingControl04:79' Output = AllOutputs(5); */
        *Output = AllOutputs[4];

        /*  BASIC WALKING, SINGLE SUPPORT */
      }

      /* 'updateBasicWalkingControl04:82' if (ControlState.StepCount == ControlParams.Supervisory.StartSecondGaitOnStep) */
      if (ControlState_StepCount ==
          ControlParams->Supervisory.StartSecondGaitOnStep) {
        /*  Let the feedforward torque ramp linearly from the torque */
        /*  along the previous output to that along the new output */
        /* 'updateBasicWalkingControl04:85' s2 = (0:0.2:1); */
        /* 'updateBasicWalkingControl04:86' Output.HAlphaStar = AllOutputs(4).HAlphaStar * diag(1-s2) + AllOutputs(5).HAlphaStar * diag(s2); */
        for (i = 0; i < 6; i++) {
          for (i_0 = 0; i_0 < 6; i_0++) {
            h_alpha_tweak[i + 6 * i_0] = 0.0;
            for (i_1 = 0; i_1 < 6; i_1++) {
              h_alpha_tweak[i + 6 * i_0] += AllOutputs[3].HAlphaStar[6 * i_1 + i]
                * b_b[6 * i_0 + i_1];
            }
          }
        }

        for (i = 0; i < 6; i++) {
          for (i_0 = 0; i_0 < 6; i_0++) {
            h_alpha[i + 6 * i_0] = 0.0;
            for (i_1 = 0; i_1 < 6; i_1++) {
              h_alpha[i + 6 * i_0] += AllOutputs[4].HAlphaStar[6 * i_1 + i] *
                c_b[6 * i_0 + i_1];
            }
          }
        }

        for (i = 0; i < 6; i++) {
          for (i_0 = 0; i_0 < 6; i_0++) {
            Output->HAlphaStar[i_0 + 6 * i] = h_alpha_tweak[6 * i + i_0] +
              h_alpha[6 * i + i_0];
          }
        }
      }

      /* 'updateBasicWalkingControl04:89' sprev = -1000; */
      /* 'updateBasicWalkingControl04:90' ControlParams.Output = Output; */
      /* 'updateBasicWalkingControl04:91' [s,ds,h0,y,dy,jacob_h0,jacob_h,s_unsaturated,ThetaPlus] = ATRIAS3D_ZD_Output03(t, q, dq, ControlState, ControlParams, sprev); */
      Walking0_ATRIAS3D_ZD_Output03_c(t, q, dq, ControlState_StanceLeg, Output,
        &unusedU9, &unusedUa, h0, hd_posing, y_prev, jacob_h0, jacob_h,
        &s_unsaturated, &ThetaPlus);

      /*  Redesign HAlpha */
      /* 'updateBasicWalkingControl04:94' h_alpha = Output.HAlpha; */
      for (i = 0; i < 36; i++) {
        h_alpha[i] = Output->HAlpha[i];
      }

      /* 'updateBasicWalkingControl04:95' h_alpha_tweak = applyGaitTweaks2(ControlState, ControlParams, 1); */
      Walking01_wi_applyGaitTweaks2_p(ControlState_ControllerMode,
        ControlParams->Supervisory.GaitTweaks, Output->H0, h_alpha_tweak);

      /* 'updateBasicWalkingControl04:97' if ~(ControlParams.Feedback.RIO) */
      if (!(ControlParams->Feedback.RIO != 0.0)) {
        /*  If RIO is 0, adapt h_alpha using standard procedure. */
        /* 'updateBasicWalkingControl04:100' if (ControlStatePrev.ControllerMode~=0) */
        if (ControlStatePrev_ControllerMode != 0.0) {
          /*  0=RESET     */
          /*  Event-based velocity control */
          /* 'updateBasicWalkingControl04:103' Discrete = updateVelocityControl(t, q, ControlState, ControlParams); */
          Walking01_updateVelocityControl(t, q, ControlState_StanceLeg,
            ControlParams->Supervisory.VelocityControlTorsoMax,
            ControlParams->Supervisory.VelocityControlTorsoMin,
            ControlParams->Supervisory.VelocityControlTorsoGain,
            ControlParams->Supervisory.VelocityControlTorsoV0,
            &ControlParams->Discrete, Discrete);

          /* 'updateBasicWalkingControl04:104' if (ControlState.StepCount >= ControlParams.Supervisory.TorsoBackOnStep) */
          if (ControlState_StepCount >=
              ControlParams->Supervisory.TorsoBackOnStep) {
            /* 'updateBasicWalkingControl04:105' h_alpha(1:2,:) = h_alpha(1:2,:) - ControlParams.Supervisory.TorsoBackAngle*pi/180; */
            unusedU9 = ControlParams->Supervisory.TorsoBackAngle *
              3.1415926535897931 / 180.0;
            for (i = 0; i < 6; i++) {
              h_alpha[6 * i] = Output->HAlpha[6 * i] - unusedU9;
              h_alpha[1 + 6 * i] = Output->HAlpha[6 * i + 1] - unusedU9;
            }

            /* 'updateBasicWalkingControl04:106' h_alpha(1:2,:) = h_alpha(1:2,:) + Discrete.VelocityControlTorsoDelta*pi/180; */
            unusedU9 = Discrete->VelocityControlTorsoDelta * 3.1415926535897931 /
              180.0;
            for (i = 0; i < 6; i++) {
              h_alpha[6 * i] += unusedU9;
              h_alpha[1 + 6 * i] += unusedU9;
            }
          } else {
            /* 'updateBasicWalkingControl04:107' else */
            /* 'updateBasicWalkingControl04:108' Discrete.VelocityControlTorsoDelta = 0; */
            Discrete->VelocityControlTorsoDelta = 0.0;
          }

          /*  Error zeroing */
          /* 'updateBasicWalkingControl04:112' if (ControlParams.Supervisory.RunMode >= 1) */
          if (ControlParams->Supervisory.RunMode >= 1.0) {
            /*  make s start at 0 */
            /* 'updateBasicWalkingControl04:114' Output.ThetaLimits(:,1) = ThetaPlus; */
            Output->ThetaLimits[0] = ThetaPlus;

            /* 'updateBasicWalkingControl04:115' Output.ThetaLimits(:,2) = max(Output.ThetaLimits(:,2), ThetaPlus + ControlParams.Supervisory.MinDeltaTheta); */
            unusedU9 = ThetaPlus + ControlParams->Supervisory.MinDeltaTheta;
            if (!((Output->ThetaLimits[1] >= unusedU9) || rtIsNaN(unusedU9))) {
              Output->ThetaLimits[1] = unusedU9;
            }

            /* 'updateBasicWalkingControl04:117' s2 = 0:0.2:1; */
            /* 'updateBasicWalkingControl04:118' M=5; */
            /* 'updateBasicWalkingControl04:119' HAlphaUpdate = (ControlParams.Supervisory.ErrorZeroFactor .* (h0 - h_alpha_tweak(:,1) - h_alpha(:,1)))*(1-s2); */
            for (i = 0; i < 6; i++) {
              hd_posing_0[i] = ((h0[i] - h_alpha_tweak[i]) - h_alpha[i]) *
                ControlParams->Supervisory.ErrorZeroFactor[i];
            }

            for (i = 0; i < 6; i++) {
              for (i_0 = 0; i_0 < 6; i_0++) {
                HAlphaUpdate[i + 6 * i_0] = hd_posing_0[i] * b[i_0];
              }
            }

            /*  Position only */
            /* 'updateBasicWalkingControl04:121' if 1 */
            /* 'updateBasicWalkingControl04:122' ControlParams.Output = Output; */
            /* 'updateBasicWalkingControl04:123' [~,ds] = ATRIAS3D_ZD_Output03(t, q, dq, ControlState, ControlParams, sprev); */
            Walking_ATRIAS3D_ZD_Output03_c0(t, q, dq, ControlState_StanceLeg,
              Output->ThetaLimits, Output->Theta.c0, Output->Theta.ct,
              Output->Theta.cq, Output->Theta.t0, Output->SaturateS,
              Output->SLimits, Output->EnforceIncreasingS, &unusedU9, &unusedUa);

            /* 'updateBasicWalkingControl04:123' ~ */
            /* HAlphaUpdate(:,2) = (h_alpha(:,1) + h_alpha_tweak(:,1) + HAlphaUpdate(:,1)) + ControlParams.Supervisory.ErrorVelZeroFactor .* (jacob_h0*dq)/(M*ds) - h_alpha_tweak(:,2) - h_alpha(:,2);  % Position and velocity */
            /* 'updateBasicWalkingControl04:125' HAlphaUpdate(:,2) = HAlphaUpdate(:,1) ... */
            /* 'updateBasicWalkingControl04:126'                                 + ControlParams.Supervisory.ErrorVelZeroFactor ... */
            /* 'updateBasicWalkingControl04:127'                                 .* ((jacob_h0*dq)/(M*ds) - ((h_alpha(:,2) + h_alpha_tweak(:,2)) - (h_alpha(:,1) + h_alpha_tweak(:,1)))); */
            unusedU9 = 5.0 * unusedUa;
            for (i = 0; i < 6; i++) {
              unusedUa = 0.0;
              for (i_0 = 0; i_0 < 13; i_0++) {
                unusedUa += jacob_h0[6 * i_0 + i] * dq[i_0];
              }

              hd_posing_0[i] = unusedUa / unusedU9 - ((h_alpha[6 + i] +
                h_alpha_tweak[6 + i]) - (h_alpha[i] + h_alpha_tweak[i]));
            }

            for (i = 0; i < 6; i++) {
              hd_posing[i] = ControlParams->Supervisory.ErrorVelZeroFactor[i] *
                hd_posing_0[i] + HAlphaUpdate[i];
            }

            for (i = 0; i < 6; i++) {
              HAlphaUpdate[6 + i] = hd_posing[i];
            }

            /*  Position and velocity */
            /* 'updateBasicWalkingControl04:129' h_alpha = h_alpha + HAlphaUpdate; */
            for (i = 0; i < 36; i++) {
              h_alpha[i] += HAlphaUpdate[i];
            }
          }
        }
      } else {
        /* 'updateBasicWalkingControl04:132' else */
        /*  Adaptive Bezier Parameters. */
        /*  h_alpha = bezierinterpolate(spPlusCurrent,bezierTable); */
        /* 'updateBasicWalkingControl04:135' h_alpha(1:4,:) = beziertableinterpolate2(s(1),ControlParams.Feedback.RIO); */
        Walking_beziertableinterpolate2(unusedU9, ControlParams->Feedback.RIO,
          tmp);
        for (i = 0; i < 6; i++) {
          h_alpha[6 * i] = tmp[i << 2];
          h_alpha[1 + 6 * i] = tmp[(i << 2) + 1];
          h_alpha[2 + 6 * i] = tmp[(i << 2) + 2];
          h_alpha[3 + 6 * i] = tmp[(i << 2) + 3];
        }
      }

      /* 'updateBasicWalkingControl04:139' Output.HAlpha = h_alpha; */
      for (i = 0; i < 36; i++) {
        Output->HAlpha[i] = h_alpha[i];
      }
    } else {
      /* 'updateBasicWalkingControl04:141' else */
      /* 'updateBasicWalkingControl04:142' Output = AllOutputs(5); */
      *Output = AllOutputs[4];

      /*  BASIC WALKING, DOUBLE SUPPORT */
      /*  Make desired angles continuous */
      /* 'updateBasicWalkingControl04:145' OutputPrev = ControlParamsPrev.Output; */
      /* 'updateBasicWalkingControl04:146' h_alpha = ControlParamsPrev.Output.HAlpha; */
      for (i = 0; i < 36; i++) {
        h_alpha[i] = ControlParamsPrev->Output.HAlpha[i];
      }

      /* 'updateBasicWalkingControl04:147' u_ff    = ControlParamsPrev.Feedback.u_ff; */
      /* 'updateBasicWalkingControl04:148' if (ControlStatePrev.ControllerMode==4) */
      if (ControlStatePrev_ControllerMode == 4.0) {
        /* h_alpha_tweak = applyGaitTweaks(0*h_alpha, ControlParamsPrev.Supervisory.GaitTweaks, 4); */
        /* 'updateBasicWalkingControl04:150' h_alpha_tweak = applyGaitTweaks2(ControlState, ControlParams, 1); */
        /* 'updateBasicWalkingControl04:151' [~, h_alpha] = computeLateralControl(q, dq, ControlState.StanceLeg, u_ff, h_alpha+h_alpha_tweak, ControlState, ControlParams); */
        for (i = 0; i < 6; i++) {
          hd_posing[i] = ControlParamsPrev->Feedback.u_ff[i];
        }

        Walking01_wi_applyGaitTweaks2_p(ControlState_ControllerMode,
          ControlParams->Supervisory.GaitTweaks, ControlParams->Output.H0,
          h_alpha_tweak);
        for (i = 0; i < 36; i++) {
          h_alpha[i] = ControlParamsPrev->Output.HAlpha[i] + h_alpha_tweak[i];
        }

        Walking01_computeLateralControl(q, ControlState_StanceLeg, h_alpha,
          ControlState_StepCount, ControlParams->Supervisory.TorsoBackOnStep,
          ControlParams->Feedback.kp_lat, ControlParams->Feedback.q3d_min_lat,
          ControlParams->Feedback.q3d_max_lat,
          ControlParams->Feedback.w_torso_lat,
          ControlParams->Feedback.LateralControlMode,
          ControlParams->Feedback.lat_bias, ControlParams->Feedback.lat_bias2);

        /* 'updateBasicWalkingControl04:151' ~ */
      }

      /* 'updateBasicWalkingControl04:153' OutputPrev.HAlpha = h_alpha; */
      /* 'updateBasicWalkingControl04:155' [~,~,h0_prev, y_prev] = ATRIAS3D_ZD_Output02(t, q, dq, ControlStatePrev, OutputPrev); */
      Walking0_ATRIAS3D_ZD_Output02_j(t, q, dq, ControlStatePrev_StanceLeg,
        ControlParamsPrev->Output.H0, h_alpha,
        ControlParamsPrev->Output.ThetaLimits,
        ControlParamsPrev->Output.Theta.c0, ControlParamsPrev->Output.Theta.ct,
        ControlParamsPrev->Output.Theta.cq, ControlParamsPrev->Output.SaturateS,
        ControlParamsPrev->Output.UseCorrection,
        ControlParamsPrev->Output.SMaxCorrection,
        ControlParamsPrev->Output.HAlphaCorrection, &unusedU9, &unusedUa,
        hd_posing, y_prev);

      /* 'updateBasicWalkingControl04:155' ~ */
      /* 'updateBasicWalkingControl04:156' hd_prev = h0_prev - y_prev; */
      /* 'updateBasicWalkingControl04:157' Output.HAlpha = hd_prev*[1 1 1 1 1 1]; */
      for (i = 0; i < 6; i++) {
        hd_posing_0[i] = hd_posing[i] - y_prev[i];
      }

      for (i = 0; i < 6; i++) {
        for (i_0 = 0; i_0 < 6; i_0++) {
          Output->HAlpha[i + 6 * i_0] = hd_posing_0[i];
        }
      }
    }
  }
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function updateControl(t)
 */
static void Walking01_withElm_updateControl(real_T t)
{
  OutputParamsBus b;
  DiscreteParamsBus c;

  /* MATLAB Function 'updateControl': '<S215>:112' */
  /* '<S215>:112:3' ControlState.StepCount = TransitionStepCount + WalkingStepCount; */
  Walking01_withElmos_B.ControlState.StepCount =
    Walking01_withElmos_DW.TransitionStepCount +
    Walking01_withElmos_DW.WalkingStepCount;

  /* '<S215>:112:4' [ControlParams.Output, ControlParams.Discrete] = updateBasicWalkingControl04(t, q, dq, ControlState, ControlParams, AllOutputs, ControlStatePrev, ControlParamsPrev); */
  Wal_updateBasicWalkingControl04(t, Walking01_withElmos_B.q,
    Walking01_withElmos_B.dq_clean,
    Walking01_withElmos_B.ControlState.ControllerMode,
    Walking01_withElmos_B.ControlState.StanceLeg,
    Walking01_withElmos_B.ControlState.InDoubleSupport,
    Walking01_withElmos_B.ControlState.StepCount,
    &Walking01_withElmos_B.ControlParams,
    Walking01_withElmos_B.VectorConcatenate,
    Walking01_withElmos_DW.ControlStatePrev.ControllerMode,
    Walking01_withElmos_DW.ControlStatePrev.StanceLeg,
    &Walking01_withElmos_DW.ControlParamsPrev, &b, &c);
  Walking01_withElmos_B.ControlParams.Output = b;
  Walking01_withElmos_B.ControlParams.Discrete = c;
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function A = serializeControlParamsBus(S)
 */
static void Walki_serializeControlParamsBus(const ControlParamsBus *S, real_T A
  [476])
{
  int32_T i;

  /* 'serializeControlParamsBus:3' if coder.target('MATLAB') */
  /* 'serializeControlParamsBus:5' else */
  /* 'serializeControlParamsBus:6' A = coder.nullcopy(zeros(476, 1)); */
  /* 'serializeControlParamsBus:8' A(1) = S.Supervisory.EnableSwapOnKAAccel; */
  A[0] = S->Supervisory.EnableSwapOnKAAccel;

  /* 'serializeControlParamsBus:9' A(2) = S.Supervisory.EnableSwapOnKASpring; */
  A[1] = S->Supervisory.EnableSwapOnKASpring;

  /* 'serializeControlParamsBus:10' A(3) = S.Supervisory.EnableBackwardSwap; */
  A[2] = S->Supervisory.EnableBackwardSwap;

  /* 'serializeControlParamsBus:11' A(4) = S.Supervisory.ImpactThresholdKAAccel; */
  A[3] = S->Supervisory.ImpactThresholdKAAccel;

  /* 'serializeControlParamsBus:12' A(5) = S.Supervisory.ImpactThresholdKASpringAbs; */
  A[4] = S->Supervisory.ImpactThresholdKASpringAbs;

  /* 'serializeControlParamsBus:13' A(6) = S.Supervisory.ImpactThresholdKASpringRel; */
  A[5] = S->Supervisory.ImpactThresholdKASpringRel;

  /* 'serializeControlParamsBus:14' A(7) = S.Supervisory.SwapThresholdS; */
  A[6] = S->Supervisory.SwapThresholdS;

  /* 'serializeControlParamsBus:15' A(8) = S.Supervisory.AllowDoubleSupport; */
  A[7] = S->Supervisory.AllowDoubleSupport;

  /* 'serializeControlParamsBus:16' A(9) = S.Supervisory.UseGaitTransition; */
  A[8] = S->Supervisory.UseGaitTransition;

  /* 'serializeControlParamsBus:17' A(10) = S.Supervisory.NumTransitionSteps; */
  A[9] = S->Supervisory.NumTransitionSteps;

  /* 'serializeControlParamsBus:18' A(11) = S.Supervisory.TransitionThresholdTorsoVel; */
  A[10] = S->Supervisory.TransitionThresholdTorsoVel;

  /* 'serializeControlParamsBus:19' A(12:13) = S.Supervisory.KAInjection; */
  A[11] = S->Supervisory.KAInjection[0];
  A[12] = S->Supervisory.KAInjection[1];

  /* 'serializeControlParamsBus:20' A(14) = S.Supervisory.MinDeltaThetaTransition; */
  A[13] = S->Supervisory.MinDeltaThetaTransition;

  /* 'serializeControlParamsBus:21' A(15) = S.Supervisory.StartSecondGaitOnStep; */
  A[14] = S->Supervisory.StartSecondGaitOnStep;

  /* 'serializeControlParamsBus:22' A(16:21) = S.Supervisory.VBLAParams; */
  for (i = 0; i < 6; i++) {
    A[i + 15] = S->Supervisory.VBLAParams[i];
  }

  /* 'serializeControlParamsBus:23' A(22:34) = S.Supervisory.BalanceParams; */
  for (i = 0; i < 13; i++) {
    A[i + 21] = S->Supervisory.BalanceParams[i];
  }

  /* 'serializeControlParamsBus:24' A(35:39) = S.Supervisory.GaitTweaks; */
  for (i = 0; i < 5; i++) {
    A[i + 34] = S->Supervisory.GaitTweaks[i];
  }

  /* 'serializeControlParamsBus:25' A(40) = S.Supervisory.TStepInitial; */
  A[39] = S->Supervisory.TStepInitial;

  /* 'serializeControlParamsBus:26' A(41) = S.Supervisory.TMaxUpdate; */
  A[40] = S->Supervisory.TMaxUpdate;

  /* 'serializeControlParamsBus:27' A(42) = S.Supervisory.RunMode; */
  A[41] = S->Supervisory.RunMode;

  /* 'serializeControlParamsBus:28' A(43) = S.Supervisory.UseAbsoluteSwingLA; */
  A[42] = S->Supervisory.UseAbsoluteSwingLA;

  /* 'serializeControlParamsBus:29' A(44:49) = S.Supervisory.ErrorZeroFactor; */
  for (i = 0; i < 6; i++) {
    A[i + 43] = S->Supervisory.ErrorZeroFactor[i];
  }

  /* 'serializeControlParamsBus:30' A(50:55) = S.Supervisory.ErrorVelZeroFactor; */
  for (i = 0; i < 6; i++) {
    A[i + 49] = S->Supervisory.ErrorVelZeroFactor[i];
  }

  /* 'serializeControlParamsBus:31' A(56) = S.Supervisory.StanceLegInit; */
  A[55] = S->Supervisory.StanceLegInit;

  /* 'serializeControlParamsBus:32' A(57) = S.Supervisory.ControllerModeInit; */
  A[56] = S->Supervisory.ControllerModeInit;

  /* 'serializeControlParamsBus:33' A(58) = S.Supervisory.UsePosingControl; */
  A[57] = S->Supervisory.UsePosingControl;

  /* 'serializeControlParamsBus:34' A(59) = S.Supervisory.TPosing; */
  A[58] = S->Supervisory.TPosing;

  /* 'serializeControlParamsBus:35' A(60) = S.Supervisory.TorsoBackAngle; */
  A[59] = S->Supervisory.TorsoBackAngle;

  /* 'serializeControlParamsBus:36' A(61) = S.Supervisory.TorsoBackOnStep; */
  A[60] = S->Supervisory.TorsoBackOnStep;

  /* 'serializeControlParamsBus:37' A(62) = S.Supervisory.EnergyControlGain; */
  A[61] = S->Supervisory.EnergyControlGain;

  /* 'serializeControlParamsBus:38' A(63) = S.Supervisory.EnergyControlPhi0; */
  A[62] = S->Supervisory.EnergyControlPhi0;

  /* 'serializeControlParamsBus:39' A(64) = S.Supervisory.VelocityControlTorsoMax; */
  A[63] = S->Supervisory.VelocityControlTorsoMax;

  /* 'serializeControlParamsBus:40' A(65) = S.Supervisory.VelocityControlTorsoMin; */
  A[64] = S->Supervisory.VelocityControlTorsoMin;

  /* 'serializeControlParamsBus:41' A(66) = S.Supervisory.VelocityControlTorsoGain; */
  A[65] = S->Supervisory.VelocityControlTorsoGain;

  /* 'serializeControlParamsBus:42' A(67) = S.Supervisory.VelocityControlTorsoV0; */
  A[66] = S->Supervisory.VelocityControlTorsoV0;

  /* 'serializeControlParamsBus:43' A(68) = S.Supervisory.MinDeltaTheta; */
  A[67] = S->Supervisory.MinDeltaTheta;

  /* 'serializeControlParamsBus:44' A(69) = S.Supervisory.Theta0; */
  A[68] = S->Supervisory.Theta0;

  /* 'serializeControlParamsBus:45' A(70) = S.Supervisory.KThetaPlus; */
  A[69] = S->Supervisory.KThetaPlus;

  /* 'serializeControlParamsBus:46' A(71) = S.Supervisory.KThetaMinus; */
  A[70] = S->Supervisory.KThetaMinus;

  /* 'serializeControlParamsBus:47' A(72) = S.Supervisory.RollPhaseVelocityThresh; */
  A[71] = S->Supervisory.RollPhaseVelocityThresh;

  /* 'serializeControlParamsBus:48' A(73) = S.Supervisory.RollPhaseSThresh; */
  A[72] = S->Supervisory.RollPhaseSThresh;

  /* 'serializeControlParamsBus:49' A(74) = S.Supervisory.MaxError; */
  A[73] = S->Supervisory.MaxError;

  /* 'serializeControlParamsBus:50' A(75) = S.Supervisory.MaxErrorVel; */
  A[74] = S->Supervisory.MaxErrorVel;

  /* 'serializeControlParamsBus:51' A(76) = S.Supervisory.MaxErrorCount; */
  A[75] = S->Supervisory.MaxErrorCount;

  /* 'serializeControlParamsBus:52' A(77:82) = S.Supervisory.K1MidStanceUpdate; */
  for (i = 0; i < 6; i++) {
    A[i + 76] = S->Supervisory.K1MidStanceUpdate[i];
  }

  /* 'serializeControlParamsBus:53' A(83:88) = S.Supervisory.K2MidStanceUpdate; */
  for (i = 0; i < 6; i++) {
    A[i + 82] = S->Supervisory.K2MidStanceUpdate[i];
  }

  /* 'serializeControlParamsBus:54' A(89) = S.Supervisory.EnableVelocityBasedUpdate; */
  A[88] = S->Supervisory.EnableVelocityBasedUpdate;

  /* 'serializeControlParamsBus:55' A(90:95) = S.Supervisory.VelocityBasedUpdateK1; */
  for (i = 0; i < 6; i++) {
    A[i + 89] = S->Supervisory.VelocityBasedUpdateK1[i];
  }

  /* 'serializeControlParamsBus:56' A(96:101) = S.Supervisory.VelocityBasedUpdateK2; */
  for (i = 0; i < 6; i++) {
    A[i + 95] = S->Supervisory.VelocityBasedUpdateK2[i];
  }

  /* 'serializeControlParamsBus:57' A(102) = S.Supervisory.VelocityBasedUpdateDTheta0; */
  A[101] = S->Supervisory.VelocityBasedUpdateDTheta0;

  /* 'serializeControlParamsBus:58' A(103:114) = S.Supervisory.VelocityBasedUpdateLimits(:); */
  for (i = 0; i < 12; i++) {
    A[102 + i] = S->Supervisory.VelocityBasedUpdateLimits[i];
  }

  /* 'serializeControlParamsBus:59' A(115) = S.Supervisory.DesiredYawOffset; */
  A[114] = S->Supervisory.DesiredYawOffset;

  /* 'serializeControlParamsBus:60' A(116) = S.Discrete.TLastUpdate; */
  A[115] = S->Discrete.TLastUpdate;

  /* 'serializeControlParamsBus:61' A(117) = S.Discrete.VelocityControlLADelta; */
  A[116] = S->Discrete.VelocityControlLADelta;

  /* 'serializeControlParamsBus:62' A(118) = S.Discrete.VelocityControlTorsoDelta; */
  A[117] = S->Discrete.VelocityControlTorsoDelta;

  /* 'serializeControlParamsBus:63' A(119) = S.Discrete.VelocityControlHipDistCur; */
  A[118] = S->Discrete.VelocityControlHipDistCur;

  /* 'serializeControlParamsBus:64' A(120) = S.Discrete.VelocityControlHipDistPrev; */
  A[119] = S->Discrete.VelocityControlHipDistPrev;

  /* 'serializeControlParamsBus:65' A(121) = S.Discrete.VirtualSpringMode; */
  A[120] = S->Discrete.VirtualSpringMode;

  /* 'serializeControlParamsBus:66' A(122) = S.Discrete.VirtualSpringStiffness; */
  A[121] = S->Discrete.VirtualSpringStiffness;

  /* 'serializeControlParamsBus:67' A(123) = S.Discrete.VirtualSpringDamping; */
  A[122] = S->Discrete.VirtualSpringDamping;

  /* 'serializeControlParamsBus:68' A(124) = S.Discrete.VirtualSpringModAmplitude; */
  A[123] = S->Discrete.VirtualSpringModAmplitude;

  /* 'serializeControlParamsBus:69' A(125) = S.Discrete.VirtualSpringModRate; */
  A[124] = S->Discrete.VirtualSpringModRate;

  /* 'serializeControlParamsBus:70' A(126) = S.Discrete.VirtualSpringRestPos; */
  A[125] = S->Discrete.VirtualSpringRestPos;

  /* 'serializeControlParamsBus:71' A(127:204) = S.Output.H0(:); */
  for (i = 0; i < 78; i++) {
    A[126 + i] = S->Output.H0[i];
  }

  /* 'serializeControlParamsBus:72' A(205:240) = S.Output.HAlpha(:); */
  for (i = 0; i < 36; i++) {
    A[204 + i] = S->Output.HAlpha[i];
  }

  /* 'serializeControlParamsBus:73' A(241:242) = S.Output.ThetaLimits; */
  A[240] = S->Output.ThetaLimits[0];
  A[241] = S->Output.ThetaLimits[1];

  /* 'serializeControlParamsBus:74' A(243) = S.Output.Theta.c0; */
  A[242] = S->Output.Theta.c0;

  /* 'serializeControlParamsBus:75' A(244) = S.Output.Theta.ct; */
  A[243] = S->Output.Theta.ct;

  /* 'serializeControlParamsBus:76' A(245:257) = S.Output.Theta.cq; */
  for (i = 0; i < 13; i++) {
    A[244 + i] = S->Output.Theta.cq[i];
  }

  /* 'serializeControlParamsBus:77' A(258) = S.Output.Theta.t0; */
  A[257] = S->Output.Theta.t0;

  /* 'serializeControlParamsBus:78' A(259:265) = S.Output.Theta.cz; */
  for (i = 0; i < 7; i++) {
    A[258 + i] = S->Output.Theta.cz[i];
  }

  /* 'serializeControlParamsBus:79' A(266) = S.Output.SaturateS; */
  A[265] = S->Output.SaturateS;

  /* 'serializeControlParamsBus:80' A(267:268) = S.Output.SLimits; */
  A[266] = S->Output.SLimits[0];
  A[267] = S->Output.SLimits[1];

  /* 'serializeControlParamsBus:81' A(269) = S.Output.EnforceIncreasingS; */
  A[268] = S->Output.EnforceIncreasingS;

  /* 'serializeControlParamsBus:82' A(270) = S.Output.UseCorrection; */
  A[269] = S->Output.UseCorrection;

  /* 'serializeControlParamsBus:83' A(271) = S.Output.SMaxCorrection; */
  A[270] = S->Output.SMaxCorrection;

  /* 'serializeControlParamsBus:84' A(272:301) = S.Output.HAlphaCorrection(:); */
  for (i = 0; i < 30; i++) {
    A[271 + i] = S->Output.HAlphaCorrection[i];
  }

  /* 'serializeControlParamsBus:85' A(302) = S.Output.Phi.c0; */
  A[301] = S->Output.Phi.c0;

  /* 'serializeControlParamsBus:86' A(303:315) = S.Output.Phi.cq; */
  for (i = 0; i < 13; i++) {
    A[302 + i] = S->Output.Phi.cq[i];
  }

  /* 'serializeControlParamsBus:87' A(316:335) = S.Output.PhiAlpha; */
  for (i = 0; i < 20; i++) {
    A[315 + i] = S->Output.PhiAlpha[i];
  }

  /* 'serializeControlParamsBus:88' A(336) = S.Output.SaturateR; */
  A[335] = S->Output.SaturateR;

  /* 'serializeControlParamsBus:89' A(337:338) = S.Output.RLimits; */
  A[336] = S->Output.RLimits[0];
  A[337] = S->Output.RLimits[1];

  /* 'serializeControlParamsBus:90' A(339:368) = S.Output.HBarAlpha(:); */
  for (i = 0; i < 30; i++) {
    A[338 + i] = S->Output.HBarAlpha[i];
  }

  /* 'serializeControlParamsBus:91' A(369:380) = S.Output.HBarLimits(:); */
  for (i = 0; i < 12; i++) {
    A[368 + i] = S->Output.HBarLimits[i];
  }

  /* 'serializeControlParamsBus:92' A(381:416) = S.Output.HAlphaStar(:); */
  for (i = 0; i < 36; i++) {
    A[380 + i] = S->Output.HAlphaStar[i];
  }

  /* 'serializeControlParamsBus:93' A(417) = S.Output.YawLimit; */
  A[416] = S->Output.YawLimit;

  /* 'serializeControlParamsBus:94' A(418:423) = S.Feedback.kp; */
  for (i = 0; i < 6; i++) {
    A[i + 417] = S->Feedback.kp[i];
  }

  /* 'serializeControlParamsBus:95' A(424:429) = S.Feedback.kd; */
  for (i = 0; i < 6; i++) {
    A[i + 423] = S->Feedback.kd[i];
  }

  /* 'serializeControlParamsBus:96' A(430:431) = S.Feedback.epsilon; */
  A[429] = S->Feedback.epsilon[0];
  A[430] = S->Feedback.epsilon[1];

  /* 'serializeControlParamsBus:97' A(432:433) = S.Feedback.kff_grav; */
  A[431] = S->Feedback.kff_grav[0];
  A[432] = S->Feedback.kff_grav[1];

  /* 'serializeControlParamsBus:98' A(434) = S.Feedback.delta_grav; */
  A[433] = S->Feedback.delta_grav;

  /* 'serializeControlParamsBus:99' A(435:436) = S.Feedback.kff_decoup; */
  A[434] = S->Feedback.kff_decoup[0];
  A[435] = S->Feedback.kff_decoup[1];

  /* 'serializeControlParamsBus:100' A(437:438) = S.Feedback.kd_torso; */
  A[436] = S->Feedback.kd_torso[0];
  A[437] = S->Feedback.kd_torso[1];

  /* 'serializeControlParamsBus:101' A(439) = S.Feedback.kp_2dof; */
  A[438] = S->Feedback.kp_2dof;

  /* 'serializeControlParamsBus:102' A(440) = S.Feedback.kd_2dof; */
  A[439] = S->Feedback.kd_2dof;

  /* 'serializeControlParamsBus:103' A(441) = S.Feedback.kpre_2dof; */
  A[440] = S->Feedback.kpre_2dof;

  /* 'serializeControlParamsBus:104' A(442) = S.Feedback.kp_lat; */
  A[441] = S->Feedback.kp_lat;

  /* 'serializeControlParamsBus:105' A(443) = S.Feedback.kd_lat; */
  A[442] = S->Feedback.kd_lat;

  /* 'serializeControlParamsBus:106' A(444) = S.Feedback.q3d_min_lat; */
  A[443] = S->Feedback.q3d_min_lat;

  /* 'serializeControlParamsBus:107' A(445) = S.Feedback.q3d_max_lat; */
  A[444] = S->Feedback.q3d_max_lat;

  /* 'serializeControlParamsBus:108' A(446) = S.Feedback.w_torso_lat; */
  A[445] = S->Feedback.w_torso_lat;

  /* 'serializeControlParamsBus:109' A(447:452) = S.Feedback.u_ff; */
  for (i = 0; i < 6; i++) {
    A[i + 446] = S->Feedback.u_ff[i];
  }

  /* 'serializeControlParamsBus:110' A(453) = S.Feedback.LateralControlMode; */
  A[452] = S->Feedback.LateralControlMode;

  /* 'serializeControlParamsBus:111' A(454) = S.Feedback.DecouplingMode; */
  A[453] = S->Feedback.DecouplingMode;

  /* 'serializeControlParamsBus:112' A(455) = S.Feedback.Use2DOF; */
  A[454] = S->Feedback.Use2DOF;

  /* 'serializeControlParamsBus:113' A(456) = S.Feedback.UseDSGravComp; */
  A[455] = S->Feedback.UseDSGravComp;

  /* 'serializeControlParamsBus:114' A(457) = S.Feedback.lat_bias; */
  A[456] = S->Feedback.lat_bias;

  /* 'serializeControlParamsBus:115' A(458) = S.Feedback.lat_bias2; */
  A[457] = S->Feedback.lat_bias2;

  /* 'serializeControlParamsBus:116' A(459) = S.Feedback.linkFeedback; */
  A[458] = S->Feedback.linkFeedback;

  /* 'serializeControlParamsBus:117' A(460) = S.Feedback.RIO; */
  A[459] = S->Feedback.RIO;

  /* 'serializeControlParamsBus:118' A(461) = S.Feedback.SelectFeedforward; */
  A[460] = S->Feedback.SelectFeedforward;

  /* 'serializeControlParamsBus:119' A(462:467) = S.Feedback.FeedforwardGain; */
  for (i = 0; i < 6; i++) {
    A[i + 461] = S->Feedback.FeedforwardGain[i];
  }

  /* 'serializeControlParamsBus:120' A(468) = S.Feedback.EnableFeedforwardOnStep; */
  A[467] = S->Feedback.EnableFeedforwardOnStep;

  /* 'serializeControlParamsBus:121' A(469) = S.Saturation.UseQPSaturation; */
  A[468] = S->Saturation.UseQPSaturation;

  /* 'serializeControlParamsBus:122' A(470:471) = S.Saturation.QPWeight; */
  A[469] = S->Saturation.QPWeight[0];
  A[470] = S->Saturation.QPWeight[1];

  /* 'serializeControlParamsBus:123' A(472) = S.Saturation.UseKASaturation; */
  A[471] = S->Saturation.UseKASaturation;

  /* 'serializeControlParamsBus:124' A(473) = S.Saturation.KASaturationS1; */
  A[472] = S->Saturation.KASaturationS1;

  /* 'serializeControlParamsBus:125' A(474) = S.Saturation.KASaturationS2; */
  A[473] = S->Saturation.KASaturationS2;

  /* 'serializeControlParamsBus:126' A(475) = S.Saturation.KASaturationEarly; */
  A[474] = S->Saturation.KASaturationEarly;

  /* 'serializeControlParamsBus:127' A(476) = S.Saturation.KASaturationMax; */
  A[475] = S->Saturation.KASaturationMax;
}

real_T rt_roundd_snf(real_T u)
{
  real_T y;
  if (fabs(u) < 4.503599627370496E+15) {
    if (u >= 0.5) {
      y = floor(u + 0.5);
    } else if (u > -0.5) {
      y = u * 0.0;
    } else {
      y = ceil(u - 0.5);
    }
  } else {
    y = u;
  }

  return y;
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function initSerial(t)
 */
static void Walking01_withElmos_initSerial(real_T t)
{
  int32_T tmp;
  int32_T i;

  /* MATLAB Function 'initSerial': '<S215>:258' */
  /* '<S215>:258:2' if (SerialBufferEnd~=SerialBufferBegin || SerialIdx==0) */
  if ((Walking01_withElmos_DW.SerialBufferEnd !=
       Walking01_withElmos_DW.SerialBufferBegin) ||
      (Walking01_withElmos_DW.SerialIdx == 0.0)) {
    /* temp = serializeControlParamsBus(ControlParams); */
    /* SerialBuffer(:,SerialBufferEnd) = [(15:-1:0)'; length(temp); t; temp]; */
    /* '<S215>:258:5' SerialBuffer(1:16,SerialBufferEnd)  = (15:-1:0)'; */
    tmp = (int32_T)Walking01_withElmos_DW.SerialBufferEnd;
    for (i = 0; i < 16; i++) {
      Walking01_withElmos_DW.SerialBuffer[i + 494 * (tmp - 1)] = 15.0 - (real_T)
        i;
    }

    /* '<S215>:258:6' SerialBuffer(17, SerialBufferEnd)   = SERIAL_BUFFER_LENGTH - 18; */
    Walking01_withElmos_DW.SerialBuffer[16 + 494 * ((int32_T)
      Walking01_withElmos_DW.SerialBufferEnd - 1)] = 494.0 - 18.0;

    /*  18 = SYNC_LENGTH + 2 */
    /* '<S215>:258:7' SerialBuffer(18, SerialBufferEnd)   = t; */
    Walking01_withElmos_DW.SerialBuffer[17 + 494 * ((int32_T)
      Walking01_withElmos_DW.SerialBufferEnd - 1)] = t;

    /* '<S215>:258:8' SerialBuffer(19:end, SerialBufferEnd) = serializeControlParamsBus(ControlParams); */
    Walki_serializeControlParamsBus(&Walking01_withElmos_B.ControlParams,
      *(real_T (*)[476])&Walking01_withElmos_DW.SerialBuffer[18 + 494 *
      ((int32_T)Walking01_withElmos_DW.SerialBufferEnd - 1)]);

    /* '<S215>:258:10' SerialBufferEnd = mod(SerialBufferEnd,SERIAL_BUFFER_WIDTH)+1; */
    if (!(4.0 == 0.0)) {
      if (4.0 == floor(4.0)) {
        Walking01_withElmos_DW.SerialBufferEnd -= floor
          (Walking01_withElmos_DW.SerialBufferEnd / 4.0) * 4.0;
      } else {
        Walking01_withElmos_DW.SerialBufferEnd /= 4.0;
        if (fabs(Walking01_withElmos_DW.SerialBufferEnd - rt_roundd_snf
                 (Walking01_withElmos_DW.SerialBufferEnd)) <=
            2.2204460492503131E-16 * fabs(Walking01_withElmos_DW.SerialBufferEnd))
        {
          Walking01_withElmos_DW.SerialBufferEnd = 0.0;
        } else {
          Walking01_withElmos_DW.SerialBufferEnd =
            (Walking01_withElmos_DW.SerialBufferEnd - floor
             (Walking01_withElmos_DW.SerialBufferEnd)) * 4.0;
        }
      }
    }

    Walking01_withElmos_DW.SerialBufferEnd++;

    /* '<S215>:258:11' if (SerialIdx==0) */
    if (Walking01_withElmos_DW.SerialIdx == 0.0) {
      /* '<S215>:258:12' SerialIdx = SERIAL_BUFFER_LENGTH; */
      Walking01_withElmos_DW.SerialIdx = 494.0;
    }
  }
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function sendSerial(t)
 */
static void Walking01_withElmos_sendSerial(real_T t)
{
  boolean_T InitiallyActive;
  int32_T k;

  /* MATLAB Function 'sendSerial': '<S215>:256' */
  /* '<S215>:256:2' if (t > tLastSend) */
  if (t > Walking01_withElmos_DW.tLastSend) {
    /* '<S215>:256:3' InitiallyActive = (SerialIdx>0); */
    InitiallyActive = (Walking01_withElmos_DW.SerialIdx > 0.0);

    /* '<S215>:256:4' for k=1:SERIAL_WIDTH */
    for (k = 0; k < (int32_T)5.0; k++) {
      /* '<S215>:256:5' if (SerialIdx>0) */
      if (Walking01_withElmos_DW.SerialIdx > 0.0) {
        /* '<S215>:256:6' SerialOut(k) = SerialBuffer(SERIAL_BUFFER_LENGTH-SerialIdx+1, SerialBufferBegin); */
        Walking01_withElmos_B.SerialOut[k] =
          Walking01_withElmos_DW.SerialBuffer[((int32_T)((494.0 -
          Walking01_withElmos_DW.SerialIdx) + 1.0) + ((int32_T)
          Walking01_withElmos_DW.SerialBufferBegin - 1) * 494) - 1];

        /* '<S215>:256:7' SerialIdx = SerialIdx-1; */
        Walking01_withElmos_DW.SerialIdx--;
      } else {
        /* '<S215>:256:8' else */
        /* '<S215>:256:9' SerialOut(k) = 0; */
        Walking01_withElmos_B.SerialOut[k] = 0.0;
      }
    }

    /* '<S215>:256:12' if (InitiallyActive && SerialIdx==0) */
    if (InitiallyActive && (Walking01_withElmos_DW.SerialIdx == 0.0)) {
      /* '<S215>:256:13' SerialBufferBegin = mod(SerialBufferBegin,SERIAL_BUFFER_WIDTH)+1; */
      if (!(4.0 == 0.0)) {
        if (4.0 == floor(4.0)) {
          Walking01_withElmos_DW.SerialBufferBegin -= floor
            (Walking01_withElmos_DW.SerialBufferBegin / 4.0) * 4.0;
        } else {
          Walking01_withElmos_DW.SerialBufferBegin /= 4.0;
          if (fabs(Walking01_withElmos_DW.SerialBufferBegin - rt_roundd_snf
                   (Walking01_withElmos_DW.SerialBufferBegin)) <=
              2.2204460492503131E-16 * fabs
              (Walking01_withElmos_DW.SerialBufferBegin)) {
            Walking01_withElmos_DW.SerialBufferBegin = 0.0;
          } else {
            Walking01_withElmos_DW.SerialBufferBegin =
              (Walking01_withElmos_DW.SerialBufferBegin - floor
               (Walking01_withElmos_DW.SerialBufferBegin)) * 4.0;
          }
        }
      }

      Walking01_withElmos_DW.SerialBufferBegin++;

      /* '<S215>:256:14' if (SerialBufferEnd~=SerialBufferBegin) */
      if (Walking01_withElmos_DW.SerialBufferEnd !=
          Walking01_withElmos_DW.SerialBufferBegin) {
        /* '<S215>:256:15' SerialIdx = SERIAL_BUFFER_LENGTH; */
        Walking01_withElmos_DW.SerialIdx = 494.0;
      }
    }

    /* '<S215>:256:18' tLastSend = t; */
    Walking01_withElmos_DW.tLastSend = t;
  }
}

/* Function for Chart: '<S202>/StateLogic' */
static void Walking01_withElmos_Serialize(void)
{
  /* During 'Serialize': '<S215>:235' */
  if (Walking01_withElmos_DW.is_active_ControlStatus != 0U) {
    /* During 'ControlStatus': '<S215>:236' */
    switch (Walking01_withElmos_DW.is_ControlStatus) {
     case Walking01_withElmos_IN_Changed:
      /* During 'Changed': '<S215>:241' */
      /* Transition: '<S215>:240' */
      Walking01_withElmos_DW.is_ControlStatus = Walking01_withElmo_IN_Unchanged;
      break;

     case Walking01_withElmo_IN_Unchanged:
      /* During 'Unchanged': '<S215>:242' */
      if (Walking01_withElmos_DW.sfEvent == Walking01_w_event_ControlUpdate) {
        /* Transition: '<S215>:238' */
        Walking01_withElmos_DW.is_ControlStatus = Walking01_withElmos_IN_Changed;
      } else {
        if (Walking01_withElmos_B.FixPtRelationalOperator) {
          /* Transition: '<S215>:239' */
          Walking01_withElmos_DW.is_ControlStatus =
            Walking01_withElmos_IN_Changed;
        }
      }
      break;

     default:
      Walking01_withElmos_DW.is_ControlStatus = Walking01__IN_NO_ACTIVE_CHILD_j;
      break;
    }
  }

  if (Walking01_withElmos_DW.is_active_SerialState != 0U) {
    /* During 'SerialState': '<S215>:243' */
    switch (Walking01_withElmos_DW.is_SerialState) {
     case Walking01_withElmos_IN_Idle:
      /* During 'Idle': '<S215>:253' */
      /* Transition: '<S215>:249' */
      if (Walking01_withElmos_DW.is_ControlStatus ==
          Walking01_withElmos_IN_Changed) {
        /* Transition: '<S215>:250' */
        /* Transition: '<S215>:251' */
        Walking01_withElmos_DW.is_SerialState = Walking01_withElmo_IN_Running_e;

        /* Entry 'Running': '<S215>:252' */
        Walking01_withElmos_initSerial(Walking01_withElmos_M->Timing.t[0]);
        Walking01_withElmos_sendSerial(Walking01_withElmos_M->Timing.t[0]);
      }
      break;

     case Walking01_withElmo_IN_Running_e:
      /* During 'Running': '<S215>:252' */
      /* Transition: '<S215>:248' */
      if (Walking01_withElmos_DW.is_ControlStatus ==
          Walking01_withElmos_IN_Changed) {
        /* Transition: '<S215>:250' */
        /* Transition: '<S215>:251' */
        Walking01_withElmos_DW.is_SerialState = Walking01_withElmo_IN_Running_e;

        /* Entry 'Running': '<S215>:252' */
        Walking01_withElmos_initSerial(Walking01_withElmos_M->Timing.t[0]);
        Walking01_withElmos_sendSerial(Walking01_withElmos_M->Timing.t[0]);
      } else if (Walking01_withElmos_DW.SerialIdx == 0.0) {
        /* Transition: '<S215>:247' */
        Walking01_withElmos_DW.is_SerialState = Walking01_withElmos_IN_Idle;

        /* Entry 'Idle': '<S215>:253' */
        Walking01_withElmos_sendSerial(Walking01_withElmos_M->Timing.t[0]);
      } else {
        Walking01_withElmos_sendSerial(Walking01_withElmos_M->Timing.t[0]);
      }
      break;

     default:
      Walking01_withElmos_DW.is_SerialState = Walking01__IN_NO_ACTIVE_CHILD_j;
      break;
    }
  }
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function [s,ds,h0,y,dy,jacob_h0,jacob_h,s_unsaturated,theta,dtheta,delta_theta,dsdq,jacob_jacobhdqdq,phi,r,dr,hdbar] = ATRIAS3D_ZD_Output03(t, q, dq, ControlState, ControlParams, sprev)
 */
static real_T Walkin_ATRIAS3D_ZD_Output03_c0j(real_T t, const real_T q[13],
  const real_T dq[13], real_T ControlState_StanceLeg, const ControlParamsBus
  *ControlParams)
{
  real_T s;
  real_T c[15];
  real_T ds;
  real_T dsdq[13];
  real_T theta;
  real_T dtheta;
  real_T delta_theta;
  real_T b;
  real_T e;
  static const int8_T g[13] = { 0, 1, 2, 5, 6, 3, 4, 10, 11, 12, 7, 8, 9 };

  int32_T i;
  int32_T loop_ub;
  int32_T d_data;
  int32_T d_sizes[2];

  /* 'ATRIAS3D_ZD_Output03:4' Output = ControlParams.Output; */
  /*  Define matrix to convert between motor and standard actuated coordinates */
  /*  [uLAst; uLAsw; uKAst; uKAsw; u3st; u3sw] = T0*[u1R; u2R; u3R; u1L; u2L; u3L] */
  /* 'ATRIAS3D_ZD_Output03:8' T0 = [0.5 0.5 0 0 0 0; 0 0 0 0.5 0.5 0; -1 1 0 0 0 0; 0 0 0 -1 1 0; 0 0 1 0 0 0; 0 0 0 0 0 1]; */
  /* 'ATRIAS3D_ZD_Output03:9' if (ControlState.StanceLeg==1) */
  /* 'ATRIAS3D_ZD_Output03:12' T1 = [zeros(6,7) T0]; */
  /*     %% Compute s and modify Bezier parameters to extend outside 0 <= s <= 1 */
  /* [Sy,Sq] = SymmetryMatrices(); */
  /* 'ATRIAS3D_ZD_Output03:16' if (ControlState.StanceLeg==0) */
  if (ControlState_StanceLeg == 0.0) {
    /* 'ATRIAS3D_ZD_Output03:17' c = [Output.Theta.c0 Output.Theta.ct Output.Theta.cq]; */
    c[0] = ControlParams->Output.Theta.c0;
    c[1] = ControlParams->Output.Theta.ct;
    for (i = 0; i < 13; i++) {
      c[i + 2] = ControlParams->Output.Theta.cq[i];
    }

    /* 'ATRIAS3D_ZD_Output03:18' jacob_h0 = Output.H0; */
  } else {
    /* 'ATRIAS3D_ZD_Output03:19' else */
    /* 'ATRIAS3D_ZD_Output03:20' c = [Output.Theta.c0 Output.Theta.ct Output.Theta.cq(:,[1 2 3 6 7 4 5 11 12 13 8 9 10])]; */
    c[0] = ControlParams->Output.Theta.c0;
    c[1] = ControlParams->Output.Theta.ct;
    for (i = 0; i < 13; i++) {
      c[i + 2] = ControlParams->Output.Theta.cq[g[i]];
    }

    /* 'ATRIAS3D_ZD_Output03:21' c(:,3:4) = -c(:,3:4); */
    c[2] = -c[2];
    c[3] = -c[3];

    /* 'ATRIAS3D_ZD_Output03:22' jacob_h0 = Output.H0(:,[1 2 3 6 7 4 5 11 12 13 8 9 10]); */
    /* 'ATRIAS3D_ZD_Output03:23' jacob_h0(:,1:2) = -jacob_h0(:,1:2); */
  }

  /* 'ATRIAS3D_ZD_Output03:27' [s,ds,dsdq,theta,dtheta,delta_theta] = ATRIAS3D_ZD_s6(t-Output.Theta.t0, q, dq, Output.ThetaLimits, c); */
  Walking01_with_ATRIAS3D_ZD_s6_b(t - ControlParams->Output.Theta.t0, q, dq,
    ControlParams->Output.ThetaLimits, c, &s, &ds, dsdq, &theta, &dtheta,
    &delta_theta);

  /* 'ATRIAS3D_ZD_Output03:28' s_unsaturated = s; */
  /* 'ATRIAS3D_ZD_Output03:30' if (Output.EnforceIncreasingS) */
  if ((ControlParams->Output.EnforceIncreasingS != 0.0) && (!(s >= (rtMinusInf))))
  {
    /* 'ATRIAS3D_ZD_Output03:31' s = max(s, sprev); */
    s = (rtMinusInf);
  }

  /* 'ATRIAS3D_ZD_Output03:34' h_alpha = Output.HAlpha; */
  /* 'ATRIAS3D_ZD_Output03:35' if (ControlState.StanceLeg==1) */
  /* 'ATRIAS3D_ZD_Output03:39' if Output.SaturateS==1 */
  if (ControlParams->Output.SaturateS == 1.0) {
    /* delta = 0.2; */
    /* p = [0.2  -0.4  0.2  0]; % coefficients of transition poly */
    /* [s, ds] = softsaturate(s, ds, delta, p); */
    /*  Modified Feb. 4th, 2014 for interpolative bezier table bounds. */
    /* 'ATRIAS3D_ZD_Output03:44' delta = 0.1; */
    /* 'ATRIAS3D_ZD_Output03:45' ds(s>1+delta) = 0; */
    /* 'ATRIAS3D_ZD_Output03:46' s(s>1+delta) = 1+delta; */
    b = s;
    Walking01_withEl_eml_li_find_en(s > 1.1, &d_data, d_sizes);
    loop_ub = d_sizes[0] * d_sizes[1];
    for (i = 0; i < loop_ub; i++) {
      b = 1.1;
    }

    /* 'ATRIAS3D_ZD_Output03:47' ds(s<-delta) = 0; */
    /* 'ATRIAS3D_ZD_Output03:48' s(s<-delta) = -delta; */
    e = b;
    Walking01_withEl_eml_li_find_en(b < -0.1, &d_data, d_sizes);
    loop_ub = d_sizes[0] * d_sizes[1];
    for (i = 0; i < loop_ub; i++) {
      e = -0.1;
    }

    s = e;
  } else if ((!(ControlParams->Output.SaturateS == 2.0)) &&
             (ControlParams->Output.SaturateS == 3.0)) {
    /* 'ATRIAS3D_ZD_Output03:70' elseif Output.SaturateS==3 */
    /* 'ATRIAS3D_ZD_Output03:71' smin = Output.SLimits(1); */
    /* 'ATRIAS3D_ZD_Output03:72' smax = Output.SLimits(2); */
    /* 'ATRIAS3D_ZD_Output03:73' ds(s>smax) = 0; */
    /* 'ATRIAS3D_ZD_Output03:74' s(s>smax)  = smax; */
    b = s;
    Walking01_withEl_eml_li_find_en(s > ControlParams->Output.SLimits[1],
      &d_data, d_sizes);
    loop_ub = d_sizes[0] * d_sizes[1];
    for (i = 0; i < loop_ub; i++) {
      b = ControlParams->Output.SLimits[1];
    }

    /* 'ATRIAS3D_ZD_Output03:75' ds(s<smin) = 0; */
    /* 'ATRIAS3D_ZD_Output03:76' s(s<smin)  = smin; */
    e = b;
    Walking01_withEl_eml_li_find_en(b < ControlParams->Output.SLimits[0],
      &d_data, d_sizes);
    loop_ub = d_sizes[0] * d_sizes[1];
    for (i = 0; i < loop_ub; i++) {
      e = ControlParams->Output.SLimits[0];
    }

    s = e;
  } else {
    /* 'ATRIAS3D_ZD_Output03:64' h_alpha(s6>1,:) = h_alpha_high(s6>1,:); */
    /*  If (s<0), hold all desired angles constant */
    /* 'ATRIAS3D_ZD_Output03:67' h_alpha_low = h_alpha(:,1)*[1 1 1 1 1 1]; */
    /* 'ATRIAS3D_ZD_Output03:68' h_alpha(s6<0,:) = h_alpha_low(s6<0,:); */
    /* 'ATRIAS3D_ZD_Output03:50' elseif Output.SaturateS==2 */
    /* 'ATRIAS3D_ZD_Output03:51' if (length(s)>1) */
    /* 'ATRIAS3D_ZD_Output03:54' else */
    /* 'ATRIAS3D_ZD_Output03:55' dqyTds = repmat((c(1,5)*delta_theta), 2, 1); */
    /* 'ATRIAS3D_ZD_Output03:56' s6 = repmat(s, 6, 1); */
    /*  If (s>1), hold the desired knee angles constant and keep the */
    /*  torso angle fixed by decreasing the desired leg angles */
    /* 'ATRIAS3D_ZD_Output03:61' h_alpha_high = h_alpha(:,end)*[1 1 1 1 1 1]; */
    /* 'ATRIAS3D_ZD_Output03:62' h_alpha_high(1:2,:) = h_alpha_high(1:2,:)+dqyTds*(-1:0.2:0); */
    /* 'ATRIAS3D_ZD_Output03:63' h_alpha_high(1:2) = max(150*pi/180, h_alpha_high(1:2)); */
  }

  /*     %% Compute terms in controller */
  /* 'ATRIAS3D_ZD_Output03:80' qmod = q; */
  /* 'ATRIAS3D_ZD_Output03:81' qmod(1) = sat(qmod(1), -Output.YawLimit, Output.YawLimit); */
  /* 'ATRIAS3D_ZD_Output03:82' h0 = jacob_h0*qmod; */
  /* 'ATRIAS3D_ZD_Output03:83' hd = bezierv(h_alpha, s); */
  /* 'ATRIAS3D_ZD_Output03:84' jacob_hd  = beziervd(h_alpha,s); */
  /* 'ATRIAS3D_ZD_Output03:85' jacob2_hd = bezierva(h_alpha,s); */
  /* 'ATRIAS3D_ZD_Output03:86' dhd = jacob_hd.*ds; */
  /* 'ATRIAS3D_ZD_Output03:88' jacob_h = jacob_h0 - jacob_hd*dsdq; */
  /* 'ATRIAS3D_ZD_Output03:89' jacob_jacobhdqdq = -jacob2_hd.*(ds.*ds); */
  /*     %% Stabilizing output term */
  /*  Allow outputs of the form */
  /*    y = H0*q - hd(s(theta(q)), h_alpha) - hStabilizing(phi - phid(s(theta(q))), StabilizingHAlpha) */
  /* 'ATRIAS3D_ZD_Output03:95' phi    = Output.Phi.cq * q; */
  /* 'ATRIAS3D_ZD_Output03:96' dphi   = Output.Phi.cq * dq; */
  /* 'ATRIAS3D_ZD_Output03:98' phid   = bezier(Output.PhiAlpha, s); */
  /* 'ATRIAS3D_ZD_Output03:99' jacob_phid = bezierd(Output.PhiAlpha, s); */
  /* 'ATRIAS3D_ZD_Output03:100' jacob2_phid = beziera(Output.PhiAlpha, s); */
  /* 'ATRIAS3D_ZD_Output03:102' r      = phi - phid; */
  /* 'ATRIAS3D_ZD_Output03:103' dr     = dphi - jacob_phid * ds; */
  /* 'ATRIAS3D_ZD_Output03:104' RSaturated = false; */
  /* 'ATRIAS3D_ZD_Output03:105' if Output.SaturateR */
  /* 'ATRIAS3D_ZD_Output03:117' hdbar  = polyv(Output.HBarAlpha, r, inf); */
  /* 'ATRIAS3D_ZD_Output03:118' if ~RSaturated */
  /* 'ATRIAS3D_ZD_Output03:126' hdbar = sat(hdbar, Output.HBarLimits(:,1), Output.HBarLimits(:,2)); */
  /* 'ATRIAS3D_ZD_Output03:127' idxsat = (hdbar == Output.HBarLimits(:,1)) | (hdbar == Output.HBarLimits(:,2)); */
  /* 'ATRIAS3D_ZD_Output03:128' jacob_hdbar(idxsat,:) = 0; */
  /* 'ATRIAS3D_ZD_Output03:129' jacob2_hdbar(idxsat,:) = 0; */
  /* 'ATRIAS3D_ZD_Output03:131' hd = hd + hdbar; */
  /* 'ATRIAS3D_ZD_Output03:132' jacob_h = jacob_h - jacob_hdbar * (Output.Phi.cq - jacob_phid * dsdq); */
  /* 'ATRIAS3D_ZD_Output03:133' jacob_jacobhdqdq = jacob_jacobhdqdq ... */
  /* 'ATRIAS3D_ZD_Output03:134'         + jacob_hdbar * jacob2_phid * ds^2 ... */
  /* 'ATRIAS3D_ZD_Output03:135'         + jacob2_hdbar * (-jacob_phid^2 * ds^2 - dphi^2 + jacob_phid * dphi * ds); */
  /*     %% Saturate the desired leg/knee/hip angles */
  /* 'ATRIAS3D_ZD_Output03:138' hd_min = [150; 150;  15;  15; -20; -20]*pi/180; */
  /* 'ATRIAS3D_ZD_Output03:139' hd_max = [220; 220; 120; 120;  20;  20]*pi/180; */
  /* 'ATRIAS3D_ZD_Output03:140' sat_correction = (jacob_h0 - T1)*q; */
  /* 'ATRIAS3D_ZD_Output03:141' hd = sat(hd, hd_min + sat_correction, hd_max + sat_correction); */
  /* 'ATRIAS3D_ZD_Output03:142' idxsat = (hd == hd_min + sat_correction) | (hd == hd_max + sat_correction); */
  /* 'ATRIAS3D_ZD_Output03:143' dhd(idxsat) = 0; */
  /* 'ATRIAS3D_ZD_Output03:144' jacob_h(idxsat) = jacob_h0(idxsat); */
  /*  jacob_hd(idxsat) = 0; */
  /*     %% */
  /* 'ATRIAS3D_ZD_Output03:147' y  = h0-hd; */
  /* 'ATRIAS3D_ZD_Output03:148' dy = jacob_h0*dq - dhd; */
  /*  Correction */
  /* 'ATRIAS3D_ZD_Output03:152' h_alpha_corr = Output.HAlphaCorrection; */
  /* 'ATRIAS3D_ZD_Output03:153' s_corr_max = Output.SMaxCorrection; */
  /* 'ATRIAS3D_ZD_Output03:154' if Output.UseCorrection && any(s <= s_corr_max) */
  return s;
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function error = checkError(t)
 */
static boolean_T Walking01_withElmos_checkError(real_T t)
{
  boolean_T error;

  /* MATLAB Function 'checkError': '<S215>:217' */
  /*  Default */
  /* '<S215>:217:4' error = false; */
  error = false;

  /* '<S215>:217:6' sprev = -inf; */
  /* '<S215>:217:7' s = ATRIAS3D_ZD_Output03(t, q, dq, ControlState, ControlParams, sprev); */
  Walking01_withElmos_DW.s = Walkin_ATRIAS3D_ZD_Output03_c0j(t,
    Walking01_withElmos_B.q, Walking01_withElmos_B.dq_clean,
    Walking01_withElmos_B.ControlState.StanceLeg,
    &Walking01_withElmos_B.ControlParams);

  /* '<S215>:217:9' if (s > 0.65) */
  if (Walking01_withElmos_DW.s > 0.65) {
    /* '<S215>:217:10' error = true; */
    error = true;
  }

  return error;
}

/* Function for Chart: '<S202>/StateLogic' */
static void Walking01_withEl_ControllerMode(void)
{
  int32_T b_previousEvent;
  boolean_T guard1 = false;

  /* During 'ControllerMode': '<S215>:71' */
  switch (Walking01_withElmos_DW.is_ControllerMode) {
   case Walking01_withElmo_IN_Injection:
    /* During 'Injection': '<S215>:79' */
    if (Walking01_withElmos_DW.temporalCounter_i2 >= (uint32_T)ceil
        (Walking01_withElmos_B.ControlParams.Supervisory.TStepInitial / 0.0005 -
         5.0000000000000005E-12)) {
      /* Transition: '<S215>:104' */
      /* Transition: '<S215>:225' */
      if (Walking01_withE_checkTransition()) {
        /* Transition: '<S215>:168' */
        /* Transition: '<S215>:223' */
        /* Transition: '<S215>:96' */
        Walking01_withElmos_DW.is_ControllerMode =
          Walking01_withElmos_IN_Walking;

        /* Entry 'Walking': '<S215>:81' */
        Walking01_withElmos_B.ControlState.ControllerMode = 4.0;
        Walking01_withElm_updateControl(Walking01_withElmos_M->Timing.t[0]);
        b_previousEvent = Walking01_withElmos_DW.sfEvent;
        Walking01_withElmos_DW.sfEvent = Walking01_w_event_ControlUpdate;
        if (Walking01_withElmos_DW.is_active_Serialize != 0U) {
          Walking01_withElmos_Serialize();
        }

        Walking01_withElmos_DW.sfEvent = b_previousEvent;
      } else {
        /* Transition: '<S215>:170' */
        /* Transition: '<S215>:172' */
        Walking01_withElmos_DW.is_ControllerMode =
          Walking01_withElm_IN_Transition;

        /* Entry 'Transition': '<S215>:80' */
        Walking01_withElmos_B.ControlState.ControllerMode = 3.0;
        Walking01_withElm_updateControl(Walking01_withElmos_M->Timing.t[0]);
        b_previousEvent = Walking01_withElmos_DW.sfEvent;
        Walking01_withElmos_DW.sfEvent = Walking01_w_event_ControlUpdate;
        if (Walking01_withElmos_DW.is_active_Serialize != 0U) {
          Walking01_withElmos_Serialize();
        }

        Walking01_withElmos_DW.sfEvent = b_previousEvent;

        /* Entry Internal 'Transition': '<S215>:80' */
        /* Transition: '<S215>:179' */
        if (Walking01_withElmos_DW.is_Transition != Walking01_withElmos_IN_Early)
        {
          Walking01_withElmos_DW.is_Transition = Walking01_withElmos_IN_Early;
          Walking01_withElmos_DW.temporalCounter_i2 = 0U;
        }
      }
    }
    break;

   case Walking01_withElmos_IN_Posing:
    /* During 'Posing': '<S215>:72' */
    /* Transition: '<S215>:91' */
    /* Transition: '<S215>:92' */
    if ((Walking01_withElmos_B.EnableTransition == 2.0) &&
        Walking01_withE_checkTransition()) {
      /* Transition: '<S215>:93' */
      Walking01_withElmos_DW.is_ControllerMode = Walking01_withElmo_IN_Injection;
      Walking01_withElmos_DW.temporalCounter_i2 = 0U;

      /* Entry 'Injection': '<S215>:79' */
      Walking01_withElmos_B.ControlState.ControllerMode = 2.0;
      Walking01_withElm_updateControl(Walking01_withElmos_M->Timing.t[0]);
      b_previousEvent = Walking01_withElmos_DW.sfEvent;
      Walking01_withElmos_DW.sfEvent = Walking01_w_event_ControlUpdate;
      if (Walking01_withElmos_DW.is_active_Serialize != 0U) {
        Walking01_withElmos_Serialize();
      }

      Walking01_withElmos_DW.sfEvent = b_previousEvent;
    } else if (Walking01_withElmos_B.EnableTransition == 4.0) {
      /* Transition: '<S215>:94' */
      /* Transition: '<S215>:223' */
      /* Transition: '<S215>:96' */
      Walking01_withElmos_DW.is_ControllerMode = Walking01_withElmos_IN_Walking;

      /* Entry 'Walking': '<S215>:81' */
      Walking01_withElmos_B.ControlState.ControllerMode = 4.0;
      Walking01_withElm_updateControl(Walking01_withElmos_M->Timing.t[0]);
      b_previousEvent = Walking01_withElmos_DW.sfEvent;
      Walking01_withElmos_DW.sfEvent = Walking01_w_event_ControlUpdate;
      if (Walking01_withElmos_DW.is_active_Serialize != 0U) {
        Walking01_withElmos_Serialize();
      }

      Walking01_withElmos_DW.sfEvent = b_previousEvent;
    } else {
      if (Walking01_withElmos_DW.temporalCounter_i2 >= 300U) {
        /* Transition: '<S215>:103' */
        Walking01_withElmos_DW.is_ControllerMode = Walking01_withElmos_IN_Posing;
        Walking01_withElmos_DW.temporalCounter_i2 = 0U;

        /* Entry 'Posing': '<S215>:72' */
        Walking01_withElmos_B.ControlState.ControllerMode = 1.0;
        Walking01_withElm_updateControl(Walking01_withElmos_M->Timing.t[0]);
      }
    }
    break;

   case Walking01_withElm_IN_Transition:
    /* During 'Transition': '<S215>:80' */
    if (Walking01_withElmos_DW.sfEvent == Walking01_withElm_event_LegSwap) {
      /* Transition: '<S215>:101' */
      Walking01_withElmos_DW.TransitionStepCount++;
      if (Walking01_withE_checkTransition()) {
        /* Transition: '<S215>:168' */
        /* Transition: '<S215>:223' */
        /* Transition: '<S215>:96' */
        /* Exit Internal 'Transition': '<S215>:80' */
        Walking01_withElmos_DW.is_Transition = Walking01__IN_NO_ACTIVE_CHILD_j;
        Walking01_withElmos_DW.is_ControllerMode =
          Walking01_withElmos_IN_Walking;

        /* Entry 'Walking': '<S215>:81' */
        Walking01_withElmos_B.ControlState.ControllerMode = 4.0;
        Walking01_withElm_updateControl(Walking01_withElmos_M->Timing.t[0]);
        b_previousEvent = Walking01_withElmos_DW.sfEvent;
        Walking01_withElmos_DW.sfEvent = Walking01_w_event_ControlUpdate;
        if (Walking01_withElmos_DW.is_active_Serialize != 0U) {
          Walking01_withElmos_Serialize();
        }

        Walking01_withElmos_DW.sfEvent = b_previousEvent;
      } else {
        /* Transition: '<S215>:170' */
        /* Transition: '<S215>:172' */
        /* Exit Internal 'Transition': '<S215>:80' */
        Walking01_withElmos_DW.is_Transition = Walking01__IN_NO_ACTIVE_CHILD_j;
        Walking01_withElmos_DW.is_ControllerMode =
          Walking01_withElm_IN_Transition;

        /* Entry 'Transition': '<S215>:80' */
        Walking01_withElmos_B.ControlState.ControllerMode = 3.0;
        Walking01_withElm_updateControl(Walking01_withElmos_M->Timing.t[0]);
        b_previousEvent = Walking01_withElmos_DW.sfEvent;
        Walking01_withElmos_DW.sfEvent = Walking01_w_event_ControlUpdate;
        if (Walking01_withElmos_DW.is_active_Serialize != 0U) {
          Walking01_withElmos_Serialize();
        }

        Walking01_withElmos_DW.sfEvent = b_previousEvent;

        /* Entry Internal 'Transition': '<S215>:80' */
        /* Transition: '<S215>:179' */
        if (Walking01_withElmos_DW.is_Transition != Walking01_withElmos_IN_Early)
        {
          Walking01_withElmos_DW.is_Transition = Walking01_withElmos_IN_Early;
          Walking01_withElmos_DW.temporalCounter_i2 = 0U;
        }
      }
    } else if (Walking01_withElmos_DW.sfEvent == Walking01_withE_event_LegImpact)
    {
      /* Transition: '<S215>:166' */
      /* Exit Internal 'Transition': '<S215>:80' */
      Walking01_withElmos_DW.is_Transition = Walking01__IN_NO_ACTIVE_CHILD_j;
      Walking01_withElmos_DW.is_ControllerMode = Walking01_withElm_IN_Transition;

      /* Entry 'Transition': '<S215>:80' */
      Walking01_withElmos_B.ControlState.ControllerMode = 3.0;
      Walking01_withElm_updateControl(Walking01_withElmos_M->Timing.t[0]);
      b_previousEvent = Walking01_withElmos_DW.sfEvent;
      Walking01_withElmos_DW.sfEvent = Walking01_w_event_ControlUpdate;
      if (Walking01_withElmos_DW.is_active_Serialize != 0U) {
        Walking01_withElmos_Serialize();
      }

      Walking01_withElmos_DW.sfEvent = b_previousEvent;

      /* Entry Internal 'Transition': '<S215>:80' */
      /* Transition: '<S215>:179' */
      if (Walking01_withElmos_DW.is_Transition != Walking01_withElmos_IN_Early)
      {
        Walking01_withElmos_DW.is_Transition = Walking01_withElmos_IN_Early;
        Walking01_withElmos_DW.temporalCounter_i2 = 0U;
      }
    } else {
      switch (Walking01_withElmos_DW.is_Transition) {
       case Walking01_withElmos_IN_Early:
        /* During 'Early': '<S215>:181' */
        if (Walking01_withElmos_DW.temporalCounter_i2 >= 200U) {
          /* Transition: '<S215>:185' */
          Walking01_withElmos_DW.is_Transition = Walking01_withElmos_IN_Late;
        }
        break;

       case Walking01_withElmos_IN_Late:
        /* During 'Late': '<S215>:182' */
        break;

       default:
        Walking01_withElmos_DW.is_Transition = Walking01__IN_NO_ACTIVE_CHILD_j;
        break;
      }
    }
    break;

   case Walking01_withElmos_IN_Walking:
    /* During 'Walking': '<S215>:81' */
    if (Walking01_withElmos_DW.sfEvent == Walking01_withElm_event_LegSwap) {
      /* Transition: '<S215>:99' */
      Walking01_withElmos_DW.WalkingStepCount++;
      if (Walking01_withElmos_checkError(Walking01_withElmos_M->Timing.t[0])) {
        /* Transition: '<S215>:194' */
        /* Transition: '<S215>:215' */
        /* Exit Internal 'Run': '<S215>:27' */
        /* Exit Internal 'Stage': '<S215>:114' */
        Walking01_withElmos_DW.is_Stage = Walking01__IN_NO_ACTIVE_CHILD_j;
        Walking01_withElmos_DW.is_active_Stage = 0U;

        /* Exit Internal 'ControllerMode': '<S215>:71' */
        Walking01_withElmos_DW.is_ControllerMode =
          Walking01__IN_NO_ACTIVE_CHILD_j;

        /* Exit Internal 'Transition': '<S215>:80' */
        Walking01_withElmos_DW.is_Transition = Walking01__IN_NO_ACTIVE_CHILD_j;
        Walking01_withElmos_DW.is_active_ControllerMode = 0U;

        /* Exit Internal 'Support': '<S215>:31' */
        Walking01_withElmos_DW.is_Support = Walking01__IN_NO_ACTIVE_CHILD_j;
        Walking01_withElmos_DW.is_active_Support = 0U;
        Walking01_withElmos_DW.is_Main = Walking01_withElmos_IN_Error_a;

        /* Entry 'Error': '<S215>:192' */
        Walking01_withElmos_B.ControlState.Error = 1.0;
      } else {
        /* Transition: '<S215>:213' */
        guard1 = true;
      }
    } else {
      if (Walking01_withElmos_DW.sfEvent == Walking01_withE_event_LegImpact) {
        /* Transition: '<S215>:100' */
        guard1 = true;
      }
    }
    break;

   default:
    Walking01_withElmos_DW.is_ControllerMode = Walking01__IN_NO_ACTIVE_CHILD_j;
    break;
  }

  if (guard1) {
    /* Transition: '<S215>:212' */
    /* Transition: '<S215>:211' */
    Walking01_withElmos_DW.is_ControllerMode = Walking01_withElmos_IN_Walking;

    /* Entry 'Walking': '<S215>:81' */
    Walking01_withElmos_B.ControlState.ControllerMode = 4.0;
    Walking01_withElm_updateControl(Walking01_withElmos_M->Timing.t[0]);
    b_previousEvent = Walking01_withElmos_DW.sfEvent;
    Walking01_withElmos_DW.sfEvent = Walking01_w_event_ControlUpdate;
    if (Walking01_withElmos_DW.is_active_Serialize != 0U) {
      Walking01_withElmos_Serialize();
    }

    Walking01_withElmos_DW.sfEvent = b_previousEvent;
  }
}

/*
 * Function for Chart: '<S202>/StateLogic'
 * function updateLegAngles(t,phase)
 */
static void Walking01_withE_updateLegAngles(real_T t, real_T phase)
{
  real_T w;
  real_T DeltaH[6];
  real_T c;
  real_T maxval[6];
  static const real_T b[6] = { 0.0, 0.2, 0.4, 0.6, 0.8, 1.0 };

  int32_T i;
  real_T tmp[36];
  int32_T i_0;
  real_T DeltaH_0;
  real_T y;

  /* MATLAB Function 'updateLegAngles': '<S215>:122' */
  /* '<S215>:122:4' if (ControlState.ControllerMode==4) */
  if ((Walking01_withElmos_B.ControlState.ControllerMode == 4.0) &&
      (!(Walking01_withElmos_DW.s > 0.9))) {
    /*  BASIC WALKING */
    /* '<S215>:122:5' sprev = -1000; */
    /* [s,ds,h0,y,dy,jacob_h0,jacob_h,s_unsaturated,theta,dtheta] = ATRIAS3D_ZD_Output03(t, q, dq, ControlState, ControlParams, sprev); */
    /* '<S215>:122:8' if s>0.9 */
    /* '<S215>:122:12' if phase==2 */
    if (phase == 2.0) {
      /* '<S215>:122:13' ControlParams.Discrete.TLastUpdate = t; */
      Walking01_withElmos_B.ControlParams.Discrete.TLastUpdate = t;
    } else {
      if (phase == 3.0) {
        /* '<S215>:122:15' elseif phase==3 */
        /* dtheta = (pi/2 - ControlParams.Output.ThetaLimits(1)); */
        /* if dtheta<0 */
        /*     return */
        /* end */
        /* '<S215>:122:20' dtheta = (1.6 - 1.5)/(t - ControlParams.Discrete.TLastUpdate); */
        /* '<S215>:122:22' w = dtheta - ControlParams.Supervisory.VelocityBasedUpdateDTheta0; */
        w = 0.10000000000000009 / (t -
          Walking01_withElmos_B.ControlParams.Discrete.TLastUpdate) -
          Walking01_withElmos_B.ControlParams.Supervisory.VelocityBasedUpdateDTheta0;

        /* '<S215>:122:23' DeltaH = ControlParams.Supervisory.VelocityBasedUpdateK1 * w ... */
        /* '<S215>:122:24'                 + ControlParams.Supervisory.VelocityBasedUpdateK2 * w^2; */
        c = w * w;

        /* '<S215>:122:26' DeltaH = sat(DeltaH, ControlParams.Supervisory.VelocityBasedUpdateLimits(:,1), ControlParams.Supervisory.VelocityBasedUpdateLimits(:,2)); */
        /* 'sat:3' y = max(lo, min(x, hi)); */
        /*  Ramp from the current s value */
        /* '<S215>:122:29' DeltaHAlpha = DeltaH * max(0, ([0 0.2 0.4 0.6 0.8 1] - s)/(1-s) ); */
        for (i = 0; i < 6; i++) {
          DeltaH_0 =
            Walking01_withElmos_B.ControlParams.Supervisory.VelocityBasedUpdateK1
            [i] * w +
            Walking01_withElmos_B.ControlParams.Supervisory.VelocityBasedUpdateK2
            [i] * c;
          if (!((DeltaH_0 <=
                 Walking01_withElmos_B.ControlParams.Supervisory.VelocityBasedUpdateLimits
                 [6 + i]) || rtIsNaN
                (Walking01_withElmos_B.ControlParams.Supervisory.VelocityBasedUpdateLimits
                 [6 + i]))) {
            DeltaH_0 =
              Walking01_withElmos_B.ControlParams.Supervisory.VelocityBasedUpdateLimits
              [6 + i];
          }

          y = (b[i] - Walking01_withElmos_DW.s) / (1.0 -
            Walking01_withElmos_DW.s);
          if ((0.0 >= y) || rtIsNaN(y)) {
            maxval[i] = 0.0;
          } else {
            maxval[i] = y;
          }

          if ((Walking01_withElmos_B.ControlParams.Supervisory.VelocityBasedUpdateLimits
               [i] >= DeltaH_0) || rtIsNaN(DeltaH_0)) {
            DeltaH[i] =
              Walking01_withElmos_B.ControlParams.Supervisory.VelocityBasedUpdateLimits
              [i];
          } else {
            DeltaH[i] = DeltaH_0;
          }
        }

        /* '<S215>:122:30' ControlParams.Output.HAlpha = ControlParams.Output.HAlpha + DeltaHAlpha; */
        for (i = 0; i < 6; i++) {
          for (i_0 = 0; i_0 < 6; i_0++) {
            tmp[i + 6 * i_0] =
              Walking01_withElmos_B.ControlParams.Output.HAlpha[6 * i_0 + i] +
              DeltaH[i] * maxval[i_0];
          }
        }

        for (i = 0; i < 36; i++) {
          Walking01_withElmos_B.ControlParams.Output.HAlpha[i] = tmp[i];
        }
      }
    }

    /*     %{ */
    /*     if (ControlState.ControllerMode==3) */
    /*         [theta_limits, h_alpha] = updateVelocityBased(t,q,dq,stance_leg,theta_limits,h_alpha,theta_limits_nom,h_alpha_nom,select_control,vcm,vdes,VBLAOptions); */
    /*          */
    /*         %[theta_limits_transition, alpha_transition] = robustUpdate(phase, RobustUpdateMode, t, q, dq, s, ds, stance_leg, stance_leg_prev, hd_posing, theta_limits_nom, h_alpha_nom, tStepInitial, tStep, qTdesired, vdes, step_params, ETA_VPP, kpFootPlacement, kdFootPlacement, select_control, theta_limits_transition, alpha_transition, RunMode, outputParams, h_alpha_update_params); */
    /*          */
    /*         uk = 0; */
    /*          */
    /*         % Update the desired swing leg angle by adding a ramp d(s) satisfying */
    /*         %   d(s_update) = 0 */
    /*         %   d(1)   = uk */
    /*         % Note that these conditions imply that */
    /*         %   d(0)   = -uk*s_update/(1-s_update) */
    /*         s_update = 0.5; %sprev; */
    /*         d0 = -uk*s_update/(1-s_update); */
    /*         d1 = uk; */
    /*         d_alpha = (0:0.2:1)*(d1-d0)+d0; */
    /*          */
    /*         h_alpha(2,:) = h_alpha(2,:) + d_alpha; */
    /*          */
    /*     end */
    /*     %} */
  } else {
    /*     %{ */
    /*     if (ControlState.ControllerMode==3) */
    /*         [theta_limits, h_alpha] = updateVelocityBased(t,q,dq,stance_leg,theta_limits,h_alpha,theta_limits_nom,h_alpha_nom,select_control,vcm,vdes,VBLAOptions); */
    /*          */
    /*         %[theta_limits_transition, alpha_transition] = robustUpdate(phase, RobustUpdateMode, t, q, dq, s, ds, stance_leg, stance_leg_prev, hd_posing, theta_limits_nom, h_alpha_nom, tStepInitial, tStep, qTdesired, vdes, step_params, ETA_VPP, kpFootPlacement, kdFootPlacement, select_control, theta_limits_transition, alpha_transition, RunMode, outputParams, h_alpha_update_params); */
    /*          */
    /*         uk = 0; */
    /*          */
    /*         % Update the desired swing leg angle by adding a ramp d(s) satisfying */
    /*         %   d(s_update) = 0 */
    /*         %   d(1)   = uk */
    /*         % Note that these conditions imply that */
    /*         %   d(0)   = -uk*s_update/(1-s_update) */
    /*         s_update = 0.5; %sprev; */
    /*         d0 = -uk*s_update/(1-s_update); */
    /*         d1 = uk; */
    /*         d_alpha = (0:0.2:1)*(d1-d0)+d0; */
    /*          */
    /*         h_alpha(2,:) = h_alpha(2,:) + d_alpha; */
    /*          */
    /*     end */
    /*     %} */
  }
}

/* Function for Chart: '<S202>/StateLogic' */
static void Walking01_withElmos_Run(void)
{
  int32_T b_previousEvent;

  /* During 'Run': '<S215>:27' */
  if (Walking01_withElmos_B.ResetControl > 0.0) {
    /* Transition: '<S215>:29' */
    /* Exit Internal 'Run': '<S215>:27' */
    /* Exit Internal 'Stage': '<S215>:114' */
    Walking01_withElmos_DW.is_Stage = Walking01__IN_NO_ACTIVE_CHILD_j;
    Walking01_withElmos_DW.is_active_Stage = 0U;

    /* Exit Internal 'ControllerMode': '<S215>:71' */
    Walking01_withElmos_DW.is_ControllerMode = Walking01__IN_NO_ACTIVE_CHILD_j;

    /* Exit Internal 'Transition': '<S215>:80' */
    Walking01_withElmos_DW.is_Transition = Walking01__IN_NO_ACTIVE_CHILD_j;
    Walking01_withElmos_DW.is_active_ControllerMode = 0U;

    /* Exit Internal 'Support': '<S215>:31' */
    Walking01_withElmos_DW.is_Support = Walking01__IN_NO_ACTIVE_CHILD_j;
    Walking01_withElmos_DW.is_active_Support = 0U;
    Walking01_withElmos_DW.is_Main = Walking01_withElmos_IN_Reset;

    /* Entry 'Reset': '<S215>:28' */
    Walking01_withElmos_B.ControlState.ControllerMode = 0.0;
    Walking01_withElmos_B.ControlState.SupportState = 0.0;
    Walking01_withElmos_B.ControlState.StanceLeg = 0.0;
    Walking01_withElmos_B.ControlState.InDoubleSupport = 0.0;
    Walking01_withElmos_B.ControlState.Error = 0.0;
  } else {
    Walking01_withElmos_B.ControlParams.Supervisory =
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory;
    Walking01_withElmos_B.ControlParams.Feedback =
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback;
    Walking01_withElmos_B.ControlParams.Saturation =
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Saturation;
    Walking01_withElmos_DW.ControlParamsPrev =
      Walking01_withElmos_B.ControlParams;
    Walking01_withElmos_DW.ControlStatePrev = Walking01_withElmos_B.ControlState;
    Walking01_withElmos_updateS(Walking01_withElmos_M->Timing.t[0]);
    if (Walking01_withElmos_DW.is_active_Support != 0U) {
      /* During 'Support': '<S215>:31' */
      switch (Walking01_withElmos_DW.is_Support) {
       case Walking01_withElm_IN_LeftDouble:
        /* During 'LeftDouble': '<S215>:38' */
        if ((Walking01_withElmos_DW.temporalCounter_i1 >= (uint32_T)ceil(0.002 /
              0.0005 - 5.0000000000000005E-12)) &&
            (Walking01_withElmo_checkSupport
             (Walking01_withElmos_B.ControlState.StanceLeg) == 0.0)) {
          /* Transition: '<S215>:68' */
          /* Transition: '<S215>:152' */
          Walking01_withElmos_DW.is_Support = Walking01_withEl_IN_RightSingle;
          Walking01_withElmos_DW.temporalCounter_i1 = 0U;
          Walkin_enter_atomic_RightSingle();
        }
        break;

       case Walking01_withElm_IN_LeftSingle:
        /* During 'LeftSingle': '<S215>:36' */
        if ((Walking01_withElmos_DW.temporalCounter_i1 >= (uint32_T)ceil(0.1 /
              0.0005 - 5.0000000000000005E-12)) && Walking01_withElmos_checkMode
            ()) {
          /* Transition: '<S215>:67' */
          Walking01_withElmos_DW.is_Support = Walking01_withElmos_IN_LeftWait;

          /* Entry 'LeftWait': '<S215>:37' */
          Walking01_withElmos_B.ControlState.SupportState = 5.0;
        }
        break;

       case Walking01_withElmos_IN_LeftWait:
        /* During 'LeftWait': '<S215>:37' */
        if (Walking01_withElmos_checkImpact()) {
          /* Transition: '<S215>:66' */
          if (Walking01_withElmos_B.ControlParams.Supervisory.AllowDoubleSupport
              == 1.0) {
            /* Transition: '<S215>:148' */
            Walking01_withElmos_DW.is_Support = Walking01_withElm_IN_LeftDouble;
            Walking01_withElmos_DW.temporalCounter_i1 = 0U;

            /* Entry 'LeftDouble': '<S215>:38' */
            Walking01_withElmos_B.ControlState.SupportState = 6.0;
            Walking01_withElmos_B.ControlState.InDoubleSupport = 1.0;
            b_previousEvent = Walking01_withElmos_DW.sfEvent;
            Walking01_withElmos_DW.sfEvent = Walking01_withE_event_LegImpact;
            if (Walking01_withElmos_DW.is_Main == Walking01_withElmos_IN_Run_k)
            {
              Walking01_withElmos_Run();
            }

            Walking01_withElmos_DW.sfEvent = b_previousEvent;
          } else {
            /* Transition: '<S215>:150' */
            /* Transition: '<S215>:151' */
            /* Transition: '<S215>:152' */
            Walking01_withElmos_DW.is_Support = Walking01_withEl_IN_RightSingle;
            Walking01_withElmos_DW.temporalCounter_i1 = 0U;
            Walkin_enter_atomic_RightSingle();
          }
        }
        break;

       case Walking01_withEl_IN_RightDouble:
        /* During 'RightDouble': '<S215>:34' */
        if ((Walking01_withElmos_DW.temporalCounter_i1 >= (uint32_T)ceil(0.002 /
              0.0005 - 5.0000000000000005E-12)) &&
            (Walking01_withElmo_checkSupport
             (Walking01_withElmos_B.ControlState.StanceLeg) == 0.0)) {
          /* Transition: '<S215>:65' */
          /* Transition: '<S215>:142' */
          Walking01_withElmos_DW.is_Support = Walking01_withElm_IN_LeftSingle;
          Walking01_withElmos_DW.temporalCounter_i1 = 0U;
          Walking_enter_atomic_LeftSingle();
        }
        break;

       case Walking01_withEl_IN_RightSingle:
        /* During 'RightSingle': '<S215>:32' */
        if ((Walking01_withElmos_DW.temporalCounter_i1 >= (uint32_T)ceil(0.1 /
              0.0005 - 5.0000000000000005E-12)) && Walking01_withElmos_checkMode
            ()) {
          /* Transition: '<S215>:63' */
          Walking01_withElmos_DW.is_Support = Walking01_withElmo_IN_RightWait;

          /* Entry 'RightWait': '<S215>:33' */
          Walking01_withElmos_B.ControlState.SupportState = 2.0;
        }
        break;

       case Walking01_withElmo_IN_RightWait:
        /* During 'RightWait': '<S215>:33' */
        if (Walking01_withElmos_checkImpact()) {
          /* Transition: '<S215>:64' */
          if (Walking01_withElmos_B.ControlParams.Supervisory.AllowDoubleSupport
              == 1.0) {
            /* Transition: '<S215>:136' */
            Walking01_withElmos_DW.is_Support = Walking01_withEl_IN_RightDouble;
            Walking01_withElmos_DW.temporalCounter_i1 = 0U;

            /* Entry 'RightDouble': '<S215>:34' */
            Walking01_withElmos_B.ControlState.SupportState = 3.0;
            Walking01_withElmos_B.ControlState.InDoubleSupport = 1.0;
            b_previousEvent = Walking01_withElmos_DW.sfEvent;
            Walking01_withElmos_DW.sfEvent = Walking01_withE_event_LegImpact;
            if (Walking01_withElmos_DW.is_Main == Walking01_withElmos_IN_Run_k)
            {
              Walking01_withElmos_Run();
            }

            Walking01_withElmos_DW.sfEvent = b_previousEvent;
          } else {
            /* Transition: '<S215>:138' */
            /* Transition: '<S215>:141' */
            /* Transition: '<S215>:142' */
            Walking01_withElmos_DW.is_Support = Walking01_withElm_IN_LeftSingle;
            Walking01_withElmos_DW.temporalCounter_i1 = 0U;
            Walking_enter_atomic_LeftSingle();
          }
        }
        break;

       default:
        Walking01_withElmos_DW.is_Support = Walking01__IN_NO_ACTIVE_CHILD_j;
        break;
      }
    }

    if (Walking01_withElmos_DW.is_Main == Walking01_withElmos_IN_Run_k) {
      if (Walking01_withElmos_DW.is_active_ControllerMode != 0U) {
        Walking01_withEl_ControllerMode();
      }

      if (!((Walking01_withElmos_DW.is_Main != Walking01_withElmos_IN_Run_k) ||
            (Walking01_withElmos_DW.is_active_Stage == 0U))) {
        /* During 'Stage': '<S215>:114' */
        switch (Walking01_withElmos_DW.is_Stage) {
         case Walking01_withElmos_IN_Early:
          /* During 'Early': '<S215>:115' */
          if ((Walking01_withElmos_DW.is_ControllerMode ==
               Walking01_withElmos_IN_Walking) && (Walking01_withElmos_DW.theta >=
               1.5) &&
              (Walking01_withElmos_B.ControlParams.Supervisory.EnableVelocityBasedUpdate
               != 0.0)) {
            /* Transition: '<S215>:120' */
            Walking01_withElmos_DW.is_Stage = Walking01_withElmos_IN_Mid;

            /* Entry 'Mid': '<S215>:261' */
            Walking01_withElmos_B.ControlState.RollPhase = 2.0;
            Walking01_withE_updateLegAngles(Walking01_withElmos_M->Timing.t[0],
              2.0);
            b_previousEvent = Walking01_withElmos_DW.sfEvent;
            Walking01_withElmos_DW.sfEvent = Walking01_w_event_ControlUpdate;
            if (Walking01_withElmos_DW.is_active_Serialize != 0U) {
              Walking01_withElmos_Serialize();
            }

            Walking01_withElmos_DW.sfEvent = b_previousEvent;
          }
          break;

         case Walking01_withElmos_IN_Late:
          /* During 'Late': '<S215>:116' */
          if (Walking01_withElmos_DW.sfEvent == Walking01_withElm_event_LegSwap)
          {
            /* Transition: '<S215>:118' */
            Walking01_withElmos_DW.is_Stage = Walking01_withElmos_IN_Wait;

            /* Entry 'Wait': '<S215>:117' */
            Walking01_withElmos_B.ControlState.RollPhase = 4.0;
          }
          break;

         case Walking01_withElmos_IN_Mid:
          /* During 'Mid': '<S215>:261' */
          if (Walking01_withElmos_DW.theta >= 1.6) {
            /* Transition: '<S215>:262' */
            Walking01_withElmos_DW.is_Stage = Walking01_withElmos_IN_Late;

            /* Entry 'Late': '<S215>:116' */
            Walking01_withElmos_B.ControlState.RollPhase = 3.0;
            Walking01_withE_updateLegAngles(Walking01_withElmos_M->Timing.t[0],
              3.0);
            b_previousEvent = Walking01_withElmos_DW.sfEvent;
            Walking01_withElmos_DW.sfEvent = Walking01_w_event_ControlUpdate;
            if (Walking01_withElmos_DW.is_active_Serialize != 0U) {
              Walking01_withElmos_Serialize();
            }

            Walking01_withElmos_DW.sfEvent = b_previousEvent;
          }
          break;

         case Walking01_withElmos_IN_Wait:
          /* During 'Wait': '<S215>:117' */
          if (Walking01_withElmos_DW.s < 0.4) {
            /* Transition: '<S215>:119' */
            Walking01_withElmos_DW.is_Stage = Walking01_withElmos_IN_Early;

            /* Entry 'Early': '<S215>:115' */
            Walking01_withElmos_B.ControlState.RollPhase = 1.0;
          }
          break;

         default:
          Walking01_withElmos_DW.is_Stage = Walking01__IN_NO_ACTIVE_CHILD_j;
          break;
        }
      }
    }
  }
}

/* Function for Chart: '<S202>/StateLogic' */
static void Walking_enter_atomic_LeftSingle(void)
{
  int32_T b_previousEvent;

  /* Entry 'LeftSingle': '<S215>:36' */
  Walking01_withElmos_B.ControlState.SupportState = 4.0;
  Walking01_withElmos_B.ControlState.StanceLeg = 1.0;
  Walking01_withElmos_B.ControlState.InDoubleSupport = 0.0;
  b_previousEvent = Walking01_withElmos_DW.sfEvent;
  Walking01_withElmos_DW.sfEvent = Walking01_withElm_event_LegSwap;
  if (Walking01_withElmos_DW.is_Main == Walking01_withElmos_IN_Run_k) {
    Walking01_withElmos_Run();
  }

  Walking01_withElmos_DW.sfEvent = b_previousEvent;
}

/*
 * Function for MATLAB Function: '<S200>/controller1'
 * function HAlpha = applyGaitTweaks2(ControlState, ControlParams, GetTweaks)
 */
static void Walking01_with_applyGaitTweaks2(real_T ControlState_ControllerMode,
  const real_T ControlParams_Supervisory_GaitT[5], const real_T
  ControlParams_Output_H0[78], const real_T ControlParams_Output_HAlpha[36],
  real_T HAlpha[36])
{
  real_T StanceKneeAngleBias;
  real_T SwingKneeAngleBias2;
  real_T TorsoBias;
  real_T QTweakVec[13];
  real_T QTweaks[78];
  int32_T ibtile;
  int32_T jtilecol;
  int32_T i;
  real_T SwingKeeAngleBias_idx_0;
  real_T SwingKeeAngleBias_idx_1;

  /*  APPLYGAITTWEAKS2 computes modified Bezier coefficients corresponding */
  /*  to a tweaked orbit. */
  /*  In order to handle different output definitions consistently, we */
  /*  create a matrix QTweak which represents Bezier coefficients for the */
  /*  desired modifications to the gait (i.e., there is one row for each */
  /*  coordinate in q). */
  /* 'applyGaitTweaks2:9' if nargin==2 */
  /* 'applyGaitTweaks2:10' GetTweaks = false; */
  /* 'applyGaitTweaks2:13' StanceKneeAngleBias = ControlParams.Supervisory.GaitTweaks(1) * pi/180; */
  StanceKneeAngleBias = ControlParams_Supervisory_GaitT[0] * 3.1415926535897931 /
    180.0;

  /* 'applyGaitTweaks2:14' SwingKneeAngleBias1 = ControlParams.Supervisory.GaitTweaks(2) * pi/180; */
  /* 'applyGaitTweaks2:15' SwingKneeAngleBias2 = ControlParams.Supervisory.GaitTweaks(3) * pi/180; */
  SwingKneeAngleBias2 = ControlParams_Supervisory_GaitT[2] * 3.1415926535897931 /
    180.0;

  /* 'applyGaitTweaks2:16' SwingKneeAngleBias3 = ControlParams.Supervisory.GaitTweaks(4) * pi/180; */
  /* 'applyGaitTweaks2:17' TorsoBias           = ControlParams.Supervisory.GaitTweaks(5) * pi/180; */
  TorsoBias = ControlParams_Supervisory_GaitT[4] * 3.1415926535897931 / 180.0;

  /* 'applyGaitTweaks2:19' QTweakVec = [... */
  /* 'applyGaitTweaks2:20'         0; ... */
  /* 'applyGaitTweaks2:21'         0; ... */
  /* 'applyGaitTweaks2:22'         TorsoBias; ... */
  /* 'applyGaitTweaks2:23'         -StanceKneeAngleBias/2 - TorsoBias; ... */
  /* 'applyGaitTweaks2:24'         StanceKneeAngleBias/2 - TorsoBias; ... */
  /* 'applyGaitTweaks2:25'         -StanceKneeAngleBias/2 - TorsoBias; ... */
  /* 'applyGaitTweaks2:26'         StanceKneeAngleBias/2 - TorsoBias; ... */
  /* 'applyGaitTweaks2:27'         -StanceKneeAngleBias/2 - TorsoBias; ... */
  /* 'applyGaitTweaks2:28'         StanceKneeAngleBias/2 - TorsoBias; ... */
  /* 'applyGaitTweaks2:29'         0; ... */
  /* 'applyGaitTweaks2:30'         -StanceKneeAngleBias/2 - TorsoBias; ... */
  /* 'applyGaitTweaks2:31'         StanceKneeAngleBias/2 - TorsoBias; ... */
  /* 'applyGaitTweaks2:32'         0]; */
  QTweakVec[0] = 0.0;
  QTweakVec[1] = 0.0;
  QTweakVec[2] = TorsoBias;
  QTweakVec[3] = -StanceKneeAngleBias / 2.0 - TorsoBias;
  QTweakVec[4] = StanceKneeAngleBias / 2.0 - TorsoBias;
  QTweakVec[5] = -StanceKneeAngleBias / 2.0 - TorsoBias;
  QTweakVec[6] = StanceKneeAngleBias / 2.0 - TorsoBias;
  QTweakVec[7] = -StanceKneeAngleBias / 2.0 - TorsoBias;
  QTweakVec[8] = StanceKneeAngleBias / 2.0 - TorsoBias;
  QTweakVec[9] = 0.0;
  QTweakVec[10] = -StanceKneeAngleBias / 2.0 - TorsoBias;
  QTweakVec[11] = StanceKneeAngleBias / 2.0 - TorsoBias;
  QTweakVec[12] = 0.0;

  /* 'applyGaitTweaks2:33' QTweaks = repmat(QTweakVec, 1, 6); */
  for (jtilecol = 0; jtilecol < 6; jtilecol++) {
    ibtile = jtilecol * 13;
    memcpy(&QTweaks[ibtile], &QTweakVec[0], 13U * sizeof(real_T));
  }

  /* 'applyGaitTweaks2:35' if (ControlState.ControllerMode == 4) */
  if (ControlState_ControllerMode == 4.0) {
    /* 'applyGaitTweaks2:36' SwingKeeAngleBias = [SwingKneeAngleBias1 SwingKneeAngleBias2 SwingKneeAngleBias2 SwingKneeAngleBias3]/2; */
    SwingKeeAngleBias_idx_0 = ControlParams_Supervisory_GaitT[1] *
      3.1415926535897931 / 180.0 / 2.0;
    SwingKeeAngleBias_idx_1 = SwingKneeAngleBias2 / 2.0;
    StanceKneeAngleBias = SwingKneeAngleBias2 / 2.0;
    SwingKneeAngleBias2 = ControlParams_Supervisory_GaitT[3] *
      3.1415926535897931 / 180.0 / 2.0;

    /* 'applyGaitTweaks2:37' QTweaks(6,2:5)  = -SwingKeeAngleBias - TorsoBias; */
    QTweaks[18] = -SwingKeeAngleBias_idx_0 - TorsoBias;
    QTweaks[31] = -SwingKeeAngleBias_idx_1 - TorsoBias;
    QTweaks[44] = -StanceKneeAngleBias - TorsoBias;
    QTweaks[57] = -SwingKneeAngleBias2 - TorsoBias;

    /* 'applyGaitTweaks2:38' QTweaks(7,2:5)  =  SwingKeeAngleBias - TorsoBias; */
    QTweaks[19] = SwingKeeAngleBias_idx_0 - TorsoBias;
    QTweaks[32] = SwingKeeAngleBias_idx_1 - TorsoBias;
    QTweaks[45] = StanceKneeAngleBias - TorsoBias;
    QTweaks[58] = SwingKneeAngleBias2 - TorsoBias;

    /* 'applyGaitTweaks2:39' QTweaks(11,2:5) = -SwingKeeAngleBias - TorsoBias; */
    QTweaks[23] = -SwingKeeAngleBias_idx_0 - TorsoBias;
    QTweaks[36] = -SwingKeeAngleBias_idx_1 - TorsoBias;
    QTweaks[49] = -StanceKneeAngleBias - TorsoBias;
    QTweaks[62] = -SwingKneeAngleBias2 - TorsoBias;

    /* 'applyGaitTweaks2:40' QTweaks(12,2:5) =  SwingKeeAngleBias - TorsoBias; */
    QTweaks[24] = SwingKeeAngleBias_idx_0 - TorsoBias;
    QTweaks[37] = SwingKeeAngleBias_idx_1 - TorsoBias;
    QTweaks[50] = StanceKneeAngleBias - TorsoBias;
    QTweaks[63] = SwingKneeAngleBias2 - TorsoBias;
  }

  /* 'applyGaitTweaks2:43' HAlpha = ControlParams.Output.H0 * QTweaks; */
  /* 'applyGaitTweaks2:44' if ~GetTweaks */
  /* 'applyGaitTweaks2:45' HAlpha = ControlParams.Output.HAlpha + HAlpha; */
  for (jtilecol = 0; jtilecol < 6; jtilecol++) {
    for (ibtile = 0; ibtile < 6; ibtile++) {
      StanceKneeAngleBias = 0.0;
      for (i = 0; i < 13; i++) {
        StanceKneeAngleBias += ControlParams_Output_H0[6 * i + jtilecol] *
          QTweaks[13 * ibtile + i];
      }

      HAlpha[jtilecol + 6 * ibtile] = ControlParams_Output_HAlpha[6 * ibtile +
        jtilecol] + StanceKneeAngleBias;
    }
  }
}

/*
 * Function for MATLAB Function: '<S200>/controller1'
 * function [s,ds,dsdq,th,dth,delta_theta,c]=ATRIAS3D_ZD_s6(t,q,dq,theta_limits,c)
 */
static void Walking01_withEl_ATRIAS3D_ZD_s6(real_T t, const real_T q[13], const
  real_T dq[13], const real_T theta_limits[2], const real_T c[15], real_T *s,
  real_T *ds, real_T dsdq[13], real_T *th, real_T *dth, real_T *delta_theta)
{
  real_T tmp[15];
  int32_T i;

  /*  NOTE: This function should work both with scalar and vector s. */
  /*  It should also work for both the full q and the zero dynamics qz. */
  /* 'ATRIAS3D_ZD_s6:5' if nargin<5 */
  /* 'ATRIAS3D_ZD_s6:11' if numel(theta_limits)==2 && iscolumn(theta_limits) */
  /* 'ATRIAS3D_ZD_s6:15' th  = c*[1; t; q]; */
  tmp[0] = 1.0;
  tmp[1] = t;
  memcpy(&tmp[2], &q[0], 13U * sizeof(real_T));
  *th = 0.0;
  for (i = 0; i < 15; i++) {
    *th += c[i] * tmp[i];
  }

  /* check offset */
  /* 'ATRIAS3D_ZD_s6:16' dth = c*[0; 1; dq]; */
  tmp[0] = 0.0;
  tmp[1] = 1.0;
  memcpy(&tmp[2], &dq[0], 13U * sizeof(real_T));
  *dth = 0.0;
  for (i = 0; i < 15; i++) {
    *dth += c[i] * tmp[i];
  }

  /* 'ATRIAS3D_ZD_s6:17' delta_theta = theta_limits(:,2)-theta_limits(:,1); */
  *delta_theta = theta_limits[1] - theta_limits[0];

  /* 'ATRIAS3D_ZD_s6:18' s    = (th-theta_limits(:,1))./delta_theta; */
  *s = (*th - theta_limits[0]) / *delta_theta;

  /* 'ATRIAS3D_ZD_s6:19' ds   = dth./delta_theta; */
  *ds = *dth / *delta_theta;

  /* 'ATRIAS3D_ZD_s6:20' dsdq = c(:,3:end)./(delta_theta*ones(1,length(q))); */
  for (i = 0; i < 13; i++) {
    dsdq[i] = c[2 + i] / *delta_theta;
  }
}

/* Function for MATLAB Function: '<S200>/controller1' */
static void Walking01_withElm_eml_li_find_e(boolean_T x, int32_T y_data[],
  int32_T y_sizes[2])
{
  int32_T k;
  k = 0;
  if (x) {
    k = 1;
  }

  y_sizes[0] = 1;
  y_sizes[1] = k;
  if (x) {
    y_data[0] = 1;
  }
}

/* Function for MATLAB Function: '<S200>/controller1' */
static void Walking01_withEl_eml_li_find_eu(const boolean_T x[6], int32_T
  y_data[], int32_T *y_sizes)
{
  int32_T j;
  int32_T i;
  *y_sizes = 0;
  for (j = 0; j < 6; j++) {
    if (x[j]) {
      (*y_sizes)++;
    }
  }

  j = 0;
  for (i = 0; i < 6; i++) {
    if (x[i]) {
      y_data[j] = i + 1;
      j++;
    }
  }
}

/*
 * Function for MATLAB Function: '<S200>/controller1'
 * function value = beziervd( afra, s )
 */
static void Walking01_withElmos_beziervd(const real_T afra[36], real_T s, real_T
  value[6])
{
  real_T x[5];
  real_T y[5];
  int32_T j;
  static const int8_T b[5] = { 5, 20, 30, 20, 5 };

  int32_T i;

  /* 'beziervd:2' [n, m] = size(afra); */
  /* 'beziervd:3' ns = size(s,1); */
  /* 'beziervd:4' value=zeros(n,1); */
  for (i = 0; i < 6; i++) {
    value[i] = 0.0;
  }

  /* 'beziervd:5' M = m-1; */
  /* 'beziervd:6' if M==3 */
  /* 'beziervd:10' elseif M==5 */
  /* 'beziervd:11' k=[5 20 30 20 5]; */
  /* % */
  /* 'beziervd:24' x = ones(ns, M); */
  /* 'beziervd:25' y = ones(ns, M); */
  for (i = 0; i < 5; i++) {
    x[i] = 1.0;
    y[i] = 1.0;
  }

  /* 'beziervd:26' for i=1:M-1 */
  /* 'beziervd:27' x(:,i+1)=s.*x(:,i); */
  x[1] = s;

  /* 'beziervd:28' y(:,i+1)=(1-s).*y(:,i); */
  y[1] = 1.0 - s;

  /* 'beziervd:27' x(:,i+1)=s.*x(:,i); */
  x[2] = s * s;

  /* 'beziervd:28' y(:,i+1)=(1-s).*y(:,i); */
  y[2] = (1.0 - s) * (1.0 - s);

  /* 'beziervd:27' x(:,i+1)=s.*x(:,i); */
  x[3] = s * x[2];

  /* 'beziervd:28' y(:,i+1)=(1-s).*y(:,i); */
  y[3] = (1.0 - s) * y[2];

  /* 'beziervd:27' x(:,i+1)=s.*x(:,i); */
  x[4] = s * x[3];

  /* 'beziervd:28' y(:,i+1)=(1-s).*y(:,i); */
  y[4] = (1.0 - s) * y[3];

  /* 'beziervd:30' idx = 1; */
  /* 'beziervd:31' for i=1:n */
  for (i = 0; i < 6; i++) {
    /* 'beziervd:32' value(i) = 0; */
    value[i] = 0.0;

    /* 'beziervd:33' for j=1:M */
    for (j = 0; j < 5; j++) {
      /* 'beziervd:34' value(i) = value(i) + (afra(i,j+1)-afra(i,j))*k(j)*x(idx,j)*y(idx,M+1-j); */
      value[i] += (afra[(1 + j) * 6 + i] - afra[6 * j + i]) * (real_T)b[j] * x[j]
        * y[4 - j];
    }

    /* 'beziervd:36' idx = idx+(ns==n); */
  }
}

/*
 * Function for MATLAB Function: '<S200>/controller1'
 * function value = bezier( afra, s )
 */
static real_T Walking01_withElmos_bezier(const real_T afra[20], real_T s)
{
  real_T value;
  real_T x[20];
  real_T y[20];
  int32_T i;
  static const int32_T b[20] = { 1, 19, 171, 969, 3876, 11628, 27132, 50388,
    75582, 92378, 92378, 75582, 50388, 27132, 11628, 3876, 969, 171, 19, 1 };

  /* 'bezier:2' [n, m] = size(afra); */
  /* 'bezier:3' value=zeros(n,1); */
  /* 'bezier:4' M = m-1; */
  /* 'bezier:5' if M==3 */
  /* 'bezier:23' else */
  /* 'bezier:24' k = binom(M); */
  /* %     */
  /* 'bezier:27' x = ones(1, M+1); */
  /* 'bezier:28' y = ones(1, M+1); */
  for (i = 0; i < 20; i++) {
    x[i] = 1.0;
    y[i] = 1.0;
  }

  /* 'bezier:29' for i=1:M */
  for (i = 0; i < 19; i++) {
    /* 'bezier:30' x(i+1)=s*x(i); */
    x[1 + i] = s * x[i];

    /* 'bezier:31' y(i+1)=(1-s)*y(i); */
    y[1 + i] = (1.0 - s) * y[i];
  }

  /* 'bezier:33' for i=1:n */
  /* 'bezier:34' value(i) = 0; */
  value = 0.0;

  /* 'bezier:35' for j=1:M+1 */
  for (i = 0; i < 20; i++) {
    /* 'bezier:36' value(i) = value(i) + afra(i, j)*k(j)*x(j)*y(M+2-j); */
    value += afra[i] * (real_T)b[i] * x[i] * y[19 - i];
  }

  return value;
}

/*
 * Function for MATLAB Function: '<S200>/controller1'
 * function value = polyvd( poly_cor, s, s_corr_max)
 */
static void Walking01_withElmos_polyvd(const real_T poly_cor[30], real_T s,
  real_T s_corr_max, real_T value[6])
{
  real_T tmp;
  int32_T s_0;
  int32_T i;

  /* 'polyvd:2' if nargin<3 */
  /* 'polyvd:5' a1=poly_cor(:,2); */
  /* 'polyvd:6' a2=poly_cor(:,3); */
  /* 'polyvd:7' a3=poly_cor(:,4); */
  /* 'polyvd:8' a4=poly_cor(:,5); */
  /* 'polyvd:9' value=a1+s.*(2*a2+s.*(3*a3+4*s.*a4)); */
  /* 'polyvd:10' value=value.*(s<=s_corr_max); */
  tmp = 4.0 * s;
  s_0 = (s <= s_corr_max);
  for (i = 0; i < 6; i++) {
    value[i] = (((poly_cor[18 + i] * 3.0 + poly_cor[24 + i] * tmp) * s +
                 poly_cor[12 + i] * 2.0) * s + poly_cor[6 + i]) * (real_T)s_0;
  }
}

/*
 * Function for MATLAB Function: '<S200>/controller1'
 * function value = polyva( poly_cor, s, s_corr_max )
 */
static void Walking01_withElmos_polyva(const real_T poly_cor[30], real_T s,
  real_T s_corr_max, real_T value[6])
{
  real_T tmp;
  int32_T s_0;
  int32_T i;

  /* 'polyva:2' if nargin<3 */
  /* 'polyva:5' a2  = poly_cor(:,3); */
  /* 'polyva:6' a3  = poly_cor(:,4); */
  /* 'polyva:7' a4  = poly_cor(:,5); */
  /* 'polyva:8' value=2*a2+s.*(6*a3+12*s.*a4); */
  /* 'polyva:9' value=value.*(s<=s_corr_max); */
  tmp = 12.0 * s;
  s_0 = (s <= s_corr_max);
  for (i = 0; i < 6; i++) {
    value[i] = ((poly_cor[18 + i] * 6.0 + poly_cor[24 + i] * tmp) * s +
                poly_cor[12 + i] * 2.0) * (real_T)s_0;
  }
}

/*
 * Function for MATLAB Function: '<S200>/controller1'
 * function value = polyv( poly_cor,s,s_corr_max)
 */
static void Walking01_withElmos_polyv(const real_T poly_cor[30], real_T s,
  real_T s_corr_max, real_T value[6])
{
  int32_T s_0;
  int32_T i;

  /* 'polyv:2' if nargin<3 */
  /* 'polyv:5' a0=poly_cor(:,1); */
  /* 'polyv:6' a1=poly_cor(:,2); */
  /* 'polyv:7' a2=poly_cor(:,3); */
  /* 'polyv:8' a3=poly_cor(:,4); */
  /* 'polyv:9' a4=poly_cor(:,5); */
  /* 'polyv:10' value=a0+s.*(a1+s.*(a2+s.*(a3+s.*a4))); */
  /* 'polyv:11' value=value.*(s<=s_corr_max); */
  s_0 = (s <= s_corr_max);
  for (i = 0; i < 6; i++) {
    value[i] = ((((poly_cor[24 + i] * s + poly_cor[18 + i]) * s + poly_cor[12 +
                  i]) * s + poly_cor[6 + i]) * s + poly_cor[i]) * (real_T)s_0;
  }
}

/*
 * Function for MATLAB Function: '<S200>/controller1'
 * function y = sat(x,lo,hi)
 */
static void Walking01_withElmos_sat(const real_T x[6], const real_T lo[6], const
  real_T hi[6], real_T y[6])
{
  int32_T k;
  real_T minval;

  /* 'ATRIAS3D_ZD_Output03:168' y = max(lo, min(x, hi)); */
  for (k = 0; k < 6; k++) {
    if ((x[k] <= hi[k]) || rtIsNaN(hi[k])) {
      minval = x[k];
    } else {
      minval = hi[k];
    }

    if ((lo[k] >= minval) || rtIsNaN(minval)) {
      y[k] = lo[k];
    } else {
      y[k] = minval;
    }
  }
}

/*
 * Function for MATLAB Function: '<S200>/controller1'
 * function value = bezierva( alpha, s )
 */
static void Walking01_withElmos_bezierva(const real_T alpha[36], real_T s,
  real_T value[6])
{
  int32_T i;
  real_T x_idx_2;
  real_T x_idx_3;
  real_T y_idx_2;
  real_T y_idx_3;
  real_T value_0;

  /* 'bezierva:2' [n, m] = size(alpha); */
  /* 'bezierva:3' ns = size(s,1); */
  /* 'bezierva:4' value=zeros(n,1); */
  /* 'bezierva:5' M = m-1; */
  /* 'bezierva:6' if M==3 */
  /* 'bezierva:10' elseif M==5 */
  /* 'bezierva:11' k = [20 60 60 20]; */
  /* % */
  /* 'bezierva:24' x = ones(ns, M-1); */
  /* 'bezierva:25' y = ones(ns, M-1); */
  /* 'bezierva:26' for i=1:M-2 */
  /* 'bezierva:27' x(:,i+1)=s.*x(:,i); */
  /* 'bezierva:28' y(:,i+1)=(1-s).*y(:,i); */
  /* 'bezierva:27' x(:,i+1)=s.*x(:,i); */
  x_idx_2 = s * s;

  /* 'bezierva:28' y(:,i+1)=(1-s).*y(:,i); */
  y_idx_2 = (1.0 - s) * (1.0 - s);

  /* 'bezierva:27' x(:,i+1)=s.*x(:,i); */
  x_idx_3 = s * x_idx_2;

  /* 'bezierva:28' y(:,i+1)=(1-s).*y(:,i); */
  y_idx_3 = (1.0 - s) * y_idx_2;

  /* 'bezierva:30' idx = 1; */
  /* 'bezierva:31' for i=1:n */
  for (i = 0; i < 6; i++) {
    /* 'bezierva:32' value(i) = 0; */
    /* 'bezierva:33' for j=1:M-1 */
    /* 'bezierva:34' value(i) = value(i) + (alpha(i,j+2)-2*alpha(i,j+1)+alpha(i,j)) *k(j)*x(idx,j)*y(idx,M-j); */
    value_0 = ((alpha[i + 30] - alpha[i + 24] * 2.0) + alpha[i + 18]) * 20.0 *
      x_idx_3 + (((alpha[i + 24] - alpha[i + 18] * 2.0) + alpha[i + 12]) * 60.0 *
                 x_idx_2 * (1.0 - s) + (((alpha[i + 18] - alpha[i + 12] * 2.0) +
      alpha[i + 6]) * 60.0 * s * y_idx_2 + ((alpha[i + 12] - alpha[i + 6] * 2.0)
      + alpha[i]) * 20.0 * y_idx_3));

    /* 'bezierva:36' idx = idx+(ns==n); */
    value[i] = value_0;
  }
}

/*
 * Function for MATLAB Function: '<S200>/controller1'
 * function value = bezierv( alpha, s )
 */
static void Walking01_withElmos_bezierv(const real_T alpha[36], real_T s, real_T
  value[6])
{
  real_T x[6];
  real_T y[6];
  int32_T j;
  static const int8_T b[6] = { 1, 5, 10, 10, 5, 1 };

  int32_T i;

  /* 'bezierv:2' [n, m] = size(alpha); */
  /* 'bezierv:3' ns = size(s,1); */
  /* 'bezierv:4' value=zeros(n,1); */
  /* 'bezierv:5' M = m-1; */
  /* 'bezierv:6' if M==3 */
  /* 'bezierv:10' elseif M==5 */
  /* 'bezierv:11' k=[1 5 10 10 5 1]; */
  /* % */
  /* 'bezierv:24' x = ones(ns, M+1); */
  /* 'bezierv:25' y = ones(ns, M+1); */
  for (i = 0; i < 6; i++) {
    value[i] = 0.0;
    x[i] = 1.0;
    y[i] = 1.0;
  }

  /* 'bezierv:26' for i=1:M */
  for (i = 0; i < 5; i++) {
    /* 'bezierv:27' x(:,i+1)=s.*x(:,i); */
    x[1 + i] = s * x[i];

    /* 'bezierv:28' y(:,i+1)=(1-s).*y(:,i); */
    y[1 + i] = (1.0 - s) * y[i];
  }

  /* 'bezierv:30' idx = 1; */
  /* 'bezierv:31' for i=1:n */
  for (i = 0; i < 6; i++) {
    /* 'bezierv:32' value(i) = 0; */
    value[i] = 0.0;

    /* 'bezierv:33' for j=1:M+1 */
    for (j = 0; j < 6; j++) {
      /* 'bezierv:34' value(i) = value(i) + alpha(i, j)*k(j)*x(idx,j)*y(idx,M+2-j); */
      value[i] += alpha[6 * j + i] * (real_T)b[j] * x[j] * y[5 - j];
    }

    /* 'bezierv:36' idx = idx+(ns==n); */
  }
}

/* Function for MATLAB Function: '<S200>/controller1' */
static boolean_T Walking01_withElmos_any_o(boolean_T x)
{
  return !(x == 0);
}

/*
 * Function for MATLAB Function: '<S200>/controller1'
 * function [s,ds,h0,y,dy,jacob_h0,jacob_h,s_unsaturated,theta,dtheta,delta_theta,dsdq,jacob_jacobhdqdq,phi,r,dr,hdbar] = ATRIAS3D_ZD_Output03(t, q, dq, ControlState, ControlParams, sprev)
 */
static void Walking01__ATRIAS3D_ZD_Output03(real_T t, const real_T q[13], const
  real_T dq[13], real_T ControlState_StanceLeg, const OutputParamsBus
  *ControlParams_Output, real_T sprev, real_T *s, real_T *ds, real_T h0[6],
  real_T y[6], real_T dy[6], real_T jacob_h0[78], real_T jacob_h[78], real_T
  *s_unsaturated, real_T *theta, real_T *dtheta, real_T *delta_theta, real_T
  dsdq[13], real_T jacob_jacobhdqdq[6], real_T *phi, real_T *r, real_T *dr,
  real_T hdbar[6])
{
  real_T T0[36];
  real_T c[15];
  real_T h_alpha[36];
  real_T h_alpha_high[36];
  real_T qmod[13];
  real_T jacob_hd[6];
  real_T dhd[6];
  boolean_T RSaturated;
  real_T jacob_hdbar[6];
  real_T jacob2_hdbar[6];
  boolean_T idxsat[6];
  real_T b;
  real_T d;
  real_T e;
  real_T g;
  real_T a;
  real_T c_c;
  static const real_T hd_min[6] = { 2.6179938779914944, 2.6179938779914944,
    0.26179938779914941, 0.26179938779914941, -0.3490658503988659,
    -0.3490658503988659 };

  static const real_T hd_max[6] = { 3.839724354387525, 3.839724354387525,
    2.0943951023931953, 2.0943951023931953, 0.3490658503988659,
    0.3490658503988659 };

  static const real_T b_T0[36] = { 0.5, 0.0, -1.0, 0.0, 0.0, 0.0, 0.5, 0.0, 1.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.5, 0.0, -1.0, 0.0, 0.0,
    0.0, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 };

  static const real_T h[36] = { 0.0, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0, 0.5, 0.0,
    1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0,
    0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 };

  static const int8_T i[13] = { 0, 1, 2, 5, 6, 3, 4, 10, 11, 12, 7, 8, 9 };

  static const real_T c_b[6] = { -1.0, -0.8, -0.6, -0.4, -0.2, 0.0 };

  int32_T i_0;
  real_T tmp[6];
  real_T tmp_0[6];
  boolean_T s_0[6];
  int32_T i_1;
  real_T jacob_h0_0[78];
  real_T jacob_hdbar_0[78];
  real_T ds_0;
  int32_T f_data;
  int32_T f_sizes[2];
  int32_T tmp_data[6];
  int32_T tmp_sizes;
  int32_T tmp_data_0[6];
  real_T h_alpha_data[36];

  /* 'ATRIAS3D_ZD_Output03:4' Output = ControlParams.Output; */
  /*  Define matrix to convert between motor and standard actuated coordinates */
  /*  [uLAst; uLAsw; uKAst; uKAsw; u3st; u3sw] = T0*[u1R; u2R; u3R; u1L; u2L; u3L] */
  /* 'ATRIAS3D_ZD_Output03:8' T0 = [0.5 0.5 0 0 0 0; 0 0 0 0.5 0.5 0; -1 1 0 0 0 0; 0 0 0 -1 1 0; 0 0 1 0 0 0; 0 0 0 0 0 1]; */
  memcpy(&T0[0], &b_T0[0], 36U * sizeof(real_T));

  /* 'ATRIAS3D_ZD_Output03:9' if (ControlState.StanceLeg==1) */
  if (ControlState_StanceLeg == 1.0) {
    /* 'ATRIAS3D_ZD_Output03:10' T0 = T0([2 1 4 3 6 5],:); */
    memcpy(&T0[0], &h[0], 36U * sizeof(real_T));
  }

  /* 'ATRIAS3D_ZD_Output03:12' T1 = [zeros(6,7) T0]; */
  /*     %% Compute s and modify Bezier parameters to extend outside 0 <= s <= 1 */
  /* [Sy,Sq] = SymmetryMatrices(); */
  /* 'ATRIAS3D_ZD_Output03:16' if (ControlState.StanceLeg==0) */
  if (ControlState_StanceLeg == 0.0) {
    /* 'ATRIAS3D_ZD_Output03:17' c = [Output.Theta.c0 Output.Theta.ct Output.Theta.cq]; */
    c[0] = ControlParams_Output->Theta.c0;
    c[1] = ControlParams_Output->Theta.ct;
    for (i_1 = 0; i_1 < 13; i_1++) {
      c[i_1 + 2] = ControlParams_Output->Theta.cq[i_1];
    }

    /* 'ATRIAS3D_ZD_Output03:18' jacob_h0 = Output.H0; */
    for (i_1 = 0; i_1 < 78; i_1++) {
      jacob_h0[i_1] = ControlParams_Output->H0[i_1];
    }
  } else {
    /* 'ATRIAS3D_ZD_Output03:19' else */
    /* 'ATRIAS3D_ZD_Output03:20' c = [Output.Theta.c0 Output.Theta.ct Output.Theta.cq(:,[1 2 3 6 7 4 5 11 12 13 8 9 10])]; */
    c[0] = ControlParams_Output->Theta.c0;
    c[1] = ControlParams_Output->Theta.ct;
    for (i_1 = 0; i_1 < 13; i_1++) {
      c[i_1 + 2] = ControlParams_Output->Theta.cq[i[i_1]];
    }

    /* 'ATRIAS3D_ZD_Output03:21' c(:,3:4) = -c(:,3:4); */
    c[2] = -c[2];
    c[3] = -c[3];

    /* 'ATRIAS3D_ZD_Output03:22' jacob_h0 = Output.H0(:,[1 2 3 6 7 4 5 11 12 13 8 9 10]); */
    for (i_1 = 0; i_1 < 13; i_1++) {
      for (i_0 = 0; i_0 < 6; i_0++) {
        jacob_h0[i_0 + 6 * i_1] = ControlParams_Output->H0[6 * i[i_1] + i_0];
      }
    }

    /* 'ATRIAS3D_ZD_Output03:23' jacob_h0(:,1:2) = -jacob_h0(:,1:2); */
    for (i_1 = 0; i_1 < 2; i_1++) {
      for (i_0 = 0; i_0 < 6; i_0++) {
        jacob_h0[i_0 + 6 * i_1] = -ControlParams_Output->H0[6 * i[i_1] + i_0];
      }
    }
  }

  /* 'ATRIAS3D_ZD_Output03:27' [s,ds,dsdq,theta,dtheta,delta_theta] = ATRIAS3D_ZD_s6(t-Output.Theta.t0, q, dq, Output.ThetaLimits, c); */
  Walking01_withEl_ATRIAS3D_ZD_s6(t - ControlParams_Output->Theta.t0, q, dq,
    ControlParams_Output->ThetaLimits, c, s, ds, dsdq, theta, dtheta,
    delta_theta);

  /* 'ATRIAS3D_ZD_Output03:28' s_unsaturated = s; */
  *s_unsaturated = *s;

  /* 'ATRIAS3D_ZD_Output03:30' if (Output.EnforceIncreasingS) */
  if ((ControlParams_Output->EnforceIncreasingS != 0.0) && (!((*s >= sprev) ||
        rtIsNaN(sprev)))) {
    /* 'ATRIAS3D_ZD_Output03:31' s = max(s, sprev); */
    *s = sprev;
  }

  /* 'ATRIAS3D_ZD_Output03:34' h_alpha = Output.HAlpha; */
  for (i_1 = 0; i_1 < 36; i_1++) {
    h_alpha[i_1] = ControlParams_Output->HAlpha[i_1];
  }

  /* 'ATRIAS3D_ZD_Output03:35' if (ControlState.StanceLeg==1) */
  /* 'ATRIAS3D_ZD_Output03:39' if Output.SaturateS==1 */
  if (ControlParams_Output->SaturateS == 1.0) {
    /* delta = 0.2; */
    /* p = [0.2  -0.4  0.2  0]; % coefficients of transition poly */
    /* [s, ds] = softsaturate(s, ds, delta, p); */
    /*  Modified Feb. 4th, 2014 for interpolative bezier table bounds. */
    /* 'ATRIAS3D_ZD_Output03:44' delta = 0.1; */
    /* 'ATRIAS3D_ZD_Output03:45' ds(s>1+delta) = 0; */
    e = *ds;
    Walking01_withElm_eml_li_find_e(*s > 1.1, &f_data, f_sizes);
    i_0 = f_sizes[0] * f_sizes[1];
    for (i_1 = 0; i_1 < i_0; i_1++) {
      e = 0.0;
    }

    /* 'ATRIAS3D_ZD_Output03:46' s(s>1+delta) = 1+delta; */
    b = *s;
    Walking01_withElm_eml_li_find_e(*s > 1.1, &f_data, f_sizes);
    i_0 = f_sizes[0] * f_sizes[1];
    for (i_1 = 0; i_1 < i_0; i_1++) {
      b = 1.1;
    }

    /* 'ATRIAS3D_ZD_Output03:47' ds(s<-delta) = 0; */
    g = e;
    Walking01_withElm_eml_li_find_e(b < -0.1, &f_data, f_sizes);
    i_0 = f_sizes[0] * f_sizes[1];
    for (i_1 = 0; i_1 < i_0; i_1++) {
      g = 0.0;
    }

    *ds = g;

    /* 'ATRIAS3D_ZD_Output03:48' s(s<-delta) = -delta; */
    d = b;
    Walking01_withElm_eml_li_find_e(b < -0.1, &f_data, f_sizes);
    i_0 = f_sizes[0] * f_sizes[1];
    for (i_1 = 0; i_1 < i_0; i_1++) {
      d = -0.1;
    }

    *s = d;
  } else if (ControlParams_Output->SaturateS == 2.0) {
    /* 'ATRIAS3D_ZD_Output03:50' elseif Output.SaturateS==2 */
    /* 'ATRIAS3D_ZD_Output03:51' if (length(s)>1) */
    /* 'ATRIAS3D_ZD_Output03:54' else */
    /* 'ATRIAS3D_ZD_Output03:55' dqyTds = repmat((c(1,5)*delta_theta), 2, 1); */
    a = c[4] * *delta_theta;

    /* 'ATRIAS3D_ZD_Output03:56' s6 = repmat(s, 6, 1); */
    /*  If (s>1), hold the desired knee angles constant and keep the */
    /*  torso angle fixed by decreasing the desired leg angles */
    /* 'ATRIAS3D_ZD_Output03:61' h_alpha_high = h_alpha(:,end)*[1 1 1 1 1 1]; */
    for (i_1 = 0; i_1 < 6; i_1++) {
      for (i_0 = 0; i_0 < 6; i_0++) {
        h_alpha_high[i_1 + 6 * i_0] = ControlParams_Output->HAlpha[30 + i_1];
      }
    }

    /* 'ATRIAS3D_ZD_Output03:62' h_alpha_high(1:2,:) = h_alpha_high(1:2,:)+dqyTds*(-1:0.2:0); */
    for (i_1 = 0; i_1 < 2; i_1++) {
      for (i_0 = 0; i_0 < 6; i_0++) {
        h_alpha_high[i_1 + 6 * i_0] += a * c_b[i_0];
      }
    }

    /* 'ATRIAS3D_ZD_Output03:63' h_alpha_high(1:2) = max(150*pi/180, h_alpha_high(1:2)); */
    a = h_alpha_high[1];
    if ((2.6179938779914944 >= h_alpha_high[0]) || rtIsNaN(h_alpha_high[0])) {
      h_alpha_high[0] = 2.6179938779914944;
    }

    if ((2.6179938779914944 >= a) || rtIsNaN(a)) {
      h_alpha_high[1] = 2.6179938779914944;
    } else {
      h_alpha_high[1] = a;
    }

    /* 'ATRIAS3D_ZD_Output03:64' h_alpha(s6>1,:) = h_alpha_high(s6>1,:); */
    for (i_1 = 0; i_1 < 6; i_1++) {
      idxsat[i_1] = (*s > 1.0);
      s_0[i_1] = (*s > 1.0);
    }

    Walking01_withEl_eml_li_find_eu(idxsat, tmp_data, &tmp_sizes);
    Walking01_withEl_eml_li_find_eu(s_0, tmp_data_0, &tmp_sizes);
    for (i_1 = 0; i_1 < 6; i_1++) {
      for (i_0 = 0; i_0 < tmp_sizes; i_0++) {
        h_alpha[(tmp_data[i_0] + 6 * i_1) - 1] = h_alpha_high[(6 * i_1 +
          tmp_data_0[i_0]) - 1];
      }
    }

    /*  If (s<0), hold all desired angles constant */
    /* 'ATRIAS3D_ZD_Output03:67' h_alpha_low = h_alpha(:,1)*[1 1 1 1 1 1]; */
    /* 'ATRIAS3D_ZD_Output03:68' h_alpha(s6<0,:) = h_alpha_low(s6<0,:); */
    for (i_1 = 0; i_1 < 6; i_1++) {
      idxsat[i_1] = (*s < 0.0);
      s_0[i_1] = (*s < 0.0);
    }

    Walking01_withEl_eml_li_find_eu(idxsat, tmp_data, &tmp_sizes);
    Walking01_withEl_eml_li_find_eu(s_0, tmp_data_0, &tmp_sizes);
    for (i_1 = 0; i_1 < 6; i_1++) {
      for (i_0 = 0; i_0 < 6; i_0++) {
        h_alpha_high[i_1 + 6 * i_0] = h_alpha[i_1];
      }
    }

    for (i_1 = 0; i_1 < 6; i_1++) {
      for (i_0 = 0; i_0 < tmp_sizes; i_0++) {
        h_alpha_data[i_0 + tmp_sizes * i_1] = h_alpha_high[(6 * i_1 +
          tmp_data_0[i_0]) - 1];
      }
    }

    for (i_1 = 0; i_1 < 6; i_1++) {
      for (i_0 = 0; i_0 < tmp_sizes; i_0++) {
        h_alpha[(tmp_data[i_0] + 6 * i_1) - 1] = h_alpha_data[tmp_sizes * i_1 +
          i_0];
      }
    }
  } else {
    if (ControlParams_Output->SaturateS == 3.0) {
      /* 'ATRIAS3D_ZD_Output03:70' elseif Output.SaturateS==3 */
      /* 'ATRIAS3D_ZD_Output03:71' smin = Output.SLimits(1); */
      /* 'ATRIAS3D_ZD_Output03:72' smax = Output.SLimits(2); */
      /* 'ATRIAS3D_ZD_Output03:73' ds(s>smax) = 0; */
      e = *ds;
      Walking01_withElm_eml_li_find_e(*s > ControlParams_Output->SLimits[1],
        &f_data, f_sizes);
      i_0 = f_sizes[0] * f_sizes[1];
      for (i_1 = 0; i_1 < i_0; i_1++) {
        e = 0.0;
      }

      /* 'ATRIAS3D_ZD_Output03:74' s(s>smax)  = smax; */
      b = *s;
      Walking01_withElm_eml_li_find_e(*s > ControlParams_Output->SLimits[1],
        &f_data, f_sizes);
      i_0 = f_sizes[0] * f_sizes[1];
      for (i_1 = 0; i_1 < i_0; i_1++) {
        b = ControlParams_Output->SLimits[1];
      }

      /* 'ATRIAS3D_ZD_Output03:75' ds(s<smin) = 0; */
      g = e;
      Walking01_withElm_eml_li_find_e(b < ControlParams_Output->SLimits[0],
        &f_data, f_sizes);
      i_0 = f_sizes[0] * f_sizes[1];
      for (i_1 = 0; i_1 < i_0; i_1++) {
        g = 0.0;
      }

      *ds = g;

      /* 'ATRIAS3D_ZD_Output03:76' s(s<smin)  = smin; */
      d = b;
      Walking01_withElm_eml_li_find_e(b < ControlParams_Output->SLimits[0],
        &f_data, f_sizes);
      i_0 = f_sizes[0] * f_sizes[1];
      for (i_1 = 0; i_1 < i_0; i_1++) {
        d = ControlParams_Output->SLimits[0];
      }

      *s = d;
    }
  }

  /*     %% Compute terms in controller */
  /* 'ATRIAS3D_ZD_Output03:80' qmod = q; */
  memcpy(&qmod[0], &q[0], 13U * sizeof(real_T));

  /* 'ATRIAS3D_ZD_Output03:81' qmod(1) = sat(qmod(1), -Output.YawLimit, Output.YawLimit); */
  /* 'ATRIAS3D_ZD_Output03:168' y = max(lo, min(x, hi)); */
  if ((q[0] <= ControlParams_Output->YawLimit) || rtIsNaN
      (ControlParams_Output->YawLimit)) {
    a = q[0];
  } else {
    a = ControlParams_Output->YawLimit;
  }

  if ((-ControlParams_Output->YawLimit >= a) || rtIsNaN(a)) {
    qmod[0] = -ControlParams_Output->YawLimit;
  } else {
    qmod[0] = a;
  }

  /* 'ATRIAS3D_ZD_Output03:82' h0 = jacob_h0*qmod; */
  /* 'ATRIAS3D_ZD_Output03:83' hd = bezierv(h_alpha, s); */
  /* 'ATRIAS3D_ZD_Output03:84' jacob_hd  = beziervd(h_alpha,s); */
  Walking01_withElmos_beziervd(h_alpha, *s, jacob_hd);

  /* 'ATRIAS3D_ZD_Output03:85' jacob2_hd = bezierva(h_alpha,s); */
  /* 'ATRIAS3D_ZD_Output03:86' dhd = jacob_hd.*ds; */
  for (i_1 = 0; i_1 < 6; i_1++) {
    h0[i_1] = 0.0;
    for (i_0 = 0; i_0 < 13; i_0++) {
      h0[i_1] += jacob_h0[6 * i_0 + i_1] * qmod[i_0];
    }

    dhd[i_1] = jacob_hd[i_1] * *ds;
  }

  /* 'ATRIAS3D_ZD_Output03:88' jacob_h = jacob_h0 - jacob_hd*dsdq; */
  /* 'ATRIAS3D_ZD_Output03:89' jacob_jacobhdqdq = -jacob2_hd.*(ds.*ds); */
  /*     %% Stabilizing output term */
  /*  Allow outputs of the form */
  /*    y = H0*q - hd(s(theta(q)), h_alpha) - hStabilizing(phi - phid(s(theta(q))), StabilizingHAlpha) */
  /* 'ATRIAS3D_ZD_Output03:95' phi    = Output.Phi.cq * q; */
  *phi = 0.0;
  for (i_1 = 0; i_1 < 13; i_1++) {
    *phi += ControlParams_Output->Phi.cq[i_1] * q[i_1];
  }

  /* 'ATRIAS3D_ZD_Output03:96' dphi   = Output.Phi.cq * dq; */
  a = 0.0;
  for (i_1 = 0; i_1 < 13; i_1++) {
    a += ControlParams_Output->Phi.cq[i_1] * dq[i_1];
  }

  /* 'ATRIAS3D_ZD_Output03:98' phid   = bezier(Output.PhiAlpha, s); */
  /* 'ATRIAS3D_ZD_Output03:99' jacob_phid = bezierd(Output.PhiAlpha, s); */
  /* 'ATRIAS3D_ZD_Output03:100' jacob2_phid = beziera(Output.PhiAlpha, s); */
  /* 'ATRIAS3D_ZD_Output03:102' r      = phi - phid; */
  *r = *phi - Walking01_withElmos_bezier(ControlParams_Output->PhiAlpha, *s);

  /* 'ATRIAS3D_ZD_Output03:103' dr     = dphi - jacob_phid * ds; */
  *dr = a - 0.0 * *ds;

  /* 'ATRIAS3D_ZD_Output03:104' RSaturated = false; */
  RSaturated = false;

  /* 'ATRIAS3D_ZD_Output03:105' if Output.SaturateR */
  if (ControlParams_Output->SaturateR != 0.0) {
    /* 'ATRIAS3D_ZD_Output03:106' if (r > Output.RLimits(2)) */
    if (*r > ControlParams_Output->RLimits[1]) {
      /* 'ATRIAS3D_ZD_Output03:107' r = Output.RLimits(2); */
      *r = ControlParams_Output->RLimits[1];

      /* 'ATRIAS3D_ZD_Output03:108' dr = 0; */
      *dr = 0.0;

      /* 'ATRIAS3D_ZD_Output03:109' RSaturated = true; */
      RSaturated = true;
    } else {
      if (*r < ControlParams_Output->RLimits[0]) {
        /* 'ATRIAS3D_ZD_Output03:110' elseif (r < Output.RLimits(1)) */
        /* 'ATRIAS3D_ZD_Output03:111' r = Output.RLimits(1); */
        *r = ControlParams_Output->RLimits[0];

        /* 'ATRIAS3D_ZD_Output03:112' dr = 0; */
        *dr = 0.0;

        /* 'ATRIAS3D_ZD_Output03:113' RSaturated = true; */
        RSaturated = true;
      }
    }
  }

  /* 'ATRIAS3D_ZD_Output03:117' hdbar  = polyv(Output.HBarAlpha, r, inf); */
  /* 'ATRIAS3D_ZD_Output03:118' if ~RSaturated */
  if (!RSaturated) {
    /* 'ATRIAS3D_ZD_Output03:119' jacob_hdbar = polyvd(Output.HBarAlpha, r, inf); */
    Walking01_withElmos_polyvd(ControlParams_Output->HBarAlpha, *r, (rtInf),
      jacob_hdbar);

    /* 'ATRIAS3D_ZD_Output03:120' jacob2_hdbar = polyva(Output.HBarAlpha, r, inf); */
    Walking01_withElmos_polyva(ControlParams_Output->HBarAlpha, *r, (rtInf),
      jacob2_hdbar);
  } else {
    /* 'ATRIAS3D_ZD_Output03:121' else */
    /* 'ATRIAS3D_ZD_Output03:122' jacob_hdbar = zeros(6,1); */
    /* 'ATRIAS3D_ZD_Output03:123' jacob2_hdbar = zeros(6,1); */
    for (i_0 = 0; i_0 < 6; i_0++) {
      jacob_hdbar[i_0] = 0.0;
      jacob2_hdbar[i_0] = 0.0;
    }
  }

  /* 'ATRIAS3D_ZD_Output03:126' hdbar = sat(hdbar, Output.HBarLimits(:,1), Output.HBarLimits(:,2)); */
  Walking01_withElmos_polyv(ControlParams_Output->HBarAlpha, *r, (rtInf), tmp_0);
  Walking01_withElmos_sat(tmp_0, *(real_T (*)[6])&
    ControlParams_Output->HBarLimits[0], *(real_T (*)[6])&
    ControlParams_Output->HBarLimits[6], hdbar);

  /* 'ATRIAS3D_ZD_Output03:127' idxsat = (hdbar == Output.HBarLimits(:,1)) | (hdbar == Output.HBarLimits(:,2)); */
  for (i_1 = 0; i_1 < 6; i_1++) {
    idxsat[i_1] = ((hdbar[i_1] == ControlParams_Output->HBarLimits[i_1]) ||
                   (ControlParams_Output->HBarLimits[6 + i_1] == hdbar[i_1]));
  }

  /* 'ATRIAS3D_ZD_Output03:128' jacob_hdbar(idxsat,:) = 0; */
  Walking01_withEl_eml_li_find_eu(idxsat, tmp_data, &i_0);
  for (i_1 = 0; i_1 < i_0; i_1++) {
    jacob_hdbar[tmp_data[i_1] - 1] = 0.0;
  }

  /* 'ATRIAS3D_ZD_Output03:129' jacob2_hdbar(idxsat,:) = 0; */
  Walking01_withEl_eml_li_find_eu(idxsat, tmp_data, &i_0);
  for (i_1 = 0; i_1 < i_0; i_1++) {
    jacob2_hdbar[tmp_data[i_1] - 1] = 0.0;
  }

  /* 'ATRIAS3D_ZD_Output03:131' hd = hd + hdbar; */
  /* 'ATRIAS3D_ZD_Output03:132' jacob_h = jacob_h - jacob_hdbar * (Output.Phi.cq - jacob_phid * dsdq); */
  for (i_1 = 0; i_1 < 13; i_1++) {
    qmod[i_1] = ControlParams_Output->Phi.cq[i_1] - 0.0 * dsdq[i_1];
  }

  for (i_1 = 0; i_1 < 6; i_1++) {
    for (i_0 = 0; i_0 < 13; i_0++) {
      jacob_h0_0[i_1 + 6 * i_0] = jacob_h0[6 * i_0 + i_1] - jacob_hd[i_1] *
        dsdq[i_0];
    }
  }

  for (i_1 = 0; i_1 < 6; i_1++) {
    for (i_0 = 0; i_0 < 13; i_0++) {
      jacob_hdbar_0[i_1 + 6 * i_0] = jacob_hdbar[i_1] * qmod[i_0];
    }
  }

  for (i_1 = 0; i_1 < 13; i_1++) {
    for (i_0 = 0; i_0 < 6; i_0++) {
      jacob_h[i_0 + 6 * i_1] = jacob_h0_0[6 * i_1 + i_0] - jacob_hdbar_0[6 * i_1
        + i_0];
    }
  }

  /* 'ATRIAS3D_ZD_Output03:133' jacob_jacobhdqdq = jacob_jacobhdqdq ... */
  /* 'ATRIAS3D_ZD_Output03:134'         + jacob_hdbar * jacob2_phid * ds^2 ... */
  /* 'ATRIAS3D_ZD_Output03:135'         + jacob2_hdbar * (-jacob_phid^2 * ds^2 - dphi^2 + jacob_phid * dphi * ds); */
  c_c = *ds * *ds;
  a = (*ds * *ds * -0.0 - a * a) + 0.0 * a * *ds;
  Walking01_withElmos_bezierva(h_alpha, *s, tmp_0);
  ds_0 = *ds * *ds;
  for (i_1 = 0; i_1 < 6; i_1++) {
    jacob_jacobhdqdq[i_1] = (jacob_hdbar[i_1] * 0.0 * c_c + -tmp_0[i_1] * ds_0)
      + jacob2_hdbar[i_1] * a;
  }

  /*     %% Saturate the desired leg/knee/hip angles */
  /* 'ATRIAS3D_ZD_Output03:138' hd_min = [150; 150;  15;  15; -20; -20]*pi/180; */
  /* 'ATRIAS3D_ZD_Output03:139' hd_max = [220; 220; 120; 120;  20;  20]*pi/180; */
  /* 'ATRIAS3D_ZD_Output03:140' sat_correction = (jacob_h0 - T1)*q; */
  for (i_1 = 0; i_1 < 7; i_1++) {
    for (i_0 = 0; i_0 < 6; i_0++) {
      jacob_hdbar_0[i_0 + 6 * i_1] = 0.0;
    }
  }

  for (i_1 = 0; i_1 < 6; i_1++) {
    for (i_0 = 0; i_0 < 6; i_0++) {
      jacob_hdbar_0[i_0 + 6 * (i_1 + 7)] = T0[6 * i_1 + i_0];
    }
  }

  for (i_1 = 0; i_1 < 13; i_1++) {
    for (i_0 = 0; i_0 < 6; i_0++) {
      jacob_h0_0[i_0 + 6 * i_1] = jacob_h0[6 * i_1 + i_0] - jacob_hdbar_0[6 *
        i_1 + i_0];
    }
  }

  /* 'ATRIAS3D_ZD_Output03:141' hd = sat(hd, hd_min + sat_correction, hd_max + sat_correction); */
  Walking01_withElmos_bezierv(h_alpha, *s, tmp_0);
  for (i_1 = 0; i_1 < 6; i_1++) {
    jacob_hd[i_1] = 0.0;
    for (i_0 = 0; i_0 < 13; i_0++) {
      jacob_hd[i_1] += jacob_h0_0[6 * i_0 + i_1] * q[i_0];
    }

    tmp[i_1] = tmp_0[i_1] + hdbar[i_1];
    jacob_hdbar[i_1] = hd_min[i_1] + jacob_hd[i_1];
    jacob2_hdbar[i_1] = hd_max[i_1] + jacob_hd[i_1];
  }

  Walking01_withElmos_sat(tmp, jacob_hdbar, jacob2_hdbar, y);

  /* 'ATRIAS3D_ZD_Output03:142' idxsat = (hd == hd_min + sat_correction) | (hd == hd_max + sat_correction); */
  for (i_0 = 0; i_0 < 6; i_0++) {
    idxsat[i_0] = ((hd_min[i_0] + jacob_hd[i_0] == y[i_0]) || (hd_max[i_0] +
      jacob_hd[i_0] == y[i_0]));
  }

  /* 'ATRIAS3D_ZD_Output03:143' dhd(idxsat) = 0; */
  Walking01_withEl_eml_li_find_eu(idxsat, tmp_data, &i_0);
  for (i_1 = 0; i_1 < i_0; i_1++) {
    dhd[tmp_data[i_1] - 1] = 0.0;
  }

  /* 'ATRIAS3D_ZD_Output03:144' jacob_h(idxsat) = jacob_h0(idxsat); */
  Walking01_withEl_eml_li_find_eu(idxsat, tmp_data, &tmp_sizes);
  Walking01_withEl_eml_li_find_eu(idxsat, tmp_data_0, &tmp_sizes);
  for (i_1 = 0; i_1 < tmp_sizes; i_1++) {
    jacob_h[tmp_data[i_1] - 1] = jacob_h0[tmp_data_0[i_1] - 1];
  }

  /*  jacob_hd(idxsat) = 0; */
  /*     %% */
  /* 'ATRIAS3D_ZD_Output03:147' y  = h0-hd; */
  for (i_1 = 0; i_1 < 6; i_1++) {
    y[i_1] = h0[i_1] - y[i_1];
  }

  /* 'ATRIAS3D_ZD_Output03:148' dy = jacob_h0*dq - dhd; */
  for (i_1 = 0; i_1 < 6; i_1++) {
    a = 0.0;
    for (i_0 = 0; i_0 < 13; i_0++) {
      a += jacob_h0[6 * i_0 + i_1] * dq[i_0];
    }

    dy[i_1] = a - dhd[i_1];
  }

  /*  Correction */
  /* 'ATRIAS3D_ZD_Output03:152' h_alpha_corr = Output.HAlphaCorrection; */
  /* 'ATRIAS3D_ZD_Output03:153' s_corr_max = Output.SMaxCorrection; */
  /* 'ATRIAS3D_ZD_Output03:154' if Output.UseCorrection && any(s <= s_corr_max) */
  if ((ControlParams_Output->UseCorrection != 0.0) && Walking01_withElmos_any_o(*
       s <= ControlParams_Output->SMaxCorrection)) {
    /* 'ATRIAS3D_ZD_Output03:155' y       = y       -  polyv( h_alpha_corr, s, s_corr_max); */
    Walking01_withElmos_polyv(ControlParams_Output->HAlphaCorrection, *s,
      ControlParams_Output->SMaxCorrection, tmp_0);

    /* 'ATRIAS3D_ZD_Output03:156' dy      = dy      -  polyvd(h_alpha_corr, s, s_corr_max).*ds; */
    Walking01_withElmos_polyvd(ControlParams_Output->HAlphaCorrection, *s,
      ControlParams_Output->SMaxCorrection, tmp);

    /* 'ATRIAS3D_ZD_Output03:157' jacob_jacobhdqdq = jacob_jacobhdqdq +  polyva(h_alpha_corr, s, s_corr_max).*(ds.*ds); */
    Walking01_withElmos_polyva(ControlParams_Output->HAlphaCorrection, *s,
      ControlParams_Output->SMaxCorrection, jacob_hdbar);
    ds_0 = *ds * *ds;
    for (i_1 = 0; i_1 < 6; i_1++) {
      y[i_1] -= tmp_0[i_1];
      dy[i_1] -= tmp[i_1] * *ds;
      jacob_jacobhdqdq[i_1] += jacob_hdbar[i_1] * ds_0;
    }

    /* 'ATRIAS3D_ZD_Output03:158' if (length(s)>1) */
    /* 'ATRIAS3D_ZD_Output03:160' else */
    /* 'ATRIAS3D_ZD_Output03:161' jacob_h = jacob_h - polyvd(h_alpha_corr, s, s_corr_max)*dsdq; */
    Walking01_withElmos_polyvd(ControlParams_Output->HAlphaCorrection, *s,
      ControlParams_Output->SMaxCorrection, tmp_0);
    for (i_1 = 0; i_1 < 6; i_1++) {
      for (i_0 = 0; i_0 < 13; i_0++) {
        jacob_h[i_1 + 6 * i_0] -= tmp_0[i_1] * dsdq[i_0];
      }
    }
  }
}

/* Function for MATLAB Function: '<S200>/controller1' */
static void Walking01_withElmos_mldivide_p(const real_T A[36], real_T B[6])
{
  real_T temp;
  real_T b_A[36];
  int8_T ipiv[6];
  int32_T j;
  int32_T c;
  int32_T ix;
  real_T s;
  int32_T jy;
  int32_T c_ix;
  int32_T d;
  int32_T ijA;
  int32_T b_kAcol;
  memcpy(&b_A[0], &A[0], 36U * sizeof(real_T));
  for (ix = 0; ix < 6; ix++) {
    ipiv[ix] = (int8_T)(1 + ix);
  }

  for (j = 0; j < 5; j++) {
    c = j * 7;
    jy = 0;
    ix = c;
    temp = fabs(b_A[c]);
    for (b_kAcol = 1; b_kAcol + 1 <= 6 - j; b_kAcol++) {
      ix++;
      s = fabs(b_A[ix]);
      if (s > temp) {
        jy = b_kAcol;
        temp = s;
      }
    }

    if (b_A[c + jy] != 0.0) {
      if (jy != 0) {
        ipiv[j] = (int8_T)((j + jy) + 1);
        ix = j;
        b_kAcol = j + jy;
        for (jy = 0; jy < 6; jy++) {
          temp = b_A[ix];
          b_A[ix] = b_A[b_kAcol];
          b_A[b_kAcol] = temp;
          ix += 6;
          b_kAcol += 6;
        }
      }

      ix = (c - j) + 6;
      for (b_kAcol = c + 1; b_kAcol + 1 <= ix; b_kAcol++) {
        b_A[b_kAcol] /= b_A[c];
      }
    }

    b_kAcol = c;
    jy = c + 6;
    for (ix = 1; ix <= 5 - j; ix++) {
      temp = b_A[jy];
      if (b_A[jy] != 0.0) {
        c_ix = c + 1;
        d = (b_kAcol - j) + 12;
        for (ijA = 7 + b_kAcol; ijA + 1 <= d; ijA++) {
          b_A[ijA] += b_A[c_ix] * -temp;
          c_ix++;
        }
      }

      jy += 6;
      b_kAcol += 6;
    }
  }

  for (ix = 0; ix < 5; ix++) {
    if (ix + 1 != ipiv[ix]) {
      temp = B[ix];
      B[ix] = B[ipiv[ix] - 1];
      B[ipiv[ix] - 1] = temp;
    }
  }

  for (ix = 0; ix < 6; ix++) {
    b_kAcol = 6 * ix;
    if (B[ix] != 0.0) {
      for (jy = ix + 1; jy + 1 < 7; jy++) {
        B[jy] -= b_A[jy + b_kAcol] * B[ix];
      }
    }
  }

  for (ix = 5; ix >= 0; ix += -1) {
    b_kAcol = 6 * ix;
    if (B[ix] != 0.0) {
      B[ix] /= b_A[ix + b_kAcol];
      for (jy = 0; jy + 1 <= ix; jy++) {
        B[jy] -= b_A[jy + b_kAcol] * B[ix];
      }
    }
  }
}

/*
 * Function for MATLAB Function: '<S204>/SmartSaturation'
 * function [u_opt,L_opt]= LA_LS_Revised_Saturation_Case_1(u_LS,u_LA,w,u1_min,u1_max,u2_min,u2_max)
 */
static void LA_LS_Revised_Saturation_Case_1(real_T u_LS, real_T u_LA, real_T w,
  real_T u_opt[2], real_T L_opt[4])
{
  /* %%%%%  03-Jun-2013 08:50:09 */
  /* %%% */
  /* ------------------------------------------------------ */
  /*  u_opt */
  /* 'LA_LS_Revised_Saturation_Case_1:9' u_opt = zeros(2,1); */
  /* 'LA_LS_Revised_Saturation_Case_1:10' u_opt(1) = - ((2*u_LS + u_LA*w)*(w - 4))/(8*w) - ((2*u_LS - u_LA*w)*(w + 4))/(8*w); */
  u_opt[0] = -((2.0 * u_LS + u_LA * w) * (w - 4.0)) / (8.0 * w) - (2.0 * u_LS -
    u_LA * w) * (w + 4.0) / (8.0 * w);

  /* 'LA_LS_Revised_Saturation_Case_1:11' u_opt(2) = ((2*u_LS + u_LA*w)*(w + 4))/(8*w) + ((2*u_LS - u_LA*w)*(w - 4))/(8*w); */
  u_opt[1] = (2.0 * u_LS + u_LA * w) * (w + 4.0) / (8.0 * w) + (2.0 * u_LS -
    u_LA * w) * (w - 4.0) / (8.0 * w);

  /* ------------------------------------------------------ */
  /*  L_opt */
  /* 'LA_LS_Revised_Saturation_Case_1:14' L_opt = zeros(4,1); */
  /* 'LA_LS_Revised_Saturation_Case_1:15' L_opt(1) = 0; */
  L_opt[0] = 0.0;

  /* 'LA_LS_Revised_Saturation_Case_1:16' L_opt(2) = 0; */
  L_opt[1] = 0.0;

  /* 'LA_LS_Revised_Saturation_Case_1:17' L_opt(3) = 0; */
  L_opt[2] = 0.0;

  /* 'LA_LS_Revised_Saturation_Case_1:18' L_opt(4) = 0; */
  L_opt[3] = 0.0;
}

/*
 * Function for MATLAB Function: '<S204>/SmartSaturation'
 * function [u_opt,L_opt]= LA_LS_Revised_Saturation_Case_2(u_LS,u_LA,w,u1_min,u1_max,u2_min,u2_max)
 */
static void LA_LS_Revised_Saturation_Case_2(real_T u_LS, real_T u_LA, real_T w,
  real_T u1_min, real_T u_opt[2], real_T L_opt[4])
{
  /* %%%%%  03-Jun-2013 08:50:11 */
  /* %%% */
  /* ------------------------------------------------------ */
  /*  u_opt */
  /* 'LA_LS_Revised_Saturation_Case_2:9' u_opt = zeros(2,1); */
  /* 'LA_LS_Revised_Saturation_Case_2:10' u_opt(1) = u1_min; */
  u_opt[0] = u1_min;

  /* 'LA_LS_Revised_Saturation_Case_2:11' u_opt(2) = (4*u1_min + 4*u_LS - u1_min*w + 2*u_LA*w)/(w + 4); */
  u_opt[1] = (((4.0 * u1_min + 4.0 * u_LS) - u1_min * w) + 2.0 * u_LA * w) / (w
    + 4.0);

  /* ------------------------------------------------------ */
  /*  L_opt */
  /* 'LA_LS_Revised_Saturation_Case_2:14' L_opt = zeros(4,1); */
  /* 'LA_LS_Revised_Saturation_Case_2:15' L_opt(1) = (8*u1_min*w - 8*u_LA*w + 4*u_LS*w)/(w + 4); */
  L_opt[0] = ((8.0 * u1_min * w - 8.0 * u_LA * w) + 4.0 * u_LS * w) / (w + 4.0);

  /* 'LA_LS_Revised_Saturation_Case_2:16' L_opt(2) = 0; */
  L_opt[1] = 0.0;

  /* 'LA_LS_Revised_Saturation_Case_2:17' L_opt(3) = 0; */
  L_opt[2] = 0.0;

  /* 'LA_LS_Revised_Saturation_Case_2:18' L_opt(4) = 0; */
  L_opt[3] = 0.0;
}

/*
 * Function for MATLAB Function: '<S204>/SmartSaturation'
 * function [u_opt,L_opt]= LA_LS_Revised_Saturation_Case_3(u_LS,u_LA,w,u1_min,u1_max,u2_min,u2_max)
 */
static void LA_LS_Revised_Saturation_Case_3(real_T u_LS, real_T u_LA, real_T w,
  real_T u1_max, real_T u_opt[2], real_T L_opt[4])
{
  /* %%%%%  03-Jun-2013 08:50:11 */
  /* %%% */
  /* ------------------------------------------------------ */
  /*  u_opt */
  /* 'LA_LS_Revised_Saturation_Case_3:9' u_opt = zeros(2,1); */
  /* 'LA_LS_Revised_Saturation_Case_3:10' u_opt(1) = u1_max; */
  u_opt[0] = u1_max;

  /* 'LA_LS_Revised_Saturation_Case_3:11' u_opt(2) = (4*u1_max + 4*u_LS - u1_max*w + 2*u_LA*w)/(w + 4); */
  u_opt[1] = (((4.0 * u1_max + 4.0 * u_LS) - u1_max * w) + 2.0 * u_LA * w) / (w
    + 4.0);

  /* ------------------------------------------------------ */
  /*  L_opt */
  /* 'LA_LS_Revised_Saturation_Case_3:14' L_opt = zeros(4,1); */
  /* 'LA_LS_Revised_Saturation_Case_3:15' L_opt(1) = 0; */
  L_opt[0] = 0.0;

  /* 'LA_LS_Revised_Saturation_Case_3:16' L_opt(2) = -(8*u1_max*w - 8*u_LA*w + 4*u_LS*w)/(w + 4); */
  L_opt[1] = -((8.0 * u1_max * w - 8.0 * u_LA * w) + 4.0 * u_LS * w) / (w + 4.0);

  /* 'LA_LS_Revised_Saturation_Case_3:17' L_opt(3) = 0; */
  L_opt[2] = 0.0;

  /* 'LA_LS_Revised_Saturation_Case_3:18' L_opt(4) = 0; */
  L_opt[3] = 0.0;
}

/*
 * Function for MATLAB Function: '<S204>/SmartSaturation'
 * function [u_opt,L_opt]= LA_LS_Revised_Saturation_Case_4(u_LS,u_LA,w,u1_min,u1_max,u2_min,u2_max)
 */
static void LA_LS_Revised_Saturation_Case_4(real_T u_LS, real_T u_LA, real_T w,
  real_T u2_min, real_T u_opt[2], real_T L_opt[4])
{
  /* %%%%%  03-Jun-2013 08:50:11 */
  /* %%% */
  /* ------------------------------------------------------ */
  /*  u_opt */
  /* 'LA_LS_Revised_Saturation_Case_4:9' u_opt = zeros(2,1); */
  /* 'LA_LS_Revised_Saturation_Case_4:10' u_opt(1) = (4*u2_min - 4*u_LS - u2_min*w + 2*u_LA*w)/(w + 4); */
  u_opt[0] = (((4.0 * u2_min - 4.0 * u_LS) - u2_min * w) + 2.0 * u_LA * w) / (w
    + 4.0);

  /* 'LA_LS_Revised_Saturation_Case_4:11' u_opt(2) = u2_min; */
  u_opt[1] = u2_min;

  /* ------------------------------------------------------ */
  /*  L_opt */
  /* 'LA_LS_Revised_Saturation_Case_4:14' L_opt = zeros(4,1); */
  /* 'LA_LS_Revised_Saturation_Case_4:15' L_opt(1) = 0; */
  L_opt[0] = 0.0;

  /* 'LA_LS_Revised_Saturation_Case_4:16' L_opt(2) = 0; */
  L_opt[1] = 0.0;

  /* 'LA_LS_Revised_Saturation_Case_4:17' L_opt(3) = -(8*u_LA*w - 8*u2_min*w + 4*u_LS*w)/(w + 4); */
  L_opt[2] = -((8.0 * u_LA * w - 8.0 * u2_min * w) + 4.0 * u_LS * w) / (w + 4.0);

  /* 'LA_LS_Revised_Saturation_Case_4:18' L_opt(4) = 0; */
  L_opt[3] = 0.0;
}

/*
 * Function for MATLAB Function: '<S204>/SmartSaturation'
 * function [u_opt,L_opt]= LA_LS_Revised_Saturation_Case_5(u_LS,u_LA,w,u1_min,u1_max,u2_min,u2_max)
 */
static void LA_LS_Revised_Saturation_Case_5(real_T u_LS, real_T u_LA, real_T w,
  real_T u2_max, real_T u_opt[2], real_T L_opt[4])
{
  /* %%%%%  03-Jun-2013 08:50:12 */
  /* %%% */
  /* ------------------------------------------------------ */
  /*  u_opt */
  /* 'LA_LS_Revised_Saturation_Case_5:9' u_opt = zeros(2,1); */
  /* 'LA_LS_Revised_Saturation_Case_5:10' u_opt(1) = (4*u2_max - 4*u_LS - u2_max*w + 2*u_LA*w)/(w + 4); */
  u_opt[0] = (((4.0 * u2_max - 4.0 * u_LS) - u2_max * w) + 2.0 * u_LA * w) / (w
    + 4.0);

  /* 'LA_LS_Revised_Saturation_Case_5:11' u_opt(2) = u2_max; */
  u_opt[1] = u2_max;

  /* ------------------------------------------------------ */
  /*  L_opt */
  /* 'LA_LS_Revised_Saturation_Case_5:14' L_opt = zeros(4,1); */
  /* 'LA_LS_Revised_Saturation_Case_5:15' L_opt(1) = 0; */
  L_opt[0] = 0.0;

  /* 'LA_LS_Revised_Saturation_Case_5:16' L_opt(2) = 0; */
  L_opt[1] = 0.0;

  /* 'LA_LS_Revised_Saturation_Case_5:17' L_opt(3) = 0; */
  L_opt[2] = 0.0;

  /* 'LA_LS_Revised_Saturation_Case_5:18' L_opt(4) = (8*u_LA*w - 8*u2_max*w + 4*u_LS*w)/(w + 4); */
  L_opt[3] = ((8.0 * u_LA * w - 8.0 * u2_max * w) + 4.0 * u_LS * w) / (w + 4.0);
}

/*
 * Function for MATLAB Function: '<S204>/SmartSaturation'
 * function [u_opt,L_opt]= LA_LS_Revised_Saturation_Case_6(u_LS,u_LA,w,u1_min,u1_max,u2_min,u2_max)
 */
static void LA_LS_Revised_Saturation_Case_6(real_T u_LS, real_T u_LA, real_T w,
  real_T u1_min, real_T u2_min, real_T u_opt[2], real_T L_opt[4])
{
  /* %%%%%  03-Jun-2013 08:50:12 */
  /* %%% */
  /* ------------------------------------------------------ */
  /*  u_opt */
  /* 'LA_LS_Revised_Saturation_Case_6:9' u_opt = zeros(2,1); */
  /* 'LA_LS_Revised_Saturation_Case_6:10' u_opt(1) = u1_min; */
  u_opt[0] = u1_min;

  /* 'LA_LS_Revised_Saturation_Case_6:11' u_opt(2) = u2_min; */
  u_opt[1] = u2_min;

  /* ------------------------------------------------------ */
  /*  L_opt */
  /* 'LA_LS_Revised_Saturation_Case_6:14' L_opt = zeros(4,1); */
  /* 'LA_LS_Revised_Saturation_Case_6:15' L_opt(1) = 2*u1_min - 2*u2_min + 2*u_LS + w*(u1_min/2 + u2_min/2 - u_LA); */
  L_opt[0] = ((u1_min / 2.0 + u2_min / 2.0) - u_LA) * w + ((2.0 * u1_min - 2.0 *
    u2_min) + 2.0 * u_LS);

  /* 'LA_LS_Revised_Saturation_Case_6:16' L_opt(2) = 0; */
  L_opt[1] = 0.0;

  /* 'LA_LS_Revised_Saturation_Case_6:17' L_opt(3) = 2*u2_min - 2*u1_min - 2*u_LS + w*(u1_min/2 + u2_min/2 - u_LA); */
  L_opt[2] = ((u1_min / 2.0 + u2_min / 2.0) - u_LA) * w + ((2.0 * u2_min - 2.0 *
    u1_min) - 2.0 * u_LS);

  /* 'LA_LS_Revised_Saturation_Case_6:18' L_opt(4) = 0; */
  L_opt[3] = 0.0;
}

/*
 * Function for MATLAB Function: '<S204>/SmartSaturation'
 * function [u_opt,L_opt]= LA_LS_Revised_Saturation_Case_7(u_LS,u_LA,w,u1_min,u1_max,u2_min,u2_max)
 */
static void LA_LS_Revised_Saturation_Case_7(real_T u_LS, real_T u_LA, real_T w,
  real_T u1_min, real_T u2_max, real_T u_opt[2], real_T L_opt[4])
{
  /* %%%%%  03-Jun-2013 08:50:13 */
  /* %%% */
  /* ------------------------------------------------------ */
  /*  u_opt */
  /* 'LA_LS_Revised_Saturation_Case_7:9' u_opt = zeros(2,1); */
  /* 'LA_LS_Revised_Saturation_Case_7:10' u_opt(1) = u1_min; */
  u_opt[0] = u1_min;

  /* 'LA_LS_Revised_Saturation_Case_7:11' u_opt(2) = u2_max; */
  u_opt[1] = u2_max;

  /* ------------------------------------------------------ */
  /*  L_opt */
  /* 'LA_LS_Revised_Saturation_Case_7:14' L_opt = zeros(4,1); */
  /* 'LA_LS_Revised_Saturation_Case_7:15' L_opt(1) = 2*u1_min - 2*u2_max + 2*u_LS + w*(u1_min/2 + u2_max/2 - u_LA); */
  L_opt[0] = ((u1_min / 2.0 + u2_max / 2.0) - u_LA) * w + ((2.0 * u1_min - 2.0 *
    u2_max) + 2.0 * u_LS);

  /* 'LA_LS_Revised_Saturation_Case_7:16' L_opt(2) = 0; */
  L_opt[1] = 0.0;

  /* 'LA_LS_Revised_Saturation_Case_7:17' L_opt(3) = 0; */
  L_opt[2] = 0.0;

  /* 'LA_LS_Revised_Saturation_Case_7:18' L_opt(4) = 2*u1_min - 2*u2_max + 2*u_LS - (u1_min*w)/2 - (u2_max*w)/2 + u_LA*w; */
  L_opt[3] = ((((2.0 * u1_min - 2.0 * u2_max) + 2.0 * u_LS) - u1_min * w / 2.0)
              - u2_max * w / 2.0) + u_LA * w;
}

/*
 * Function for MATLAB Function: '<S204>/SmartSaturation'
 * function [u_opt,L_opt]= LA_LS_Revised_Saturation_Case_8(u_LS,u_LA,w,u1_min,u1_max,u2_min,u2_max)
 */
static void LA_LS_Revised_Saturation_Case_8(real_T u_LS, real_T u_LA, real_T w,
  real_T u1_max, real_T u2_min, real_T u_opt[2], real_T L_opt[4])
{
  /* %%%%%  03-Jun-2013 08:50:13 */
  /* %%% */
  /* ------------------------------------------------------ */
  /*  u_opt */
  /* 'LA_LS_Revised_Saturation_Case_8:9' u_opt = zeros(2,1); */
  /* 'LA_LS_Revised_Saturation_Case_8:10' u_opt(1) = u1_max; */
  u_opt[0] = u1_max;

  /* 'LA_LS_Revised_Saturation_Case_8:11' u_opt(2) = u2_min; */
  u_opt[1] = u2_min;

  /* ------------------------------------------------------ */
  /*  L_opt */
  /* 'LA_LS_Revised_Saturation_Case_8:14' L_opt = zeros(4,1); */
  /* 'LA_LS_Revised_Saturation_Case_8:15' L_opt(1) = 0; */
  L_opt[0] = 0.0;

  /* 'LA_LS_Revised_Saturation_Case_8:16' L_opt(2) = 2*u2_min - 2*u1_max - 2*u_LS - (u2_min*w)/2 - (u1_max*w)/2 + u_LA*w; */
  L_opt[1] = ((((2.0 * u2_min - 2.0 * u1_max) - 2.0 * u_LS) - u2_min * w / 2.0)
              - u1_max * w / 2.0) + u_LA * w;

  /* 'LA_LS_Revised_Saturation_Case_8:17' L_opt(3) = 2*u2_min - 2*u1_max - 2*u_LS + w*(u2_min/2 + u1_max/2 - u_LA); */
  L_opt[2] = ((u2_min / 2.0 + u1_max / 2.0) - u_LA) * w + ((2.0 * u2_min - 2.0 *
    u1_max) - 2.0 * u_LS);

  /* 'LA_LS_Revised_Saturation_Case_8:18' L_opt(4) = 0; */
  L_opt[3] = 0.0;
}

/*
 * Function for MATLAB Function: '<S204>/SmartSaturation'
 * function [u_opt,L_opt]= LA_LS_Revised_Saturation_Case_9(u_LS,u_LA,w,u1_min,u1_max,u2_min,u2_max)
 */
static void LA_LS_Revised_Saturation_Case_9(real_T u_LS, real_T u_LA, real_T w,
  real_T u1_max, real_T u2_max, real_T u_opt[2], real_T L_opt[4])
{
  /* %%%%%  03-Jun-2013 08:50:13 */
  /* %%% */
  /* ------------------------------------------------------ */
  /*  u_opt */
  /* 'LA_LS_Revised_Saturation_Case_9:9' u_opt = zeros(2,1); */
  /* 'LA_LS_Revised_Saturation_Case_9:10' u_opt(1) = u1_max; */
  u_opt[0] = u1_max;

  /* 'LA_LS_Revised_Saturation_Case_9:11' u_opt(2) = u2_max; */
  u_opt[1] = u2_max;

  /* ------------------------------------------------------ */
  /*  L_opt */
  /* 'LA_LS_Revised_Saturation_Case_9:14' L_opt = zeros(4,1); */
  /* 'LA_LS_Revised_Saturation_Case_9:15' L_opt(1) = 0; */
  L_opt[0] = 0.0;

  /* 'LA_LS_Revised_Saturation_Case_9:16' L_opt(2) = 2*u2_max - 2*u1_max - 2*u_LS - (u1_max*w)/2 - (u2_max*w)/2 + u_LA*w; */
  L_opt[1] = ((((2.0 * u2_max - 2.0 * u1_max) - 2.0 * u_LS) - u1_max * w / 2.0)
              - u2_max * w / 2.0) + u_LA * w;

  /* 'LA_LS_Revised_Saturation_Case_9:17' L_opt(3) = 0; */
  L_opt[2] = 0.0;

  /* 'LA_LS_Revised_Saturation_Case_9:18' L_opt(4) = 2*u1_max - 2*u2_max + 2*u_LS - (u1_max*w)/2 - (u2_max*w)/2 + u_LA*w; */
  L_opt[3] = ((((2.0 * u1_max - 2.0 * u2_max) + 2.0 * u_LS) - u1_max * w / 2.0)
              - u2_max * w / 2.0) + u_LA * w;
}

/*
 * Function for MATLAB Function: '<S204>/SmartSaturation'
 * function [u_opt,L_opt,case_n]= LA_LS_Revised_Saturation(u_LS,u_LA,w,u1_min,u1_max,u2_min,u2_max)
 */
static void Walkin_LA_LS_Revised_Saturation(real_T u_LS, real_T u_LA, real_T w,
  real_T u1_min, real_T u1_max, real_T u2_min, real_T u2_max, real_T u_opt[2])
{
  real_T u_opt_1[2];
  real_T L_opt_1[4];
  real_T u_opt_2[2];
  real_T L_opt_2[4];
  real_T u_opt_3[2];
  real_T L_opt_3[4];
  real_T u_opt_4[2];
  real_T L_opt_4[4];
  real_T u_opt_5[2];
  real_T L_opt_5[4];
  real_T u_opt_6[2];
  real_T L_opt_6[4];
  real_T u_opt_7[2];
  real_T L_opt_7[4];
  real_T u_opt_8[2];
  real_T L_opt_8[4];
  real_T u_opt_9[2];
  real_T L_opt_9[4];
  int32_T ixstart;
  int32_T ix;
  boolean_T exitg27;
  real_T LB_idx_0;
  real_T UB_idx_0;

  /* -------------------------------------------------------------------------- */
  /*  Inputs: */
  /*  1) u_LS: desired LS torque */
  /*  2) u_LA: desired LA torque */
  /*  3) w: weight in the cost function. Note that w should be strictly positive. */
  /*  The cost function is defined as */
  /*  J = (Delta J_LS)^2 + w * (Delta J_LA)^2 */
  /*  4) u1_min: lower bound on u1 */
  /*  5) u1_max: upper bound on u1 */
  /*  6) u2_min: lower bound on u2 */
  /*  7) u2_max: upper bound on u2 */
  /* -------------------------------------------------------------------------- */
  /*  Outputs: */
  /*  1) u_opt: optimal solution of the QP */
  /*  2) L_opt: Lagrange multipliers at the optimal solution */
  /*  3) case_m: case number. */
  /* -------------------------------------------------------------------------- */
  /*  Consider different cases */
  /* 'LA_LS_Revised_Saturation:30' [u_opt_1,L_opt_1] = LA_LS_Revised_Saturation_Case_1(u_LS,u_LA,w,u1_min,u1_max,u2_min,u2_max); */
  LA_LS_Revised_Saturation_Case_1(u_LS, u_LA, w, u_opt_1, L_opt_1);

  /* 'LA_LS_Revised_Saturation:31' [u_opt_2,L_opt_2] = LA_LS_Revised_Saturation_Case_2(u_LS,u_LA,w,u1_min,u1_max,u2_min,u2_max); */
  LA_LS_Revised_Saturation_Case_2(u_LS, u_LA, w, u1_min, u_opt_2, L_opt_2);

  /* 'LA_LS_Revised_Saturation:32' [u_opt_3,L_opt_3] = LA_LS_Revised_Saturation_Case_3(u_LS,u_LA,w,u1_min,u1_max,u2_min,u2_max); */
  LA_LS_Revised_Saturation_Case_3(u_LS, u_LA, w, u1_max, u_opt_3, L_opt_3);

  /* 'LA_LS_Revised_Saturation:33' [u_opt_4,L_opt_4] = LA_LS_Revised_Saturation_Case_4(u_LS,u_LA,w,u1_min,u1_max,u2_min,u2_max); */
  LA_LS_Revised_Saturation_Case_4(u_LS, u_LA, w, u2_min, u_opt_4, L_opt_4);

  /* 'LA_LS_Revised_Saturation:34' [u_opt_5,L_opt_5] = LA_LS_Revised_Saturation_Case_5(u_LS,u_LA,w,u1_min,u1_max,u2_min,u2_max); */
  LA_LS_Revised_Saturation_Case_5(u_LS, u_LA, w, u2_max, u_opt_5, L_opt_5);

  /* 'LA_LS_Revised_Saturation:35' [u_opt_6,L_opt_6] = LA_LS_Revised_Saturation_Case_6(u_LS,u_LA,w,u1_min,u1_max,u2_min,u2_max); */
  LA_LS_Revised_Saturation_Case_6(u_LS, u_LA, w, u1_min, u2_min, u_opt_6,
    L_opt_6);

  /* 'LA_LS_Revised_Saturation:36' [u_opt_7,L_opt_7] = LA_LS_Revised_Saturation_Case_7(u_LS,u_LA,w,u1_min,u1_max,u2_min,u2_max); */
  LA_LS_Revised_Saturation_Case_7(u_LS, u_LA, w, u1_min, u2_max, u_opt_7,
    L_opt_7);

  /* 'LA_LS_Revised_Saturation:37' [u_opt_8,L_opt_8] = LA_LS_Revised_Saturation_Case_8(u_LS,u_LA,w,u1_min,u1_max,u2_min,u2_max); */
  LA_LS_Revised_Saturation_Case_8(u_LS, u_LA, w, u1_max, u2_min, u_opt_8,
    L_opt_8);

  /* 'LA_LS_Revised_Saturation:38' [u_opt_9,L_opt_9] = LA_LS_Revised_Saturation_Case_9(u_LS,u_LA,w,u1_min,u1_max,u2_min,u2_max); */
  LA_LS_Revised_Saturation_Case_9(u_LS, u_LA, w, u1_max, u2_max, u_opt_9,
    L_opt_9);

  /*  Lower and upper bounds for [u1; u2] */
  /* 'LA_LS_Revised_Saturation:41' LB = [u1_min; u2_min]; */
  /* 'LA_LS_Revised_Saturation:42' UB = [u1_max; u2_max]; */
  /*  Set the initial value */
  /* 'LA_LS_Revised_Saturation:45' u_opt = zeros(2,1); */
  u_opt[0] = 0.0;
  u_opt[1] = 0.0;

  /* 'LA_LS_Revised_Saturation:46' L_opt = zeros(4,1); */
  /* 'LA_LS_Revised_Saturation:47' case_n = 0; */
  /*  Case 1 */
  /* 'LA_LS_Revised_Saturation:49' if (max(u_opt_1-UB)<=0) && (min(u_opt_1-LB)>=0) && (min(L_opt_1)>=0) */
  UB_idx_0 = u_opt_1[0] - u1_max;
  LB_idx_0 = u_opt_1[1] - u2_max;
  ixstart = 1;
  if (rtIsNaN(UB_idx_0)) {
    ix = 2;
    exitg27 = false;
    while ((!exitg27) && (ix < 3)) {
      ixstart = 2;
      if (!rtIsNaN(LB_idx_0)) {
        UB_idx_0 = LB_idx_0;
        exitg27 = true;
      } else {
        ix = 3;
      }
    }
  }

  if ((ixstart < 2) && (LB_idx_0 > UB_idx_0)) {
    UB_idx_0 = LB_idx_0;
  }

  if (UB_idx_0 <= 0.0) {
    UB_idx_0 = u_opt_1[0] - u1_min;
    LB_idx_0 = u_opt_1[1] - u2_min;
    ixstart = 1;
    if (rtIsNaN(UB_idx_0)) {
      ix = 2;
      exitg27 = false;
      while ((!exitg27) && (ix < 3)) {
        ixstart = 2;
        if (!rtIsNaN(LB_idx_0)) {
          UB_idx_0 = LB_idx_0;
          exitg27 = true;
        } else {
          ix = 3;
        }
      }
    }

    if ((ixstart < 2) && (LB_idx_0 < UB_idx_0)) {
      UB_idx_0 = LB_idx_0;
    }

    if (UB_idx_0 >= 0.0) {
      ixstart = 1;
      UB_idx_0 = L_opt_1[0];
      if (rtIsNaN(L_opt_1[0])) {
        ix = 2;
        exitg27 = false;
        while ((!exitg27) && (ix < 5)) {
          ixstart = ix;
          if (!rtIsNaN(L_opt_1[ix - 1])) {
            UB_idx_0 = L_opt_1[ix - 1];
            exitg27 = true;
          } else {
            ix++;
          }
        }
      }

      if (ixstart < 4) {
        while (ixstart + 1 < 5) {
          if (L_opt_1[ixstart] < UB_idx_0) {
            UB_idx_0 = L_opt_1[ixstart];
          }

          ixstart++;
        }
      }

      if (UB_idx_0 >= 0.0) {
        /* 'LA_LS_Revised_Saturation:50' u_opt = u_opt_1; */
        u_opt[0] = u_opt_1[0];
        u_opt[1] = u_opt_1[1];

        /* 'LA_LS_Revised_Saturation:51' L_opt = L_opt_1; */
        /* 'LA_LS_Revised_Saturation:52' case_n = 1; */
      }
    }
  }

  /*  Case 2 */
  /* 'LA_LS_Revised_Saturation:56' if (max(u_opt_2-UB)<=0) && (min(u_opt_2-LB)>=0) && (min(L_opt_2)>=0) */
  UB_idx_0 = u_opt_2[0] - u1_max;
  LB_idx_0 = u_opt_2[1] - u2_max;
  ixstart = 1;
  if (rtIsNaN(UB_idx_0)) {
    ix = 2;
    exitg27 = false;
    while ((!exitg27) && (ix < 3)) {
      ixstart = 2;
      if (!rtIsNaN(LB_idx_0)) {
        UB_idx_0 = LB_idx_0;
        exitg27 = true;
      } else {
        ix = 3;
      }
    }
  }

  if ((ixstart < 2) && (LB_idx_0 > UB_idx_0)) {
    UB_idx_0 = LB_idx_0;
  }

  if (UB_idx_0 <= 0.0) {
    UB_idx_0 = u_opt_2[0] - u1_min;
    LB_idx_0 = u_opt_2[1] - u2_min;
    ixstart = 1;
    if (rtIsNaN(UB_idx_0)) {
      ix = 2;
      exitg27 = false;
      while ((!exitg27) && (ix < 3)) {
        ixstart = 2;
        if (!rtIsNaN(LB_idx_0)) {
          UB_idx_0 = LB_idx_0;
          exitg27 = true;
        } else {
          ix = 3;
        }
      }
    }

    if ((ixstart < 2) && (LB_idx_0 < UB_idx_0)) {
      UB_idx_0 = LB_idx_0;
    }

    if (UB_idx_0 >= 0.0) {
      ixstart = 1;
      UB_idx_0 = L_opt_2[0];
      if (rtIsNaN(L_opt_2[0])) {
        ix = 2;
        exitg27 = false;
        while ((!exitg27) && (ix < 5)) {
          ixstart = ix;
          if (!rtIsNaN(L_opt_2[ix - 1])) {
            UB_idx_0 = L_opt_2[ix - 1];
            exitg27 = true;
          } else {
            ix++;
          }
        }
      }

      if (ixstart < 4) {
        while (ixstart + 1 < 5) {
          if (L_opt_2[ixstart] < UB_idx_0) {
            UB_idx_0 = L_opt_2[ixstart];
          }

          ixstart++;
        }
      }

      if (UB_idx_0 >= 0.0) {
        /* 'LA_LS_Revised_Saturation:57' u_opt = u_opt_2; */
        u_opt[0] = u_opt_2[0];
        u_opt[1] = u_opt_2[1];

        /* 'LA_LS_Revised_Saturation:58' L_opt = L_opt_2; */
        /* 'LA_LS_Revised_Saturation:59' case_n = 2; */
      }
    }
  }

  /*  Case 3 */
  /* 'LA_LS_Revised_Saturation:63' if (max(u_opt_3-UB)<=0) && (min(u_opt_3-LB)>=0) && (min(L_opt_3)>=0) */
  UB_idx_0 = u_opt_3[0] - u1_max;
  LB_idx_0 = u_opt_3[1] - u2_max;
  ixstart = 1;
  if (rtIsNaN(UB_idx_0)) {
    ix = 2;
    exitg27 = false;
    while ((!exitg27) && (ix < 3)) {
      ixstart = 2;
      if (!rtIsNaN(LB_idx_0)) {
        UB_idx_0 = LB_idx_0;
        exitg27 = true;
      } else {
        ix = 3;
      }
    }
  }

  if ((ixstart < 2) && (LB_idx_0 > UB_idx_0)) {
    UB_idx_0 = LB_idx_0;
  }

  if (UB_idx_0 <= 0.0) {
    UB_idx_0 = u_opt_3[0] - u1_min;
    LB_idx_0 = u_opt_3[1] - u2_min;
    ixstart = 1;
    if (rtIsNaN(UB_idx_0)) {
      ix = 2;
      exitg27 = false;
      while ((!exitg27) && (ix < 3)) {
        ixstart = 2;
        if (!rtIsNaN(LB_idx_0)) {
          UB_idx_0 = LB_idx_0;
          exitg27 = true;
        } else {
          ix = 3;
        }
      }
    }

    if ((ixstart < 2) && (LB_idx_0 < UB_idx_0)) {
      UB_idx_0 = LB_idx_0;
    }

    if (UB_idx_0 >= 0.0) {
      ixstart = 1;
      UB_idx_0 = L_opt_3[0];
      if (rtIsNaN(L_opt_3[0])) {
        ix = 2;
        exitg27 = false;
        while ((!exitg27) && (ix < 5)) {
          ixstart = ix;
          if (!rtIsNaN(L_opt_3[ix - 1])) {
            UB_idx_0 = L_opt_3[ix - 1];
            exitg27 = true;
          } else {
            ix++;
          }
        }
      }

      if (ixstart < 4) {
        while (ixstart + 1 < 5) {
          if (L_opt_3[ixstart] < UB_idx_0) {
            UB_idx_0 = L_opt_3[ixstart];
          }

          ixstart++;
        }
      }

      if (UB_idx_0 >= 0.0) {
        /* 'LA_LS_Revised_Saturation:64' u_opt = u_opt_3; */
        u_opt[0] = u_opt_3[0];
        u_opt[1] = u_opt_3[1];

        /* 'LA_LS_Revised_Saturation:65' L_opt = L_opt_3; */
        /* 'LA_LS_Revised_Saturation:66' case_n = 3; */
      }
    }
  }

  /*  Case 4 */
  /* 'LA_LS_Revised_Saturation:70' if (max(u_opt_4-UB)<=0) && (min(u_opt_4-LB)>=0) && (min(L_opt_4)>=0) */
  UB_idx_0 = u_opt_4[0] - u1_max;
  LB_idx_0 = u_opt_4[1] - u2_max;
  ixstart = 1;
  if (rtIsNaN(UB_idx_0)) {
    ix = 2;
    exitg27 = false;
    while ((!exitg27) && (ix < 3)) {
      ixstart = 2;
      if (!rtIsNaN(LB_idx_0)) {
        UB_idx_0 = LB_idx_0;
        exitg27 = true;
      } else {
        ix = 3;
      }
    }
  }

  if ((ixstart < 2) && (LB_idx_0 > UB_idx_0)) {
    UB_idx_0 = LB_idx_0;
  }

  if (UB_idx_0 <= 0.0) {
    UB_idx_0 = u_opt_4[0] - u1_min;
    LB_idx_0 = u_opt_4[1] - u2_min;
    ixstart = 1;
    if (rtIsNaN(UB_idx_0)) {
      ix = 2;
      exitg27 = false;
      while ((!exitg27) && (ix < 3)) {
        ixstart = 2;
        if (!rtIsNaN(LB_idx_0)) {
          UB_idx_0 = LB_idx_0;
          exitg27 = true;
        } else {
          ix = 3;
        }
      }
    }

    if ((ixstart < 2) && (LB_idx_0 < UB_idx_0)) {
      UB_idx_0 = LB_idx_0;
    }

    if (UB_idx_0 >= 0.0) {
      ixstart = 1;
      UB_idx_0 = L_opt_4[0];
      if (rtIsNaN(L_opt_4[0])) {
        ix = 2;
        exitg27 = false;
        while ((!exitg27) && (ix < 5)) {
          ixstart = ix;
          if (!rtIsNaN(L_opt_4[ix - 1])) {
            UB_idx_0 = L_opt_4[ix - 1];
            exitg27 = true;
          } else {
            ix++;
          }
        }
      }

      if (ixstart < 4) {
        while (ixstart + 1 < 5) {
          if (L_opt_4[ixstart] < UB_idx_0) {
            UB_idx_0 = L_opt_4[ixstart];
          }

          ixstart++;
        }
      }

      if (UB_idx_0 >= 0.0) {
        /* 'LA_LS_Revised_Saturation:71' u_opt = u_opt_4; */
        u_opt[0] = u_opt_4[0];
        u_opt[1] = u_opt_4[1];

        /* 'LA_LS_Revised_Saturation:72' L_opt = L_opt_4; */
        /* 'LA_LS_Revised_Saturation:73' case_n = 4; */
      }
    }
  }

  /*  Case 5 */
  /* 'LA_LS_Revised_Saturation:77' if (max(u_opt_5-UB)<=0) && (min(u_opt_5-LB)>=0) && (min(L_opt_5)>=0) */
  UB_idx_0 = u_opt_5[0] - u1_max;
  LB_idx_0 = u_opt_5[1] - u2_max;
  ixstart = 1;
  if (rtIsNaN(UB_idx_0)) {
    ix = 2;
    exitg27 = false;
    while ((!exitg27) && (ix < 3)) {
      ixstart = 2;
      if (!rtIsNaN(LB_idx_0)) {
        UB_idx_0 = LB_idx_0;
        exitg27 = true;
      } else {
        ix = 3;
      }
    }
  }

  if ((ixstart < 2) && (LB_idx_0 > UB_idx_0)) {
    UB_idx_0 = LB_idx_0;
  }

  if (UB_idx_0 <= 0.0) {
    UB_idx_0 = u_opt_5[0] - u1_min;
    LB_idx_0 = u_opt_5[1] - u2_min;
    ixstart = 1;
    if (rtIsNaN(UB_idx_0)) {
      ix = 2;
      exitg27 = false;
      while ((!exitg27) && (ix < 3)) {
        ixstart = 2;
        if (!rtIsNaN(LB_idx_0)) {
          UB_idx_0 = LB_idx_0;
          exitg27 = true;
        } else {
          ix = 3;
        }
      }
    }

    if ((ixstart < 2) && (LB_idx_0 < UB_idx_0)) {
      UB_idx_0 = LB_idx_0;
    }

    if (UB_idx_0 >= 0.0) {
      ixstart = 1;
      UB_idx_0 = L_opt_5[0];
      if (rtIsNaN(L_opt_5[0])) {
        ix = 2;
        exitg27 = false;
        while ((!exitg27) && (ix < 5)) {
          ixstart = ix;
          if (!rtIsNaN(L_opt_5[ix - 1])) {
            UB_idx_0 = L_opt_5[ix - 1];
            exitg27 = true;
          } else {
            ix++;
          }
        }
      }

      if (ixstart < 4) {
        while (ixstart + 1 < 5) {
          if (L_opt_5[ixstart] < UB_idx_0) {
            UB_idx_0 = L_opt_5[ixstart];
          }

          ixstart++;
        }
      }

      if (UB_idx_0 >= 0.0) {
        /* 'LA_LS_Revised_Saturation:78' u_opt = u_opt_5; */
        u_opt[0] = u_opt_5[0];
        u_opt[1] = u_opt_5[1];

        /* 'LA_LS_Revised_Saturation:79' L_opt = L_opt_5; */
        /* 'LA_LS_Revised_Saturation:80' case_n = 5; */
      }
    }
  }

  /*  Case 6 */
  /* 'LA_LS_Revised_Saturation:84' if (max(u_opt_6-UB)<=0) && (min(u_opt_6-LB)>=0) && (min(L_opt_6)>=0) */
  UB_idx_0 = u_opt_6[0] - u1_max;
  LB_idx_0 = u_opt_6[1] - u2_max;
  ixstart = 1;
  if (rtIsNaN(UB_idx_0)) {
    ix = 2;
    exitg27 = false;
    while ((!exitg27) && (ix < 3)) {
      ixstart = 2;
      if (!rtIsNaN(LB_idx_0)) {
        UB_idx_0 = LB_idx_0;
        exitg27 = true;
      } else {
        ix = 3;
      }
    }
  }

  if ((ixstart < 2) && (LB_idx_0 > UB_idx_0)) {
    UB_idx_0 = LB_idx_0;
  }

  if (UB_idx_0 <= 0.0) {
    UB_idx_0 = u_opt_6[0] - u1_min;
    LB_idx_0 = u_opt_6[1] - u2_min;
    ixstart = 1;
    if (rtIsNaN(UB_idx_0)) {
      ix = 2;
      exitg27 = false;
      while ((!exitg27) && (ix < 3)) {
        ixstart = 2;
        if (!rtIsNaN(LB_idx_0)) {
          UB_idx_0 = LB_idx_0;
          exitg27 = true;
        } else {
          ix = 3;
        }
      }
    }

    if ((ixstart < 2) && (LB_idx_0 < UB_idx_0)) {
      UB_idx_0 = LB_idx_0;
    }

    if (UB_idx_0 >= 0.0) {
      ixstart = 1;
      UB_idx_0 = L_opt_6[0];
      if (rtIsNaN(L_opt_6[0])) {
        ix = 2;
        exitg27 = false;
        while ((!exitg27) && (ix < 5)) {
          ixstart = ix;
          if (!rtIsNaN(L_opt_6[ix - 1])) {
            UB_idx_0 = L_opt_6[ix - 1];
            exitg27 = true;
          } else {
            ix++;
          }
        }
      }

      if (ixstart < 4) {
        while (ixstart + 1 < 5) {
          if (L_opt_6[ixstart] < UB_idx_0) {
            UB_idx_0 = L_opt_6[ixstart];
          }

          ixstart++;
        }
      }

      if (UB_idx_0 >= 0.0) {
        /* 'LA_LS_Revised_Saturation:85' u_opt = u_opt_6; */
        u_opt[0] = u_opt_6[0];
        u_opt[1] = u_opt_6[1];

        /* 'LA_LS_Revised_Saturation:86' L_opt = L_opt_6; */
        /* 'LA_LS_Revised_Saturation:87' case_n = 6; */
      }
    }
  }

  /*  Case 7 */
  /* 'LA_LS_Revised_Saturation:91' if (max(u_opt_7-UB)<=0) && (min(u_opt_7-LB)>=0) && (min(L_opt_7)>=0) */
  UB_idx_0 = u_opt_7[0] - u1_max;
  LB_idx_0 = u_opt_7[1] - u2_max;
  ixstart = 1;
  if (rtIsNaN(UB_idx_0)) {
    ix = 2;
    exitg27 = false;
    while ((!exitg27) && (ix < 3)) {
      ixstart = 2;
      if (!rtIsNaN(LB_idx_0)) {
        UB_idx_0 = LB_idx_0;
        exitg27 = true;
      } else {
        ix = 3;
      }
    }
  }

  if ((ixstart < 2) && (LB_idx_0 > UB_idx_0)) {
    UB_idx_0 = LB_idx_0;
  }

  if (UB_idx_0 <= 0.0) {
    UB_idx_0 = u_opt_7[0] - u1_min;
    LB_idx_0 = u_opt_7[1] - u2_min;
    ixstart = 1;
    if (rtIsNaN(UB_idx_0)) {
      ix = 2;
      exitg27 = false;
      while ((!exitg27) && (ix < 3)) {
        ixstart = 2;
        if (!rtIsNaN(LB_idx_0)) {
          UB_idx_0 = LB_idx_0;
          exitg27 = true;
        } else {
          ix = 3;
        }
      }
    }

    if ((ixstart < 2) && (LB_idx_0 < UB_idx_0)) {
      UB_idx_0 = LB_idx_0;
    }

    if (UB_idx_0 >= 0.0) {
      ixstart = 1;
      UB_idx_0 = L_opt_7[0];
      if (rtIsNaN(L_opt_7[0])) {
        ix = 2;
        exitg27 = false;
        while ((!exitg27) && (ix < 5)) {
          ixstart = ix;
          if (!rtIsNaN(L_opt_7[ix - 1])) {
            UB_idx_0 = L_opt_7[ix - 1];
            exitg27 = true;
          } else {
            ix++;
          }
        }
      }

      if (ixstart < 4) {
        while (ixstart + 1 < 5) {
          if (L_opt_7[ixstart] < UB_idx_0) {
            UB_idx_0 = L_opt_7[ixstart];
          }

          ixstart++;
        }
      }

      if (UB_idx_0 >= 0.0) {
        /* 'LA_LS_Revised_Saturation:92' u_opt = u_opt_7; */
        u_opt[0] = u_opt_7[0];
        u_opt[1] = u_opt_7[1];

        /* 'LA_LS_Revised_Saturation:93' L_opt = L_opt_7; */
        /* 'LA_LS_Revised_Saturation:94' case_n = 7; */
      }
    }
  }

  /*  Case 8 */
  /* 'LA_LS_Revised_Saturation:98' if (max(u_opt_8-UB)<=0) && (min(u_opt_8-LB)>=0) && (min(L_opt_8)>=0) */
  UB_idx_0 = u_opt_8[0] - u1_max;
  LB_idx_0 = u_opt_8[1] - u2_max;
  ixstart = 1;
  if (rtIsNaN(UB_idx_0)) {
    ix = 2;
    exitg27 = false;
    while ((!exitg27) && (ix < 3)) {
      ixstart = 2;
      if (!rtIsNaN(LB_idx_0)) {
        UB_idx_0 = LB_idx_0;
        exitg27 = true;
      } else {
        ix = 3;
      }
    }
  }

  if ((ixstart < 2) && (LB_idx_0 > UB_idx_0)) {
    UB_idx_0 = LB_idx_0;
  }

  if (UB_idx_0 <= 0.0) {
    UB_idx_0 = u_opt_8[0] - u1_min;
    LB_idx_0 = u_opt_8[1] - u2_min;
    ixstart = 1;
    if (rtIsNaN(UB_idx_0)) {
      ix = 2;
      exitg27 = false;
      while ((!exitg27) && (ix < 3)) {
        ixstart = 2;
        if (!rtIsNaN(LB_idx_0)) {
          UB_idx_0 = LB_idx_0;
          exitg27 = true;
        } else {
          ix = 3;
        }
      }
    }

    if ((ixstart < 2) && (LB_idx_0 < UB_idx_0)) {
      UB_idx_0 = LB_idx_0;
    }

    if (UB_idx_0 >= 0.0) {
      ixstart = 1;
      UB_idx_0 = L_opt_8[0];
      if (rtIsNaN(L_opt_8[0])) {
        ix = 2;
        exitg27 = false;
        while ((!exitg27) && (ix < 5)) {
          ixstart = ix;
          if (!rtIsNaN(L_opt_8[ix - 1])) {
            UB_idx_0 = L_opt_8[ix - 1];
            exitg27 = true;
          } else {
            ix++;
          }
        }
      }

      if (ixstart < 4) {
        while (ixstart + 1 < 5) {
          if (L_opt_8[ixstart] < UB_idx_0) {
            UB_idx_0 = L_opt_8[ixstart];
          }

          ixstart++;
        }
      }

      if (UB_idx_0 >= 0.0) {
        /* 'LA_LS_Revised_Saturation:99' u_opt = u_opt_8; */
        u_opt[0] = u_opt_8[0];
        u_opt[1] = u_opt_8[1];

        /* 'LA_LS_Revised_Saturation:100' L_opt = L_opt_8; */
        /* 'LA_LS_Revised_Saturation:101' case_n = 8; */
      }
    }
  }

  /*  Case 9 */
  /* 'LA_LS_Revised_Saturation:105' if (max(u_opt_9-UB)<=0) && (min(u_opt_9-LB)>=0) && (min(L_opt_9)>=0) */
  UB_idx_0 = u_opt_9[0] - u1_max;
  LB_idx_0 = u_opt_9[1] - u2_max;
  ixstart = 1;
  if (rtIsNaN(UB_idx_0)) {
    ix = 2;
    exitg27 = false;
    while ((!exitg27) && (ix < 3)) {
      ixstart = 2;
      if (!rtIsNaN(LB_idx_0)) {
        UB_idx_0 = LB_idx_0;
        exitg27 = true;
      } else {
        ix = 3;
      }
    }
  }

  if ((ixstart < 2) && (LB_idx_0 > UB_idx_0)) {
    UB_idx_0 = LB_idx_0;
  }

  if (UB_idx_0 <= 0.0) {
    LB_idx_0 = u_opt_9[0] - u1_min;
    UB_idx_0 = u_opt_9[1] - u2_min;
    ixstart = 1;
    if (rtIsNaN(LB_idx_0)) {
      ix = 2;
      exitg27 = false;
      while ((!exitg27) && (ix < 3)) {
        ixstart = 2;
        if (!rtIsNaN(UB_idx_0)) {
          LB_idx_0 = UB_idx_0;
          exitg27 = true;
        } else {
          ix = 3;
        }
      }
    }

    if ((ixstart < 2) && (UB_idx_0 < LB_idx_0)) {
      LB_idx_0 = UB_idx_0;
    }

    if (LB_idx_0 >= 0.0) {
      ixstart = 1;
      UB_idx_0 = L_opt_9[0];
      if (rtIsNaN(L_opt_9[0])) {
        ix = 2;
        exitg27 = false;
        while ((!exitg27) && (ix < 5)) {
          ixstart = ix;
          if (!rtIsNaN(L_opt_9[ix - 1])) {
            UB_idx_0 = L_opt_9[ix - 1];
            exitg27 = true;
          } else {
            ix++;
          }
        }
      }

      if (ixstart < 4) {
        while (ixstart + 1 < 5) {
          if (L_opt_9[ixstart] < UB_idx_0) {
            UB_idx_0 = L_opt_9[ixstart];
          }

          ixstart++;
        }
      }

      if (UB_idx_0 >= 0.0) {
        /* 'LA_LS_Revised_Saturation:106' u_opt = u_opt_9; */
        u_opt[0] = u_opt_9[0];
        u_opt[1] = u_opt_9[1];

        /* 'LA_LS_Revised_Saturation:107' L_opt = L_opt_9; */
        /* 'LA_LS_Revised_Saturation:108' case_n = 9; */
      }
    }
  }
}

/* Function for MATLAB Function: '<S204>/SmartSaturation' */
static void Walking01_withElmos_mldivide(const real_T A[36], real_T B[6])
{
  real_T temp;
  real_T b_A[36];
  int8_T ipiv[6];
  int32_T j;
  int32_T c;
  int32_T ix;
  real_T s;
  int32_T jy;
  int32_T c_ix;
  int32_T d;
  int32_T ijA;
  int32_T b_kAcol;
  memcpy(&b_A[0], &A[0], 36U * sizeof(real_T));
  for (ix = 0; ix < 6; ix++) {
    ipiv[ix] = (int8_T)(1 + ix);
  }

  for (j = 0; j < 5; j++) {
    c = j * 7;
    jy = 0;
    ix = c;
    temp = fabs(b_A[c]);
    for (b_kAcol = 2; b_kAcol <= 6 - j; b_kAcol++) {
      ix++;
      s = fabs(b_A[ix]);
      if (s > temp) {
        jy = b_kAcol - 1;
        temp = s;
      }
    }

    if (b_A[c + jy] != 0.0) {
      if (jy != 0) {
        ipiv[j] = (int8_T)((j + jy) + 1);
        ix = j;
        b_kAcol = j + jy;
        for (jy = 0; jy < 6; jy++) {
          temp = b_A[ix];
          b_A[ix] = b_A[b_kAcol];
          b_A[b_kAcol] = temp;
          ix += 6;
          b_kAcol += 6;
        }
      }

      ix = (c - j) + 6;
      for (b_kAcol = c + 1; b_kAcol + 1 <= ix; b_kAcol++) {
        b_A[b_kAcol] /= b_A[c];
      }
    }

    b_kAcol = c;
    jy = c + 6;
    for (ix = 1; ix <= 5 - j; ix++) {
      temp = b_A[jy];
      if (b_A[jy] != 0.0) {
        c_ix = c + 1;
        d = (b_kAcol - j) + 12;
        for (ijA = 7 + b_kAcol; ijA + 1 <= d; ijA++) {
          b_A[ijA] += b_A[c_ix] * -temp;
          c_ix++;
        }
      }

      jy += 6;
      b_kAcol += 6;
    }
  }

  for (ix = 0; ix < 5; ix++) {
    if (ix + 1 != ipiv[ix]) {
      temp = B[ix];
      B[ix] = B[ipiv[ix] - 1];
      B[ipiv[ix] - 1] = temp;
    }
  }

  for (ix = 0; ix < 6; ix++) {
    b_kAcol = 6 * ix;
    if (B[ix] != 0.0) {
      for (jy = ix + 1; jy + 1 < 7; jy++) {
        B[jy] -= b_A[jy + b_kAcol] * B[ix];
      }
    }
  }

  for (ix = 5; ix >= 0; ix += -1) {
    b_kAcol = 6 * ix;
    if (B[ix] != 0.0) {
      B[ix] /= b_A[ix + b_kAcol];
      for (jy = 0; jy + 1 <= ix; jy++) {
        B[jy] -= b_A[jy + b_kAcol] * B[ix];
      }
    }
  }
}

/*
 * Function for MATLAB Function: '<S1>/SAFETY'
 * function [violation, qmin, qmax, dqmin, dqmax, qminv, qmaxv, T] = MARLOBasicSafetyLimits2(q, dq)
 */
static void Walking_MARLOBasicSafetyLimits2(const real_T q[13], const real_T dq
  [13], boolean_T violation[34])
{
  real_T qbar[34];
  real_T dqbar[34];
  static const int8_T b[34] = { 20, 20, 40, 40, 50, 50, 30, 30, 20, 20, 40, 40,
    50, 50, 30, 30, 3, 3, 2, 2, 2, 2, 2, 2, 0, 0, 20, 0, 15, 10, 20, 20, 20, 20
  };

  static const int16_T dqmax[34] = { 600, 600, 500, 500, 500, 500, 500, 500, 600,
    600, 500, 500, 500, 500, 500, 500, 300, 300, 200, 200, 300, 300, 500, 500,
    250, 250, 400, 300, 150, 150, 300, 300, 300, 300 };

  static const int16_T qmax[34] = { 200, 200, 260, 260, 230, 230, 90, 90, 200,
    200, 260, 260, 230, 230, 90, 90, 6, 6, 3, 3, 3, 3, 3, 3, 15, 15, 45, 30, 15,
    20, 220, 220, 220, 220 };

  static const int8_T c[34] = { 60, 60, 40, 40, 50, 50, 15, 15, 60, 60, 40, 40,
    50, 50, 15, 15, 1, 1, 4, 4, 2, 2, 6, 6, 0, 0, 20, 0, 10, 10, 20, 20, 20, 20
  };

  static const int16_T dqmin[34] = { -400, -400, -400, -400, -400, -400, -500,
    -500, -400, -400, -400, -400, -400, -400, -500, -500, -200, -200, -400, -400,
    -300, -300, -600, -600, -250, -250, -400, -300, -150, -150, -300, -300, -300,
    -300 };

  static const int16_T qmin[34] = { 100, 100, 160, 160, 130, 130, 15, 15, 100,
    100, 160, 160, 130, 130, 15, 15, -2, -2, -6, -6, -3, -3, -8, -8, -20, -20,
    -45, -25, -30, -20, 140, 140, 140, 140 };

  static const real_T a[442] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, -0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 0.5,
    0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, -0.5, 0.0, -1.0,
    0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
    0.0, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0,
    0.0, 0.0, -0.5, 0.0, 1.0, 0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0,
    0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, -1.0, 0.0, -0.5, 0.0, -1.0, 0.0, 0.0, -0.5, 0.0, 0.0,
    0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.5, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.5, 0.0, -1.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5,
    0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,
    0.5, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.0, 1.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };

  real_T a_0[34];
  int32_T i;
  int32_T i_0;
  real_T a_1[34];

  /*  MARLOBASICSAFETYLIMITS2 Checks to see if the configuration and velocity satisfy basic safety limits. */
  /*  % q1 */
  /*  % q2 */
  /*  % qLA */
  /*  % qKA */
  /*  % qgr1 */
  /*  % qgr2 */
  /*  % qgrLA */
  /*  % qgrKA */
  /*  % qsp1 */
  /*  % qsp2 */
  /*  % qspLA */
  /*  % qspKA */
  /*  % q3 */
  /*  % qDLA */
  /*  % q3RL */
  /*  % qxT */
  /*  % qyT */
  /*  % theta */
  /*  % thetagr */
  /* 'MARLOBasicSafetyLimits2:4' T = [... */
  /* 'MARLOBasicSafetyLimits2:5' 		... % q1 */
  /* 'MARLOBasicSafetyLimits2:6' 		0 0 0 1 0 0 0 0 0 0 0 0 0; */
  /* 'MARLOBasicSafetyLimits2:7' 		0 0 0 0 0 1 0 0 0 0 0 0 0;  */
  /* 'MARLOBasicSafetyLimits2:8' 		... % q2 */
  /* 'MARLOBasicSafetyLimits2:9' 		0 0 0 0 1 0 0 0 0 0 0 0 0; */
  /* 'MARLOBasicSafetyLimits2:10' 		0 0 0 0 0 0 1 0 0 0 0 0 0;  */
  /* 'MARLOBasicSafetyLimits2:11' 		... % qLA */
  /* 'MARLOBasicSafetyLimits2:12' 		0 0 0 0.5 0.5 0 0 0 0 0 0 0 0; */
  /* 'MARLOBasicSafetyLimits2:13' 		0 0 0 0 0 0.5 0.5 0 0 0 0 0 0;  */
  /* 'MARLOBasicSafetyLimits2:14' 		... % qKA */
  /* 'MARLOBasicSafetyLimits2:15' 		0 0 0 -1 1 0 0 0 0 0 0 0 0; */
  /* 'MARLOBasicSafetyLimits2:16' 		0 0 0 0 0 -1 1 0 0 0 0 0 0;  */
  /* 'MARLOBasicSafetyLimits2:17' 		... % qgr1 */
  /* 'MARLOBasicSafetyLimits2:18' 		0 0 0 0 0 0 0 1 0 0 0 0 0; */
  /* 'MARLOBasicSafetyLimits2:19' 		0 0 0 0 0 0 0 0 0 0 1 0 0;  */
  /* 'MARLOBasicSafetyLimits2:20' 		... % qgr2 */
  /* 'MARLOBasicSafetyLimits2:21' 		0 0 0 0 0 0 0 0 1 0 0 0 0; */
  /* 'MARLOBasicSafetyLimits2:22' 		0 0 0 0 0 0 0 0 0 0 0 1 0;  */
  /* 'MARLOBasicSafetyLimits2:23' 		... % qgrLA */
  /* 'MARLOBasicSafetyLimits2:24' 		0 0 0 0 0 0 0 0.5 0.5 0 0 0 0; */
  /* 'MARLOBasicSafetyLimits2:25' 		0 0 0 0 0 0 0 0 0 0 0.5 0.5 0;  */
  /* 'MARLOBasicSafetyLimits2:26' 		... % qgrKA */
  /* 'MARLOBasicSafetyLimits2:27' 		0 0 0 0 0 0 0 -1 1 0 0 0 0; */
  /* 'MARLOBasicSafetyLimits2:28' 		0 0 0 0 0 0 0 0 0 0 -1 1 0;  */
  /* 'MARLOBasicSafetyLimits2:29' 		... % qsp1 */
  /* 'MARLOBasicSafetyLimits2:30' 		0 0 0 -1 0 0 0 1 0 0 0 0 0; */
  /* 'MARLOBasicSafetyLimits2:31' 		0 0 0 0 0 -1 0 0 0 0 1 0 0;  */
  /* 'MARLOBasicSafetyLimits2:32' 		... % qsp2 */
  /* 'MARLOBasicSafetyLimits2:33' 		0 0 0 0 -1 0 0 0 1 0 0 0 0; */
  /* 'MARLOBasicSafetyLimits2:34' 		0 0 0 0 0 0 -1 0 0 0 0 1 0;  */
  /* 'MARLOBasicSafetyLimits2:35' 		... % qspLA */
  /* 'MARLOBasicSafetyLimits2:36' 		0 0 0 -0.5 -0.5 0 0 0.5 0.5 0 0 0 0; */
  /* 'MARLOBasicSafetyLimits2:37' 		0 0 0 0 0 -0.5 -0.5 0 0 0 0.5 0.5 0;  */
  /* 'MARLOBasicSafetyLimits2:38' 		... % qspKA */
  /* 'MARLOBasicSafetyLimits2:39' 		0 0 0 1 -1 0 0 -1 1 0 0 0 0; */
  /* 'MARLOBasicSafetyLimits2:40' 		0 0 0 0 0 1 -1 0 0 0 -1 1 0;  */
  /* 'MARLOBasicSafetyLimits2:41' 		... % q3 */
  /* 'MARLOBasicSafetyLimits2:42' 		0 0 0 0 0 0 0 0 0 1 0 0 0; */
  /* 'MARLOBasicSafetyLimits2:43' 		0 0 0 0 0 0 0 0 0 0 0 0 1;  */
  /* 'MARLOBasicSafetyLimits2:44' 		... % qDLA */
  /* 'MARLOBasicSafetyLimits2:45' 		0 0 0 0.5 0.5 -0.5 -0.5 0 0 0 0 0 0;  */
  /* 'MARLOBasicSafetyLimits2:46' 		... % q3RL */
  /* 'MARLOBasicSafetyLimits2:47' 		0 0 0 0 0 0 0 0 0 1 0 0 1;  */
  /* 'MARLOBasicSafetyLimits2:48' 		... % qxT */
  /* 'MARLOBasicSafetyLimits2:49' 		0 0 1 0 0 0 0 0 0 0 0 0 0;  */
  /* 'MARLOBasicSafetyLimits2:50' 		... % qyT */
  /* 'MARLOBasicSafetyLimits2:51' 		0 1 0 0 0 0 0 0 0 0 0 0 0;  */
  /* 'MARLOBasicSafetyLimits2:52' 		... % theta */
  /* 'MARLOBasicSafetyLimits2:53' 		0 0 1 0.5 0.5 0 0 0 0 0 0 0 0; */
  /* 'MARLOBasicSafetyLimits2:54' 		0 0 1 0 0 0.5 0.5 0 0 0 0 0 0;  */
  /* 'MARLOBasicSafetyLimits2:55' 		... % thetagr */
  /* 'MARLOBasicSafetyLimits2:56' 		0 0 1 0 0 0 0 0.5 0.5 0 0 0 0; */
  /* 'MARLOBasicSafetyLimits2:57' 		0 0 1 0 0 0 0 0 0 0 0.5 0.5 0;  */
  /* 'MARLOBasicSafetyLimits2:58' 	]; */
  /*  % minimum q */
  /*  % q1 */
  /*  % q2 */
  /*  % qLA */
  /*  % qKA */
  /*  % qgr1 */
  /*  % qgr2 */
  /*  % qgrLA */
  /*  % qgrKA */
  /*  % qsp1 */
  /*  % qsp2 */
  /*  % qspLA */
  /*  % qspKA */
  /*  % q3 */
  /*  % qDLA */
  /*  % q3RL */
  /*  % qxT */
  /*  % qyT */
  /*  % theta */
  /*  % thetagr */
  /* 'MARLOBasicSafetyLimits2:60' qmin = [... % minimum q */
  /* 'MARLOBasicSafetyLimits2:61' 		... % q1 */
  /* 'MARLOBasicSafetyLimits2:62' 		100.000000;  */
  /* 'MARLOBasicSafetyLimits2:63' 		100.000000;  */
  /* 'MARLOBasicSafetyLimits2:64' 		... % q2 */
  /* 'MARLOBasicSafetyLimits2:65' 		160.000000;  */
  /* 'MARLOBasicSafetyLimits2:66' 		160.000000;  */
  /* 'MARLOBasicSafetyLimits2:67' 		... % qLA */
  /* 'MARLOBasicSafetyLimits2:68' 		130.000000;  */
  /* 'MARLOBasicSafetyLimits2:69' 		130.000000;  */
  /* 'MARLOBasicSafetyLimits2:70' 		... % qKA */
  /* 'MARLOBasicSafetyLimits2:71' 		15.000000;  */
  /* 'MARLOBasicSafetyLimits2:72' 		15.000000;  */
  /* 'MARLOBasicSafetyLimits2:73' 		... % qgr1 */
  /* 'MARLOBasicSafetyLimits2:74' 		100.000000;  */
  /* 'MARLOBasicSafetyLimits2:75' 		100.000000;  */
  /* 'MARLOBasicSafetyLimits2:76' 		... % qgr2 */
  /* 'MARLOBasicSafetyLimits2:77' 		160.000000;  */
  /* 'MARLOBasicSafetyLimits2:78' 		160.000000;  */
  /* 'MARLOBasicSafetyLimits2:79' 		... % qgrLA */
  /* 'MARLOBasicSafetyLimits2:80' 		130.000000;  */
  /* 'MARLOBasicSafetyLimits2:81' 		130.000000;  */
  /* 'MARLOBasicSafetyLimits2:82' 		... % qgrKA */
  /* 'MARLOBasicSafetyLimits2:83' 		15.000000;  */
  /* 'MARLOBasicSafetyLimits2:84' 		15.000000;  */
  /* 'MARLOBasicSafetyLimits2:85' 		... % qsp1 */
  /* 'MARLOBasicSafetyLimits2:86' 		-2.000000;  */
  /* 'MARLOBasicSafetyLimits2:87' 		-2.000000;  */
  /* 'MARLOBasicSafetyLimits2:88' 		... % qsp2 */
  /* 'MARLOBasicSafetyLimits2:89' 		-6.000000;  */
  /* 'MARLOBasicSafetyLimits2:90' 		-6.000000;  */
  /* 'MARLOBasicSafetyLimits2:91' 		... % qspLA */
  /* 'MARLOBasicSafetyLimits2:92' 		-3.000000;  */
  /* 'MARLOBasicSafetyLimits2:93' 		-3.000000;  */
  /* 'MARLOBasicSafetyLimits2:94' 		... % qspKA */
  /* 'MARLOBasicSafetyLimits2:95' 		-8.000000;  */
  /* 'MARLOBasicSafetyLimits2:96' 		-8.000000;  */
  /* 'MARLOBasicSafetyLimits2:97' 		... % q3 */
  /* 'MARLOBasicSafetyLimits2:98' 		-20.000000;  */
  /* 'MARLOBasicSafetyLimits2:99' 		-20.000000;  */
  /* 'MARLOBasicSafetyLimits2:100' 		... % qDLA */
  /* 'MARLOBasicSafetyLimits2:101' 		-45.000000;  */
  /* 'MARLOBasicSafetyLimits2:102' 		... % q3RL */
  /* 'MARLOBasicSafetyLimits2:103' 		-25.000000;  */
  /* 'MARLOBasicSafetyLimits2:104' 		... % qxT */
  /* 'MARLOBasicSafetyLimits2:105' 		-30.000000;  */
  /* 'MARLOBasicSafetyLimits2:106' 		... % qyT */
  /* 'MARLOBasicSafetyLimits2:107' 		-20.000000;  */
  /* 'MARLOBasicSafetyLimits2:108' 		... % theta */
  /* 'MARLOBasicSafetyLimits2:109' 		140.000000;  */
  /* 'MARLOBasicSafetyLimits2:110' 		140.000000;  */
  /* 'MARLOBasicSafetyLimits2:111' 		... % thetagr */
  /* 'MARLOBasicSafetyLimits2:112' 		140.000000;  */
  /* 'MARLOBasicSafetyLimits2:113' 		140.000000;  */
  /* 'MARLOBasicSafetyLimits2:114' 	]; */
  /*  % maximum q */
  /*  % q1 */
  /*  % q2 */
  /*  % qLA */
  /*  % qKA */
  /*  % qgr1 */
  /*  % qgr2 */
  /*  % qgrLA */
  /*  % qgrKA */
  /*  % qsp1 */
  /*  % qsp2 */
  /*  % qspLA */
  /*  % qspKA */
  /*  % q3 */
  /*  % qDLA */
  /*  % q3RL */
  /*  % qxT */
  /*  % qyT */
  /*  % theta */
  /*  % thetagr */
  /* 'MARLOBasicSafetyLimits2:115' qmax = [... % maximum q */
  /* 'MARLOBasicSafetyLimits2:116' 		... % q1 */
  /* 'MARLOBasicSafetyLimits2:117' 		200.000000;  */
  /* 'MARLOBasicSafetyLimits2:118' 		200.000000;  */
  /* 'MARLOBasicSafetyLimits2:119' 		... % q2 */
  /* 'MARLOBasicSafetyLimits2:120' 		260.000000;  */
  /* 'MARLOBasicSafetyLimits2:121' 		260.000000;  */
  /* 'MARLOBasicSafetyLimits2:122' 		... % qLA */
  /* 'MARLOBasicSafetyLimits2:123' 		230.000000;  */
  /* 'MARLOBasicSafetyLimits2:124' 		230.000000;  */
  /* 'MARLOBasicSafetyLimits2:125' 		... % qKA */
  /* 'MARLOBasicSafetyLimits2:126' 		90.000000;  */
  /* 'MARLOBasicSafetyLimits2:127' 		90.000000;  */
  /* 'MARLOBasicSafetyLimits2:128' 		... % qgr1 */
  /* 'MARLOBasicSafetyLimits2:129' 		200.000000;  */
  /* 'MARLOBasicSafetyLimits2:130' 		200.000000;  */
  /* 'MARLOBasicSafetyLimits2:131' 		... % qgr2 */
  /* 'MARLOBasicSafetyLimits2:132' 		260.000000;  */
  /* 'MARLOBasicSafetyLimits2:133' 		260.000000;  */
  /* 'MARLOBasicSafetyLimits2:134' 		... % qgrLA */
  /* 'MARLOBasicSafetyLimits2:135' 		230.000000;  */
  /* 'MARLOBasicSafetyLimits2:136' 		230.000000;  */
  /* 'MARLOBasicSafetyLimits2:137' 		... % qgrKA */
  /* 'MARLOBasicSafetyLimits2:138' 		90.000000;  */
  /* 'MARLOBasicSafetyLimits2:139' 		90.000000;  */
  /* 'MARLOBasicSafetyLimits2:140' 		... % qsp1 */
  /* 'MARLOBasicSafetyLimits2:141' 		6.000000;  */
  /* 'MARLOBasicSafetyLimits2:142' 		6.000000;  */
  /* 'MARLOBasicSafetyLimits2:143' 		... % qsp2 */
  /* 'MARLOBasicSafetyLimits2:144' 		3.000000;  */
  /* 'MARLOBasicSafetyLimits2:145' 		3.000000;  */
  /* 'MARLOBasicSafetyLimits2:146' 		... % qspLA */
  /* 'MARLOBasicSafetyLimits2:147' 		3.000000;  */
  /* 'MARLOBasicSafetyLimits2:148' 		3.000000;  */
  /* 'MARLOBasicSafetyLimits2:149' 		... % qspKA */
  /* 'MARLOBasicSafetyLimits2:150' 		3.000000;  */
  /* 'MARLOBasicSafetyLimits2:151' 		3.000000;  */
  /* 'MARLOBasicSafetyLimits2:152' 		... % q3 */
  /* 'MARLOBasicSafetyLimits2:153' 		15.000000;  */
  /* 'MARLOBasicSafetyLimits2:154' 		15.000000;  */
  /* 'MARLOBasicSafetyLimits2:155' 		... % qDLA */
  /* 'MARLOBasicSafetyLimits2:156' 		45.000000;  */
  /* 'MARLOBasicSafetyLimits2:157' 		... % q3RL */
  /* 'MARLOBasicSafetyLimits2:158' 		30.000000;  */
  /* 'MARLOBasicSafetyLimits2:159' 		... % qxT */
  /* 'MARLOBasicSafetyLimits2:160' 		15.000000;  */
  /* 'MARLOBasicSafetyLimits2:161' 		... % qyT */
  /* 'MARLOBasicSafetyLimits2:162' 		20.000000;  */
  /* 'MARLOBasicSafetyLimits2:163' 		... % theta */
  /* 'MARLOBasicSafetyLimits2:164' 		220.000000;  */
  /* 'MARLOBasicSafetyLimits2:165' 		220.000000;  */
  /* 'MARLOBasicSafetyLimits2:166' 		... % thetagr */
  /* 'MARLOBasicSafetyLimits2:167' 		220.000000;  */
  /* 'MARLOBasicSafetyLimits2:168' 		220.000000;  */
  /* 'MARLOBasicSafetyLimits2:169' 	]; */
  /*  % minimum dq */
  /*  % q1 */
  /*  % q2 */
  /*  % qLA */
  /*  % qKA */
  /*  % qgr1 */
  /*  % qgr2 */
  /*  % qgrLA */
  /*  % qgrKA */
  /*  % qsp1 */
  /*  % qsp2 */
  /*  % qspLA */
  /*  % qspKA */
  /*  % q3 */
  /*  % qDLA */
  /*  % q3RL */
  /*  % qxT */
  /*  % qyT */
  /*  % theta */
  /*  % thetagr */
  /* 'MARLOBasicSafetyLimits2:170' dqmin = [... % minimum dq */
  /* 'MARLOBasicSafetyLimits2:171' 		... % q1 */
  /* 'MARLOBasicSafetyLimits2:172' 		-400.000000;  */
  /* 'MARLOBasicSafetyLimits2:173' 		-400.000000;  */
  /* 'MARLOBasicSafetyLimits2:174' 		... % q2 */
  /* 'MARLOBasicSafetyLimits2:175' 		-400.000000;  */
  /* 'MARLOBasicSafetyLimits2:176' 		-400.000000;  */
  /* 'MARLOBasicSafetyLimits2:177' 		... % qLA */
  /* 'MARLOBasicSafetyLimits2:178' 		-400.000000;  */
  /* 'MARLOBasicSafetyLimits2:179' 		-400.000000;  */
  /* 'MARLOBasicSafetyLimits2:180' 		... % qKA */
  /* 'MARLOBasicSafetyLimits2:181' 		-500.000000;  */
  /* 'MARLOBasicSafetyLimits2:182' 		-500.000000;  */
  /* 'MARLOBasicSafetyLimits2:183' 		... % qgr1 */
  /* 'MARLOBasicSafetyLimits2:184' 		-400.000000;  */
  /* 'MARLOBasicSafetyLimits2:185' 		-400.000000;  */
  /* 'MARLOBasicSafetyLimits2:186' 		... % qgr2 */
  /* 'MARLOBasicSafetyLimits2:187' 		-400.000000;  */
  /* 'MARLOBasicSafetyLimits2:188' 		-400.000000;  */
  /* 'MARLOBasicSafetyLimits2:189' 		... % qgrLA */
  /* 'MARLOBasicSafetyLimits2:190' 		-400.000000;  */
  /* 'MARLOBasicSafetyLimits2:191' 		-400.000000;  */
  /* 'MARLOBasicSafetyLimits2:192' 		... % qgrKA */
  /* 'MARLOBasicSafetyLimits2:193' 		-500.000000;  */
  /* 'MARLOBasicSafetyLimits2:194' 		-500.000000;  */
  /* 'MARLOBasicSafetyLimits2:195' 		... % qsp1 */
  /* 'MARLOBasicSafetyLimits2:196' 		-200.000000;  */
  /* 'MARLOBasicSafetyLimits2:197' 		-200.000000;  */
  /* 'MARLOBasicSafetyLimits2:198' 		... % qsp2 */
  /* 'MARLOBasicSafetyLimits2:199' 		-400.000000;  */
  /* 'MARLOBasicSafetyLimits2:200' 		-400.000000;  */
  /* 'MARLOBasicSafetyLimits2:201' 		... % qspLA */
  /* 'MARLOBasicSafetyLimits2:202' 		-300.000000;  */
  /* 'MARLOBasicSafetyLimits2:203' 		-300.000000;  */
  /* 'MARLOBasicSafetyLimits2:204' 		... % qspKA */
  /* 'MARLOBasicSafetyLimits2:205' 		-600.000000;  */
  /* 'MARLOBasicSafetyLimits2:206' 		-600.000000;  */
  /* 'MARLOBasicSafetyLimits2:207' 		... % q3 */
  /* 'MARLOBasicSafetyLimits2:208' 		-250.000000;  */
  /* 'MARLOBasicSafetyLimits2:209' 		-250.000000;  */
  /* 'MARLOBasicSafetyLimits2:210' 		... % qDLA */
  /* 'MARLOBasicSafetyLimits2:211' 		-400.000000;  */
  /* 'MARLOBasicSafetyLimits2:212' 		... % q3RL */
  /* 'MARLOBasicSafetyLimits2:213' 		-300.000000;  */
  /* 'MARLOBasicSafetyLimits2:214' 		... % qxT */
  /* 'MARLOBasicSafetyLimits2:215' 		-150.000000;  */
  /* 'MARLOBasicSafetyLimits2:216' 		... % qyT */
  /* 'MARLOBasicSafetyLimits2:217' 		-150.000000;  */
  /* 'MARLOBasicSafetyLimits2:218' 		... % theta */
  /* 'MARLOBasicSafetyLimits2:219' 		-300.000000;  */
  /* 'MARLOBasicSafetyLimits2:220' 		-300.000000;  */
  /* 'MARLOBasicSafetyLimits2:221' 		... % thetagr */
  /* 'MARLOBasicSafetyLimits2:222' 		-300.000000;  */
  /* 'MARLOBasicSafetyLimits2:223' 		-300.000000;  */
  /* 'MARLOBasicSafetyLimits2:224' 	]; */
  /*  % maximum dq */
  /*  % q1 */
  /*  % q2 */
  /*  % qLA */
  /*  % qKA */
  /*  % qgr1 */
  /*  % qgr2 */
  /*  % qgrLA */
  /*  % qgrKA */
  /*  % qsp1 */
  /*  % qsp2 */
  /*  % qspLA */
  /*  % qspKA */
  /*  % q3 */
  /*  % qDLA */
  /*  % q3RL */
  /*  % qxT */
  /*  % qyT */
  /*  % theta */
  /*  % thetagr */
  /* 'MARLOBasicSafetyLimits2:225' dqmax = [... % maximum dq */
  /* 'MARLOBasicSafetyLimits2:226' 		... % q1 */
  /* 'MARLOBasicSafetyLimits2:227' 		600.000000;  */
  /* 'MARLOBasicSafetyLimits2:228' 		600.000000;  */
  /* 'MARLOBasicSafetyLimits2:229' 		... % q2 */
  /* 'MARLOBasicSafetyLimits2:230' 		500.000000;  */
  /* 'MARLOBasicSafetyLimits2:231' 		500.000000;  */
  /* 'MARLOBasicSafetyLimits2:232' 		... % qLA */
  /* 'MARLOBasicSafetyLimits2:233' 		500.000000;  */
  /* 'MARLOBasicSafetyLimits2:234' 		500.000000;  */
  /* 'MARLOBasicSafetyLimits2:235' 		... % qKA */
  /* 'MARLOBasicSafetyLimits2:236' 		500.000000;  */
  /* 'MARLOBasicSafetyLimits2:237' 		500.000000;  */
  /* 'MARLOBasicSafetyLimits2:238' 		... % qgr1 */
  /* 'MARLOBasicSafetyLimits2:239' 		600.000000;  */
  /* 'MARLOBasicSafetyLimits2:240' 		600.000000;  */
  /* 'MARLOBasicSafetyLimits2:241' 		... % qgr2 */
  /* 'MARLOBasicSafetyLimits2:242' 		500.000000;  */
  /* 'MARLOBasicSafetyLimits2:243' 		500.000000;  */
  /* 'MARLOBasicSafetyLimits2:244' 		... % qgrLA */
  /* 'MARLOBasicSafetyLimits2:245' 		500.000000;  */
  /* 'MARLOBasicSafetyLimits2:246' 		500.000000;  */
  /* 'MARLOBasicSafetyLimits2:247' 		... % qgrKA */
  /* 'MARLOBasicSafetyLimits2:248' 		500.000000;  */
  /* 'MARLOBasicSafetyLimits2:249' 		500.000000;  */
  /* 'MARLOBasicSafetyLimits2:250' 		... % qsp1 */
  /* 'MARLOBasicSafetyLimits2:251' 		300.000000;  */
  /* 'MARLOBasicSafetyLimits2:252' 		300.000000;  */
  /* 'MARLOBasicSafetyLimits2:253' 		... % qsp2 */
  /* 'MARLOBasicSafetyLimits2:254' 		200.000000;  */
  /* 'MARLOBasicSafetyLimits2:255' 		200.000000;  */
  /* 'MARLOBasicSafetyLimits2:256' 		... % qspLA */
  /* 'MARLOBasicSafetyLimits2:257' 		300.000000;  */
  /* 'MARLOBasicSafetyLimits2:258' 		300.000000;  */
  /* 'MARLOBasicSafetyLimits2:259' 		... % qspKA */
  /* 'MARLOBasicSafetyLimits2:260' 		500.000000;  */
  /* 'MARLOBasicSafetyLimits2:261' 		500.000000;  */
  /* 'MARLOBasicSafetyLimits2:262' 		... % q3 */
  /* 'MARLOBasicSafetyLimits2:263' 		250.000000;  */
  /* 'MARLOBasicSafetyLimits2:264' 		250.000000;  */
  /* 'MARLOBasicSafetyLimits2:265' 		... % qDLA */
  /* 'MARLOBasicSafetyLimits2:266' 		400.000000;  */
  /* 'MARLOBasicSafetyLimits2:267' 		... % q3RL */
  /* 'MARLOBasicSafetyLimits2:268' 		300.000000;  */
  /* 'MARLOBasicSafetyLimits2:269' 		... % qxT */
  /* 'MARLOBasicSafetyLimits2:270' 		150.000000;  */
  /* 'MARLOBasicSafetyLimits2:271' 		... % qyT */
  /* 'MARLOBasicSafetyLimits2:272' 		150.000000;  */
  /* 'MARLOBasicSafetyLimits2:273' 		... % theta */
  /* 'MARLOBasicSafetyLimits2:274' 		300.000000;  */
  /* 'MARLOBasicSafetyLimits2:275' 		300.000000;  */
  /* 'MARLOBasicSafetyLimits2:276' 		... % thetagr */
  /* 'MARLOBasicSafetyLimits2:277' 		300.000000;  */
  /* 'MARLOBasicSafetyLimits2:278' 		300.000000;  */
  /* 'MARLOBasicSafetyLimits2:279' 	]; */
  /*  % minimum q at full negative velocity (dqmin) */
  /*  % q1 */
  /*  % q2 */
  /*  % qLA */
  /*  % qKA */
  /*  % qgr1 */
  /*  % qgr2 */
  /*  % qgrLA */
  /*  % qgrKA */
  /*  % qsp1 */
  /*  % qsp2 */
  /*  % qspLA */
  /*  % qspKA */
  /*  % q3 */
  /*  % qDLA */
  /*  % q3RL */
  /*  % qxT */
  /*  % qyT */
  /*  % theta */
  /*  % thetagr */
  /* 'MARLOBasicSafetyLimits2:280' qminv = [... % minimum q at full negative velocity (dqmin) */
  /* 'MARLOBasicSafetyLimits2:281' 		... % q1 */
  /* 'MARLOBasicSafetyLimits2:282' 		160.000000;  */
  /* 'MARLOBasicSafetyLimits2:283' 		160.000000;  */
  /* 'MARLOBasicSafetyLimits2:284' 		... % q2 */
  /* 'MARLOBasicSafetyLimits2:285' 		200.000000;  */
  /* 'MARLOBasicSafetyLimits2:286' 		200.000000;  */
  /* 'MARLOBasicSafetyLimits2:287' 		... % qLA */
  /* 'MARLOBasicSafetyLimits2:288' 		180.000000;  */
  /* 'MARLOBasicSafetyLimits2:289' 		180.000000;  */
  /* 'MARLOBasicSafetyLimits2:290' 		... % qKA */
  /* 'MARLOBasicSafetyLimits2:291' 		30.000000;  */
  /* 'MARLOBasicSafetyLimits2:292' 		30.000000;  */
  /* 'MARLOBasicSafetyLimits2:293' 		... % qgr1 */
  /* 'MARLOBasicSafetyLimits2:294' 		160.000000;  */
  /* 'MARLOBasicSafetyLimits2:295' 		160.000000;  */
  /* 'MARLOBasicSafetyLimits2:296' 		... % qgr2 */
  /* 'MARLOBasicSafetyLimits2:297' 		200.000000;  */
  /* 'MARLOBasicSafetyLimits2:298' 		200.000000;  */
  /* 'MARLOBasicSafetyLimits2:299' 		... % qgrLA */
  /* 'MARLOBasicSafetyLimits2:300' 		180.000000;  */
  /* 'MARLOBasicSafetyLimits2:301' 		180.000000;  */
  /* 'MARLOBasicSafetyLimits2:302' 		... % qgrKA */
  /* 'MARLOBasicSafetyLimits2:303' 		30.000000;  */
  /* 'MARLOBasicSafetyLimits2:304' 		30.000000;  */
  /* 'MARLOBasicSafetyLimits2:305' 		... % qsp1 */
  /* 'MARLOBasicSafetyLimits2:306' 		-1.000000;  */
  /* 'MARLOBasicSafetyLimits2:307' 		-1.000000;  */
  /* 'MARLOBasicSafetyLimits2:308' 		... % qsp2 */
  /* 'MARLOBasicSafetyLimits2:309' 		-2.000000;  */
  /* 'MARLOBasicSafetyLimits2:310' 		-2.000000;  */
  /* 'MARLOBasicSafetyLimits2:311' 		... % qspLA */
  /* 'MARLOBasicSafetyLimits2:312' 		-1.000000;  */
  /* 'MARLOBasicSafetyLimits2:313' 		-1.000000;  */
  /* 'MARLOBasicSafetyLimits2:314' 		... % qspKA */
  /* 'MARLOBasicSafetyLimits2:315' 		-2.000000;  */
  /* 'MARLOBasicSafetyLimits2:316' 		-2.000000;  */
  /* 'MARLOBasicSafetyLimits2:317' 		... % q3 */
  /* 'MARLOBasicSafetyLimits2:318' 		-20.000000;  */
  /* 'MARLOBasicSafetyLimits2:319' 		-20.000000;  */
  /* 'MARLOBasicSafetyLimits2:320' 		... % qDLA */
  /* 'MARLOBasicSafetyLimits2:321' 		-25.000000;  */
  /* 'MARLOBasicSafetyLimits2:322' 		... % q3RL */
  /* 'MARLOBasicSafetyLimits2:323' 		-25.000000;  */
  /* 'MARLOBasicSafetyLimits2:324' 		... % qxT */
  /* 'MARLOBasicSafetyLimits2:325' 		-20.000000;  */
  /* 'MARLOBasicSafetyLimits2:326' 		... % qyT */
  /* 'MARLOBasicSafetyLimits2:327' 		-10.000000;  */
  /* 'MARLOBasicSafetyLimits2:328' 		... % theta */
  /* 'MARLOBasicSafetyLimits2:329' 		160.000000;  */
  /* 'MARLOBasicSafetyLimits2:330' 		160.000000;  */
  /* 'MARLOBasicSafetyLimits2:331' 		... % thetagr */
  /* 'MARLOBasicSafetyLimits2:332' 		160.000000;  */
  /* 'MARLOBasicSafetyLimits2:333' 		160.000000;  */
  /* 'MARLOBasicSafetyLimits2:334' 	]; */
  /*  % maximum q at full positive velocity (dqmax) */
  /*  % q1 */
  /*  % q2 */
  /*  % qLA */
  /*  % qKA */
  /*  % qgr1 */
  /*  % qgr2 */
  /*  % qgrLA */
  /*  % qgrKA */
  /*  % qsp1 */
  /*  % qsp2 */
  /*  % qspLA */
  /*  % qspKA */
  /*  % q3 */
  /*  % qDLA */
  /*  % q3RL */
  /*  % qxT */
  /*  % qyT */
  /*  % theta */
  /*  % thetagr */
  /* 'MARLOBasicSafetyLimits2:335' qmaxv = [... % maximum q at full positive velocity (dqmax) */
  /* 'MARLOBasicSafetyLimits2:336' 		... % q1 */
  /* 'MARLOBasicSafetyLimits2:337' 		180.000000;  */
  /* 'MARLOBasicSafetyLimits2:338' 		180.000000;  */
  /* 'MARLOBasicSafetyLimits2:339' 		... % q2 */
  /* 'MARLOBasicSafetyLimits2:340' 		220.000000;  */
  /* 'MARLOBasicSafetyLimits2:341' 		220.000000;  */
  /* 'MARLOBasicSafetyLimits2:342' 		... % qLA */
  /* 'MARLOBasicSafetyLimits2:343' 		180.000000;  */
  /* 'MARLOBasicSafetyLimits2:344' 		180.000000;  */
  /* 'MARLOBasicSafetyLimits2:345' 		... % qKA */
  /* 'MARLOBasicSafetyLimits2:346' 		60.000000;  */
  /* 'MARLOBasicSafetyLimits2:347' 		60.000000;  */
  /* 'MARLOBasicSafetyLimits2:348' 		... % qgr1 */
  /* 'MARLOBasicSafetyLimits2:349' 		180.000000;  */
  /* 'MARLOBasicSafetyLimits2:350' 		180.000000;  */
  /* 'MARLOBasicSafetyLimits2:351' 		... % qgr2 */
  /* 'MARLOBasicSafetyLimits2:352' 		220.000000;  */
  /* 'MARLOBasicSafetyLimits2:353' 		220.000000;  */
  /* 'MARLOBasicSafetyLimits2:354' 		... % qgrLA */
  /* 'MARLOBasicSafetyLimits2:355' 		180.000000;  */
  /* 'MARLOBasicSafetyLimits2:356' 		180.000000;  */
  /* 'MARLOBasicSafetyLimits2:357' 		... % qgrKA */
  /* 'MARLOBasicSafetyLimits2:358' 		60.000000;  */
  /* 'MARLOBasicSafetyLimits2:359' 		60.000000;  */
  /* 'MARLOBasicSafetyLimits2:360' 		... % qsp1 */
  /* 'MARLOBasicSafetyLimits2:361' 		3.000000;  */
  /* 'MARLOBasicSafetyLimits2:362' 		3.000000;  */
  /* 'MARLOBasicSafetyLimits2:363' 		... % qsp2 */
  /* 'MARLOBasicSafetyLimits2:364' 		1.000000;  */
  /* 'MARLOBasicSafetyLimits2:365' 		1.000000;  */
  /* 'MARLOBasicSafetyLimits2:366' 		... % qspLA */
  /* 'MARLOBasicSafetyLimits2:367' 		1.000000;  */
  /* 'MARLOBasicSafetyLimits2:368' 		1.000000;  */
  /* 'MARLOBasicSafetyLimits2:369' 		... % qspKA */
  /* 'MARLOBasicSafetyLimits2:370' 		1.000000;  */
  /* 'MARLOBasicSafetyLimits2:371' 		1.000000;  */
  /* 'MARLOBasicSafetyLimits2:372' 		... % q3 */
  /* 'MARLOBasicSafetyLimits2:373' 		15.000000;  */
  /* 'MARLOBasicSafetyLimits2:374' 		15.000000;  */
  /* 'MARLOBasicSafetyLimits2:375' 		... % qDLA */
  /* 'MARLOBasicSafetyLimits2:376' 		25.000000;  */
  /* 'MARLOBasicSafetyLimits2:377' 		... % q3RL */
  /* 'MARLOBasicSafetyLimits2:378' 		30.000000;  */
  /* 'MARLOBasicSafetyLimits2:379' 		... % qxT */
  /* 'MARLOBasicSafetyLimits2:380' 		0.000000;  */
  /* 'MARLOBasicSafetyLimits2:381' 		... % qyT */
  /* 'MARLOBasicSafetyLimits2:382' 		10.000000;  */
  /* 'MARLOBasicSafetyLimits2:383' 		... % theta */
  /* 'MARLOBasicSafetyLimits2:384' 		200.000000;  */
  /* 'MARLOBasicSafetyLimits2:385' 		200.000000;  */
  /* 'MARLOBasicSafetyLimits2:386' 		... % thetagr */
  /* 'MARLOBasicSafetyLimits2:387' 		200.000000;  */
  /* 'MARLOBasicSafetyLimits2:388' 		200.000000;  */
  /* 'MARLOBasicSafetyLimits2:389' 	]; */
  /*  Check limits */
  /* 'MARLOBasicSafetyLimits2:392' qbar = T * q * 180/pi; */
  /* 'MARLOBasicSafetyLimits2:393' dqbar = T * dq * 180/pi; */
  /* 'MARLOBasicSafetyLimits2:394' violation = (qbar < qmin) | (qbar > qmax) ... */
  /* 'MARLOBasicSafetyLimits2:395' 		 | (dqbar < dqmin) | (dqbar > dqmax) ... */
  /* 'MARLOBasicSafetyLimits2:396' 		 | dqbar .* (qminv - qmin) < dqmin .* (qbar - qmin) ... */
  /* 'MARLOBasicSafetyLimits2:397' 		 | dqbar .* (qmax - qmaxv) > dqmax .* (qmax - qbar); */
  for (i = 0; i < 34; i++) {
    a_0[i] = 0.0;
    for (i_0 = 0; i_0 < 13; i_0++) {
      a_0[i] += a[34 * i_0 + i] * q[i_0];
    }

    qbar[i] = a_0[i] * 180.0 / 3.1415926535897931;
    a_1[i] = 0.0;
    for (i_0 = 0; i_0 < 13; i_0++) {
      a_1[i] += a[34 * i_0 + i] * dq[i_0];
    }

    dqbar[i] = a_1[i] * 180.0 / 3.1415926535897931;
    violation[i] = ((qbar[i] < qmin[i]) || (qbar[i] > qmax[i]) || (dqbar[i] <
      dqmin[i]) || (dqbar[i] > dqmax[i]) || (dqbar[i] * (real_T)c[i] < (qbar[i]
      - (real_T)qmin[i]) * (real_T)dqmin[i]) || (dqbar[i] * (real_T)b[i] >
      ((real_T)qmax[i] - qbar[i]) * (real_T)dqmax[i]));
  }
}

/* Function for MATLAB Function: '<S1>/SAFETY' */
static boolean_T Walking01_withElmos_any(const boolean_T x[6])
{
  boolean_T y;
  int32_T k;
  boolean_T exitg1;
  y = false;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k < 6)) {
    if (!(x[k] == 0)) {
      y = true;
      exitg1 = true;
    } else {
      k++;
    }
  }

  return y;
}

/* Function for MATLAB Function: '<S194>/EstimateOrientation' */
static real_T Walking01_withElmos_norm(const real_T x[3])
{
  real_T y;
  real_T scale;
  real_T absxk;
  real_T t;
  scale = 2.2250738585072014E-308;
  absxk = fabs(x[0]);
  if (absxk > 2.2250738585072014E-308) {
    y = 1.0;
    scale = absxk;
  } else {
    t = absxk / 2.2250738585072014E-308;
    y = t * t;
  }

  absxk = fabs(x[1]);
  if (absxk > scale) {
    t = scale / absxk;
    y = y * t * t + 1.0;
    scale = absxk;
  } else {
    t = absxk / scale;
    y += t * t;
  }

  absxk = fabs(x[2]);
  if (absxk > scale) {
    t = scale / absxk;
    y = y * t * t + 1.0;
    scale = absxk;
  } else {
    t = absxk / scale;
    y += t * t;
  }

  return scale * sqrt(y);
}

/* Model output function for TID0 */
void Walking01_withElmos_output0(void) /* Sample time: [0.0005s, 0.0s] */
{
  /* local block i/o variables */
  real_T rtb_Gain[9];
  real_T rtb_UnitDelay4[9];
  real_T rtb_UnitDelay3[2];
  real_T rtb_DigitalClock;
  real_T rtb_Switch_o[6];
  real_T rtb_Switch2[6];
  real_T rtb_current_unsat[6];
  real_T rtb_Switch_n[6];
  real_T rtb_Switch2_p[6];
  real_T rtb_DataTypeConversion10;
  real_T rtb_DataTypeConversion108;
  real_T rtb_DataTypeConversion109;
  real_T rtb_DataTypeConversion11;
  real_T rtb_DataTypeConversion110;
  real_T rtb_DataTypeConversion12;
  real_T rtb_DataTypeConversion123;
  real_T rtb_DataTypeConversion124;
  real_T rtb_DataTypeConversion125;
  real_T rtb_DataTypeConversion16;
  real_T rtb_DataTypeConversion2;
  real_T rtb_DataTypeConversion23[2];
  real_T rtb_DataTypeConversion27;
  real_T rtb_DataTypeConversion29;
  real_T rtb_DataTypeConversion34;
  real_T rtb_DataTypeConversion35;
  real_T rtb_DataTypeConversion36;
  real_T rtb_DataTypeConversion47[2];
  real_T rtb_DataTypeConversion5;
  real_T rtb_DataTypeConversion51;
  real_T rtb_DataTypeConversion53;
  real_T rtb_DataTypeConversion58;
  real_T rtb_DataTypeConversion59;
  real_T rtb_DataTypeConversion60;
  real_T rtb_DataTypeConversion71[2];
  real_T rtb_DataTypeConversion75;
  real_T rtb_DataTypeConversion77;
  real_T rtb_DataTypeConversion82;
  real_T rtb_DataTypeConversion83;
  real_T rtb_DataTypeConversion84;
  real_T rtb_DataTypeConversion95[2];
  real_T rtb_Reshape[9];
  real_T rtb_u_sat[6];
  real_T rtb_motorVoltage[6];
  real_T rtb_logicVoltage[6];
  real_T rtb_measuredCurrent[10];
  real_T rtb_ImpSel_InsertedFor_q_at_o_g;
  real_T rtb_ImpSel_InsertedFor_Counter_;
  real_T rtb_ImpSel_InsertedFor_q_limi_h[2];
  real_T rtb_ImpSel_InsertedFor_Threshol;
  real_T rtb_DigitalClock_a;
  boolean_T rtb_LogicalOperator;
  boolean_T rtb_Counter_o2;

  /* local scratch DWork variables */
  int32_T ForEach_itr;
  int32_T ForEach_itr_n;
  real_T RefAngle[6];
  boolean_T iHigh[2];
  real_T NormalizedCountPrev[9];
  real_T NormalizedCount[9];
  real32_T ys[9];
  static const int8_T c[13] = { 16, 17, 18, 0, 1, 2, 3, 4, 5, 14, 6, 7, 15 };

  static const int8_T b[8] = { 3, 4, 5, 6, 7, 8, 10, 11 };

  int32_T c_previousEvent;
  real_T HAlpha[36];
  real_T L2fh[6];
  real_T T[36];
  real_T jacob_h_D_inv[78];
  real_T b_s;
  real_T b_ds;
  real_T jacob_h0[78];
  real_T b_s_unsaturated;
  real_T b_theta;
  real_T dsdq[13];
  real_T b_phi;
  real_T b_r;
  static const int8_T b_0[6] = { 1, 5, 10, 10, 5, 1 };

  static const real_T b_b[78] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 50.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 50.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 26.7, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 50.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 50.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 26.7 };

  static const real_T c_b[36] = { 50.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 50.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 26.7, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 50.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 50.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 26.7 };

  static const int8_T c_0[6] = { 0, 2, 4, 1, 3, 5 };

  static const int8_T d[6] = { 3, 4, 5, 0, 1, 2 };

  static const real_T e[36] = { 0.0, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0, 0.5, 0.0,
    1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0,
    0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 };

  static const real_T T0[36] = { 0.5, 0.0, -1.0, 0.0, 0.0, 0.0, 0.5, 0.0, 1.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.5, 0.0, -1.0, 0.0, 0.0,
    0.0, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 };

  boolean_T guard1 = false;
  real_T weight[2];
  static const real_T b_1[36] = { 0.0, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0, 0.5, 0.0,
    1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0,
    0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 };

  static const real_T b_T0[36] = { 0.5, 0.0, -1.0, 0.0, 0.0, 0.0, 0.5, 0.0, 1.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.5, 0.0, -1.0, 0.0, 0.0,
    0.0, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 };

  boolean_T exitg3;
  real_T x[34];
  int32_T ihi;
  int32_T imid;
  int32_T exponent;
  int32_T b_exponent;
  static const real_T SS_DYNAMIC_STATE_LIMIT[34] = { 1.0, 2.0, 4.0, 8.0, 16.0,
    32.0, 64.0, 128.0, 256.0, 512.0, 1024.0, 2048.0, 4096.0, 8192.0, 16384.0,
    32768.0, 65536.0, 131072.0, 262144.0, 524288.0, 1.048576E+6, 2.097152E+6,
    4.194304E+6, 8.388608E+6, 1.6777216E+7, 3.3554432E+7, 6.7108864E+7,
    1.34217728E+8, 2.68435456E+8, 5.36870912E+8, 1.073741824E+9, 2.147483648E+9,
    4.294967296E+9, 8.589934592E+9 };

  boolean_T guard1_0 = false;
  boolean_T rtb_UnitDelay_m;
  real_T rtb_VectorConcatenate[13];
  real_T rtb_y[6];
  real_T rtb_dy[6];
  real_T rtb_hd[6];
  real_T rtb_hdbar[6];
  real_T rtb_ControlStateVec[7];
  real_T rtb_u_star[6];
  real_T rtb_u_pd[6];
  real_T rtb_ImpAsg_InsertedFor_q_clean_[3];
  real_T rtb_ImpAsg_InsertedFor_dq_clean[3];
  boolean_T rtb_Compare_pw = false;
  uint32_T rtb_TmpSignalConversionAtSFunct[10];
  real_T rtb_TmpSignalConversionAtSFu_mr[9];
  real_T rtb_ImpAsg_InsertedFor_q_clea_k[19];
  real_T rtb_ImpAsg_InsertedFor_dq_cle_i[19];
  real_T rtb_ImpAsg_InsertedFor_ErrorC_g[19];
  uint32_T rtb_TmpSignalConversionAtSFun_o[9];
  real_T rtb_ImpAsg_InsertedFor_ErrorCou[3];
  real_T rtb_q_clean[13];
  real_T rtb_u[6];
  OutputParamsBus rtb_Output_k;
  OutputParamsBus rtb_Output_p;
  OutputParamsBus rtb_BusAssignment5;
  OutputParamsBus rtb_BusAssignment2;
  OutputParamsBus rtb_BusAssignment4;
  int32_T i;
  boolean_T RefAngle_0[6];
  boolean_T tmp[34];
  real_T tmp_0[2];
  boolean_T NormalizedCountPrev_0[9];
  real_T tmp_1[8];
  real_T jacob_h_D_inv_0[78];
  real_T RefAngle_1[6];
  int32_T d_data[9];
  int32_T tmp_data[2];
  int32_T tmp_data_0[2];
  int32_T tmp_data_1[2];
  real_T weight_data[2];
  real_T HalfMaxTicks_idx_0;
  real_T HalfMaxTicks_idx_1;
  real_T CalOffset_idx_0;
  real_T CalOffset_idx_1;
  real_T rtb_Switch1_idx_1;
  real_T rtb_Switch1_idx_2;

  {                                    /* Sample time: [0.0005s, 0.0s] */
    rate_monotonic_scheduler();
  }

  {
    /* user code (Output function Header for TID0) */

    /*------------ S-Function Block: <S19>/EtherCAT Init  Process Received Frames ------------*/
    xpcEtherCATReadProcessData(0,NULL);

    /* Reset subsysRan breadcrumbs */
    srClearBC(Walking01_withElmos_DW.ResetCPUOverloadCount_SubsysRan);

    /* Reset subsysRan breadcrumbs */
    srClearBC
      (Walking01_withElmos_DW.ShutdownControlWord.ShutdownControlWord_SubsysRanBC);

    /* Reset subsysRan breadcrumbs */
    srClearBC
      (Walking01_withElmos_DW.EnableControlWord.EnableControlWord_SubsysRanBC);

    /* Reset subsysRan breadcrumbs */
    srClearBC(Walking01_withElmos_DW.FaultReset.FaultReset_SubsysRanBC);

    /* Reset subsysRan breadcrumbs */
    srClearBC
      (Walking01_withElmos_DW.NothingControlWord.NothingControlWord_SubsysRanBC);

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[6];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[7];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[8];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[9];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[10];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[11];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[12];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[13];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[14];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[15];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[16];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion57' */
    Walking01_withElmos_B.DataTypeConversion57 =
      Walking01_withElmos_B.EtherCATRxVar_h;

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[17];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion81' */
    Walking01_withElmos_B.DataTypeConversion81 =
      Walking01_withElmos_B.EtherCATRxVar_k;

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[18];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion9' */
    Walking01_withElmos_B.DataTypeConversion9 =
      Walking01_withElmos_B.EtherCATRxVar_o;

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[19];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion33' */
    Walking01_withElmos_B.DataTypeConversion33 =
      Walking01_withElmos_B.EtherCATRxVar_p;

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[20];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion104' */
    Walking01_withElmos_B.DataTypeConversion104 =
      Walking01_withElmos_B.EtherCATRxVar2_g;

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[21];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion119' */
    Walking01_withElmos_B.DataTypeConversion119 =
      Walking01_withElmos_B.EtherCATRxVar2_i;

    /* UnitDelay: '<S14>/Unit Delay' */
    rtb_UnitDelay_m = Walking01_withElmos_DW.UnitDelay_DSTATE_n;

    /* Logic: '<S14>/Logical Operator1' incorporates:
     *  Constant: '<S14>/ResetDAQ1'
     *  UnitDelay: '<S14>/Unit Delay'
     */
    Walking01_withElmos_B.LogicalOperator1 = (Walking01_withElmos_P.ResetDAQ ||
      Walking01_withElmos_DW.UnitDelay_DSTATE_n);

    /* SignalConversion: '<S22>/TmpSignal ConversionAt SFunction Inport2' incorporates:
     *  DataTypeConversion: '<S19>/Data Type Conversion1'
     *  DataTypeConversion: '<S19>/Data Type Conversion114'
     *  DataTypeConversion: '<S19>/Data Type Conversion25'
     *  DataTypeConversion: '<S19>/Data Type Conversion26'
     *  DataTypeConversion: '<S19>/Data Type Conversion3'
     *  DataTypeConversion: '<S19>/Data Type Conversion49'
     *  DataTypeConversion: '<S19>/Data Type Conversion50'
     *  DataTypeConversion: '<S19>/Data Type Conversion73'
     *  DataTypeConversion: '<S19>/Data Type Conversion74'
     *  DataTypeConversion: '<S19>/Data Type Conversion98'
     *  MATLAB Function: '<S13>/calibrate'
     */
    rtb_TmpSignalConversionAtSFunct[0] = Walking01_withElmos_B.EtherCATRxVar4;
    rtb_TmpSignalConversionAtSFunct[1] = Walking01_withElmos_B.EtherCATRxVar4_p;
    rtb_TmpSignalConversionAtSFunct[2] = Walking01_withElmos_B.EtherCATRxVar4_n;
    rtb_TmpSignalConversionAtSFunct[3] = Walking01_withElmos_B.EtherCATRxVar4_e;
    rtb_TmpSignalConversionAtSFunct[4] = Walking01_withElmos_B.EtherCATRxVar8;
    rtb_TmpSignalConversionAtSFunct[5] = Walking01_withElmos_B.EtherCATRxVar8_h;
    rtb_TmpSignalConversionAtSFunct[6] = Walking01_withElmos_B.EtherCATRxVar8_b;
    rtb_TmpSignalConversionAtSFunct[7] = Walking01_withElmos_B.EtherCATRxVar8_bs;
    rtb_TmpSignalConversionAtSFunct[8] = Walking01_withElmos_B.EtherCATRxVar4_m;
    rtb_TmpSignalConversionAtSFunct[9] = Walking01_withElmos_B.EtherCATRxVar4_nd;

    /* SignalConversion: '<S22>/TmpSignal ConversionAt SFunction Inport3' incorporates:
     *  MATLAB Function: '<S13>/calibrate'
     */
    rtb_TmpSignalConversionAtSFu_mr[0] =
      Walking01_withElmos_B.DataTypeConversion57;
    rtb_TmpSignalConversionAtSFu_mr[1] =
      Walking01_withElmos_B.DataTypeConversion81;
    rtb_TmpSignalConversionAtSFu_mr[2] =
      Walking01_withElmos_B.DataTypeConversion9;
    rtb_TmpSignalConversionAtSFu_mr[3] =
      Walking01_withElmos_B.DataTypeConversion33;
    rtb_TmpSignalConversionAtSFu_mr[4] =
      Walking01_withElmos_B.DataTypeConversion104;
    rtb_TmpSignalConversionAtSFu_mr[5] =
      Walking01_withElmos_B.DataTypeConversion119;
    rtb_TmpSignalConversionAtSFu_mr[6] =
      Walking01_withElmos_ConstB.DataTypeConversion141[0];
    rtb_TmpSignalConversionAtSFu_mr[7] =
      Walking01_withElmos_ConstB.DataTypeConversion141[1];
    rtb_TmpSignalConversionAtSFu_mr[8] =
      Walking01_withElmos_ConstB.DataTypeConversion141[2];

    /* MATLAB Function: '<S13>/calibrate' incorporates:
     *  Constant: '<S13>/CalibrationParameters'
     *  DataTypeConversion: '<S19>/Data Type Conversion114'
     *  DataTypeConversion: '<S19>/Data Type Conversion98'
     *  SignalConversion: '<S22>/TmpSignal ConversionAt SFunction Inport3'
     *  UnitDelay: '<S13>/Unit Delay'
     *  UnitDelay: '<S13>/Unit Delay1'
     *  UnitDelay: '<S13>/Unit Delay2'
     */
    /* MATLAB Function 'DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/calibrate': '<S22>:1' */
    /* '<S22>:1:3' [AbsAngle, IncAngle, Rollover, IncCalTick] = calibrateEncoders2(Calibration,AbsEncoders,IncEncoders,IncEncodersPrev,Reset,RolloverIn,IncCalTickIn); */
    for (i = 0; i < 10; i++) {
      Walking01_withElmos_B.VectorConcatenate_m[i] =
        rtb_TmpSignalConversionAtSFunct[i];
    }

    /* This function calibrates the encoder values and converts to radians. */
    /*  Absolute hip encoders might rollover. This is not possible for the */
    /*  linear optical encoders. We solve the rollover problem for the */
    /*  absolute hip encoders by noting that they can only move about 30 */
    /*  degrees, so if the TICK count is very far from the CAL TICK count, we */
    /*  know a rollover has occurred. We can then add or subtract the max */
    /*  tick count to correct the problem. */
    /* 'calibrateEncoders2:11' AbsEncoders(9:10) = unrollAbsEncoders(Calibration.AbsMaxTick(9:10), Calibration.AbsCalTick(9:10), AbsEncoders(9:10)); */
    /*  We solve the rollover problem for the absolute hip encoders by noting */
    /*  that they can only move about 30 degrees, so if the TICK count is */
    /*  very far from the CAL TICK count, we know a rollover has occurred. We */
    /*  can then add or subtract the max tick count to correct the problem. */
    /* 'calibrateEncoders2:68' AbsUnrolled = AbsEncoder; */
    weight[0] = Walking01_withElmos_B.EtherCATRxVar4_m;
    weight[1] = Walking01_withElmos_B.EtherCATRxVar4_nd;

    /*  Find offset of Cal from center of tick range */
    /* 'calibrateEncoders2:71' HalfMaxTicks = AbsMaxTick/2; */
    HalfMaxTicks_idx_0 =
      Walking01_withElmos_ConstP.CalibrationParameters_Valu.AbsMaxTick[8] / 2.0;
    HalfMaxTicks_idx_1 =
      Walking01_withElmos_ConstP.CalibrationParameters_Valu.AbsMaxTick[9] / 2.0;

    /* 'calibrateEncoders2:72' CalOffset = AbsCalTick - HalfMaxTicks; */
    CalOffset_idx_0 =
      Walking01_withElmos_ConstP.CalibrationParameters_Valu.AbsCalTick[8] -
      HalfMaxTicks_idx_0;
    CalOffset_idx_1 =
      Walking01_withElmos_ConstP.CalibrationParameters_Valu.AbsCalTick[9] -
      HalfMaxTicks_idx_1;

    /*  Find index of elements where the current encoder reading is GREATER */
    /*  than CalOffset ticks above the CalTick. Correct by subtracting */
    /*  MaxTicks (results in a negative number, which is okay). */
    /* 'calibrateEncoders2:77' iHigh = (CalOffset<0) & (AbsEncoder > AbsCalTick + HalfMaxTicks); */
    iHigh[0] = ((CalOffset_idx_0 < 0.0) &&
                (Walking01_withElmos_B.EtherCATRxVar4_m >
                 Walking01_withElmos_ConstP.CalibrationParameters_Valu.AbsCalTick
                 [8] + HalfMaxTicks_idx_0));
    iHigh[1] = ((CalOffset_idx_1 < 0.0) &&
                (Walking01_withElmos_B.EtherCATRxVar4_nd >
                 Walking01_withElmos_ConstP.CalibrationParameters_Valu.AbsCalTick
                 [9] + HalfMaxTicks_idx_1));

    /* 'calibrateEncoders2:78' AbsUnrolled(iHigh) = AbsUnrolled(iHigh) - AbsMaxTick(iHigh); */
    Walking01_withElmos_eml_li_find(iHigh, tmp_data, &i);
    Walking01_withElmos_eml_li_find(iHigh, tmp_data_0, &i);
    Walking01_withElmos_eml_li_find(iHigh, tmp_data_1, &c_previousEvent);
    for (ihi = 0; ihi < i; ihi++) {
      weight[tmp_data[ihi] - 1] = (real_T)
        rtb_TmpSignalConversionAtSFunct[tmp_data_0[ihi] + 7] -
        Walking01_withElmos_ConstP.CalibrationParameters_Valu.AbsMaxTick[tmp_data_1
        [ihi] + 7];
    }

    /*  Find index of elements where the current encoder reading is LESS than */
    /*  CalOffset ticks below the CalTick. Correct by adding MaxTicks */
    /*  (results in a count greater than MaxTicks, which is okay). */
    /* 'calibrateEncoders2:83' iLow = (CalOffset>0) & (AbsEncoder < AbsCalTick - HalfMaxTicks); */
    iHigh[0] = ((CalOffset_idx_0 > 0.0) &&
                (Walking01_withElmos_B.EtherCATRxVar4_m <
                 Walking01_withElmos_ConstP.CalibrationParameters_Valu.AbsCalTick
                 [8] - HalfMaxTicks_idx_0));
    iHigh[1] = ((CalOffset_idx_1 > 0.0) &&
                (Walking01_withElmos_B.EtherCATRxVar4_nd <
                 Walking01_withElmos_ConstP.CalibrationParameters_Valu.AbsCalTick
                 [9] - HalfMaxTicks_idx_1));

    /* 'calibrateEncoders2:84' AbsUnrolled(iLow) = AbsUnrolled(iLow) + AbsMaxTick(iLow); */
    Walking01_withElmos_eml_li_find(iHigh, tmp_data, &i);
    Walking01_withElmos_eml_li_find(iHigh, tmp_data_0, &i);
    Walking01_withElmos_eml_li_find(iHigh, tmp_data_1, &c_previousEvent);
    for (ihi = 0; ihi < i; ihi++) {
      weight_data[ihi] = weight[tmp_data_0[ihi] - 1] +
        Walking01_withElmos_ConstP.CalibrationParameters_Valu.AbsMaxTick[tmp_data_1
        [ihi] + 7];
    }

    for (ihi = 0; ihi < i; ihi++) {
      weight[tmp_data[ihi] - 1] = weight_data[ihi];
    }

    Walking01_withElmos_B.VectorConcatenate_m[8] = weight[0];
    Walking01_withElmos_B.VectorConcatenate_m[9] = weight[1];

    /*  Calibrate absolute encoders */
    /* 'calibrateEncoders2:14' AbsAngle = Calibration.AbsCalAngle + Calibration.AbsCalConst.*(AbsEncoders - Calibration.AbsCalTick); */
    for (ihi = 0; ihi < 10; ihi++) {
      Walking01_withElmos_B.VectorConcatenate_m[ihi] =
        (Walking01_withElmos_B.VectorConcatenate_m[ihi] -
         Walking01_withElmos_ConstP.CalibrationParameters_Valu.AbsCalTick[ihi]) *
        Walking01_withElmos_ConstP.CalibrationParameters_Valu.AbsCalConst[ihi] +
        Walking01_withElmos_ConstP.CalibrationParameters_Valu.AbsCalAngle[ihi];
    }

    /*  Calibration and rollover count for incremental encoders */
    /* 'calibrateEncoders2:17' if Reset */
    if (Walking01_withElmos_B.LogicalOperator1) {
      /* 'calibrateEncoders2:18' Rollover = 0*RolloverIn; */
      for (i = 0; i < 9; i++) {
        Walking01_withElmos_B.Rollover[i] = 0.0 *
          Walking01_withElmos_DW.UnitDelay_DSTATE[i];
      }

      /* 'calibrateEncoders2:19' RefAngle = [AbsAngle(5:8)*50; AbsAngle(9:10)]; */
      RefAngle[0] = Walking01_withElmos_B.VectorConcatenate_m[4] * 50.0;
      RefAngle[1] = Walking01_withElmos_B.VectorConcatenate_m[5] * 50.0;
      RefAngle[2] = Walking01_withElmos_B.VectorConcatenate_m[6] * 50.0;
      RefAngle[3] = Walking01_withElmos_B.VectorConcatenate_m[7] * 50.0;
      RefAngle[4] = Walking01_withElmos_B.VectorConcatenate_m[8];
      RefAngle[5] = Walking01_withElmos_B.VectorConcatenate_m[9];

      /* 'calibrateEncoders2:20' [IncCalTick, Rollover(1:6)] = getIncCalTick(Calibration.IncCalConst, Calibration.IncMaxTick, RefAngle, IncEncoders(1:6)); */
      /*  Compute the calibration tick count corresponding to 0 degrees */
      /* 'calibrateEncoders2:36' IncCalTick = mod(IncTick - AbsAngle./IncCalConst, IncMaxTick); */
      for (i = 0; i < 6; i++) {
        L2fh[i] = rtb_TmpSignalConversionAtSFu_mr[i] - RefAngle[i] /
          Walking01_withElmos_ConstP.CalibrationParameters_Valu.IncCalConst[i];
        Walking01_withElmos_B.IncCalTick[i] = 0.0;
      }

      for (i = 0; i < 6; i++) {
        if (Walking01_withElmos_ConstP.CalibrationParameters_Valu.IncMaxTick[i] ==
            0.0) {
          Walking01_withElmos_Y.r = L2fh[i];
        } else if
            (Walking01_withElmos_ConstP.CalibrationParameters_Valu.IncMaxTick[i]
             == floor
             (Walking01_withElmos_ConstP.CalibrationParameters_Valu.IncMaxTick[i]))
        {
          Walking01_withElmos_Y.r = L2fh[i] - floor(L2fh[i] /
            Walking01_withElmos_ConstP.CalibrationParameters_Valu.IncMaxTick[i])
            * Walking01_withElmos_ConstP.CalibrationParameters_Valu.IncMaxTick[i];
        } else {
          Walking01_withElmos_Y.r = L2fh[i] /
            Walking01_withElmos_ConstP.CalibrationParameters_Valu.IncMaxTick[i];
          if (fabs(Walking01_withElmos_Y.r - rt_roundd_snf
                   (Walking01_withElmos_Y.r)) <= 2.2204460492503131E-16 * fabs
              (Walking01_withElmos_Y.r)) {
            Walking01_withElmos_Y.r = 0.0;
          } else {
            Walking01_withElmos_Y.r = (Walking01_withElmos_Y.r - floor
              (Walking01_withElmos_Y.r)) *
              Walking01_withElmos_ConstP.CalibrationParameters_Valu.IncMaxTick[i];
          }
        }

        Walking01_withElmos_B.IncCalTick[i] = Walking01_withElmos_Y.r;
      }

      /* Rollover = floor((IncCalTick-IncTick)./IncMaxTick); */
      /* 'calibrateEncoders2:38' Rollover = floor((AbsAngle./IncCalConst-IncTick+IncCalTick)./IncMaxTick); */
      for (ihi = 0; ihi < 6; ihi++) {
        HalfMaxTicks_idx_0 = floor(((RefAngle[ihi] /
          Walking01_withElmos_ConstP.CalibrationParameters_Valu.IncCalConst[ihi]
          - rtb_TmpSignalConversionAtSFu_mr[ihi]) +
          Walking01_withElmos_B.IncCalTick[ihi]) /
          Walking01_withElmos_ConstP.CalibrationParameters_Valu.IncMaxTick[ihi]);
        Walking01_withElmos_B.Rollover[ihi] = HalfMaxTicks_idx_0;
        RefAngle[ihi] = HalfMaxTicks_idx_0;
      }
    } else {
      /* 'calibrateEncoders2:21' else */
      /* 'calibrateEncoders2:23' Rollover   = RolloverIn + getRollover(Calibration.MaxTick, IncEncoders, IncEncodersPrev); */
      /*  Determine if a rollover has occurred on any incremental encoder */
      /*  The determination is made by assuming the encoder shaft has rotated */
      /*  less than half of a revolution since the previous time step. If a */
      /*  rollover is detected on a particular encoder, the corresponding */
      /*  element of Rollover is either +1 or -1, depending on the direction of */
      /*  the rollover */
      /*  */
      /*  To compute the rollover, ticks are normalized by the maximum tick */
      /*  number. This maps all (NormalizedCountPrev, NormalizedCount) pairs */
      /*  into the region [0,1]X[0,1] in the plane. The upper left hand corner */
      /*  corresponds to negative rollover, and the lower right hand corner */
      /*  corresponds to positive rollover. */
      /* 'calibrateEncoders2:55' NormalizedCountPrev = IncEncodersPrev./MaxTick; */
      /* 'calibrateEncoders2:56' NormalizedCount     = IncEncoders./MaxTick; */
      /* 'calibrateEncoders2:58' Rollover = zeros(9,1); */
      /* 'calibrateEncoders2:59' Rollover(NormalizedCountPrev<0.5 & NormalizedCount > (NormalizedCountPrev+0.5)) = -1; */
      for (i = 0; i < 9; i++) {
        HalfMaxTicks_idx_0 = Walking01_withElmos_DW.UnitDelay1_DSTATE[i] /
          Walking01_withElmos_ConstP.CalibrationParameters_Valu.MaxTick[i];
        HalfMaxTicks_idx_1 = rtb_TmpSignalConversionAtSFu_mr[i] /
          Walking01_withElmos_ConstP.CalibrationParameters_Valu.MaxTick[i];
        Walking01_withElmos_B.Rollover[i] = 0.0;
        NormalizedCountPrev_0[i] = ((HalfMaxTicks_idx_0 < 0.5) &&
          (HalfMaxTicks_idx_1 > HalfMaxTicks_idx_0 + 0.5));
        NormalizedCountPrev[i] = HalfMaxTicks_idx_0;
        NormalizedCount[i] = HalfMaxTicks_idx_1;
      }

      Walking01_withElm_eml_li_find_k(NormalizedCountPrev_0, d_data,
        &c_previousEvent);
      for (ihi = 0; ihi < c_previousEvent; ihi++) {
        Walking01_withElmos_B.Rollover[d_data[ihi] - 1] = -1.0;
      }

      /* 'calibrateEncoders2:60' Rollover(NormalizedCountPrev>0.5 & NormalizedCount < (NormalizedCountPrev-0.5)) = 1; */
      for (ihi = 0; ihi < 9; ihi++) {
        NormalizedCountPrev_0[ihi] = ((NormalizedCountPrev[ihi] > 0.5) &&
          (NormalizedCount[ihi] < NormalizedCountPrev[ihi] - 0.5));
      }

      Walking01_withElm_eml_li_find_k(NormalizedCountPrev_0, d_data,
        &c_previousEvent);
      for (ihi = 0; ihi < c_previousEvent; ihi++) {
        Walking01_withElmos_B.Rollover[d_data[ihi] - 1] = 1.0;
      }

      for (ihi = 0; ihi < 9; ihi++) {
        Walking01_withElmos_B.Rollover[ihi] +=
          Walking01_withElmos_DW.UnitDelay_DSTATE[ihi];
      }

      /* 'calibrateEncoders2:24' IncCalTick = IncCalTickIn; */
      for (i = 0; i < 6; i++) {
        Walking01_withElmos_B.IncCalTick[i] =
          Walking01_withElmos_DW.UnitDelay2_DSTATE[i];
      }
    }

    /*  Calibrate incremental encoders */
    /* 'calibrateEncoders2:28' IncCalTickB = [IncCalTick; Calibration.BoomCalTick]; */
    /* 'calibrateEncoders2:29' IncCalAngle = [zeros(6,1); Calibration.BoomCalAngle]; */
    /* 'calibrateEncoders2:30' IncTick     = IncEncoders + Calibration.MaxTick.*Rollover; */
    /* 'calibrateEncoders2:31' IncAngle    = IncCalAngle + [Calibration.IncCalConst; Calibration.BoomCalConst].*(IncTick - IncCalTickB); */
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_B.VectorConcatenate_m[i + 10] =
        ((Walking01_withElmos_ConstP.CalibrationParameters_Valu.MaxTick[i] *
          Walking01_withElmos_B.Rollover[i] + rtb_TmpSignalConversionAtSFu_mr[i])
         - Walking01_withElmos_B.IncCalTick[i]) *
        Walking01_withElmos_ConstP.CalibrationParameters_Valu.IncCalConst[i];
    }

    Walking01_withElmos_B.VectorConcatenate_m[16] =
      ((Walking01_withElmos_ConstP.CalibrationParameters_Valu.MaxTick[6] *
        Walking01_withElmos_B.Rollover[6] +
        Walking01_withElmos_ConstB.DataTypeConversion141[0]) -
       Walking01_withElmos_ConstP.CalibrationParameters_Valu.BoomCalTick[0]) *
      Walking01_withElmos_ConstP.CalibrationParameters_Valu.BoomCalConst[0] +
      Walking01_withElmos_ConstP.CalibrationParameters_Valu.BoomCalAngle[0];
    Walking01_withElmos_B.VectorConcatenate_m[17] =
      ((Walking01_withElmos_ConstP.CalibrationParameters_Valu.MaxTick[7] *
        Walking01_withElmos_B.Rollover[7] +
        Walking01_withElmos_ConstB.DataTypeConversion141[1]) -
       Walking01_withElmos_ConstP.CalibrationParameters_Valu.BoomCalTick[1]) *
      Walking01_withElmos_ConstP.CalibrationParameters_Valu.BoomCalConst[1] +
      Walking01_withElmos_ConstP.CalibrationParameters_Valu.BoomCalAngle[1];
    Walking01_withElmos_B.VectorConcatenate_m[18] =
      ((Walking01_withElmos_ConstP.CalibrationParameters_Valu.MaxTick[8] *
        Walking01_withElmos_B.Rollover[8] +
        Walking01_withElmos_ConstB.DataTypeConversion141[2]) -
       Walking01_withElmos_ConstP.CalibrationParameters_Valu.BoomCalTick[2]) *
      Walking01_withElmos_ConstP.CalibrationParameters_Valu.BoomCalConst[2] +
      Walking01_withElmos_ConstP.CalibrationParameters_Valu.BoomCalAngle[2];

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[22];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[23];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[24];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[25];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[26];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[27];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[28];
      sfcnOutputs(rts, 0);
    }

    /* SignalConversion: '<S13>/TmpSignal ConversionAtEncoderFiltersInport5' incorporates:
     *  DataTypeConversion: '<S19>/Data Type Conversion107'
     *  DataTypeConversion: '<S19>/Data Type Conversion122'
     *  DataTypeConversion: '<S19>/Data Type Conversion18'
     *  DataTypeConversion: '<S19>/Data Type Conversion31'
     *  DataTypeConversion: '<S19>/Data Type Conversion55'
     *  DataTypeConversion: '<S19>/Data Type Conversion7'
     *  DataTypeConversion: '<S19>/Data Type Conversion79'
     */
    Walking01_withElmos_B.TmpSignalConversionAtEncoderFil[0] =
      Walking01_withElmos_B.EtherCATRxVar18;
    Walking01_withElmos_B.TmpSignalConversionAtEncoderFil[1] =
      Walking01_withElmos_B.EtherCATRxVar18_c;
    Walking01_withElmos_B.TmpSignalConversionAtEncoderFil[2] =
      Walking01_withElmos_B.EtherCATRxVar18_i;
    Walking01_withElmos_B.TmpSignalConversionAtEncoderFil[3] =
      Walking01_withElmos_B.EtherCATRxVar18_f;
    Walking01_withElmos_B.TmpSignalConversionAtEncoderFil[4] =
      Walking01_withElmos_B.EtherCATRxVar18;
    Walking01_withElmos_B.TmpSignalConversionAtEncoderFil[5] =
      Walking01_withElmos_B.EtherCATRxVar18_c;
    Walking01_withElmos_B.TmpSignalConversionAtEncoderFil[6] =
      Walking01_withElmos_B.EtherCATRxVar18_i;
    Walking01_withElmos_B.TmpSignalConversionAtEncoderFil[7] =
      Walking01_withElmos_B.EtherCATRxVar18_f;
    Walking01_withElmos_B.TmpSignalConversionAtEncoderFil[8] =
      Walking01_withElmos_B.EtherCATRxVar15_b;
    Walking01_withElmos_B.TmpSignalConversionAtEncoderFil[9] =
      Walking01_withElmos_B.EtherCATRxVar15_g;
    Walking01_withElmos_B.TmpSignalConversionAtEncoderFil[10] =
      Walking01_withElmos_B.EtherCATRxVar18;
    Walking01_withElmos_B.TmpSignalConversionAtEncoderFil[11] =
      Walking01_withElmos_B.EtherCATRxVar18_c;
    Walking01_withElmos_B.TmpSignalConversionAtEncoderFil[12] =
      Walking01_withElmos_B.EtherCATRxVar18_i;
    Walking01_withElmos_B.TmpSignalConversionAtEncoderFil[13] =
      Walking01_withElmos_B.EtherCATRxVar18_f;
    Walking01_withElmos_B.TmpSignalConversionAtEncoderFil[14] =
      Walking01_withElmos_B.EtherCATRxVar15_b;
    Walking01_withElmos_B.TmpSignalConversionAtEncoderFil[15] =
      Walking01_withElmos_B.EtherCATRxVar15_g;
    Walking01_withElmos_B.TmpSignalConversionAtEncoderFil[16] =
      Walking01_withElmos_B.EtherCATRxVar17_c;
    Walking01_withElmos_B.TmpSignalConversionAtEncoderFil[17] =
      Walking01_withElmos_B.EtherCATRxVar17_c;
    Walking01_withElmos_B.TmpSignalConversionAtEncoderFil[18] =
      Walking01_withElmos_B.EtherCATRxVar17_c;

    /* Outputs for Iterator SubSystem: '<S13>/EncoderFilters' incorporates:
     *  ForEach: '<S18>/For Each'
     */
    for (ForEach_itr_n = 0; ForEach_itr_n < 19; ForEach_itr_n++) {
      /* ForEachSliceSelector: '<S18>/ImpSel_InsertedFor_q_at_outport_0' */
      rtb_ImpSel_InsertedFor_q_at_o_g =
        Walking01_withElmos_B.VectorConcatenate_m[ForEach_itr_n];

      /* ForEachSliceSelector: '<S18>/ImpSel_InsertedFor_Counter_at_outport_0' */
      rtb_ImpSel_InsertedFor_Counter_ =
        Walking01_withElmos_B.TmpSignalConversionAtEncoderFil[ForEach_itr_n];

      /* ForEachSliceSelector: '<S18>/ImpSel_InsertedFor_q_limits_at_outport_0' incorporates:
       *  Constant: '<S13>/EncoderAngleLimits'
       */
      rtb_ImpSel_InsertedFor_q_limi_h[0] =
        Walking01_withElmos_ConstInitP.EncoderAngleLimits_V[ForEach_itr_n];
      rtb_ImpSel_InsertedFor_q_limi_h[1] =
        Walking01_withElmos_ConstInitP.EncoderAngleLimits_V[ForEach_itr_n + 19];

      /* ForEachSliceSelector: '<S18>/ImpSel_InsertedFor_Threshold_at_outport_0' incorporates:
       *  Constant: '<S13>/EncoderThreshold'
       */
      rtb_ImpSel_InsertedFor_Threshol =
        Walking01_withElmos_ConstP.EncoderThreshold_Val[ForEach_itr_n];

      /* UnitDelay: '<S24>/Unit Delay' */
      Walking01_withElmos_B.CoreSubsys[ForEach_itr_n].UnitDelay =
        Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n].UnitDelay_DSTATE;

      /* Chart: '<S24>/AnomalyDetection' incorporates:
       *  Constant: '<S24>/Constant'
       */
      Walking01_with_AnomalyDetection(rtb_ImpSel_InsertedFor_q_at_o_g,
        Walking01_withElmos_B.CoreSubsys[ForEach_itr_n].UnitDelay,
        rtb_ImpSel_InsertedFor_Counter_, rtb_ImpSel_InsertedFor_q_limi_h,
        rtb_ImpSel_InsertedFor_Threshol, Walking01_withElmos_B.LogicalOperator1,
        0.0005, &Walking01_withElmos_B.CoreSubsys[ForEach_itr_n].
        sf_AnomalyDetection, &Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n].
        sf_AnomalyDetection);

      /* DiscreteStateSpace: '<S24>/Discrete State-Space' */
      {
        Walking01_withElmos_B.CoreSubsys[ForEach_itr_n].DiscreteStateSpace =
          (28.7137836069783)*Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n].
          DiscreteStateSpace_DSTATE[0]
          + (24.404633282623223)*Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n]
          .DiscreteStateSpace_DSTATE[1]
          + (-12.020156246194272)*
          Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n].
          DiscreteStateSpace_DSTATE[2]
          + (1.3967204886477091)*Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n]
          .DiscreteStateSpace_DSTATE[3];
        Walking01_withElmos_B.CoreSubsys[ForEach_itr_n].DiscreteStateSpace +=
          1542.8571428571429*Walking01_withElmos_B.CoreSubsys[ForEach_itr_n].
          sf_AnomalyDetection.q_clean;
      }

      /* ForEachSliceAssignment: '<S18>/ImpAsg_InsertedFor_q_clean_at_inport_0' */
      rtb_ImpAsg_InsertedFor_q_clea_k[ForEach_itr_n] =
        Walking01_withElmos_B.CoreSubsys[ForEach_itr_n].
        sf_AnomalyDetection.q_clean;

      /* ForEachSliceAssignment: '<S18>/ImpAsg_InsertedFor_dq_clean_at_inport_0' */
      rtb_ImpAsg_InsertedFor_dq_cle_i[ForEach_itr_n] =
        Walking01_withElmos_B.CoreSubsys[ForEach_itr_n].DiscreteStateSpace;

      /* ForEachSliceAssignment: '<S18>/ImpAsg_InsertedFor_ErrorCount_at_inport_0' */
      rtb_ImpAsg_InsertedFor_ErrorC_g[ForEach_itr_n] =
        Walking01_withElmos_B.CoreSubsys[ForEach_itr_n].
        sf_AnomalyDetection.ErrorCount;
    }

    /* End of Outputs for SubSystem: '<S13>/EncoderFilters' */

    /* RateTransition: '<S5>/Rate Transition2' */
    if (Walking01_withElmos_M->Timing.RateInteraction.TID0_1) {
      Walking01_withElmos_B.RateTransition2[0] =
        Walking01_withElmos_DW.RateTransition2_Buffer0[0];
      Walking01_withElmos_B.RateTransition2[1] =
        Walking01_withElmos_DW.RateTransition2_Buffer0[1];
      Walking01_withElmos_B.RateTransition2[2] =
        Walking01_withElmos_DW.RateTransition2_Buffer0[2];
    }

    /* End of RateTransition: '<S5>/Rate Transition2' */

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[29];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[30];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[31];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[32];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[33];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[34];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[35];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[36];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[37];
      sfcnOutputs(rts, 0);
    }

    /* SignalConversion: '<S42>/TmpSignal ConversionAt SFunction Inport1' incorporates:
     *  MATLAB Function: '<S33>/TypecastAndCast'
     */
    rtb_TmpSignalConversionAtSFun_o[0] = Walking01_withElmos_B.EtherCATRxVar6;
    rtb_TmpSignalConversionAtSFun_o[1] = Walking01_withElmos_B.EtherCATRxVar1;
    rtb_TmpSignalConversionAtSFun_o[2] = Walking01_withElmos_B.EtherCATRxVar2;
    rtb_TmpSignalConversionAtSFun_o[3] = Walking01_withElmos_B.EtherCATRxVar5;
    rtb_TmpSignalConversionAtSFun_o[4] = Walking01_withElmos_B.EtherCATRxVar3;
    rtb_TmpSignalConversionAtSFun_o[5] = Walking01_withElmos_B.EtherCATRxVar4_ph;
    rtb_TmpSignalConversionAtSFun_o[6] = Walking01_withElmos_B.EtherCATRxVar19;
    rtb_TmpSignalConversionAtSFun_o[7] = Walking01_withElmos_B.EtherCATRxVar7;
    rtb_TmpSignalConversionAtSFun_o[8] = Walking01_withElmos_B.EtherCATRxVar8_m;

    /* MATLAB Function: '<S33>/TypecastAndCast' incorporates:
     *  Gain: '<S13>/Gain'
     */
    /* MATLAB Function 'DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/TypecastAndCast': '<S42>:1' */
    /* '<S42>:1:3' ys = typecast(u, 'single'); */
    memcpy(&ys[0], &rtb_TmpSignalConversionAtSFun_o[0], (size_t)9 * sizeof
           (real32_T));

    /* '<S42>:1:4' y  = double(ys); */
    for (ihi = 0; ihi < 9; ihi++) {
      NormalizedCountPrev[ihi] = ys[ihi];
    }

    /* Gain: '<S13>/Gain' */
    for (ihi = 0; ihi < 3; ihi++) {
      for (c_previousEvent = 0; c_previousEvent < 3; c_previousEvent++) {
        rtb_Gain[ihi + 3 * c_previousEvent] = 0.0;
        rtb_Gain[ihi + 3 * c_previousEvent] += NormalizedCountPrev[3 *
          c_previousEvent] * Walking01_withElmos_ConstP.Gain_Gain[ihi];
        rtb_Gain[ihi + 3 * c_previousEvent] += NormalizedCountPrev[3 *
          c_previousEvent + 1] * Walking01_withElmos_ConstP.Gain_Gain[ihi + 3];
        rtb_Gain[ihi + 3 * c_previousEvent] += NormalizedCountPrev[3 *
          c_previousEvent + 2] * Walking01_withElmos_ConstP.Gain_Gain[ihi + 6];
      }
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[38];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[39];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[40];
      sfcnOutputs(rts, 0);
    }

    /* MATLAB Function: '<S33>/TypecastAndCast2' */
    Walking01_with_TypecastAndCast1(Walking01_withElmos_B.EtherCATRxVar10,
      Walking01_withElmos_B.EtherCATRxVar14,
      Walking01_withElmos_B.EtherCATRxVar13,
      &Walking01_withElmos_B.sf_TypecastAndCast2);

    /* Logic: '<S13>/Logical Operator' incorporates:
     *  Constant: '<S5>/ResetYaw'
     */
    rtb_LogicalOperator = (Walking01_withElmos_B.LogicalOperator1 ||
      Walking01_withElmos_P.ResetYaw);

    /* UnitDelay: '<S13>/Unit Delay4' */
    memcpy(&rtb_UnitDelay4[0], &Walking01_withElmos_DW.UnitDelay4_DSTATE[0], 9U *
           sizeof(real_T));

    /* UnitDelay: '<S13>/Unit Delay3' */
    rtb_UnitDelay3[0] = Walking01_withElmos_DW.UnitDelay3_DSTATE[0];
    rtb_UnitDelay3[1] = Walking01_withElmos_DW.UnitDelay3_DSTATE[1];

    /* MATLAB Function: '<S13>/ComputeEulerAngles' incorporates:
     *  Constant: '<S13>/MisalignmentMatrixParams'
     */
    Walking01_wi_ComputeEulerAngles(rtb_Gain,
      Walking01_withElmos_B.sf_TypecastAndCast2.y,
      Walking01_withElmos_ConstP.MisalignmentMatrixPar, rtb_LogicalOperator,
      rtb_UnitDelay4, rtb_UnitDelay3,
      &Walking01_withElmos_B.sf_ComputeEulerAngles);

    /* Outputs for Iterator SubSystem: '<S13>/IMUFilters' incorporates:
     *  ForEach: '<S20>/For Each'
     */
    for (ForEach_itr = 0; ForEach_itr < 3; ForEach_itr++) {
      /* ForEachSliceSelector: '<S20>/ImpSel_InsertedFor_q_at_outport_0' */
      HalfMaxTicks_idx_0 =
        Walking01_withElmos_B.sf_ComputeEulerAngles.ZYX[ForEach_itr];

      /* ForEachSliceSelector: '<S20>/ImpSel_InsertedFor_IMURate_at_outport_0' */
      HalfMaxTicks_idx_1 =
        Walking01_withElmos_B.sf_ComputeEulerAngles.dZYX[ForEach_itr];

      /* RateTransition: '<S117>/Rate Transition' incorporates:
       *  RateTransition: '<S117>/Rate Transition3'
       */
      if (Walking01_withElmos_M->Timing.RateInteraction.TID0_2) {
        Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].RateTransition =
          HalfMaxTicks_idx_0;

        /* RateTransition: '<S117>/Rate Transition7' */
        Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].RateTransition7 =
          Walking01_withElmos_B.LogicalOperator1;
        Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].RateTransition3 =
          HalfMaxTicks_idx_1;

        /* RateTransition: '<S117>/Rate Transition4' incorporates:
         *  Constant: '<S13>/UseIMURates'
         */
        Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].RateTransition4 = 0.0;
      }

      /* End of RateTransition: '<S117>/Rate Transition' */

      /* ForEachSliceAssignment: '<S20>/ImpAsg_InsertedFor_q_clean_at_inport_0' incorporates:
       *  RateTransition: '<S117>/Rate Transition1'
       */
      rtb_ImpAsg_InsertedFor_q_clean_[ForEach_itr] =
        Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .RateTransition1_Buffer[Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .RateTransition1_ActiveBufIdx];

      /* ForEachSliceAssignment: '<S20>/ImpAsg_InsertedFor_dq_clean_at_inport_0' incorporates:
       *  RateTransition: '<S117>/Rate Transition2'
       */
      rtb_ImpAsg_InsertedFor_dq_clean[ForEach_itr] =
        Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .RateTransition2_Buffer[Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .RateTransition2_ActiveBufIdx];

      /* ForEachSliceAssignment: '<S20>/ImpAsg_InsertedFor_ErrorCount_at_inport_0' incorporates:
       *  RateTransition: '<S117>/Rate Transition8'
       */
      rtb_ImpAsg_InsertedFor_ErrorCou[ForEach_itr] =
        Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .RateTransition8_Buffer[Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .RateTransition8_ActiveBufIdx];
    }

    /* End of Outputs for SubSystem: '<S13>/IMUFilters' */

    /* RateTransition: '<S5>/Rate Transition1' */
    if (Walking01_withElmos_M->Timing.RateInteraction.TID0_1) {
      Walking01_withElmos_B.RateTransition1[0] =
        Walking01_withElmos_DW.RateTransition1_Buffer0[0];
      Walking01_withElmos_B.RateTransition1[1] =
        Walking01_withElmos_DW.RateTransition1_Buffer0[1];
      Walking01_withElmos_B.RateTransition1[2] =
        Walking01_withElmos_DW.RateTransition1_Buffer0[2];
    }

    /* End of RateTransition: '<S5>/Rate Transition1' */

    /* Switch: '<S16>/Switch1' incorporates:
     *  Constant: '<S16>/UseKVH'
     */
    if (1.0 > 0.0) {
      CalOffset_idx_1 = Walking01_withElmos_B.RateTransition1[0];
      rtb_Switch1_idx_1 = Walking01_withElmos_B.RateTransition1[1];
      rtb_Switch1_idx_2 = Walking01_withElmos_B.RateTransition1[2];
    } else {
      CalOffset_idx_1 = rtb_ImpAsg_InsertedFor_dq_clean[0];
      rtb_Switch1_idx_1 = rtb_ImpAsg_InsertedFor_dq_clean[1];
      rtb_Switch1_idx_2 = rtb_ImpAsg_InsertedFor_dq_clean[2];
    }

    /* End of Switch: '<S16>/Switch1' */

    /* MATLAB Function: '<S16>/GeneralizedCoordinates' incorporates:
     *  Constant: '<S16>/UseIMU'
     *  Constant: '<S16>/UseMotorIncEncoders'
     *  Constant: '<S5>/GearOffset'
     *  Constant: '<S5>/IMUTorsoOffset'
     */
    /* MATLAB Function 'DAQ_WITH_SAFETY_IMU/DAQ/StateEstimator/GeneralizedCoordinates': '<S197>:1' */
    /*  q_clean = */
    /*   [qzT; qyT; qxT; q1R; q2R; q1L; q2L; qgr1R; qgr2R; q3R; qgr1L; qgr2L; q3L]; */
    /*  */
    /*  EncoderAngles =  */
    /*   [Leg1R; Leg2R; Leg1L; Leg2L; Motor1R; Motor2R; Motor1L; Motor2L; Hip3R; Hip3L; ...   % ABSOLUTE ENCODERS */
    /*    Inc1R; Inc2R; Inc1L; Inc2L; Inc3R; Inc3L; Boom; Boom; Boom]                         % INCREMENTAL ENCODERS */
    /* '<S197>:1:11' if (Reset) */
    if (Walking01_withElmos_B.LogicalOperator1) {
      /* '<S197>:1:12' q_clean  = zeros(13,1); */
      /* '<S197>:1:13' dq_clean = zeros(13,1); */
      for (i = 0; i < 13; i++) {
        rtb_q_clean[i] = 0.0;
        Walking01_withElmos_B.dq_clean[i] = 0.0;
      }
    } else {
      /* '<S197>:1:14' else */
      /* '<S197>:1:15' q_clean  = EncoderAngles([17:19 1:6 15 7:8 16]); */
      /* '<S197>:1:16' dq_clean = EncoderVelocities([17:19 1:6 15 7:8 16]); */
      for (ihi = 0; ihi < 13; ihi++) {
        rtb_q_clean[ihi] = rtb_ImpAsg_InsertedFor_q_clea_k[c[ihi]];
        Walking01_withElmos_B.dq_clean[ihi] =
          rtb_ImpAsg_InsertedFor_dq_cle_i[c[ihi]];
      }

      /* '<S197>:1:18' if (UseMotorIncEncoders) */
      if (0.0 != 0.0) {
        /* '<S197>:1:19' if 0 */
        /* '<S197>:1:31' else */
        /*  BGB 2015-02-05 */
        /*  Perhaps the harmonic drive is bad? We are seeing drift in */
        /*  the 2L incremental motor encoder. */
        /* '<S197>:1:35' q_clean(8:9)  = EncoderAngles(11:12)/50; */
        rtb_q_clean[7] = rtb_ImpAsg_InsertedFor_q_clea_k[10] / 50.0;
        rtb_q_clean[8] = rtb_ImpAsg_InsertedFor_q_clea_k[11] / 50.0;

        /* '<S197>:1:36' dq_clean(8:9) = EncoderVelocities(11:12)/50; */
        Walking01_withElmos_B.dq_clean[7] = rtb_ImpAsg_InsertedFor_dq_cle_i[10] /
          50.0;
        Walking01_withElmos_B.dq_clean[8] = rtb_ImpAsg_InsertedFor_dq_cle_i[11] /
          50.0;
      }

      /*  Add offset to gear angles to allow zeroing of spring deflections. */
      /* '<S197>:1:41' q_clean([8:9 11:12]) = q_clean([8:9 11:12]) + GearOffset*pi/180; */
      HalfMaxTicks_idx_0 = Walking01_withElmos_P.GearOffsets[1] *
        3.1415926535897931 / 180.0 + rtb_q_clean[8];
      HalfMaxTicks_idx_1 = Walking01_withElmos_P.GearOffsets[2] *
        3.1415926535897931 / 180.0 + rtb_q_clean[10];
      CalOffset_idx_0 = Walking01_withElmos_P.GearOffsets[3] *
        3.1415926535897931 / 180.0 + rtb_q_clean[11];
      rtb_q_clean[7] += Walking01_withElmos_P.GearOffsets[0] *
        3.1415926535897931 / 180.0;
      rtb_q_clean[8] = HalfMaxTicks_idx_0;
      rtb_q_clean[10] = HalfMaxTicks_idx_1;
      rtb_q_clean[11] = CalOffset_idx_0;

      /* '<S197>:1:43' if (UseIMU) */
      if (1.0 != 0.0) {
        /* Switch: '<S16>/Switch' incorporates:
         *  Constant: '<S16>/UseKVH'
         */
        /* '<S197>:1:44' q_clean(1:3)  = IMUAngles + [0; IMUTorsoOffset]*pi/180; */
        if (1.0 > 0.0) {
          rtb_q_clean[0] = Walking01_withElmos_B.RateTransition2[0];
          HalfMaxTicks_idx_1 = Walking01_withElmos_B.RateTransition2[1];
        } else {
          rtb_q_clean[0] = rtb_ImpAsg_InsertedFor_q_clean_[0];
          HalfMaxTicks_idx_1 = rtb_ImpAsg_InsertedFor_q_clean_[1];
        }

        rtb_q_clean[1] = Walking01_withElmos_P.IMUTorsoOffsets[0] *
          3.1415926535897931 / 180.0 + HalfMaxTicks_idx_1;

        /* Switch: '<S16>/Switch' incorporates:
         *  Constant: '<S16>/UseKVH'
         *  Constant: '<S5>/IMUTorsoOffset'
         */
        if (1.0 > 0.0) {
          HalfMaxTicks_idx_1 = Walking01_withElmos_B.RateTransition2[2];
        } else {
          HalfMaxTicks_idx_1 = rtb_ImpAsg_InsertedFor_q_clean_[2];
        }

        rtb_q_clean[2] = Walking01_withElmos_P.IMUTorsoOffsets[1] *
          3.1415926535897931 / 180.0 + HalfMaxTicks_idx_1;

        /* '<S197>:1:45' dq_clean(1:3) = IMUVelocities; */
        Walking01_withElmos_B.dq_clean[0] = CalOffset_idx_1;
        Walking01_withElmos_B.dq_clean[1] = rtb_Switch1_idx_1;
        Walking01_withElmos_B.dq_clean[2] = rtb_Switch1_idx_2;
      }
    }

    /* End of MATLAB Function: '<S16>/GeneralizedCoordinates' */

    /* MATLAB Function: '<S1>/AdjustForCOMOffset' incorporates:
     *  Constant: '<S1>/TorsoCOMOffsets'
     */
    /* MATLAB Function 'DAQ_WITH_SAFETY_IMU/AdjustForCOMOffset': '<S3>:1' */
    /* '<S3>:1:4' TorsoCOMRollOffset  = TorsoCOMOffsets(1)*pi/180; */
    HalfMaxTicks_idx_0 = Walking01_withElmos_P.TorsoCOMOffsets[0] *
      3.1415926535897931 / 180.0;

    /* '<S3>:1:5' TorsoCOMPitchOffset = TorsoCOMOffsets(2)*pi/180; */
    HalfMaxTicks_idx_1 = Walking01_withElmos_P.TorsoCOMOffsets[1] *
      3.1415926535897931 / 180.0;

    /* '<S3>:1:7' q = q_in; */
    memcpy(&Walking01_withElmos_B.q[0], &rtb_q_clean[0], 13U * sizeof(real_T));

    /* '<S3>:1:8' q(2)  = q(2)  + TorsoCOMRollOffset; */
    Walking01_withElmos_B.q[1] = rtb_q_clean[1] + HalfMaxTicks_idx_0;

    /* '<S3>:1:9' q(10) = q(10) - TorsoCOMRollOffset; */
    Walking01_withElmos_B.q[9] -= HalfMaxTicks_idx_0;

    /* '<S3>:1:10' q(13) = q(13) + TorsoCOMRollOffset; */
    Walking01_withElmos_B.q[12] += HalfMaxTicks_idx_0;

    /* '<S3>:1:12' q(3) = q(3) + TorsoCOMPitchOffset; */
    Walking01_withElmos_B.q[2] += HalfMaxTicks_idx_1;

    /* '<S3>:1:13' q([4:9 11:12]) = q([4:9 11:12]) - TorsoCOMPitchOffset; */
    for (ihi = 0; ihi < 8; ihi++) {
      tmp_1[ihi] = Walking01_withElmos_B.q[b[ihi]] - HalfMaxTicks_idx_1;
    }

    for (ihi = 0; ihi < 8; ihi++) {
      Walking01_withElmos_B.q[b[ihi]] = tmp_1[ihi];
    }

    for (i = 0; i < 13; i++) {
      /* Outport: '<Root>/q' */
      Walking01_withElmos_Y.q[i] = Walking01_withElmos_B.q[i];

      /* Outport: '<Root>/dq' */
      Walking01_withElmos_Y.dq[i] = Walking01_withElmos_B.dq_clean[i];
    }

    /* End of MATLAB Function: '<S1>/AdjustForCOMOffset' */

    /* Gain: '<S204>/Gain1' incorporates:
     *  Constant: '<S204>/LegHipTorqueSat'
     */
    for (ihi = 0; ihi < 6; ihi++) {
      rtb_Switch2[ihi] = 0.0;
      rtb_Switch2[ihi] += Walking01_withElmos_ConstP.Gain1_Gain[ihi] *
        Walking01_withElmos_P.LegHipTorqueLimit[0];
      rtb_Switch2[ihi] += Walking01_withElmos_ConstP.Gain1_Gain[ihi + 6] *
        Walking01_withElmos_P.LegHipTorqueLimit[1];
    }

    /* End of Gain: '<S204>/Gain1' */

    /* DigitalClock: '<Root>/Digital Clock' */
    rtb_DigitalClock = Walking01_withElmos_M->Timing.t[0];

    /* Gain: '<S214>/TKA' */
    for (ihi = 0; ihi < 2; ihi++) {
      Walking01_withElmos_B.TKA[ihi] = 0.0;
      for (c_previousEvent = 0; c_previousEvent < 13; c_previousEvent++) {
        Walking01_withElmos_B.TKA[ihi] += Walking01_withElmos_ConstP.TKA_Gain
          [(c_previousEvent << 1) + ihi] *
          Walking01_withElmos_B.q[c_previousEvent];
      }
    }

    /* End of Gain: '<S214>/TKA' */

    /* DiscreteStateSpace: '<S214>/Discrete State-Space' */
    {
      Walking01_withElmos_B.VectorConcatenate_a[0] = (28.7137836069783)*
        Walking01_withElmos_DW.DiscreteStateSpace_DSTATE[0]
        + (24.404633282623223)*Walking01_withElmos_DW.DiscreteStateSpace_DSTATE
        [1]
        + (-12.020156246194272)*
        Walking01_withElmos_DW.DiscreteStateSpace_DSTATE[2]
        + (1.3967204886477091)*Walking01_withElmos_DW.DiscreteStateSpace_DSTATE
        [3];
      Walking01_withElmos_B.VectorConcatenate_a[0] += 1542.8571428571429*
        Walking01_withElmos_B.TKA[0];
    }

    /* DiscreteStateSpace: '<S214>/Discrete State-Space1' */
    {
      Walking01_withElmos_B.VectorConcatenate_a[1] = (28.7137836069783)*
        Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE[0]
        + (24.404633282623223)*
        Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE[1]
        + (-12.020156246194272)*
        Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE[2]
        + (1.3967204886477091)*
        Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE[3];
      Walking01_withElmos_B.VectorConcatenate_a[1] += 1542.8571428571429*
        Walking01_withElmos_B.TKA[1];
    }

    /* S-Function (sdspmultiportsel): '<S201>/Multiport Selector2' incorporates:
     *  Constant: '<S201>/swap_params'
     */
    rtb_DigitalClock_a = Walking01_withElmos_P.swap_params[6];

    /* BusAssignment: '<S201>/Bus Assignment3' incorporates:
     *  Constant: '<S201>/OutputPosing'
     */
    rtb_Output_k = Walking01_withElmos_ConstP.OutputPosing_Value;

    /* Gain: '<S201>/Gain' incorporates:
     *  Constant: '<S201>/hd_posing'
     */
    for (ihi = 0; ihi < 6; ihi++) {
      for (c_previousEvent = 0; c_previousEvent < 6; c_previousEvent++) {
        HAlpha[ihi + 6 * c_previousEvent] = Walking01_withElmos_P.hd_posing[ihi]
          * Walking01_withElmos_ConstP.Gain_Gain_a[c_previousEvent];
      }
    }

    /* BusAssignment: '<S201>/Bus Assignment3' incorporates:
     *  Constant: '<S201>/HAlphaStarPosing'
     *  Gain: '<S201>/Gain'
     */
    for (ihi = 0; ihi < 36; ihi++) {
      rtb_Output_k.HAlpha[ihi] = HAlpha[ihi];
      rtb_Output_k.HAlphaStar[ihi] = Walking01_withElmos_P.HAlphaStarPosing[ihi];
    }

    /* BusCreator: '<S202>/BusConversion_InsertedFor_StateLogic_at_inport_3' incorporates:
     *  BusAssignment: '<S201>/Bus Assignment'
     *  BusAssignment: '<S201>/Bus Assignment1'
     *  BusAssignment: '<S201>/Bus Assignment3'
     *  BusAssignment: '<S201>/Bus Assignment9'
     *  BusCreator: '<S202>/BusConversion_InsertedFor_StateLogic_at_inport_3'
     *  Constant: '<S201>/AllowDoubleSupport'
     *  Constant: '<S201>/ControllerModeInit'
     *  Constant: '<S201>/DecouplingMode'
     *  Constant: '<S201>/DefaultDiscreteParams'
     *  Constant: '<S201>/DefaultFeedbackParams'
     *  Constant: '<S201>/DefaultSupervisoryParams'
     *  Constant: '<S201>/DesiredYawOffset'
     *  Constant: '<S201>/EnableFeedforwardOnStep'
     *  Constant: '<S201>/EnableVelocityBasedUpdate'
     *  Constant: '<S201>/EnergyControlGain'
     *  Constant: '<S201>/EnergyControlPhi0'
     *  Constant: '<S201>/ErrorVelZeroFactor'
     *  Constant: '<S201>/ErrorZeroFactor'
     *  Constant: '<S201>/FeedforwardGain'
     *  Constant: '<S201>/HAlphaStarPosing'
     *  Constant: '<S201>/K1MidStanceUpdate'
     *  Constant: '<S201>/K2MidStanceUpdate'
     *  Constant: '<S201>/KASaturationEarly'
     *  Constant: '<S201>/KASaturationMax'
     *  Constant: '<S201>/KASaturationS1'
     *  Constant: '<S201>/KASaturationS2'
     *  Constant: '<S201>/KThetaMinus'
     *  Constant: '<S201>/KThetaPlus'
     *  Constant: '<S201>/MaxError'
     *  Constant: '<S201>/MaxErrorVel'
     *  Constant: '<S201>/MinDeltaTheta'
     *  Constant: '<S201>/MinDeltaThetaTransition'
     *  Constant: '<S201>/RIO'
     *  Constant: '<S201>/RollPhaseVelocityThresh'
     *  Constant: '<S201>/RunMode'
     *  Constant: '<S201>/SelectFeedforward'
     *  Constant: '<S201>/StanceLegInit'
     *  Constant: '<S201>/StartSecondGaitOnStep'
     *  Constant: '<S201>/TMaxUpdate'
     *  Constant: '<S201>/TPosing'
     *  Constant: '<S201>/Theta0'
     *  Constant: '<S201>/TorsoBackAngle'
     *  Constant: '<S201>/TorsoBackOnStep'
     *  Constant: '<S201>/UseKASaturation'
     *  Constant: '<S201>/UsePosingControl'
     *  Constant: '<S201>/VBLAOptions'
     *  Constant: '<S201>/VelocityBasedUpdateDTheta0'
     *  Constant: '<S201>/VelocityBasedUpdateK1'
     *  Constant: '<S201>/VelocityBasedUpdateK2'
     *  Constant: '<S201>/VelocityBasedUpdateLimits'
     *  Constant: '<S201>/VelocityControlTorsoGain'
     *  Constant: '<S201>/VelocityControlTorsoMax'
     *  Constant: '<S201>/VelocityControlTorsoMin'
     *  Constant: '<S201>/VelocityControlTorsoV0'
     *  Constant: '<S201>/balanceParams'
     *  Constant: '<S201>/epsilon'
     *  Constant: '<S201>/ff_params'
     *  Constant: '<S201>/k_precomp'
     *  Constant: '<S201>/kd'
     *  Constant: '<S201>/kd_2dof'
     *  Constant: '<S201>/kd_torso'
     *  Constant: '<S201>/kp'
     *  Constant: '<S201>/kp_2dof'
     *  Constant: '<S201>/lat_bias'
     *  Constant: '<S201>/lat_bias2'
     *  Constant: '<S201>/lateralParams'
     *  Constant: '<S201>/linkFeedback'
     *  Constant: '<S201>/optimal_sat_weights'
     *  Constant: '<S201>/step_params'
     *  Constant: '<S201>/swap_params'
     *  Constant: '<S201>/tStepInitial'
     *  Constant: '<S201>/transitionParams'
     *  Constant: '<S201>/u_ff'
     *  Constant: '<S201>/use2DOFHipControl'
     *  Constant: '<S201>/useOptimalSaturation'
     *  Constant: '<S201>/w_torso_lat'
     *  S-Function (sdspmultiportsel): '<S201>/Multiport Selector2'
     */
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.EnableSwapOnKAAccel
      = Walking01_withElmos_P.swap_params[0];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.EnableSwapOnKASpring
      = Walking01_withElmos_P.swap_params[1];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.EnableBackwardSwap
      = Walking01_withElmos_P.swap_params[2];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.ImpactThresholdKAAccel
      = Walking01_withElmos_P.swap_params[3];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.ImpactThresholdKASpringAbs
      = Walking01_withElmos_P.swap_params[4];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.ImpactThresholdKASpringRel
      = Walking01_withElmos_P.swap_params[5];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.SwapThresholdS
      = rtb_DigitalClock_a;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.AllowDoubleSupport
      = Walking01_withElmos_P.AllowDoubleSupport;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.UseGaitTransition
      = Walking01_withElmos_P.transitionParams[0];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.NumTransitionSteps
      = Walking01_withElmos_P.transitionParams[4];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.TransitionThresholdTorsoVel
      = Walking01_withElmos_P.transitionParams[3];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.KAInjection
      [0] = Walking01_withElmos_P.transitionParams[1];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.KAInjection
      [1] = Walking01_withElmos_P.transitionParams[2];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.MinDeltaThetaTransition
      = Walking01_withElmos_P.MinDeltaThetaTransition;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.StartSecondGaitOnStep
      = Walking01_withElmos_P.StartSecondGaitOnStep;
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.VBLAParams
        [i] = Walking01_withElmos_ConstP.VBLAOptions_Value[i];
    }

    for (i = 0; i < 13; i++) {
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.BalanceParams
        [i] = Walking01_withElmos_ConstP.balanceParams_Value[i];
    }

    for (i = 0; i < 5; i++) {
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.GaitTweaks
        [i] = Walking01_withElmos_P.step_params[i];
    }

    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.TStepInitial
      = Walking01_withElmos_P.tStepInitial;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.TMaxUpdate
      = Walking01_withElmos_P.TMaxUpdate;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.RunMode =
      Walking01_withElmos_P.RunMode;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.UseAbsoluteSwingLA
      = Walking01_withElmos_ConstP.DefaultSupervisoryParams_V.UseAbsoluteSwingLA;
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.ErrorZeroFactor
        [i] = Walking01_withElmos_P.ErrorZeroFactor[i];
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.ErrorVelZeroFactor
        [i] = Walking01_withElmos_P.ErrorVelZeroFactor[i];
    }

    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.StanceLegInit
      = Walking01_withElmos_P.StanceLegInit;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.ControllerModeInit
      = Walking01_withElmos_P.ControllerModeInit;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.UsePosingControl
      = Walking01_withElmos_P.UsePosingControl;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.TPosing =
      Walking01_withElmos_P.TPosing;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.TorsoBackAngle
      = Walking01_withElmos_P.TorsoBackAngle;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.TorsoBackOnStep
      = Walking01_withElmos_P.TorsoBackOnStep;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.EnergyControlGain
      = 0.0;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.EnergyControlPhi0
      = 2.5;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.VelocityControlTorsoMax
      = Walking01_withElmos_P.VelocityControlTorsoMax;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.VelocityControlTorsoMin
      = Walking01_withElmos_P.VelocityControlTorsoMin;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.VelocityControlTorsoGain
      = Walking01_withElmos_P.VelocityControlTorsoGain;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.VelocityControlTorsoV0
      = Walking01_withElmos_P.VelocityControlTorsoV0;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.MinDeltaTheta
      = Walking01_withElmos_P.MinDeltaTheta;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.Theta0 =
      Walking01_withElmos_P.Theta0;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.KThetaPlus
      = Walking01_withElmos_P.KThetaPlus;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.KThetaMinus
      = Walking01_withElmos_P.KThetaMinus;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.RollPhaseVelocityThresh
      = Walking01_withElmos_P.RollPhaseVelocityThresh;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.RollPhaseSThresh
      = Walking01_withElmos_ConstP.DefaultSupervisoryParams_V.RollPhaseSThresh;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.MaxError =
      Walking01_withElmos_P.MaxError;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.MaxErrorVel
      = Walking01_withElmos_P.MaxErrorVel;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.MaxErrorCount
      = Walking01_withElmos_ConstP.DefaultSupervisoryParams_V.MaxErrorCount;
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.K1MidStanceUpdate
        [i] = Walking01_withElmos_P.K1MidStanceUpdate[i];
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.K2MidStanceUpdate
        [i] = Walking01_withElmos_P.K2MidStanceUpdate[i];
    }

    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.EnableVelocityBasedUpdate
      = Walking01_withElmos_P.EnableVelocityBasedUpdate;
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.VelocityBasedUpdateK1
        [i] = Walking01_withElmos_P.VelocityBasedUpdateK1[i];
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.VelocityBasedUpdateK2
        [i] = Walking01_withElmos_P.VelocityBasedUpdateK2[i];
    }

    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.VelocityBasedUpdateDTheta0
      = Walking01_withElmos_P.VelocityBasedUpdateDTheta0;
    for (i = 0; i < 12; i++) {
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.VelocityBasedUpdateLimits
        [i] = Walking01_withElmos_P.VelocityBasedUpdateLimits[i];
    }

    Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory.DesiredYawOffset
      = Walking01_withElmos_P.DesiredYawOffset;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Discrete =
      Walking01_withElmos_rtZDiscreteParamsBus;
    for (i = 0; i < 78; i++) {
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Output.H0[i] =
        rtb_Output_k.H0[i];
    }

    for (i = 0; i < 36; i++) {
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Output.HAlpha[i] =
        rtb_Output_k.HAlpha[i];
    }

    Walking01_withElmos_B.BusConversion_InsertedFor_State.Output.ThetaLimits[0] =
      rtb_Output_k.ThetaLimits[0];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Output.ThetaLimits[1] =
      rtb_Output_k.ThetaLimits[1];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Output.Theta =
      rtb_Output_k.Theta;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Output.SaturateS =
      rtb_Output_k.SaturateS;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Output.SLimits[0] =
      rtb_Output_k.SLimits[0];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Output.SLimits[1] =
      rtb_Output_k.SLimits[1];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Output.EnforceIncreasingS
      = rtb_Output_k.EnforceIncreasingS;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Output.UseCorrection =
      rtb_Output_k.UseCorrection;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Output.SMaxCorrection =
      rtb_Output_k.SMaxCorrection;
    for (i = 0; i < 30; i++) {
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Output.HAlphaCorrection
        [i] = rtb_Output_k.HAlphaCorrection[i];
    }

    Walking01_withElmos_B.BusConversion_InsertedFor_State.Output.Phi =
      rtb_Output_k.Phi;
    for (i = 0; i < 20; i++) {
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Output.PhiAlpha[i] =
        rtb_Output_k.PhiAlpha[i];
    }

    Walking01_withElmos_B.BusConversion_InsertedFor_State.Output.SaturateR =
      rtb_Output_k.SaturateR;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Output.RLimits[0] =
      rtb_Output_k.RLimits[0];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Output.RLimits[1] =
      rtb_Output_k.RLimits[1];
    for (i = 0; i < 30; i++) {
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Output.HBarAlpha[i] =
        rtb_Output_k.HBarAlpha[i];
    }

    for (i = 0; i < 12; i++) {
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Output.HBarLimits[i]
        = rtb_Output_k.HBarLimits[i];
    }

    for (i = 0; i < 36; i++) {
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Output.HAlphaStar[i]
        = Walking01_withElmos_P.HAlphaStarPosing[i];
    }

    Walking01_withElmos_B.BusConversion_InsertedFor_State.Output.YawLimit =
      rtb_Output_k.YawLimit;
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.kp[i] =
        Walking01_withElmos_P.kp[i];
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.kd[i] =
        Walking01_withElmos_P.kd[i];
    }

    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.epsilon[0] =
      Walking01_withElmos_P.epsilon[0];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.epsilon[1] =
      Walking01_withElmos_P.epsilon[1];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.kff_grav[0] =
      Walking01_withElmos_P.ff_params[1];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.kff_grav[1] =
      Walking01_withElmos_P.ff_params[2];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.delta_grav =
      Walking01_withElmos_P.ff_params[3];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.kff_decoup[0]
      = Walking01_withElmos_P.ff_params[0];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.kff_decoup[1]
      = Walking01_withElmos_P.ff_params[4];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.kd_torso[0] =
      Walking01_withElmos_P.kd_torso[0];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.kd_torso[1] =
      Walking01_withElmos_P.kd_torso[1];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.kp_2dof =
      Walking01_withElmos_P.kp_2dof;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.kd_2dof =
      Walking01_withElmos_P.kd_2dof;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.kpre_2dof =
      Walking01_withElmos_P.k_precomp;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.kp_lat =
      Walking01_withElmos_P.lateralParams[1];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.kd_lat =
      Walking01_withElmos_P.lateralParams[2];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.q3d_min_lat =
      Walking01_withElmos_P.lateralParams[3];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.q3d_max_lat =
      Walking01_withElmos_P.lateralParams[4];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.w_torso_lat =
      Walking01_withElmos_P.w_torso_lat;
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.u_ff[i] =
        Walking01_withElmos_P.u_ff[i];
    }

    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.LateralControlMode
      = Walking01_withElmos_P.lateralParams[0];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.DecouplingMode
      = Walking01_withElmos_P.DecouplingMode;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.Use2DOF =
      Walking01_withElmos_P.use2DOFHipControl;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.UseDSGravComp
      = Walking01_withElmos_ConstP.DefaultFeedbackParams_Valu.UseDSGravComp;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.lat_bias =
      Walking01_withElmos_P.lat_bias;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.lat_bias2 =
      Walking01_withElmos_P.lat_bias2;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.linkFeedback =
      Walking01_withElmos_P.linkFeedback;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.RIO = 0.0;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.SelectFeedforward
      = Walking01_withElmos_P.SelectFeedforward;
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.FeedforwardGain
        [i] = Walking01_withElmos_P.FeedforwardGain[i];
    }

    Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback.EnableFeedforwardOnStep
      = Walking01_withElmos_P.EnableFeedforwardOnStep;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Saturation.UseQPSaturation
      = Walking01_withElmos_P.useOptimalSaturation;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Saturation.QPWeight[0]
      = Walking01_withElmos_P.optimal_sat_weights[0];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Saturation.QPWeight[1]
      = Walking01_withElmos_P.optimal_sat_weights[1];
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Saturation.UseKASaturation
      = Walking01_withElmos_P.UseKASaturation;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Saturation.KASaturationS1
      = Walking01_withElmos_P.KASaturationS1;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Saturation.KASaturationS2
      = Walking01_withElmos_P.KASaturationS2;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Saturation.KASaturationEarly
      = Walking01_withElmos_P.KASaturationEarly;
    Walking01_withElmos_B.BusConversion_InsertedFor_State.Saturation.KASaturationMax
      = Walking01_withElmos_P.KASaturationMax;

    /* End of BusCreator: '<S202>/BusConversion_InsertedFor_StateLogic_at_inport_3' */

    /* BusAssignment: '<S201>/Bus Assignment6' incorporates:
     *  Constant: '<S201>/HAlphaStarInjection'
     *  Constant: '<S201>/OutputInjection'
     */
    rtb_Output_p = Walking01_withElmos_ConstP.OutputInjection_Value;
    for (i = 0; i < 36; i++) {
      rtb_Output_p.HAlphaStar[i] = Walking01_withElmos_P.HAlphaStarInjection[i];
    }

    /* End of BusAssignment: '<S201>/Bus Assignment6' */

    /* BusAssignment: '<S201>/Bus Assignment5' incorporates:
     *  Constant: '<S201>/H0Transition'
     *  Constant: '<S201>/HAlphaStarTransition'
     *  Constant: '<S201>/HAlphaTransition'
     *  Constant: '<S201>/HBarAlphaTransition'
     *  Constant: '<S201>/HBarLimitsTransition'
     *  Constant: '<S201>/OutputTransition'
     *  Constant: '<S201>/PhiOffset'
     *  Constant: '<S201>/RLimits'
     *  Constant: '<S201>/ThetaLimitsTransition'
     */
    rtb_BusAssignment5 = Walking01_withElmos_ConstP.pooled1;
    for (i = 0; i < 78; i++) {
      rtb_BusAssignment5.H0[i] = Walking01_withElmos_P.H0Transition[i];
    }

    for (i = 0; i < 36; i++) {
      rtb_BusAssignment5.HAlpha[i] = Walking01_withElmos_P.HAlphaTransition[i];
    }

    rtb_BusAssignment5.ThetaLimits[0] =
      Walking01_withElmos_P.ThetaLimitsTransition[0];
    rtb_BusAssignment5.ThetaLimits[1] =
      Walking01_withElmos_P.ThetaLimitsTransition[1];
    for (i = 0; i < 30; i++) {
      rtb_BusAssignment5.HBarAlpha[i] =
        Walking01_withElmos_P.HBarAlphaTransition[i];
    }

    for (i = 0; i < 12; i++) {
      rtb_BusAssignment5.HBarLimits[i] =
        Walking01_withElmos_P.HBarLimitsTransition[i];
    }

    for (i = 0; i < 36; i++) {
      rtb_BusAssignment5.HAlphaStar[i] =
        Walking01_withElmos_P.HAlphaStarTransition[i];
    }

    rtb_BusAssignment5.Phi.c0 = Walking01_withElmos_P.PhiOffset;
    rtb_BusAssignment5.RLimits[0] = Walking01_withElmos_P.RLimits[0];
    rtb_BusAssignment5.RLimits[1] = Walking01_withElmos_P.RLimits[1];

    /* End of BusAssignment: '<S201>/Bus Assignment5' */

    /* BusAssignment: '<S201>/Bus Assignment2' incorporates:
     *  Constant: '<S201>/H0WalkingSingle'
     *  Constant: '<S201>/HAlphaStarSingle'
     *  Constant: '<S201>/HAlphaWalkingSingle'
     *  Constant: '<S201>/HBarAlphaWalkingSingle'
     *  Constant: '<S201>/HBarLimitsWalkingSingle'
     *  Constant: '<S201>/OutputWalkingSingle'
     *  Constant: '<S201>/PhiOffset'
     *  Constant: '<S201>/RLimits'
     *  Constant: '<S201>/ThetaLimitsWalkingSingle'
     *  Constant: '<S201>/YawLimit'
     */
    rtb_BusAssignment2 = Walking01_withElmos_ConstP.pooled1;
    for (i = 0; i < 78; i++) {
      rtb_BusAssignment2.H0[i] = Walking01_withElmos_P.H0WalkingSingle[i];
    }

    for (i = 0; i < 36; i++) {
      rtb_BusAssignment2.HAlpha[i] = Walking01_withElmos_P.HAlphaWalkingSingle[i];
    }

    rtb_BusAssignment2.ThetaLimits[0] =
      Walking01_withElmos_P.ThetaLimitsWalkingSingle[0];
    rtb_BusAssignment2.ThetaLimits[1] =
      Walking01_withElmos_P.ThetaLimitsWalkingSingle[1];
    for (i = 0; i < 30; i++) {
      rtb_BusAssignment2.HBarAlpha[i] =
        Walking01_withElmos_P.HBarAlphaWalkingSingle[i];
    }

    for (i = 0; i < 12; i++) {
      rtb_BusAssignment2.HBarLimits[i] =
        Walking01_withElmos_P.HBarLimitsWalkingSingle[i];
    }

    for (i = 0; i < 36; i++) {
      rtb_BusAssignment2.HAlphaStar[i] =
        Walking01_withElmos_P.HAlphaStarWalkingSingle[i];
    }

    rtb_BusAssignment2.YawLimit = Walking01_withElmos_P.YawLimit;
    rtb_BusAssignment2.Phi.c0 = Walking01_withElmos_P.PhiOffset;
    rtb_BusAssignment2.RLimits[0] = Walking01_withElmos_P.RLimits[0];
    rtb_BusAssignment2.RLimits[1] = Walking01_withElmos_P.RLimits[1];

    /* End of BusAssignment: '<S201>/Bus Assignment2' */

    /* BusAssignment: '<S201>/Bus Assignment4' incorporates:
     *  Constant: '<S201>/H0WalkingDouble'
     *  Constant: '<S201>/HAlphaStarDouble'
     *  Constant: '<S201>/HAlphaWalkingDouble'
     *  Constant: '<S201>/HBarAlphaWalkingDouble'
     *  Constant: '<S201>/HBarLimitsWalkingDouble'
     *  Constant: '<S201>/OutputWalkingDouble'
     *  Constant: '<S201>/PhiOffset'
     *  Constant: '<S201>/RLimits'
     *  Constant: '<S201>/ThetaLimitsWalkingDouble'
     *  Constant: '<S201>/YawLimit'
     */
    rtb_BusAssignment4 = Walking01_withElmos_ConstP.pooled1;
    for (i = 0; i < 78; i++) {
      rtb_BusAssignment4.H0[i] = Walking01_withElmos_P.H0WalkingDouble[i];
    }

    for (i = 0; i < 36; i++) {
      rtb_BusAssignment4.HAlpha[i] = Walking01_withElmos_P.HAlphaWalkingDouble[i];
    }

    rtb_BusAssignment4.ThetaLimits[0] =
      Walking01_withElmos_P.ThetaLimitsWalkingDouble[0];
    rtb_BusAssignment4.ThetaLimits[1] =
      Walking01_withElmos_P.ThetaLimitsWalkingDouble[1];
    for (i = 0; i < 30; i++) {
      rtb_BusAssignment4.HBarAlpha[i] =
        Walking01_withElmos_P.HBarAlphaWalkingDouble[i];
    }

    for (i = 0; i < 12; i++) {
      rtb_BusAssignment4.HBarLimits[i] =
        Walking01_withElmos_P.HBarLimitsWalkingDouble[i];
    }

    for (i = 0; i < 36; i++) {
      rtb_BusAssignment4.HAlphaStar[i] =
        Walking01_withElmos_P.HAlphaStarWalkingDouble[i];
    }

    rtb_BusAssignment4.YawLimit = Walking01_withElmos_P.YawLimit;
    rtb_BusAssignment4.Phi.c0 = Walking01_withElmos_P.PhiOffset;
    rtb_BusAssignment4.RLimits[0] = Walking01_withElmos_P.RLimits[0];
    rtb_BusAssignment4.RLimits[1] = Walking01_withElmos_P.RLimits[1];

    /* End of BusAssignment: '<S201>/Bus Assignment4' */

    /* Concatenate: '<S201>/Vector Concatenate' */
    Walking01_withElmos_B.VectorConcatenate[0] = rtb_Output_k;
    Walking01_withElmos_B.VectorConcatenate[1] = rtb_Output_p;
    Walking01_withElmos_B.VectorConcatenate[2] = rtb_BusAssignment5;
    Walking01_withElmos_B.VectorConcatenate[3] = rtb_BusAssignment2;
    Walking01_withElmos_B.VectorConcatenate[4] = rtb_BusAssignment4;

    /* Constant: '<S202>/EnableTransition' */
    Walking01_withElmos_B.EnableTransition =
      Walking01_withElmos_P.EnableTransition;

    /* RelationalOperator: '<S216>/Compare' incorporates:
     *  Constant: '<S202>/ManualSwap'
     *  Constant: '<S216>/Constant'
     */
    Walking01_withElmos_B.Compare = (uint8_T)(Walking01_withElmos_P.ManualSwap >
      0.0);

    /* DataTypeConversion: '<S202>/Data Type Conversion1' incorporates:
     *  RelationalOperator: '<S212>/FixPt Relational Operator'
     *  UnitDelay: '<S212>/Delay Input1'
     */
    Walking01_withElmos_B.DataTypeConversion1 = (Walking01_withElmos_B.Compare >
      Walking01_withElmos_DW.DelayInput1_DSTATE);

    /* Constant: '<S202>/ResetControl' */
    Walking01_withElmos_B.ResetControl = Walking01_withElmos_P.ResetControl;

    /* RelationalOperator: '<S217>/Compare' incorporates:
     *  Constant: '<S202>/CommandSerialize'
     *  Constant: '<S217>/Constant'
     */
    Walking01_withElmos_B.Compare_l = (Walking01_withElmos_P.CommandSerialize >
      0.0);

    /* RelationalOperator: '<S213>/FixPt Relational Operator' incorporates:
     *  UnitDelay: '<S213>/Delay Input1'
     */
    Walking01_withElmos_B.FixPtRelationalOperator = ((int32_T)
      Walking01_withElmos_B.Compare_l > (int32_T)
      Walking01_withElmos_DW.DelayInput1_DSTATE_c);

    /* Chart: '<S202>/StateLogic' */
    if (Walking01_withElmos_DW.temporalCounter_i1 < MAX_uint32_T) {
      Walking01_withElmos_DW.temporalCounter_i1++;
    }

    if (Walking01_withElmos_DW.temporalCounter_i2 < MAX_uint32_T) {
      Walking01_withElmos_DW.temporalCounter_i2++;
    }

    /* Gateway: Walking/Discrete/StateLogic */
    Walking01_withElmos_DW.sfEvent = -1;

    /* During: Walking/Discrete/StateLogic */
    if (Walking01_withElmos_DW.is_active_c22_LibWalking == 0U) {
      /* Entry: Walking/Discrete/StateLogic */
      Walking01_withElmos_DW.is_active_c22_LibWalking = 1U;

      /* Entry Internal: Walking/Discrete/StateLogic */
      Walking01_withElmos_DW.is_active_Main = 1U;

      /* Entry Internal 'Main': '<S215>:163' */
      /* Transition: '<S215>:134' */
      if (Walking01_withElmos_DW.is_Main != Walking01_withElmos_IN_Reset) {
        Walking01_withElmos_DW.is_Main = Walking01_withElmos_IN_Reset;

        /* Entry 'Reset': '<S215>:28' */
        Walking01_withElmos_B.ControlState.ControllerMode = 0.0;
        Walking01_withElmos_B.ControlState.SupportState = 0.0;
        Walking01_withElmos_B.ControlState.StanceLeg = 0.0;
        Walking01_withElmos_B.ControlState.InDoubleSupport = 0.0;
        Walking01_withElmos_B.ControlState.Error = 0.0;
      }

      Walking01_withElmos_DW.is_active_Serialize = 1U;

      /* Entry Internal 'Serialize': '<S215>:235' */
      Walking01_withElmos_DW.is_active_ControlStatus = 1U;

      /* Entry Internal 'ControlStatus': '<S215>:236' */
      /* Transition: '<S215>:237' */
      Walking01_withElmos_DW.is_ControlStatus = Walking01_withElmos_IN_Changed;
      Walking01_withElmos_DW.is_active_SerialState = 1U;

      /* Entry Internal 'SerialState': '<S215>:243' */
      /* Transition: '<S215>:246' */
      if (Walking01_withElmos_DW.is_SerialState !=
          Walking01_withElmo_IN_Running_e) {
        Walking01_withElmos_DW.is_SerialState = Walking01_withElmo_IN_Running_e;

        /* Entry 'Running': '<S215>:252' */
        Walking01_withElmos_initSerial(Walking01_withElmos_M->Timing.t[0]);
        Walking01_withElmos_sendSerial(Walking01_withElmos_M->Timing.t[0]);
      }
    } else {
      if (Walking01_withElmos_DW.is_active_Main != 0U) {
        /* During 'Main': '<S215>:163' */
        switch (Walking01_withElmos_DW.is_Main) {
         case Walking01_withElmos_IN_Error_a:
          /* During 'Error': '<S215>:192' */
          if (Walking01_withElmos_B.ResetControl > 0.0) {
            /* Transition: '<S215>:193' */
            Walking01_withElmos_DW.is_Main = Walking01_withElmos_IN_Reset;

            /* Entry 'Reset': '<S215>:28' */
            Walking01_withElmos_B.ControlState.ControllerMode = 0.0;
            Walking01_withElmos_B.ControlState.SupportState = 0.0;
            Walking01_withElmos_B.ControlState.StanceLeg = 0.0;
            Walking01_withElmos_B.ControlState.InDoubleSupport = 0.0;
            Walking01_withElmos_B.ControlState.Error = 0.0;
          }
          break;

         case Walking01_withElmos_IN_Reset:
          /* During 'Reset': '<S215>:28' */
          if (Walking01_withElmos_B.ResetControl == 0.0) {
            /* Transition: '<S215>:30' */
            Walking01_withElmos_DW.is_Main = Walking01_withElmos_IN_Run_k;

            /* Entry 'Run': '<S215>:27' */
            Walking01_withElmos_B.ControlParams =
              Walking01_withElmos_B.BusConversion_InsertedFor_State;
            Walking01_withElmos_B.ControlParams.Supervisory =
              Walking01_withElmos_B.BusConversion_InsertedFor_State.Supervisory;
            Walking01_withElmos_B.ControlParams.Feedback =
              Walking01_withElmos_B.BusConversion_InsertedFor_State.Feedback;
            Walking01_withElmos_B.ControlParams.Saturation =
              Walking01_withElmos_B.BusConversion_InsertedFor_State.Saturation;
            Walking01_withElmos_DW.ControlParamsPrev =
              Walking01_withElmos_B.ControlParams;
            Walking01_withElmos_DW.ControlStatePrev =
              Walking01_withElmos_B.ControlState;
            Walking01_withElmos_updateS(Walking01_withElmos_M->Timing.t[0]);

            /* Entry Internal 'Run': '<S215>:27' */
            Walking01_withElmos_DW.is_active_Support = 1U;

            /* Entry Internal 'Support': '<S215>:31' */
            if (Walking01_withElmos_B.ControlParams.Supervisory.StanceLegInit ==
                0.0) {
              /* Transition: '<S215>:62' */
              if (Walking01_withElmos_DW.is_Support !=
                  Walking01_withEl_IN_RightSingle) {
                Walking01_withElmos_DW.is_Support =
                  Walking01_withEl_IN_RightSingle;
                Walking01_withElmos_DW.temporalCounter_i1 = 0U;
                Walkin_enter_atomic_RightSingle();
              }
            } else {
              /* Transition: '<S215>:69' */
              if (Walking01_withElmos_DW.is_Support !=
                  Walking01_withElm_IN_LeftSingle) {
                Walking01_withElmos_DW.is_Support =
                  Walking01_withElm_IN_LeftSingle;
                Walking01_withElmos_DW.temporalCounter_i1 = 0U;
                Walking_enter_atomic_LeftSingle();
              }
            }

            if (Walking01_withElmos_DW.is_active_Support != 0U) {
              Walking01_withElmos_DW.is_active_ControllerMode = 1U;

              /* Entry Internal 'ControllerMode': '<S215>:71' */
              /* Transition: '<S215>:76' */
              if (Walking01_withElmos_B.ControlParams.Supervisory.ControllerModeInit
                  == 4.0) {
                /* Transition: '<S215>:87' */
                if (Walking01_withElmos_DW.is_ControllerMode !=
                    Walking01_withElmos_IN_Walking) {
                  Walking01_withElmos_DW.is_ControllerMode =
                    Walking01_withElmos_IN_Walking;

                  /* Entry 'Walking': '<S215>:81' */
                  Walking01_withElmos_B.ControlState.ControllerMode = 4.0;
                  Walking01_withElm_updateControl
                    (Walking01_withElmos_M->Timing.t[0]);
                  c_previousEvent = Walking01_withElmos_DW.sfEvent;
                  Walking01_withElmos_DW.sfEvent =
                    Walking01_w_event_ControlUpdate;
                  if (Walking01_withElmos_DW.is_active_Serialize != 0U) {
                    Walking01_withElmos_Serialize();
                  }

                  Walking01_withElmos_DW.sfEvent = c_previousEvent;
                }
              } else {
                /* Transition: '<S215>:77' */
                if (Walking01_withElmos_B.ControlParams.Supervisory.ControllerModeInit
                    == 2.0) {
                  /* Transition: '<S215>:84' */
                  if (Walking01_withElmos_DW.is_ControllerMode !=
                      Walking01_withElmo_IN_Injection) {
                    Walking01_withElmos_DW.is_ControllerMode =
                      Walking01_withElmo_IN_Injection;
                    Walking01_withElmos_DW.temporalCounter_i2 = 0U;

                    /* Entry 'Injection': '<S215>:79' */
                    Walking01_withElmos_B.ControlState.ControllerMode = 2.0;
                    Walking01_withElm_updateControl
                      (Walking01_withElmos_M->Timing.t[0]);
                    i = Walking01_withElmos_DW.sfEvent;
                    Walking01_withElmos_DW.sfEvent =
                      Walking01_w_event_ControlUpdate;
                    if (Walking01_withElmos_DW.is_active_Serialize != 0U) {
                      Walking01_withElmos_Serialize();
                    }

                    Walking01_withElmos_DW.sfEvent = i;
                  }
                } else {
                  /* Transition: '<S215>:78' */
                  /* Transition: '<S215>:83' */
                  /* {send(ControlUpdate, Serialize);} */
                  if (Walking01_withElmos_DW.is_ControllerMode !=
                      Walking01_withElmos_IN_Posing) {
                    Walking01_withElmos_DW.is_ControllerMode =
                      Walking01_withElmos_IN_Posing;
                    Walking01_withElmos_DW.temporalCounter_i2 = 0U;

                    /* Entry 'Posing': '<S215>:72' */
                    Walking01_withElmos_B.ControlState.ControllerMode = 1.0;
                    Walking01_withElm_updateControl
                      (Walking01_withElmos_M->Timing.t[0]);
                  }
                }
              }

              Walking01_withElmos_DW.is_active_Stage = 1U;

              /* Entry Internal 'Stage': '<S215>:114' */
              /* Transition: '<S215>:121' */
              if (Walking01_withElmos_DW.is_Stage !=
                  Walking01_withElmos_IN_Early) {
                Walking01_withElmos_DW.is_Stage = Walking01_withElmos_IN_Early;

                /* Entry 'Early': '<S215>:115' */
                Walking01_withElmos_B.ControlState.RollPhase = 1.0;
              }
            }
          }
          break;

         case Walking01_withElmos_IN_Run_k:
          Walking01_withElmos_Run();
          break;

         default:
          Walking01_withElmos_DW.is_Main = Walking01__IN_NO_ACTIVE_CHILD_j;
          break;
        }
      }

      if (Walking01_withElmos_DW.is_active_Serialize != 0U) {
        Walking01_withElmos_Serialize();
      }
    }

    /* End of Chart: '<S202>/StateLogic' */

    /* Sum: '<S198>/Add' */
    rtb_VectorConcatenate[0] = Walking01_withElmos_B.q[0] -
      Walking01_withElmos_B.ControlParams.Supervisory.DesiredYawOffset;

    /* SignalConversion: '<S198>/ConcatBufferAtVector ConcatenateIn2' */
    memcpy(&rtb_VectorConcatenate[1], &Walking01_withElmos_B.q[1], 12U * sizeof
           (real_T));

    /* MATLAB Function: '<S200>/controller1' incorporates:
     *  UnitDelay: '<S200>/Unit Delay'
     */
    rtb_Output_k = Walking01_withElmos_B.ControlParams.Output;
    CalOffset_idx_1 = Walking01_withElmos_B.ControlParams.Feedback.Use2DOF;

    /* MATLAB Function 'Walking/Continuous/controller1': '<S206>:1' */
    /*     %% Set options and parameters for each ControllerMode */
    /* '<S206>:1:7' HAlpha = ControlParams.Output.HAlpha; */
    for (ihi = 0; ihi < 36; ihi++) {
      HAlpha[ihi] = Walking01_withElmos_B.ControlParams.Output.HAlpha[ihi];
    }

    /* '<S206>:1:9' switch (ControlState.ControllerMode) */
    switch ((int32_T)Walking01_withElmos_B.ControlState.ControllerMode) {
     case 0:
      /* '<S206>:1:10' case 0 */
      /*  RESET */
      /* '<S206>:1:12' u             = zeros(6,1); */
      /* '<S206>:1:13' y             = zeros(6,1); */
      /* '<S206>:1:14' dy            = zeros(6,1); */
      /* '<S206>:1:15' hd            = zeros(6,1); */
      /* '<S206>:1:16' s             = zeros(size(ControlParams.Output.Theta.c0)); */
      b_s = 0.0;

      /* '<S206>:1:17' s_unsaturated = zeros(size(ControlParams.Output.Theta.c0)); */
      b_s_unsaturated = 0.0;

      /* '<S206>:1:18' ds            = zeros(size(ControlParams.Output.Theta.c0)); */
      b_ds = 0.0;

      /* '<S206>:1:19' theta         = zeros(size(ControlParams.Output.Theta.c0)); */
      b_theta = 0.0;

      /* '<S206>:1:20' phi           = 0; */
      b_phi = 0.0;

      /* '<S206>:1:21' r             = 0; */
      b_r = 0.0;

      /* '<S206>:1:22' hdbar         = zeros(6,1); */
      /* '<S206>:1:23' u_star        = zeros(6,1); */
      /* '<S206>:1:24' u_pd          = zeros(6,1); */
      for (i = 0; i < 6; i++) {
        rtb_u[i] = 0.0;
        rtb_y[i] = 0.0;
        rtb_dy[i] = 0.0;
        rtb_hd[i] = 0.0;
        rtb_hdbar[i] = 0.0;
        rtb_u_star[i] = 0.0;
        rtb_u_pd[i] = 0.0;
      }
      break;

     case 1:
      /* '<S206>:1:27' case 1 */
      /*  POSING */
      /* '<S206>:1:29' ControlParams.Output.SaturateS    = 1; */
      rtb_Output_k.SaturateS = 1.0;

      /*  ControlParams.Feedback.Use2DOF    = 0; */
      /* '<S206>:1:31' ControlParams.Feedback.kff_grav   = [0; 0]; */
      /* '<S206>:1:32' ControlParams.Feedback.kff_decoup = [0; 0]; */
      guard1 = true;
      break;

     case 2:
      /* '<S206>:1:34' case 2 */
      /*  INJECTION */
      /* '<S206>:1:36' ControlParams.Output.SaturateS    = 1; */
      rtb_Output_k.SaturateS = 1.0;

      /* '<S206>:1:37' ControlParams.Feedback.Use2DOF    = 0; */
      CalOffset_idx_1 = 0.0;

      /* '<S206>:1:38' ControlParams.Feedback.kff_grav   = [0; 0]; */
      /* '<S206>:1:39' ControlParams.Feedback.kff_decoup = [0; 0]; */
      guard1 = true;
      break;

     case 3:
      /* '<S206>:1:41' case 3 */
      /*  TRANSITION */
      /* '<S206>:1:43' ControlParams.Feedback.Use2DOF    = 0; */
      CalOffset_idx_1 = 0.0;

      /* '<S206>:1:44' ControlParams.Feedback.kff_grav   = [0; 0]; */
      /* [u_ff, HAlpha] = computeLateralControl(q, dq, ControlState.StanceLeg, u_ff, HAlpha, ControlParams.Feedback); */
      guard1 = true;
      break;

     case 4:
      /* '<S206>:1:48' case 4 */
      /*  REGULAR WALKING */
      /* '<S206>:1:50' if (~ControlState.InDoubleSupport) */
      if (!(Walking01_withElmos_B.ControlState.InDoubleSupport != 0.0)) {
        /* '<S206>:1:51' HAlpha = applyGaitTweaks2(ControlState, ControlParams); */
        Walking01_with_applyGaitTweaks2
          (Walking01_withElmos_B.ControlState.ControllerMode,
           Walking01_withElmos_B.ControlParams.Supervisory.GaitTweaks,
           Walking01_withElmos_B.ControlParams.Output.H0,
           Walking01_withElmos_B.ControlParams.Output.HAlpha, HAlpha);
      }

      guard1 = true;
      break;

     default:
      guard1 = true;
      break;
    }

    if (guard1) {
      /* '<S206>:1:55' ControlParams.Output.HAlpha = HAlpha; */
      for (ihi = 0; ihi < 36; ihi++) {
        rtb_Output_k.HAlpha[ihi] = HAlpha[ihi];
      }

      /*     %% Additional model terms */
      /* '<S206>:1:58' H = zeros(13,1); */
      /* '<S206>:1:59' B = [zeros(7,6); diag([50 50 26.7 50 50 26.7])]; */
      /*     %% Compute control */
      /* [u,y,dy,hd,s,s_unsaturated,ds,theta,~,~,~,~,phi,r,hdbar]=ATRIAS3D_ZD_Control05(t, q, dq, D, H, G, B, ControlState, ControlParams, sprev); */
      /* '<S206>:1:63' [u,y,dy,hd,s,s_unsaturated,ds,theta,u_star,u_pd,phi,r,hdbar,condDecoup] = ATRIAS3D_ZD_Control06(t, q, dq, D, H, G, B, ControlState, ControlParams, sprev); */
      /*  Updated to handle the case of ControlParams.Feedback.linkFeedback, */
      /*  which is the case when feedback is based on link errors as opposed to */
      /*  HZD based output errors. kp and kd should be tuned differently for */
      /*  this case. */
      /*  April 3rd, 2014. BAG. */
      /*     %% Output */
      /* 'ATRIAS3D_ZD_Control06:10' [s,ds,h0,y,dy,jacob_h0,jacob_h,s_unsaturated,theta,dtheta,delta_theta,dsdq,jacob_jacobhdqdq,phi,r,dr,hdbar] = ATRIAS3D_ZD_Output03(t, q, dq, ControlState, ControlParams, sprev); */
      Walking01__ATRIAS3D_ZD_Output03(rtb_DigitalClock, rtb_VectorConcatenate,
        Walking01_withElmos_B.dq_clean,
        Walking01_withElmos_B.ControlState.StanceLeg, &rtb_Output_k,
        Walking01_withElmos_DW.UnitDelay_DSTATE_d, &b_s, &b_ds, rtb_hd, rtb_y,
        rtb_dy, jacob_h0, jacob_h_D_inv, &b_s_unsaturated, &b_theta,
        &HalfMaxTicks_idx_0, &HalfMaxTicks_idx_1, dsdq, RefAngle, &b_phi, &b_r,
        &CalOffset_idx_0, rtb_hdbar);

      /* 'ATRIAS3D_ZD_Control06:11' hd = h0-y; */
      for (ihi = 0; ihi < 6; ihi++) {
        rtb_hd[ihi] -= rtb_y[ihi];
      }

      /*     %% Mapping Matrices */
      /*  Define matrix to convert between motor and standard actuated coordinates */
      /*  [uLAst; uLAsw; uKAst; uKAsw; u3st; u3sw] = T0*[u1R; u2R; u3R; u1L; u2L; u3L] */
      /* 'ATRIAS3D_ZD_Control06:17' T0 = [0.5 0.5 0 0 0 0; 0 0 0 0.5 0.5 0; -1 1 0 0 0 0; 0 0 0 -1 1 0; 0 0 1 0 0 0; 0 0 0 0 0 1]; */
      memcpy(&HAlpha[0], &T0[0], 36U * sizeof(real_T));

      /* 'ATRIAS3D_ZD_Control06:18' if ControlState.StanceLeg==1 */
      if (Walking01_withElmos_B.ControlState.StanceLeg == 1.0) {
        /* 'ATRIAS3D_ZD_Control06:19' T0 = T0([2 1 4 3 6 5],:); */
        memcpy(&HAlpha[0], &e[0], 36U * sizeof(real_T));
      }

      /*  Define matrix to map a two element vector [Leg; Hip] into the */
      /*  six-element vector [Leg; Leg; Hip; Leg; Leg; Hip] */
      /* 'ATRIAS3D_ZD_Control06:24' TLegHip = [1 0; 1 0; 0 1; 1 0; 1 0; 0 1]; */
      /*     %% Decoupling Matrix and Feedforward     */
      /* 'ATRIAS3D_ZD_Control06:27' u_star = zeros(6,1); */
      /* 'ATRIAS3D_ZD_Control06:28' L2fh   = zeros(6,1); */
      for (i = 0; i < 6; i++) {
        rtb_u_star[i] = 0.0;
        L2fh[i] = 0.0;
      }

      /* 'ATRIAS3D_ZD_Control06:29' switch (ControlParams.Feedback.DecouplingMode) */
      switch ((int32_T)
              Walking01_withElmos_B.ControlParams.Feedback.DecouplingMode) {
       case 1:
        /* 'ATRIAS3D_ZD_Control06:30' case 1 */
        /*  CONSTANT DECOUPLING */
        /*  Note, this is default for linkFeedback. */
        /* 'ATRIAS3D_ZD_Control06:33' T = T0*B(8:13,:); */
        for (ihi = 0; ihi < 6; ihi++) {
          for (c_previousEvent = 0; c_previousEvent < 6; c_previousEvent++) {
            T[ihi + 6 * c_previousEvent] = 0.0;
            for (i = 0; i < 6; i++) {
              T[ihi + 6 * c_previousEvent] += HAlpha[6 * i + ihi] * c_b[6 *
                c_previousEvent + i];
            }
          }
        }
        break;

       case 2:
        /* 'ATRIAS3D_ZD_Control06:34' case 2 */
        /*  CONSTANT DECOUPLING */
        /* 'ATRIAS3D_ZD_Control06:36' T = jacob_h0*B; */
        for (ihi = 0; ihi < 6; ihi++) {
          for (c_previousEvent = 0; c_previousEvent < 6; c_previousEvent++) {
            T[ihi + 6 * c_previousEvent] = 0.0;
            for (i = 0; i < 13; i++) {
              T[ihi + 6 * c_previousEvent] += jacob_h0[6 * i + ihi] * b_b[13 *
                c_previousEvent + i];
            }
          }
        }
        break;

       default:
        /* 'ATRIAS3D_ZD_Control06:37' otherwise */
        /* case 3 */
        /*  THEORETICALLY CORRECT DECOUPLING */
        /* 'ATRIAS3D_ZD_Control06:39' jacob_h_D_inv = jacob_h/D; */
        for (ihi = 0; ihi < 78; ihi++) {
          jacob_h_D_inv[ihi] /= 0.0;
        }

        /* 'ATRIAS3D_ZD_Control06:40' T = jacob_h_D_inv*B; */
        for (ihi = 0; ihi < 6; ihi++) {
          for (c_previousEvent = 0; c_previousEvent < 6; c_previousEvent++) {
            T[ihi + 6 * c_previousEvent] = 0.0;
            for (i = 0; i < 13; i++) {
              T[ihi + 6 * c_previousEvent] += jacob_h_D_inv[6 * i + ihi] * b_b
                [13 * c_previousEvent + i];
            }
          }
        }

        /*  LgLfh */
        /* 'ATRIAS3D_ZD_Control06:41' L2fh = -jacob_h_D_inv*H  + jacob_jacobhdqdq; */
        for (ihi = 0; ihi < 13; ihi++) {
          for (c_previousEvent = 0; c_previousEvent < 6; c_previousEvent++) {
            jacob_h_D_inv_0[c_previousEvent + 6 * ihi] = -jacob_h_D_inv[6 * ihi
              + c_previousEvent];
          }
        }

        for (ihi = 0; ihi < 6; ihi++) {
          HalfMaxTicks_idx_1 = 0.0;
          for (c_previousEvent = 0; c_previousEvent < 13; c_previousEvent++) {
            HalfMaxTicks_idx_1 += jacob_h_D_inv_0[6 * c_previousEvent + ihi] *
              0.0;
          }

          L2fh[ihi] = HalfMaxTicks_idx_1 + RefAngle[ihi];
        }

        /*  L2fh */
        break;
      }

      /* 'ATRIAS3D_ZD_Control06:44' if (ControlState.StepCount >= ControlParams.Feedback.EnableFeedforwardOnStep) */
      if (Walking01_withElmos_B.ControlState.StepCount >=
          Walking01_withElmos_B.ControlParams.Feedback.EnableFeedforwardOnStep)
      {
        /* 'ATRIAS3D_ZD_Control06:45' if (ControlParams.Feedback.SelectFeedforward == 1) */
        if (Walking01_withElmos_B.ControlParams.Feedback.SelectFeedforward ==
            1.0) {
          /* 'ATRIAS3D_ZD_Control06:46' u_star = -T\L2fh; */
          for (i = 0; i < 6; i++) {
            rtb_u_star[i] = L2fh[i];
          }

          for (ihi = 0; ihi < 36; ihi++) {
            HAlpha[ihi] = -T[ihi];
          }

          Walking01_withElmos_mldivide_p(HAlpha, rtb_u_star);
        } else {
          if (Walking01_withElmos_B.ControlParams.Feedback.SelectFeedforward ==
              2.0) {
            /* 'ATRIAS3D_ZD_Control06:47' elseif (ControlParams.Feedback.SelectFeedforward == 2) */
            /* 'ATRIAS3D_ZD_Control06:48' u_star = bezier(ControlParams.Output.HAlphaStar, s); */
            /* 'bezier:2' [n, m] = size(afra); */
            /* 'bezier:3' value=zeros(n,1); */
            /* 'bezier:4' M = m-1; */
            /* 'bezier:5' if M==3 */
            /* 'bezier:9' elseif M==5 */
            /* 'bezier:10' k=[1 5 10 10 5 1]; */
            /* %     */
            /* 'bezier:27' x = ones(1, M+1); */
            /* 'bezier:28' y = ones(1, M+1); */
            for (ihi = 0; ihi < 6; ihi++) {
              rtb_u[ihi] = 1.0;
              Walking01_withElmos_Y.y[ihi] = 1.0;
            }

            /* 'bezier:29' for i=1:M */
            for (i = 0; i < 5; i++) {
              /* 'bezier:30' x(i+1)=s*x(i); */
              rtb_u[1 + i] = b_s * rtb_u[i];

              /* 'bezier:31' y(i+1)=(1-s)*y(i); */
              Walking01_withElmos_Y.y[1 + i] = (1.0 - b_s) *
                Walking01_withElmos_Y.y[i];
            }

            /* 'bezier:33' for i=1:n */
            for (i = 0; i < 6; i++) {
              /* 'bezier:34' value(i) = 0; */
              rtb_u_star[i] = 0.0;

              /* 'bezier:35' for j=1:M+1 */
              for (c_previousEvent = 0; c_previousEvent < 6; c_previousEvent++)
              {
                /* 'bezier:36' value(i) = value(i) + afra(i, j)*k(j)*x(j)*y(M+2-j); */
                rtb_u_star[i] +=
                  Walking01_withElmos_B.ControlParams.Output.HAlphaStar[6 *
                  c_previousEvent + i] * (real_T)b_0[c_previousEvent] *
                  rtb_u[c_previousEvent] * Walking01_withElmos_Y.y[5 -
                  c_previousEvent];
              }
            }

            /* 'ATRIAS3D_ZD_Control06:49' if (ControlState.StanceLeg == 1) */
            if (Walking01_withElmos_B.ControlState.StanceLeg == 1.0) {
              /* 'ATRIAS3D_ZD_Control06:50' u_star = u_star([4 5 6 1 2 3]); */
              for (ihi = 0; ihi < 6; ihi++) {
                rtb_u[ihi] = rtb_u_star[d[ihi]];
              }

              for (ihi = 0; ihi < 6; ihi++) {
                rtb_u_star[ihi] = rtb_u[ihi];
              }
            }
          }
        }

        /* 'ATRIAS3D_ZD_Control06:53' u_star = ControlParams.Feedback.FeedforwardGain .* u_star; */
        for (ihi = 0; ihi < 6; ihi++) {
          rtb_u_star[ihi] *=
            Walking01_withElmos_B.ControlParams.Feedback.FeedforwardGain[ihi];
        }
      }

      /* 'ATRIAS3D_ZD_Control06:56' if coder.target('MATLAB') */
      /* 'ATRIAS3D_ZD_Control06:59' else */
      /* 'ATRIAS3D_ZD_Control06:60' condDecoup = 0; */
      /* 'ATRIAS3D_ZD_Control06:63' if 0 */
      /* 'ATRIAS3D_ZD_Control06:90' else */
      /* u_grav = [0; 0; 0; 0; 0; 0]; */
      /*     %% PD Control */
      /* 'ATRIAS3D_ZD_Control06:95' epsilon = ControlParams.Feedback.epsilon; */
      /* 'ATRIAS3D_ZD_Control06:96' kp = ControlParams.Feedback.kp ./ [epsilon; epsilon; epsilon].^2; */
      RefAngle[0] = Walking01_withElmos_B.ControlParams.Feedback.epsilon[0];
      RefAngle[1] = Walking01_withElmos_B.ControlParams.Feedback.epsilon[1];
      RefAngle[2] = Walking01_withElmos_B.ControlParams.Feedback.epsilon[0];
      RefAngle[3] = Walking01_withElmos_B.ControlParams.Feedback.epsilon[1];
      RefAngle[4] = Walking01_withElmos_B.ControlParams.Feedback.epsilon[0];
      RefAngle[5] = Walking01_withElmos_B.ControlParams.Feedback.epsilon[1];
      for (i = 0; i < 6; i++) {
        rtb_u_pd[i] = Walking01_withElmos_B.ControlParams.Feedback.kp[i] /
          (RefAngle[i] * RefAngle[i]);
      }

      /* 'ATRIAS3D_ZD_Control06:97' kd = ControlParams.Feedback.kd ./ [epsilon; epsilon; epsilon]; */
      RefAngle[0] = Walking01_withElmos_B.ControlParams.Feedback.kd[0] /
        Walking01_withElmos_B.ControlParams.Feedback.epsilon[0];
      RefAngle[1] = Walking01_withElmos_B.ControlParams.Feedback.kd[1] /
        Walking01_withElmos_B.ControlParams.Feedback.epsilon[1];
      RefAngle[2] = Walking01_withElmos_B.ControlParams.Feedback.kd[2] /
        Walking01_withElmos_B.ControlParams.Feedback.epsilon[0];
      RefAngle[3] = Walking01_withElmos_B.ControlParams.Feedback.kd[3] /
        Walking01_withElmos_B.ControlParams.Feedback.epsilon[1];
      RefAngle[4] = Walking01_withElmos_B.ControlParams.Feedback.kd[4] /
        Walking01_withElmos_B.ControlParams.Feedback.epsilon[0];
      RefAngle[5] = Walking01_withElmos_B.ControlParams.Feedback.kd[5] /
        Walking01_withElmos_B.ControlParams.Feedback.epsilon[1];

      /*  Allow choice between feedback based on HZD outputs or link positions. */
      /* 'ATRIAS3D_ZD_Control06:100' if ~(ControlParams.Feedback.linkFeedback) */
      if (!(Walking01_withElmos_B.ControlParams.Feedback.linkFeedback != 0.0)) {
        /* 'ATRIAS3D_ZD_Control06:101' pd = kp.*y + kd.*dy; */
        /* 'ATRIAS3D_ZD_Control06:102' u_pd = -T\pd; */
        for (ihi = 0; ihi < 6; ihi++) {
          rtb_u_pd[ihi] = rtb_u_pd[ihi] * rtb_y[ihi] + RefAngle[ihi] *
            rtb_dy[ihi];
        }

        for (ihi = 0; ihi < 36; ihi++) {
          HAlpha[ihi] = -T[ihi];
        }

        Walking01_withElmos_mldivide_p(HAlpha, rtb_u_pd);

        /*  PD control */
      } else {
        /* 'ATRIAS3D_ZD_Control06:103' else */
        /*  THEORETICALLY CORRECT DECOUPLING (updated 20141106BAG) */
        /* 'ATRIAS3D_ZD_Control06:105' Ttemp = T; */
        /*  Use T decided by case statements above. */
        /*          jacob_h_D_inv = jacob_h/D; */
        /*          Ttemp = jacob_h_D_inv*B;  %%LgLfh */
        /* 'ATRIAS3D_ZD_Control06:108' kp = kp([1 3 5 2 4 6]); */
        for (ihi = 0; ihi < 6; ihi++) {
          rtb_u[ihi] = rtb_u_pd[c_0[ihi]];
        }

        /* 'ATRIAS3D_ZD_Control06:109' kd = kd([1 3 5 2 4 6]); */
        for (ihi = 0; ihi < 6; ihi++) {
          rtb_u_pd[ihi] = rtb_u[ihi];
          RefAngle_1[ihi] = RefAngle[c_0[ihi]];
        }

        /* 'ATRIAS3D_ZD_Control06:110' u_pd = -kp.*(Ttemp\y) -kd.*(Ttemp\dy); */
        for (ihi = 0; ihi < 6; ihi++) {
          RefAngle[ihi] = RefAngle_1[ihi];
          L2fh[ihi] = rtb_y[ihi];
        }

        Walking01_withElmos_mldivide_p(T, L2fh);
        for (i = 0; i < 6; i++) {
          rtb_u[i] = rtb_dy[i];
        }

        Walking01_withElmos_mldivide_p(T, rtb_u);
        for (ihi = 0; ihi < 6; ihi++) {
          rtb_u_pd[ihi] = -rtb_u_pd[ihi] * L2fh[ihi] - RefAngle[ihi] * rtb_u[ihi];
        }
      }

      /*     %% 2DOF Hip Control */
      /* 'ATRIAS3D_ZD_Control06:115' if (ControlParams.Feedback.Use2DOF) */
      if (CalOffset_idx_1 != 0.0) {
        /* 'ATRIAS3D_ZD_Control06:116' kp_2dof = ControlParams.Feedback.kp_2dof; */
        /* 'ATRIAS3D_ZD_Control06:117' kd_2dof = ControlParams.Feedback.kd_2dof; */
        /* 'ATRIAS3D_ZD_Control06:118' kpre_2dof = ControlParams.Feedback.kpre_2dof; */
        /* 'ATRIAS3D_ZD_Control06:120' q3_swing  = jacob_h0(6,:)*q; */
        /* 'ATRIAS3D_ZD_Control06:121' dq3_swing = jacob_h0(6,:)*dq; */
        /* 'ATRIAS3D_ZD_Control06:122' e_swing   = kpre_2dof*hd(6) - q3_swing; */
        /* 'ATRIAS3D_ZD_Control06:123' u3_swing  = kp_2dof*e_swing - kd_2dof*dq3_swing; */
        HalfMaxTicks_idx_1 = 0.0;
        HalfMaxTicks_idx_0 = 0.0;
        for (ihi = 0; ihi < 13; ihi++) {
          HalfMaxTicks_idx_1 += jacob_h0[6 * ihi + 5] *
            rtb_VectorConcatenate[ihi];
          HalfMaxTicks_idx_0 += jacob_h0[6 * ihi + 5] *
            Walking01_withElmos_B.dq_clean[ihi];
        }

        HalfMaxTicks_idx_0 =
          (Walking01_withElmos_B.ControlParams.Feedback.kpre_2dof * rtb_hd[5] -
           HalfMaxTicks_idx_1) *
          Walking01_withElmos_B.ControlParams.Feedback.kp_2dof -
          Walking01_withElmos_B.ControlParams.Feedback.kd_2dof *
          HalfMaxTicks_idx_0;

        /* 'ATRIAS3D_ZD_Control06:125' if ControlState.StanceLeg==0 */
        if (Walking01_withElmos_B.ControlState.StanceLeg == 0.0) {
          /* 'ATRIAS3D_ZD_Control06:126' u_pd(6) = u3_swing; */
          rtb_u_pd[5] = HalfMaxTicks_idx_0;
        } else {
          /* 'ATRIAS3D_ZD_Control06:127' else */
          /* 'ATRIAS3D_ZD_Control06:128' u_pd(3) = u3_swing; */
          rtb_u_pd[2] = HalfMaxTicks_idx_0;
        }
      }

      /* 'ATRIAS3D_ZD_Control06:132' if 0 */
      /*  Constant feedforward toque */
      /* u0_ff = ControlParams.Feedback.u_ff; */
      /*  Torques in LA/KA/Hip coordinates */
      /* u0 = u0_ff + u0_decoupling + u0_torso_damping; */
      /*  Torque command in motor coordinates [u1R; u2R; u3R; u1L; u2L; u3L] */
      /* 'ATRIAS3D_ZD_Control06:157' u  = u_pd + u_star; */
      /*  + u_grav + T0\u0; */
      for (i = 0; i < 6; i++) {
        rtb_u[i] = rtb_u_pd[i] + rtb_u_star[i];
      }
    }

    Walking01_withElmos_B.s = b_s;

    /* MATLAB Function: '<S204>/SmartSaturation' incorporates:
     *  Constant: '<S204>/LegHipTorqueSat'
     */
    /* MATLAB Function 'Walking/Continuous/Saturation/SmartSaturation': '<S208>:1' */
    /* '<S208>:1:4' u_sat = u; */
    for (i = 0; i < 6; i++) {
      rtb_u_sat[i] = rtb_u[i];
    }

    /* '<S208>:1:6' if (ControlParams.Saturation.UseQPSaturation) */
    if (Walking01_withElmos_B.ControlParams.Saturation.UseQPSaturation != 0.0) {
      /* '<S208>:1:7' if (ControlState.StanceLeg==0) */
      if (Walking01_withElmos_B.ControlState.StanceLeg == 0.0) {
        /* '<S208>:1:8' weight = ControlParams.Saturation.QPWeight; */
        weight[0] = Walking01_withElmos_B.ControlParams.Saturation.QPWeight[0];
        weight[1] = Walking01_withElmos_B.ControlParams.Saturation.QPWeight[1];
      } else {
        /* '<S208>:1:9' else */
        /* '<S208>:1:10' weight = [0 1; 1 0]*ControlParams.Saturation.QPWeight; */
        weight[0] = 0.0 *
          Walking01_withElmos_B.ControlParams.Saturation.QPWeight[0] +
          Walking01_withElmos_B.ControlParams.Saturation.QPWeight[1];
        weight[1] = 0.0 *
          Walking01_withElmos_B.ControlParams.Saturation.QPWeight[1] +
          Walking01_withElmos_B.ControlParams.Saturation.QPWeight[0];
      }

      /* '<S208>:1:13' u_LA_R = (u(1)+u(2))/2; */
      /* '<S208>:1:14' u_LS_R = u(2)-u(1); */
      /* '<S208>:1:15' u_LA_L =(u(4)+u(5))/2; */
      /* '<S208>:1:16' u_LS_L = u(5)-u(4); */
      /* '<S208>:1:18' uR = LA_LS_Revised_Saturation(u_LS_R,u_LA_R,weight(1),-sat(1),sat(1),-sat(2),sat(2)); */
      /* '<S208>:1:19' uL = LA_LS_Revised_Saturation(u_LS_L,u_LA_L,weight(2),-sat(1),sat(1),-sat(2),sat(2)); */
      /* '<S208>:1:20' u_sat = [uR; u(3); uL; u(6)]; */
      Walkin_LA_LS_Revised_Saturation(rtb_u[1] - rtb_u[0], (rtb_u[0] + rtb_u[1])
        / 2.0, weight[0], -Walking01_withElmos_P.LegHipTorqueLimit[0],
        Walking01_withElmos_P.LegHipTorqueLimit[0],
        -Walking01_withElmos_P.LegHipTorqueLimit[1],
        Walking01_withElmos_P.LegHipTorqueLimit[1], weight_data);
      Walkin_LA_LS_Revised_Saturation(rtb_u[4] - rtb_u[3], (rtb_u[3] + rtb_u[4])
        / 2.0, weight[1], -Walking01_withElmos_P.LegHipTorqueLimit[0],
        Walking01_withElmos_P.LegHipTorqueLimit[0],
        -Walking01_withElmos_P.LegHipTorqueLimit[1],
        Walking01_withElmos_P.LegHipTorqueLimit[1], tmp_0);
      rtb_u_sat[0] = weight_data[0];
      rtb_u_sat[1] = weight_data[1];
      rtb_u_sat[2] = rtb_u[2];
      rtb_u_sat[3] = tmp_0[0];
      rtb_u_sat[4] = tmp_0[1];
      rtb_u_sat[5] = rtb_u[5];
    }

    /* '<S208>:1:23' if (ControlState.ControllerMode>=3  && ControlParams.Saturation.UseKASaturation) */
    if ((Walking01_withElmos_B.ControlState.ControllerMode >= 3.0) &&
        (Walking01_withElmos_B.ControlParams.Saturation.UseKASaturation != 0.0))
    {
      /*  Define matrix to convert between motor and standard actuated coordinates */
      /*  [uLAst; uLAsw; uKAst; uKAsw; u3st; u3sw] = T0*[u1R; u2R; u3R; u1L; u2L; u3L] */
      /* '<S208>:1:26' T0 = [0.5 0.5 0 0 0 0; 0 0 0 0.5 0.5 0; -1 1 0 0 0 0; 0 0 0 -1 1 0; 0 0 1 0 0 0; 0 0 0 0 0 1]; */
      memcpy(&HAlpha[0], &b_T0[0], 36U * sizeof(real_T));

      /* '<S208>:1:27' if (ControlState.StanceLeg==1) */
      if (Walking01_withElmos_B.ControlState.StanceLeg == 1.0) {
        /* '<S208>:1:28' T0 = T0([2 1 4 3 6 5],:); */
        memcpy(&HAlpha[0], &b_1[0], 36U * sizeof(real_T));
      }

      /* '<S208>:1:31' u0 = T0*u_sat; */
      for (ihi = 0; ihi < 6; ihi++) {
        RefAngle[ihi] = 0.0;
        for (c_previousEvent = 0; c_previousEvent < 6; c_previousEvent++) {
          RefAngle[ihi] += HAlpha[6 * c_previousEvent + ihi] *
            rtb_u_sat[c_previousEvent];
        }
      }

      /* '<S208>:1:32' deltaS = (ControlParams.Saturation.KASaturationS2 - ControlParams.Saturation.KASaturationS1); */
      /* '<S208>:1:33' deltaS = min(deltaS, 1); */
      /* '<S208>:1:34' if (s < ControlParams.Saturation.KASaturationS1) */
      if (Walking01_withElmos_B.s <
          Walking01_withElmos_B.ControlParams.Saturation.KASaturationS1) {
        /* '<S208>:1:35' KASaturationLim = ControlParams.Saturation.KASaturationEarly; */
        HalfMaxTicks_idx_0 =
          Walking01_withElmos_B.ControlParams.Saturation.KASaturationEarly;
      } else if (Walking01_withElmos_B.s <
                 Walking01_withElmos_B.ControlParams.Saturation.KASaturationS2)
      {
        /* '<S208>:1:36' elseif (s < ControlParams.Saturation.KASaturationS2) */
        /* '<S208>:1:37' KASaturationLim = [ControlParams.Saturation.KASaturationS2-s s-ControlParams.Saturation.KASaturationS1] ... */
        /* '<S208>:1:38'                 * [ControlParams.Saturation.KASaturationEarly; ControlParams.Saturation.KASaturationMax]/deltaS; */
        HalfMaxTicks_idx_0 =
          Walking01_withElmos_B.ControlParams.Saturation.KASaturationS2 -
          Walking01_withElmos_B.ControlParams.Saturation.KASaturationS1;
        if (!(HalfMaxTicks_idx_0 <= 1.0)) {
          HalfMaxTicks_idx_0 = 1.0;
        }

        HalfMaxTicks_idx_0 =
          ((Walking01_withElmos_B.ControlParams.Saturation.KASaturationS2 -
            Walking01_withElmos_B.s) *
           Walking01_withElmos_B.ControlParams.Saturation.KASaturationEarly +
           (Walking01_withElmos_B.s -
            Walking01_withElmos_B.ControlParams.Saturation.KASaturationS1) *
           Walking01_withElmos_B.ControlParams.Saturation.KASaturationMax) /
          HalfMaxTicks_idx_0;
      } else {
        /* '<S208>:1:39' else */
        /* '<S208>:1:40' KASaturationLim = ControlParams.Saturation.KASaturationMax; */
        HalfMaxTicks_idx_0 =
          Walking01_withElmos_B.ControlParams.Saturation.KASaturationMax;
      }

      /* '<S208>:1:42' u0(3) = max(-KASaturationLim, min(u0(3), KASaturationLim)); */
      if ((RefAngle[2] <= HalfMaxTicks_idx_0) || rtIsNaN(HalfMaxTicks_idx_0)) {
        HalfMaxTicks_idx_1 = RefAngle[2];
      } else {
        HalfMaxTicks_idx_1 = HalfMaxTicks_idx_0;
      }

      if ((-HalfMaxTicks_idx_0 >= HalfMaxTicks_idx_1) || rtIsNaN
          (HalfMaxTicks_idx_1)) {
        RefAngle[2] = -HalfMaxTicks_idx_0;
      } else {
        RefAngle[2] = HalfMaxTicks_idx_1;
      }

      /* '<S208>:1:43' u_sat = T0\u0; */
      for (i = 0; i < 6; i++) {
        rtb_u_sat[i] = RefAngle[i];
      }

      Walking01_withElmos_mldivide(HAlpha, rtb_u_sat);
    }

    /* End of MATLAB Function: '<S204>/SmartSaturation' */

    /* Outport: '<Root>/s' */
    Walking01_withElmos_Y.s = Walking01_withElmos_B.s;

    /* Outport: '<Root>/s_unsaturated' incorporates:
     *  MATLAB Function: '<S200>/controller1'
     */
    Walking01_withElmos_Y.s_unsaturated = b_s_unsaturated;

    /* Outport: '<Root>/ds' incorporates:
     *  MATLAB Function: '<S200>/controller1'
     */
    Walking01_withElmos_Y.ds = b_ds;

    /* Outport: '<Root>/theta' incorporates:
     *  MATLAB Function: '<S200>/controller1'
     */
    Walking01_withElmos_Y.theta = b_theta;

    /* Outport: '<Root>/phi' incorporates:
     *  MATLAB Function: '<S200>/controller1'
     */
    Walking01_withElmos_Y.phi = b_phi;

    /* Outport: '<Root>/r' incorporates:
     *  MATLAB Function: '<S200>/controller1'
     */
    Walking01_withElmos_Y.r = b_r;
    for (i = 0; i < 6; i++) {
      /* Gain: '<S204>/Gain' */
      rtb_Switch_o[i] = (-1.0) * rtb_Switch2[i];

      /* Switch: '<S207>/Switch' incorporates:
       *  RelationalOperator: '<S207>/UpperRelop'
       */
      if (!(rtb_u_sat[i] < rtb_Switch_o[i])) {
        rtb_Switch_o[i] = rtb_u_sat[i];
      }

      /* End of Switch: '<S207>/Switch' */

      /* Switch: '<S207>/Switch2' incorporates:
       *  RelationalOperator: '<S207>/LowerRelop1'
       */
      if (!(rtb_u_sat[i] > rtb_Switch2[i])) {
        rtb_Switch2[i] = rtb_Switch_o[i];
      }

      /* End of Switch: '<S207>/Switch2' */

      /* Outport: '<Root>/u' incorporates:
       *  DataTypeConversion: '<S204>/Data Type Conversion1'
       */
      Walking01_withElmos_Y.u[i] = rtb_Switch2[i];

      /* Outport: '<Root>/y' */
      Walking01_withElmos_Y.y[i] = rtb_y[i];

      /* Outport: '<Root>/dy' */
      Walking01_withElmos_Y.dy[i] = rtb_dy[i];

      /* Outport: '<Root>/hd' */
      Walking01_withElmos_Y.hd[i] = rtb_hd[i];

      /* Outport: '<Root>/hdbar' */
      Walking01_withElmos_Y.hdbar[i] = rtb_hdbar[i];
    }

    /* SignalConversion: '<S2>/ConcatBufferAtControlStateVecIn1' */
    rtb_ControlStateVec[0] = Walking01_withElmos_B.ControlState.ControllerMode;

    /* SignalConversion: '<S2>/ConcatBufferAtControlStateVecIn2' */
    rtb_ControlStateVec[1] = Walking01_withElmos_B.ControlState.SupportState;

    /* SignalConversion: '<S2>/ConcatBufferAtControlStateVecIn3' */
    rtb_ControlStateVec[2] = Walking01_withElmos_B.ControlState.StanceLeg;

    /* SignalConversion: '<S2>/ConcatBufferAtControlStateVecIn4' */
    rtb_ControlStateVec[3] = Walking01_withElmos_B.ControlState.InDoubleSupport;

    /* SignalConversion: '<S2>/ConcatBufferAtControlStateVecIn5' */
    rtb_ControlStateVec[4] = Walking01_withElmos_B.ControlState.RollPhase;

    /* SignalConversion: '<S2>/ConcatBufferAtControlStateVecIn6' */
    rtb_ControlStateVec[5] = Walking01_withElmos_B.ControlState.StepCount;

    /* SignalConversion: '<S2>/ConcatBufferAtControlStateVecIn7' */
    rtb_ControlStateVec[6] = Walking01_withElmos_B.ControlState.Error;

    /* Outport: '<Root>/ControlState' */
    for (i = 0; i < 7; i++) {
      Walking01_withElmos_Y.ControlState[i] = rtb_ControlStateVec[i];
    }

    /* End of Outport: '<Root>/ControlState' */

    /* Outport: '<Root>/SerialOut' */
    for (i = 0; i < 5; i++) {
      Walking01_withElmos_Y.SerialOut[i] = Walking01_withElmos_B.SerialOut[i];
    }

    /* End of Outport: '<Root>/SerialOut' */

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[41];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[42];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[43];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[44];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[45];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[46];
      sfcnOutputs(rts, 0);
    }

    /* Outport: '<Root>/Switches' incorporates:
     *  DataTypeConversion: '<S19>/Data Type Conversion112'
     *  DataTypeConversion: '<S19>/Data Type Conversion157'
     *  DataTypeConversion: '<S19>/Data Type Conversion28'
     *  DataTypeConversion: '<S19>/Data Type Conversion4'
     *  DataTypeConversion: '<S19>/Data Type Conversion52'
     *  DataTypeConversion: '<S19>/Data Type Conversion76'
     *  MATLAB Function: '<S19>/EncodeSwitches'
     */
    /* MATLAB Function 'DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/EncodeSwitches': '<S30>:1' */
    /* '<S30>:1:2' LimitSwitchesVec     = uint32(Switches); */
    /* '<S30>:1:3' LimitSwitchesEncoded = double(EncodeSwitches(LimitSwitchesVec)); */
    /*  From OSU code: */
    /*  (See atrias/software/atrias_medulla_drivers/src/LegMedulla.cpp and */
    /*  http://code.google.com/p/atrias/wiki/LimitSwitches; note error in Leg */
    /*  A bits 4 and 5.) */
    /*  */
    /*  Hip */
    /*  0 	Inside limit (relaxed position) */
    /*  1 	Outside limit (fully extended) */
    /*  */
    /*  Leg A */
    /*  0 	Negative motor limit */
    /*  1 	Positive motor limit */
    /*  2 	Negative spring deflection limit */
    /*  3 	Positive spring deflection limit */
    /*  4 	Leg extension limit */
    /*  5 	Leg retraction limit */
    /*  */
    /*  Leg B */
    /*  0 	Negative motor limit */
    /*  1 	Positive motor limit */
    /*  2 	Negative spring deflection limit */
    /*  3 	Positive spring deflection limit */
    /*  4 	Motor retraction limit */
    /*  LimitSwitches is an integer which encodes the state of all of the limit switches */
    /*  The bit encoding is as follows: */
    /*    Right Shin (A) */
    /*      LSB 0:	Negative motor limit */
    /*          1: 	Positive motor limit */
    /*          2: 	Negative spring deflection limit */
    /*          3: 	Positive spring deflection limit */
    /*          4: 	Leg retraction limit */
    /*          5: 	Leg extension limit */
    /*    Right Thigh (B) */
    /*    	  6: 	Negative motor limit */
    /*    	  7:	Positive motor limit */
    /*    	  8:	Negative spring deflection limit */
    /*    	  9:	Positive spring deflection limit */
    /*    	 10:	Motor retraction limit */
    /*    Right Hip */
    /*    	 11:	Inside limit (relaxed position) */
    /*    	 12:    Outside limit (fully extended) */
    /*    Left Shin (A) */
    /*         16:	Negative motor limit */
    /*         17: 	Positive motor limit */
    /*         18: 	Negative spring deflection limit */
    /*         19: 	Positive spring deflection limit */
    /*         20: 	Leg retraction limit */
    /*         21: 	Leg extension limit */
    /*    Left Thigh (B) */
    /*    	 22: 	Negative motor limit */
    /*    	 23:	Positive motor limit */
    /*    	 24:	Negative spring deflection limit */
    /*    	 25:	Positive spring deflection limit */
    /*    	 26:	Motor retraction limit */
    /*    Left Hip */
    /*    	 27:	Inside limit (relaxed position) */
    /*    	 28:	Outside limit (fully extended) */
    /* 'EncodeSwitches:61' LimitSwitchesEncoded  = uint32(0); */
    /* 'EncodeSwitches:62' LimitSwitchesEncoded  = bitor(LimitSwitchesEncoded, bitshift(LimitSwitchesVec(1), 0)); */
    /*  Right Shin (A) */
    /* 'EncodeSwitches:63' LimitSwitchesEncoded  = bitor(LimitSwitchesEncoded, bitshift(LimitSwitchesVec(2), 6)); */
    /*  Right Thigh (B) */
    /* 'EncodeSwitches:64' LimitSwitchesEncoded  = bitor(LimitSwitchesEncoded, bitshift(LimitSwitchesVec(3), 11)); */
    /*  Right Hip */
    /* 'EncodeSwitches:65' LimitSwitchesEncoded  = bitor(LimitSwitchesEncoded, bitshift(LimitSwitchesVec(4), 16)); */
    /*  Left Shin (A) */
    /* 'EncodeSwitches:66' LimitSwitchesEncoded  = bitor(LimitSwitchesEncoded, bitshift(LimitSwitchesVec(5), 22)); */
    /*  Left Thigh (B) */
    /* 'EncodeSwitches:67' LimitSwitchesEncoded  = bitor(LimitSwitchesEncoded, bitshift(LimitSwitchesVec(6), 27)); */
    /*  Left Hip */
    Walking01_withElmos_Y.Switches = (uint32_T)
      Walking01_withElmos_B.EtherCATRxVar21_b << 6U |
      Walking01_withElmos_B.EtherCATRxVar21 | (uint32_T)
      Walking01_withElmos_B.EtherCATRxVar18_j << 11U | (uint32_T)
      Walking01_withElmos_B.EtherCATRxVar21_o << 16U | (uint32_T)
      Walking01_withElmos_B.EtherCATRxVar21_m << 22U | (uint32_T)
      Walking01_withElmos_B.EtherCATRxVar18_h << 27U;

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[47];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion54' */
    rtb_DigitalClock_a = Walking01_withElmos_B.EtherCATRxVar22;

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[48];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[49];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[50];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[51];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[52];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[53];
      sfcnOutputs(rts, 0);
    }

    /* Outport: '<Root>/MedullaState' incorporates:
     *  DataTypeConversion: '<S19>/Data Type Conversion105'
     *  DataTypeConversion: '<S19>/Data Type Conversion120'
     *  DataTypeConversion: '<S19>/Data Type Conversion17'
     *  DataTypeConversion: '<S19>/Data Type Conversion30'
     *  DataTypeConversion: '<S19>/Data Type Conversion6'
     *  DataTypeConversion: '<S19>/Data Type Conversion78'
     */
    Walking01_withElmos_Y.MedullaState[0] = rtb_DigitalClock_a;
    Walking01_withElmos_Y.MedullaState[1] =
      Walking01_withElmos_B.EtherCATRxVar22_o;
    Walking01_withElmos_Y.MedullaState[2] =
      Walking01_withElmos_B.EtherCATRxVar19_o;
    Walking01_withElmos_Y.MedullaState[3] =
      Walking01_withElmos_B.EtherCATRxVar22_g;
    Walking01_withElmos_Y.MedullaState[4] =
      Walking01_withElmos_B.EtherCATRxVar22_a;
    Walking01_withElmos_Y.MedullaState[5] =
      Walking01_withElmos_B.EtherCATRxVar19_i;
    Walking01_withElmos_Y.MedullaState[6] =
      Walking01_withElmos_B.EtherCATRxVar18_k;

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[54];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion56' */
    rtb_DigitalClock_a = Walking01_withElmos_B.EtherCATRxVar19_c;

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[55];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[56];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[57];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[58];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[59];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[60];
      sfcnOutputs(rts, 0);
    }

    /* Outport: '<Root>/ErrorFlags' incorporates:
     *  DataTypeConversion: '<S19>/Data Type Conversion106'
     *  DataTypeConversion: '<S19>/Data Type Conversion121'
     *  DataTypeConversion: '<S19>/Data Type Conversion19'
     *  DataTypeConversion: '<S19>/Data Type Conversion32'
     *  DataTypeConversion: '<S19>/Data Type Conversion8'
     *  DataTypeConversion: '<S19>/Data Type Conversion80'
     */
    Walking01_withElmos_Y.ErrorFlags[0] = rtb_DigitalClock_a;
    Walking01_withElmos_Y.ErrorFlags[1] =
      Walking01_withElmos_B.EtherCATRxVar19_m;
    Walking01_withElmos_Y.ErrorFlags[2] =
      Walking01_withElmos_B.EtherCATRxVar16_bt;
    Walking01_withElmos_Y.ErrorFlags[3] =
      Walking01_withElmos_B.EtherCATRxVar19_e;
    Walking01_withElmos_Y.ErrorFlags[4] =
      Walking01_withElmos_B.EtherCATRxVar19_d;
    Walking01_withElmos_Y.ErrorFlags[5] =
      Walking01_withElmos_B.EtherCATRxVar16_d;
    Walking01_withElmos_Y.ErrorFlags[6] =
      Walking01_withElmos_B.EtherCATRxVar15_d;

    /* Outport: '<Root>/Counters' incorporates:
     *  DataTypeConversion: '<S19>/Data Type Conversion107'
     *  DataTypeConversion: '<S19>/Data Type Conversion122'
     *  DataTypeConversion: '<S19>/Data Type Conversion18'
     *  DataTypeConversion: '<S19>/Data Type Conversion31'
     *  DataTypeConversion: '<S19>/Data Type Conversion55'
     *  DataTypeConversion: '<S19>/Data Type Conversion7'
     *  DataTypeConversion: '<S19>/Data Type Conversion79'
     */
    Walking01_withElmos_Y.Counters[0] = Walking01_withElmos_B.EtherCATRxVar18;
    Walking01_withElmos_Y.Counters[1] = Walking01_withElmos_B.EtherCATRxVar18_c;
    Walking01_withElmos_Y.Counters[2] = Walking01_withElmos_B.EtherCATRxVar15_b;
    Walking01_withElmos_Y.Counters[3] = Walking01_withElmos_B.EtherCATRxVar18_i;
    Walking01_withElmos_Y.Counters[4] = Walking01_withElmos_B.EtherCATRxVar18_f;
    Walking01_withElmos_Y.Counters[5] = Walking01_withElmos_B.EtherCATRxVar15_g;
    Walking01_withElmos_Y.Counters[6] = Walking01_withElmos_B.EtherCATRxVar17_c;
    for (i = 0; i < 6; i++) {
      /* Outport: '<Root>/u_star' */
      Walking01_withElmos_Y.u_star[i] = rtb_u_star[i];

      /* Outport: '<Root>/u_pd' */
      Walking01_withElmos_Y.u_pd[i] = rtb_u_pd[i];

      /* DataTypeConversion: '<S19>/Data Type Conversion97' */
      Walking01_withElmos_B.DataTypeConversion97[i] =
        Walking01_withElmos_B.EtherCATInit[i];

      /* Outport: '<Root>/EtherCATStatus' */
      Walking01_withElmos_Y.EtherCATStatus[i] =
        Walking01_withElmos_B.DataTypeConversion97[i];
    }

    /* RateTransition: '<S5>/Rate Transition3' */
    if (Walking01_withElmos_M->Timing.RateInteraction.TID0_1) {
      Walking01_withElmos_B.RateTransition3 =
        Walking01_withElmos_B.LogicalOperator1;
    }

    /* End of RateTransition: '<S5>/Rate Transition3' */

    /* Outport: '<Root>/AnomalyCounts' */
    memcpy(&Walking01_withElmos_Y.AnomalyCounts[0],
           &rtb_ImpAsg_InsertedFor_ErrorC_g[0], 19U * sizeof(real_T));
    Walking01_withElmos_Y.AnomalyCounts[19] = rtb_ImpAsg_InsertedFor_ErrorCou[0];
    Walking01_withElmos_Y.AnomalyCounts[20] = rtb_ImpAsg_InsertedFor_ErrorCou[1];
    Walking01_withElmos_Y.AnomalyCounts[21] = rtb_ImpAsg_InsertedFor_ErrorCou[2];

    /* Outport: '<Root>/MicrostrainEulerAnglesClean' */
    Walking01_withElmos_Y.MicrostrainEulerAnglesClean[0] =
      rtb_ImpAsg_InsertedFor_q_clean_[0];
    Walking01_withElmos_Y.MicrostrainEulerAnglesClean[1] =
      rtb_ImpAsg_InsertedFor_q_clean_[1];
    Walking01_withElmos_Y.MicrostrainEulerAnglesClean[2] =
      rtb_ImpAsg_InsertedFor_q_clean_[2];

    /* Outport: '<Root>/MicrostrainEulerAngleDerivsClean' */
    Walking01_withElmos_Y.MicrostrainEulerAngleDerivsClea[0] =
      rtb_ImpAsg_InsertedFor_dq_clean[0];
    Walking01_withElmos_Y.MicrostrainEulerAngleDerivsClea[1] =
      rtb_ImpAsg_InsertedFor_dq_clean[1];
    Walking01_withElmos_Y.MicrostrainEulerAngleDerivsClea[2] =
      rtb_ImpAsg_InsertedFor_dq_clean[2];
    for (i = 0; i < 6; i++) {
      /* Gain: '<S1>/TorqueToCurrent' incorporates:
       *  DataTypeConversion: '<S204>/Data Type Conversion1'
       */
      rtb_current_unsat[i] = Walking01_withElmos_ConstP.TorqueToCurrent_Gain[i] *
        rtb_Switch2[i];

      /* Switch: '<S7>/Switch' incorporates:
       *  RelationalOperator: '<S7>/UpperRelop'
       */
      if (rtb_current_unsat[i] < Walking01_withElmos_ConstB.Gain) {
        rtb_Switch_n[i] = Walking01_withElmos_ConstB.Gain;
      } else {
        rtb_Switch_n[i] = rtb_current_unsat[i];
      }

      /* End of Switch: '<S7>/Switch' */

      /* Switch: '<S7>/Switch2' incorporates:
       *  Constant: '<S1>/CurrentSaturation'
       *  RelationalOperator: '<S7>/LowerRelop1'
       */
      if (rtb_current_unsat[i] > 50.0) {
        rtb_Switch2_p[i] = 50.0;
      } else {
        rtb_Switch2_p[i] = rtb_Switch_n[i];
      }

      /* End of Switch: '<S7>/Switch2' */
    }

    /* MATLAB Function: '<S200>/CheckError' incorporates:
     *  Constant: '<S204>/LegHipTorqueSat'
     *  UnitDelay: '<S200>/Unit Delay1'
     */
    /* MATLAB Function 'Walking/Continuous/CheckError': '<S203>:1' */
    /* '<S203>:1:4' ErrorCount = 0; */
    Walking01_withElmos_B.ErrorCount = 0.0;

    /* '<S203>:1:6' if all(TorqueSaturationLimits > 1) ... */
    /* '<S203>:1:7'             && (norm(y, inf) > ControlParams.Supervisory.MaxError * pi/180 ... */
    /* '<S203>:1:8'             || norm(dy, inf) > ControlParams.Supervisory.MaxErrorVel  * pi/180) */
    guard1 = true;
    i = 0;
    exitg3 = false;
    while ((!exitg3) && (i < 2)) {
      if ((Walking01_withElmos_P.LegHipTorqueLimit[i] > 1.0) == 0) {
        guard1 = false;
        exitg3 = true;
      } else {
        i++;
      }
    }

    if (guard1) {
      HalfMaxTicks_idx_0 = 0.0;
      i = 0;
      exitg3 = false;
      while ((!exitg3) && (i < 6)) {
        HalfMaxTicks_idx_1 = fabs(rtb_y[i]);
        if (rtIsNaN(HalfMaxTicks_idx_1)) {
          HalfMaxTicks_idx_0 = (rtNaN);
          exitg3 = true;
        } else {
          if (HalfMaxTicks_idx_1 > HalfMaxTicks_idx_0) {
            HalfMaxTicks_idx_0 = HalfMaxTicks_idx_1;
          }

          i++;
        }
      }

      if (HalfMaxTicks_idx_0 >
          Walking01_withElmos_B.ControlParams.Supervisory.MaxError *
          3.1415926535897931 / 180.0) {
        rtb_Compare_pw = true;
      } else {
        HalfMaxTicks_idx_0 = 0.0;
        i = 0;
        guard1 = false;
        while ((!guard1) && (i < 6)) {
          HalfMaxTicks_idx_1 = fabs(rtb_dy[i]);
          if (rtIsNaN(HalfMaxTicks_idx_1)) {
            HalfMaxTicks_idx_0 = (rtNaN);
            guard1 = true;
          } else {
            if (HalfMaxTicks_idx_1 > HalfMaxTicks_idx_0) {
              HalfMaxTicks_idx_0 = HalfMaxTicks_idx_1;
            }

            i++;
          }
        }

        if (HalfMaxTicks_idx_0 >
            Walking01_withElmos_B.ControlParams.Supervisory.MaxErrorVel *
            3.1415926535897931 / 180.0) {
          rtb_Compare_pw = true;
        }
      }

      if (rtb_Compare_pw) {
        /* '<S203>:1:10' ErrorCount = ErrorCountIn + 1; */
        Walking01_withElmos_B.ErrorCount =
          Walking01_withElmos_DW.UnitDelay1_DSTATE_g + 1.0;
      }
    }

    /* '<S203>:1:12' Error = (ErrorCount > ControlParams.Supervisory.MaxErrorCount); */

    /* Level2 S-Function Block: '<S4>/Task Execution Time ' (xpctimeinfo) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[61];
      sfcnOutputs(rts, 0);
    }

    /* RelationalOperator: '<S9>/Compare' incorporates:
     *  Constant: '<S9>/Constant'
     */
    rtb_Compare_pw = (Walking01_withElmos_B.TaskExecutionTime >= 0.005);

    /* S-Function (sdspcount2): '<S21>/Counter' */
    if (Walking01_withElmos_DW.Counter_Count_o < ((uint8_T)29U)) {
      Walking01_withElmos_DW.Counter_Count_o++;
    } else {
      Walking01_withElmos_DW.Counter_Count_o = 0U;
    }

    /* End of S-Function (sdspcount2): '<S21>/Counter' */

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[62];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[63];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[64];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[65];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[66];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[67];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[68];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[69];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[70];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[71];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[72];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[73];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[74];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[75];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[76];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[77];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[78];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[79];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[80];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[81];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[82];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[83];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[84];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[85];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[86];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[87];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[88];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[89];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[90];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[91];
      sfcnOutputs(rts, 0);
    }

    /* DiscreteFilter: '<S21>/Discrete Filter' */
    /* MATLAB Function 'DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/ConvertThermistors': '<S29>:1' */
    /* '<S29>:1:3' MEDULLA_ADC_MAX_VOLTS     = 2.70; */
    /* '<S29>:1:4' MEDULLA_ADC_OFFSET_COUNTS = 172; */
    /* '<S29>:1:6' processedADCValue = (adc_value - MEDULLA_ADC_OFFSET_COUNTS) * (MEDULLA_ADC_MAX_VOLTS/(4095.0)); */
    /* '<S29>:1:7' Temperatures = zeros(30,1); */
    /*  20141104 */
    /*  Temperatures = (1.0./( (1.0/298.15) + (1.0/3988.0)*log(4700.0./((3.26./processedADCValue) - 1.0)/10000))) - 273.15; */
    for (i = 0; i < 30; i++) {
      Walking01_withElmos_DW.DiscreteFilter_tmp[i] = (0.0 - (-0.99) *
        Walking01_withElmos_DW.DiscreteFilter_states[i]) / 1.0;
    }

    /* End of DiscreteFilter: '<S21>/Discrete Filter' */

    /* MATLAB Function: '<S1>/SAFETY' incorporates:
     *  Constant: '<S199>/Constant'
     *  Constant: '<S1>/MedullaCommand'
     *  Logic: '<S1>/Logical Operator'
     *  Logic: '<S2>/Logical Operator'
     *  MATLAB Function: '<S200>/CheckError'
     *  RelationalOperator: '<S199>/Compare'
     *  UnitDelay: '<S1>/Unit Delay'
     *  UnitDelay: '<S1>/Unit Delay1'
     */
    /* MATLAB Function 'DAQ_WITH_SAFETY_IMU/SAFETY': '<S6>:1' */
    /* '<S6>:1:2' IMUCommand = 1; */
    /*  Legacy. */
    /* '<S6>:1:3' LogicVoltage = []; */
    /*  Not currently used. */
    /* '<S6>:1:4' SelectBasicLimits = 2; */
    /* '<S6>:1:5' [MotorCurrentCommandSafe, MedullaCommandSafe, IMUCommandSafe, SafetyState, SafetyCountOut] = MARLOSafety(MotorCurrentCommand, MedullaCommand, IMUCommand, q, dq, Switches, Thermistors, LogicVoltage, SafetyCountIn, RequestSoftStop, SelectBasicLimits, FaultDetected); */
    /*  Checks DAQ inputs and outputs to ensure that the commands sent to the */
    /*  robot and the state reported by the robot are okay. Any invalid */
    /*  commands to the robot are discarded, and default (zero) commands are */
    /*  send instead. The cause of the failure can be traced by logging the */
    /*  SafetyStateOut output. */
    /*  */
    /*  SafetyState is a double with integer value in the range 0 to */
    /*  2^52-1. The 52 bits of the significand represent different safety */
    /*  checks. Corresponding bits are set when a safety violation is */
    /*  detected. If SafetyState is nonzero for more than SSMAX time steps, */
    /*  the requested commands (MotorCurrentCommand, MedullaCommand, */
    /*  IMUCommand) are replaced with the safe commands specified below. This */
    /*  should cause the torque to be zero and the Medullas to enter the HALT */
    /*  or ERROR state. */
    /* 'MARLOSafety:20' if (nargin < 11) */
    /*  SAFE OUTPUTS */
    /*  THESE OUTPUTS ARE USED IN A HARD SHUTDOWN, AND CAUSE ALL COMMANDED */
    /*  CURRENTS TO BE ZEROED AND THE MEDULLAS TO ENTER THE HALT STATE. */
    /* 'MARLOSafety:27' MotorCurrentCommandSafe   = [0; 0; 0; 0; 0; 0]; */
    for (i = 0; i < 6; i++) {
      L2fh[i] = 0.0;
    }

    /* 'MARLOSafety:28' MedullaCommandSafe        = 4; */
    Walking01_withElmos_B.MedullaCommandSafe = 4.0;

    /*  4=HALT */
    /* 'MARLOSafety:29' IMUCommandSafe            = 0; */
    /* 'MARLOSafety:30' SafetyState               = 0; */
    /*  HARD SAFETY PARAMETERS */
    /*  THE FOLLOWING PARAMETERS SPECIFY LIMITS WHICH, WHEN EXCEEDED, CAUSE */
    /*  THE SAFETY TO LOCK DOWN THE ROBOT BY SENDING THE DEFAULT SAFE OUTPUTS */
    /*  ABOVE. */
    /* MAX_MOTOR_TEMP         = 80; % C */
    /* 'MARLOSafety:37' MAX_MOTOR_CURRENT      = 120; */
    /*  Amps  */
    /* 'MARLOSafety:38' VALID_MEDULLA_COMMANDS = [0 1 2 3 4 5 6 7]; */
    /* VALID_IMU_COMMANDS     = [0 1 2]; % Meaningless for now */
    /*  END (HARD SAFETY PARAMETERS) */
    /*  SOFT SAFETY PARAMETERS */
    /*  THE FOLLOWING PARAMETERS SPECIFY LIMITS WHICH DO NOT CAUSE THE SAFETY */
    /*  TO LOCK DOWN THE WHOLE ROBOT. INSTEAD, APPROPRIATE CURRENTS ARE */
    /*  LIMITED TO PREVENT DRIVING THE MOTORS IN A MANNER THAT MIGHT CAUSE */
    /*  DAMAGE */
    /* MAX_HIP_ANGLE_SOFT           = 7; % degrees; mechanical limit is reported to be 20 degrees */
    /* MIN_HIP_ANGLE_SOFT           = -15; % degrees; mechanical limit is reported to be -10 degrees  */
    /* SOFT_LIMIT_WIDTH_HIP         = 4;  % degrees */
    /* SOFT_LIMIT_UMAX_HIP          = 15; % Amps */
    /*  END (SOFT SAFETY PARAMETERS) */
    /*  SAFETY STATE DEFINITION */
    /* SS_DYNAMIC_STATE_LIMIT     = 2.^(0:39).'; % bits 1:40 */
    /* 'MARLOSafety:58' SS_DYNAMIC_STATE_LIMIT     = 2.^(0:33).'; */
    /*  bits 1:40 */
    /* 'MARLOSafety:59' SS_INVALID_MOTOR_COMMAND   = 2^40; */
    /*  bit 41 */
    /* 'MARLOSafety:60' SS_INVALID_MEDULLA_COMMAND = 2^41; */
    /*  bit 42 */
    /* SSMASK_INVALID_IMU_COMMAND     = 2^42; % bit 43 */
    /* SSMASK_OVERTEMP                = 2^43; % bit 44 */
    /*  CHECK ROBOT CONFIGURATION AND VELOCITY (HARD SAFETY) */
    /* 'MARLOSafety:66' switch SelectBasicLimits */
    /* 'MARLOSafety:67' case 2 */
    /* 'MARLOSafety:68' violation = MARLOBasicSafetyLimits2(q, dq); */
    /* 'MARLOSafety:72' SafetyState = sum(SS_DYNAMIC_STATE_LIMIT .* violation); */
    Walking_MARLOBasicSafetyLimits2(rtb_q_clean, Walking01_withElmos_B.dq_clean,
      tmp);
    for (ihi = 0; ihi < 34; ihi++) {
      x[ihi] = SS_DYNAMIC_STATE_LIMIT[ihi] * (real_T)tmp[ihi];
    }

    Walking01_withElmos_Y.SafetyState = x[0];
    for (i = 0; i < 33; i++) {
      Walking01_withElmos_Y.SafetyState += x[i + 1];
    }

    /*  VALIDATE MOTOR COMMAND */
    /*                     % Check for NaN and +Inf and -Inf */
    /* 'MARLOSafety:75' if any(~isfinite(MotorCurrentCommand)) ...                    % Check for NaN and +Inf and -Inf */
    /* 'MARLOSafety:76'             || any(abs(MotorCurrentCommand) > MAX_MOTOR_CURRENT) */
    for (ihi = 0; ihi < 6; ihi++) {
      RefAngle_0[ihi] = !((!rtIsInf(rtb_Switch2_p[ihi])) && (!rtIsNaN
        (rtb_Switch2_p[ihi])));
    }

    if (Walking01_withElmos_any(RefAngle_0)) {
      guard1_0 = true;
    } else {
      for (i = 0; i < 6; i++) {
        RefAngle_0[i] = (fabs(rtb_Switch2_p[i]) > 120.0);
      }

      if (Walking01_withElmos_any(RefAngle_0)) {
        guard1_0 = true;
      }
    }

    if (guard1_0) {
      /*  Check for extremely large commands */
      /* 'MARLOSafety:77' SafetyState = SafetyState + SS_INVALID_MOTOR_COMMAND; */
      Walking01_withElmos_Y.SafetyState += 1.099511627776E+12;
    }

    /*  VALIDATE MEDULLA COMMAND */
    /* 'MARLOSafety:81' if any(~ismember(MedullaCommand, VALID_MEDULLA_COMMANDS)) */
    guard1 = false;
    c_previousEvent = 0;
    i = 1;
    ihi = 8;
    exitg3 = false;
    while ((!exitg3) && (ihi >= i)) {
      imid = ((i >> 1) + (ihi >> 1)) - 1;
      if (((i & 1) == 1) && ((ihi & 1) == 1)) {
        imid++;
      }

      HalfMaxTicks_idx_0 = fabs((real_T)imid / 2.0);
      if (HalfMaxTicks_idx_0 <= 2.2250738585072014E-308) {
        HalfMaxTicks_idx_0 = 4.94065645841247E-324;
      } else {
        frexp(HalfMaxTicks_idx_0, &exponent);
        HalfMaxTicks_idx_0 = ldexp(1.0, exponent - 53);
      }

      if (fabs((real_T)imid - Walking01_withElmos_P.MedullaCommand) <
          HalfMaxTicks_idx_0) {
        c_previousEvent = imid + 1;
        exitg3 = true;
      } else if (Walking01_withElmos_P.MedullaCommand < imid) {
        ihi = imid;
      } else {
        i = imid + 2;
      }
    }

    if (c_previousEvent > 0) {
      exitg3 = false;
      while ((!exitg3) && (c_previousEvent - 1 > 0)) {
        HalfMaxTicks_idx_0 = (real_T)(c_previousEvent - 2) / 2.0;
        if (HalfMaxTicks_idx_0 <= 2.2250738585072014E-308) {
          b_r = 4.94065645841247E-324;
        } else {
          frexp(HalfMaxTicks_idx_0, &b_exponent);
          b_r = ldexp(1.0, b_exponent - 53);
        }

        if (fabs((real_T)(c_previousEvent - 2) -
                 Walking01_withElmos_P.MedullaCommand) < b_r) {
          c_previousEvent--;
        } else {
          exitg3 = true;
        }
      }
    }

    if (c_previousEvent > 0) {
      guard1 = true;
    }

    if (!(!guard1 == 0)) {
      /* 'MARLOSafety:82' SafetyState = SafetyState + SS_INVALID_MEDULLA_COMMAND; */
      Walking01_withElmos_Y.SafetyState += 2.199023255552E+12;
    }

    /*  VALIDATE IMU COMMAND */
    /* if any(~ismember(IMUCommand, VALID_IMU_COMMANDS)) */
    /*     SafetyState = SafetyState + SS_INVALID_IMU_COMMAND; */
    /* end     */
    /*  CHECK THERMISTORS     */
    /*  TODO */
    /*  CHECK ROBOT CONFIGURATION (SOFT SAFETY) */
    /*  THE FOLLOWING LIMITS, WHEN EXCEEDED, DO *NOT* CAUSE THE SAFETY TO */
    /*  LOCK DOWN THE WHOLE ROBOT. INSTEAD, APPROPRIATE CURENTS ARE LIMITED */
    /*  TO PREVENT DRIVING THE MOTORS IN A MANNER THAT MIGHT CAUSE DAMAGE */
    /*     %{ */
    /*     % BGB 2014-05-21 */
    /*     q3R = q(10); */
    /*     q3L = q(13); */
    /*      */
    /*     MotorCurrentCommand(3) = continuouslySaturate(MotorCurrentCommand(3), q3R, [MIN_HIP_ANGLE_SOFT MAX_HIP_ANGLE_SOFT]*pi/180, SOFT_LIMIT_WIDTH_HIP*pi/180, SOFT_LIMIT_UMAX_HIP); */
    /*     MotorCurrentCommand(6) = continuouslySaturate(MotorCurrentCommand(6), q3L, [MIN_HIP_ANGLE_SOFT MAX_HIP_ANGLE_SOFT]*pi/180, SOFT_LIMIT_WIDTH_HIP*pi/180, SOFT_LIMIT_UMAX_HIP); */
    /*     % END BGB 2014-05-21 */
    /*     %} */
    /*  IF EVERYTHING LOOKS OKAY (SAFETYSTATE==0), THEN PASS THE COMMANDS TO THE DAQ */
    /* 'MARLOSafety:112' if (SafetyState==0) */
    if (Walking01_withElmos_Y.SafetyState == 0.0) {
      /* 'MARLOSafety:113' SafetyCountOut = max(0, SafetyCountIn-1); */
      if ((0.0 >= Walking01_withElmos_DW.UnitDelay_DSTATE_k - 1.0) || rtIsNaN
          (Walking01_withElmos_DW.UnitDelay_DSTATE_k - 1.0)) {
        Walking01_withElmos_B.SafetyCountOut = 0.0;
      } else {
        Walking01_withElmos_B.SafetyCountOut =
          Walking01_withElmos_DW.UnitDelay_DSTATE_k - 1.0;
      }
    } else {
      /* 'MARLOSafety:114' else */
      /* 'MARLOSafety:115' SafetyCountOut = min(SafetyCountIn+1, 10); */
      if (Walking01_withElmos_DW.UnitDelay_DSTATE_k + 1.0 <= 10.0) {
        Walking01_withElmos_B.SafetyCountOut =
          Walking01_withElmos_DW.UnitDelay_DSTATE_k + 1.0;
      } else {
        Walking01_withElmos_B.SafetyCountOut = 10.0;
      }
    }

    /* 'MARLOSafety:118' if (SafetyCountOut < 4) && (RequestSoftStop == 0) && (max(FaultDetected) == 0) */
    if ((Walking01_withElmos_B.SafetyCountOut < 4.0) &&
        (((Walking01_withElmos_B.ErrorCount >
           Walking01_withElmos_B.ControlParams.Supervisory.MaxErrorCount) ||
          (Walking01_withElmos_B.ControlState.Error != 0.0) || rtb_Compare_pw) ==
         0)) {
      c_previousEvent = 1;
      HalfMaxTicks_idx_0 = Walking01_withElmos_DW.UnitDelay1_DSTATE_h[0];
      if (rtIsNaN(Walking01_withElmos_DW.UnitDelay1_DSTATE_h[0])) {
        i = 2;
        guard1 = false;
        while ((!guard1) && (i < 5)) {
          c_previousEvent = i;
          if (!rtIsNaN(Walking01_withElmos_DW.UnitDelay1_DSTATE_h[i - 1])) {
            HalfMaxTicks_idx_0 = Walking01_withElmos_DW.UnitDelay1_DSTATE_h[i -
              1];
            guard1 = true;
          } else {
            i++;
          }
        }
      }

      if (c_previousEvent < 4) {
        while (c_previousEvent + 1 < 5) {
          if (Walking01_withElmos_DW.UnitDelay1_DSTATE_h[c_previousEvent] >
              HalfMaxTicks_idx_0) {
            HalfMaxTicks_idx_0 =
              Walking01_withElmos_DW.UnitDelay1_DSTATE_h[c_previousEvent];
          }

          c_previousEvent++;
        }
      }

      if (HalfMaxTicks_idx_0 == 0.0) {
        /* 'MARLOSafety:119' MotorCurrentCommandSafe = MotorCurrentCommand; */
        for (i = 0; i < 6; i++) {
          L2fh[i] = rtb_Switch2_p[i];
        }

        /* 'MARLOSafety:120' MedullaCommandSafe = MedullaCommand; */
        Walking01_withElmos_B.MedullaCommandSafe =
          Walking01_withElmos_P.MedullaCommand;

        /* 'MARLOSafety:121' IMUCommandSafe = IMUCommand; */
      }
    }

    /* End of MATLAB Function: '<S1>/SAFETY' */

    /* Outport: '<Root>/MotorCurrentSafe' */
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_Y.MotorCurrentSafe[i] = L2fh[i];
    }

    /* End of Outport: '<Root>/MotorCurrentSafe' */

    /* DataTypeConversion: '<S1>/Data Type Conversion1' */
    rtb_DigitalClock_a = rtb_Compare_pw;

    /* Outport: '<Root>/CPUOverloadRegulator' */
    Walking01_withElmos_Y.CPUOverloadRegulator = rtb_DigitalClock_a;

    /* Level2 S-Function Block: '<S1>/Get Overload Counter ' (xpcgetoverload) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[92];
      sfcnOutputs(rts, 0);
    }

    /* RateTransition: '<S1>/Rate Transition1' */
    if (Walking01_withElmos_M->Timing.RateInteraction.TID0_1) {
      Walking01_withElmos_B.RateTransition1_p =
        Walking01_withElmos_DW.RateTransition1_Buffer0_i;
    }

    /* End of RateTransition: '<S1>/Rate Transition1' */

    /* RateTransition: '<S1>/Rate Transition' */
    if (Walking01_withElmos_M->Timing.RateInteraction.TID0_2) {
      Walking01_withElmos_B.RateTransition =
        Walking01_withElmos_DW.RateTransition_Buffer0;
    }

    /* End of RateTransition: '<S1>/Rate Transition' */

    /* Outport: '<Root>/CPUOverloadCounter' incorporates:
     *  DataTypeConversion: '<S1>/Data Type Conversion'
     */
    Walking01_withElmos_Y.CPUOverloadCounter[0] =
      Walking01_withElmos_B.GetOverloadCounter;
    Walking01_withElmos_Y.CPUOverloadCounter[1] =
      Walking01_withElmos_B.RateTransition1_p;
    Walking01_withElmos_Y.CPUOverloadCounter[2] =
      Walking01_withElmos_B.RateTransition;

    /* Outport: '<Root>/MedullaCommandSafe' */
    Walking01_withElmos_Y.MedullaCommandSafe =
      Walking01_withElmos_B.MedullaCommandSafe;

    /* Outport: '<Root>/EncoderAnglesDirty' */
    memcpy(&Walking01_withElmos_Y.EncoderAnglesDirty[0],
           &Walking01_withElmos_B.VectorConcatenate_m[0], 19U * sizeof(real_T));

    /* Level2 S-Function Block: '<S64>/EtherCAT PDO Receive' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[93];
      sfcnOutputs(rts, 0);
    }

    /* Fcn: '<S71>/Fcn' incorporates:
     *  Constant: '<S35>/MaxRatedCurrent'
     *  DataTypeConversion: '<S35>/Data Type Conversion3'
     *  SignalConversion: '<S71>/ConcatBufferAtVector ConcatenateIn2'
     */
    rtb_DigitalClock_a = (real_T)Walking01_withElmos_B.EtherCATPDOReceive * 25.0
      / 1000.0;

    /* Level2 S-Function Block: '<S100>/EtherCAT PDO Receive' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[94];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S46>/EtherCAT PDO Receive' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[95];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S82>/EtherCAT PDO Receive' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[96];
      sfcnOutputs(rts, 0);
    }

    /* Outport: '<Root>/CurrentActual' incorporates:
     *  Constant: '<S34>/MaxRatedCurrent'
     *  Constant: '<S36>/MaxRatedCurrent'
     *  Constant: '<S37>/MaxRatedCurrent'
     *  DataTypeConversion: '<S34>/Data Type Conversion2'
     *  DataTypeConversion: '<S36>/Data Type Conversion2'
     *  DataTypeConversion: '<S37>/Data Type Conversion2'
     *  Fcn: '<S107>/Fcn'
     *  Fcn: '<S53>/Fcn'
     *  Fcn: '<S89>/Fcn'
     *  SignalConversion: '<S107>/ConcatBufferAtVector ConcatenateIn2'
     *  SignalConversion: '<S53>/ConcatBufferAtVector ConcatenateIn2'
     *  SignalConversion: '<S89>/ConcatBufferAtVector ConcatenateIn2'
     */
    Walking01_withElmos_Y.CurrentActual[0] = rtb_DigitalClock_a;
    Walking01_withElmos_Y.CurrentActual[1] = (real_T)
      Walking01_withElmos_B.EtherCATPDOReceive_b * 25.0 / 1000.0;
    Walking01_withElmos_Y.CurrentActual[2] = (real_T)
      Walking01_withElmos_B.EtherCATPDOReceive_n * 25.0 / 1000.0;
    Walking01_withElmos_Y.CurrentActual[3] = (real_T)
      Walking01_withElmos_B.EtherCATPDOReceive_nq * 25.0 / 1000.0;

    /* Level2 S-Function Block: '<S64>/EtherCAT PDO Receive3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[97];
      sfcnOutputs(rts, 0);
    }

    /* Fcn: '<S72>/Fcn' incorporates:
     *  Constant: '<S35>/MaxRatedCurrent'
     *  DataTypeConversion: '<S35>/Data Type Conversion2'
     *  SignalConversion: '<S72>/ConcatBufferAtVector ConcatenateIn2'
     */
    rtb_DigitalClock_a = (real_T)Walking01_withElmos_B.EtherCATPDOReceive3 *
      25.0 / 1000.0;

    /* Level2 S-Function Block: '<S100>/EtherCAT PDO Receive3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[98];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S46>/EtherCAT PDO Receive3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[99];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S82>/EtherCAT PDO Receive3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[100];
      sfcnOutputs(rts, 0);
    }

    /* Outport: '<Root>/CurrentDemanded' incorporates:
     *  Constant: '<S34>/MaxRatedCurrent'
     *  Constant: '<S36>/MaxRatedCurrent'
     *  Constant: '<S37>/MaxRatedCurrent'
     *  DataTypeConversion: '<S34>/Data Type Conversion3'
     *  DataTypeConversion: '<S36>/Data Type Conversion3'
     *  DataTypeConversion: '<S37>/Data Type Conversion3'
     *  Fcn: '<S108>/Fcn'
     *  Fcn: '<S54>/Fcn'
     *  Fcn: '<S90>/Fcn'
     *  SignalConversion: '<S108>/ConcatBufferAtVector ConcatenateIn2'
     *  SignalConversion: '<S54>/ConcatBufferAtVector ConcatenateIn2'
     *  SignalConversion: '<S90>/ConcatBufferAtVector ConcatenateIn2'
     */
    Walking01_withElmos_Y.CurrentDemanded[0] = rtb_DigitalClock_a;
    Walking01_withElmos_Y.CurrentDemanded[1] = (real_T)
      Walking01_withElmos_B.EtherCATPDOReceive3_b * 25.0 / 1000.0;
    Walking01_withElmos_Y.CurrentDemanded[2] = (real_T)
      Walking01_withElmos_B.EtherCATPDOReceive3_j * 25.0 / 1000.0;
    Walking01_withElmos_Y.CurrentDemanded[3] = (real_T)
      Walking01_withElmos_B.EtherCATPDOReceive3_n * 25.0 / 1000.0;

    /* Level2 S-Function Block: '<S64>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[101];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S35>/Data Type Conversion42' */
    rtb_DigitalClock_a = Walking01_withElmos_B.EtherCATPDOReceive1;

    /* Level2 S-Function Block: '<S100>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[102];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S46>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[103];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S82>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[104];
      sfcnOutputs(rts, 0);
    }

    /* Outport: '<Root>/HallPosition' incorporates:
     *  DataTypeConversion: '<S34>/Data Type Conversion42'
     *  DataTypeConversion: '<S36>/Data Type Conversion42'
     *  DataTypeConversion: '<S37>/Data Type Conversion42'
     */
    Walking01_withElmos_Y.HallPosition[0] = rtb_DigitalClock_a;
    Walking01_withElmos_Y.HallPosition[1] =
      Walking01_withElmos_B.EtherCATPDOReceive1_f;
    Walking01_withElmos_Y.HallPosition[2] =
      Walking01_withElmos_B.EtherCATPDOReceive1_n;
    Walking01_withElmos_Y.HallPosition[3] =
      Walking01_withElmos_B.EtherCATPDOReceive1_i;

    /* Level2 S-Function Block: '<S64>/EtherCAT PDO Receive4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[105];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S35>/Data Type Conversion46' */
    rtb_DigitalClock_a = Walking01_withElmos_B.EtherCATPDOReceive4;

    /* Level2 S-Function Block: '<S100>/EtherCAT PDO Receive4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[106];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S46>/EtherCAT PDO Receive4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[107];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S82>/EtherCAT PDO Receive4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[108];
      sfcnOutputs(rts, 0);
    }

    /* Outport: '<Root>/HallVelocity' incorporates:
     *  DataTypeConversion: '<S34>/Data Type Conversion46'
     *  DataTypeConversion: '<S36>/Data Type Conversion46'
     *  DataTypeConversion: '<S37>/Data Type Conversion46'
     */
    Walking01_withElmos_Y.HallVelocity[0] = rtb_DigitalClock_a;
    Walking01_withElmos_Y.HallVelocity[1] =
      Walking01_withElmos_B.EtherCATPDOReceive4_d;
    Walking01_withElmos_Y.HallVelocity[2] =
      Walking01_withElmos_B.EtherCATPDOReceive4_b;
    Walking01_withElmos_Y.HallVelocity[3] =
      Walking01_withElmos_B.EtherCATPDOReceive4_p;

    /* Level2 S-Function Block: '<S64>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[109];
      sfcnOutputs(rts, 0);
    }

    /* RelationalOperator: '<S77>/Compare' incorporates:
     *  Constant: '<S77>/Constant'
     *  S-Function (sfix_bitop): '<S67>/Bitwise Operator'
     */
    Walking01_withElmos_B.Compare_n =
      ((Walking01_withElmos_B.EtherCATPDOReceive5 & ((uint16_T)79U)) ==
       ((uint16_T)64U));

    /* RelationalOperator: '<S78>/Compare' incorporates:
     *  Constant: '<S78>/Constant'
     *  S-Function (sfix_bitop): '<S68>/Bitwise Operator'
     */
    Walking01_withElmos_B.Compare_lw =
      ((Walking01_withElmos_B.EtherCATPDOReceive5 & ((uint16_T)111U)) ==
       ((uint16_T)39U));

    /* RelationalOperator: '<S79>/Compare' incorporates:
     *  Constant: '<S79>/Constant'
     *  S-Function (sfix_bitop): '<S69>/Bitwise Operator'
     */
    Walking01_withElmos_B.Compare_a =
      ((Walking01_withElmos_B.EtherCATPDOReceive5 & ((uint16_T)111U)) ==
       ((uint16_T)33U));

    /* RelationalOperator: '<S80>/Compare' incorporates:
     *  Constant: '<S80>/Constant'
     *  S-Function (sfix_bitop): '<S70>/Bitwise Operator'
     */
    Walking01_withElmos_B.Compare_e =
      ((Walking01_withElmos_B.EtherCATPDOReceive5 & ((uint16_T)8U)) ==
       ((uint16_T)8U));

    /* Chart: '<S35>/Chart' */
    Walking01_withElmos_Chart(Walking01_withElmos_B.Compare_n,
      Walking01_withElmos_B.Compare_a, Walking01_withElmos_B.Compare_e,
      Walking01_withElmos_B.MedullaCommandSafe, &Walking01_withElmos_B.sf_Chart,
      &Walking01_withElmos_DW.sf_Chart);

    /* Level2 S-Function Block: '<S100>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[110];
      sfcnOutputs(rts, 0);
    }

    /* RelationalOperator: '<S113>/Compare' incorporates:
     *  Constant: '<S113>/Constant'
     *  S-Function (sfix_bitop): '<S103>/Bitwise Operator'
     */
    Walking01_withElmos_B.Compare_p =
      ((Walking01_withElmos_B.EtherCATPDOReceive5_d & ((uint16_T)79U)) ==
       ((uint16_T)64U));

    /* RelationalOperator: '<S114>/Compare' incorporates:
     *  Constant: '<S114>/Constant'
     *  S-Function (sfix_bitop): '<S104>/Bitwise Operator'
     */
    Walking01_withElmos_B.Compare_i =
      ((Walking01_withElmos_B.EtherCATPDOReceive5_d & ((uint16_T)111U)) ==
       ((uint16_T)39U));

    /* RelationalOperator: '<S115>/Compare' incorporates:
     *  Constant: '<S115>/Constant'
     *  S-Function (sfix_bitop): '<S105>/Bitwise Operator'
     */
    Walking01_withElmos_B.Compare_j =
      ((Walking01_withElmos_B.EtherCATPDOReceive5_d & ((uint16_T)111U)) ==
       ((uint16_T)33U));

    /* RelationalOperator: '<S116>/Compare' incorporates:
     *  Constant: '<S116>/Constant'
     *  S-Function (sfix_bitop): '<S106>/Bitwise Operator'
     */
    Walking01_withElmos_B.Compare_c =
      ((Walking01_withElmos_B.EtherCATPDOReceive5_d & ((uint16_T)8U)) ==
       ((uint16_T)8U));

    /* Chart: '<S37>/Chart' */
    Walking01_withElmos_Chart(Walking01_withElmos_B.Compare_p,
      Walking01_withElmos_B.Compare_j, Walking01_withElmos_B.Compare_c,
      Walking01_withElmos_B.MedullaCommandSafe,
      &Walking01_withElmos_B.sf_Chart_b, &Walking01_withElmos_DW.sf_Chart_b);

    /* Level2 S-Function Block: '<S46>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[111];
      sfcnOutputs(rts, 0);
    }

    /* RelationalOperator: '<S59>/Compare' incorporates:
     *  Constant: '<S59>/Constant'
     *  S-Function (sfix_bitop): '<S49>/Bitwise Operator'
     */
    Walking01_withElmos_B.Compare_pz =
      ((Walking01_withElmos_B.EtherCATPDOReceive5_h & ((uint16_T)79U)) ==
       ((uint16_T)64U));

    /* RelationalOperator: '<S60>/Compare' incorporates:
     *  Constant: '<S60>/Constant'
     *  S-Function (sfix_bitop): '<S50>/Bitwise Operator'
     */
    Walking01_withElmos_B.Compare_h =
      ((Walking01_withElmos_B.EtherCATPDOReceive5_h & ((uint16_T)111U)) ==
       ((uint16_T)39U));

    /* RelationalOperator: '<S61>/Compare' incorporates:
     *  Constant: '<S61>/Constant'
     *  S-Function (sfix_bitop): '<S51>/Bitwise Operator'
     */
    Walking01_withElmos_B.Compare_e5 =
      ((Walking01_withElmos_B.EtherCATPDOReceive5_h & ((uint16_T)111U)) ==
       ((uint16_T)33U));

    /* RelationalOperator: '<S62>/Compare' incorporates:
     *  Constant: '<S62>/Constant'
     *  S-Function (sfix_bitop): '<S52>/Bitwise Operator'
     */
    Walking01_withElmos_B.Compare_g =
      ((Walking01_withElmos_B.EtherCATPDOReceive5_h & ((uint16_T)8U)) ==
       ((uint16_T)8U));

    /* Chart: '<S34>/Chart' */
    /* Gateway: DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1L/Chart */
    Walking01_withElmos_DW.sfEvent_a = -1;

    /* During: DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1L/Chart */
    if (Walking01_withElmos_DW.is_active_c20_Walking01_withElm == 0U) {
      /* Entry: DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1L/Chart */
      Walking01_withElmos_DW.is_active_c20_Walking01_withElm = 1U;

      /* Entry Internal: DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1L/Chart */
      /* Transition: '<S45>:78' */
      Walking01_withElmos_DW.is_c20_Walking01_withElmos =
        Walking01_withElmos_IN_Start1_d;

      /* Entry 'Start1': '<S45>:79' */
      /* '<S45>:79:1' ControlWordIndex = 0; */
      Walking01_withElmos_B.ControlWordIndex_j = 0.0;

      /* '<S45>:79:1' EnableTargetTorque = 0; */
      Walking01_withElmos_B.EnableTargetTorque_f = 0.0;

      /* '<S45>:79:3' FaultDetected = 0; */
      Walking01_withElmos_B.FaultDetected_n = 0.0;
    } else {
      switch (Walking01_withElmos_DW.is_c20_Walking01_withElmos) {
       case Walking01_wit_IN_FaultRunning_g:
        /* During 'FaultRunning': '<S45>:81' */
        break;

       case Walking01_w_IN_Initialization_e:
        /* During 'Initialization': '<S45>:87' */
        /* '<S45>:71:1' sf_internal_predicateOutput = ... */
        /* '<S45>:71:1' MedullaCommand == 4 || MedullaCommand == 5; */
        if ((Walking01_withElmos_B.MedullaCommandSafe == 4.0) ||
            (Walking01_withElmos_B.MedullaCommandSafe == 5.0)) {
          /* Transition: '<S45>:71' */
          /* Exit Internal 'Initialization': '<S45>:87' */
          Walking01_withElmos_DW.is_Initialization_h =
            Walking01__IN_NO_ACTIVE_CHILD_j;
          Walking01_withElmos_DW.is_c20_Walking01_withElmos =
            Walking01_wit_IN_FaultRunning_g;

          /* Entry 'FaultRunning': '<S45>:81' */
          /* '<S45>:81:1' ControlWordIndex = 1; */
          Walking01_withElmos_B.ControlWordIndex_j = 1.0;

          /* '<S45>:81:1' EnableTargetTorque = 0; */
          Walking01_withElmos_B.EnableTargetTorque_f = 0.0;

          /* '<S45>:81:3' FaultDetected = 1; */
          Walking01_withElmos_B.FaultDetected_n = 1.0;
        } else {
          switch (Walking01_withElmos_DW.is_Initialization_h) {
           case Walking01_withElmos_IN_Fault_d:
            /* During 'Fault': '<S45>:72' */
            /* '<S45>:83:1' sf_internal_predicateOutput = ... */
            /* '<S45>:83:1' Timeout >=20; */
            if (Walking01_withElmos_DW.Timeout_i >= 20.0) {
              /* Transition: '<S45>:83' */
              Walking01_withElmos_DW.is_Initialization_h =
                Walking01_withElmos_IN_Fault_d;

              /* Entry 'Fault': '<S45>:72' */
              /* '<S45>:72:1' ControlWordIndex = 3; */
              Walking01_withElmos_B.ControlWordIndex_j = 3.0;

              /* '<S45>:72:1' EnableTargetTorque = 0; */
              Walking01_withElmos_B.EnableTargetTorque_f = 0.0;

              /* '<S45>:72:3' Timeout = 0; */
              Walking01_withElmos_DW.Timeout_i = 0.0;
            } else {
              /* '<S45>:92:1' sf_internal_predicateOutput = ... */
              /* '<S45>:92:1' SwitchOnDisabledMode == 1; */
              if (Walking01_withElmos_B.Compare_pz == 1) {
                /* Transition: '<S45>:92' */
                Walking01_withElmos_DW.is_Initialization_h =
                  Walking01_IN_SwitchOnDisabled_e;

                /* Entry 'SwitchOnDisabled': '<S45>:73' */
                /* '<S45>:73:1' ControlWordIndex = 1; */
                Walking01_withElmos_B.ControlWordIndex_j = 1.0;

                /* '<S45>:73:1' Timeout = 0; */
                Walking01_withElmos_DW.Timeout_i = 0.0;

                /* '<S45>:73:3' EnableTargetTorque = 0; */
                Walking01_withElmos_B.EnableTargetTorque_f = 0.0;
              } else {
                /* '<S45>:72:4' Timeout = Timeout + 1; */
                Walking01_withElmos_DW.Timeout_i++;

                /* '<S45>:72:5' ControlWordIndex = 0; */
                Walking01_withElmos_B.ControlWordIndex_j = 0.0;
              }
            }
            break;

           case Walking01__IN_ReadyToSwitchOn_n:
            /* During 'ReadyToSwitchOn': '<S45>:91' */
            /* '<S45>:90:1' sf_internal_predicateOutput = ... */
            /* '<S45>:90:1' FaultMode == 1; */
            if (Walking01_withElmos_B.Compare_g == 1) {
              /* Transition: '<S45>:90' */
              Walking01_withElmos_DW.is_Initialization_h =
                Walking01_withElmos_IN_Fault_d;

              /* Entry 'Fault': '<S45>:72' */
              /* '<S45>:72:1' ControlWordIndex = 3; */
              Walking01_withElmos_B.ControlWordIndex_j = 3.0;

              /* '<S45>:72:1' EnableTargetTorque = 0; */
              Walking01_withElmos_B.EnableTargetTorque_f = 0.0;

              /* '<S45>:72:3' Timeout = 0; */
              Walking01_withElmos_DW.Timeout_i = 0.0;
            } else {
              /* '<S45>:94:1' sf_internal_predicateOutput = ... */
              /* '<S45>:94:1' SwitchOnDisabledMode == 1; */
              if (Walking01_withElmos_B.Compare_pz == 1) {
                /* Transition: '<S45>:94' */
                Walking01_withElmos_DW.is_Initialization_h =
                  Walking01_IN_SwitchOnDisabled_e;

                /* Entry 'SwitchOnDisabled': '<S45>:73' */
                /* '<S45>:73:1' ControlWordIndex = 1; */
                Walking01_withElmos_B.ControlWordIndex_j = 1.0;

                /* '<S45>:73:1' Timeout = 0; */
                Walking01_withElmos_DW.Timeout_i = 0.0;

                /* '<S45>:73:3' EnableTargetTorque = 0; */
                Walking01_withElmos_B.EnableTargetTorque_f = 0.0;
              } else {
                /* Transition: '<S45>:74' */
                Walking01_withElmos_DW.is_Initialization_h =
                  Walking01__IN_NO_ACTIVE_CHILD_j;
                Walking01_withElmos_DW.is_c20_Walking01_withElmos =
                  Walking01_withElmo_IN_Running_j;

                /* Entry 'Running': '<S45>:76' */
                /* '<S45>:76:1' ControlWordIndex = 2; */
                Walking01_withElmos_B.ControlWordIndex_j = 2.0;

                /* '<S45>:76:1' EnableTargetTorque = 1; */
                Walking01_withElmos_B.EnableTargetTorque_f = 1.0;
              }
            }
            break;

           default:
            /* During 'SwitchOnDisabled': '<S45>:73' */
            /* '<S45>:75:1' sf_internal_predicateOutput = ... */
            /* '<S45>:75:1' ReadyToSwitchOnMode == 1; */
            if (Walking01_withElmos_B.Compare_e5 == 1) {
              /* Transition: '<S45>:75' */
              Walking01_withElmos_DW.is_Initialization_h =
                Walking01__IN_ReadyToSwitchOn_n;

              /* Entry 'ReadyToSwitchOn': '<S45>:91' */
              /* '<S45>:91:1' ControlWordIndex = 2; */
              Walking01_withElmos_B.ControlWordIndex_j = 2.0;

              /* '<S45>:91:1' Timeout = 0; */
              Walking01_withElmos_DW.Timeout_i = 0.0;

              /* '<S45>:91:3' EnableTargetTorque = 0; */
              Walking01_withElmos_B.EnableTargetTorque_f = 0.0;
            } else {
              /* '<S45>:86:1' sf_internal_predicateOutput = ... */
              /* '<S45>:86:1' FaultMode == 1; */
              if (Walking01_withElmos_B.Compare_g == 1) {
                /* Transition: '<S45>:86' */
                Walking01_withElmos_DW.is_Initialization_h =
                  Walking01_withElmos_IN_Fault_d;

                /* Entry 'Fault': '<S45>:72' */
                /* '<S45>:72:1' ControlWordIndex = 3; */
                Walking01_withElmos_B.ControlWordIndex_j = 3.0;

                /* '<S45>:72:1' EnableTargetTorque = 0; */
                Walking01_withElmos_B.EnableTargetTorque_f = 0.0;

                /* '<S45>:72:3' Timeout = 0; */
                Walking01_withElmos_DW.Timeout_i = 0.0;
              } else {
                /* '<S45>:73:3' Timeout = Timeout + 1; */
                Walking01_withElmos_DW.Timeout_i++;
              }
            }
            break;
          }
        }
        break;

       case Walking01_withElmo_IN_Running_j:
        /* During 'Running': '<S45>:76' */
        /* '<S45>:77:1' sf_internal_predicateOutput = ... */
        /* '<S45>:77:1' FaultMode == 1; */
        if (Walking01_withElmos_B.Compare_g == 1) {
          /* Transition: '<S45>:77' */
          Walking01_withElmos_DW.is_c20_Walking01_withElmos =
            Walking01_wit_IN_FaultRunning_g;

          /* Entry 'FaultRunning': '<S45>:81' */
          /* '<S45>:81:1' ControlWordIndex = 1; */
          Walking01_withElmos_B.ControlWordIndex_j = 1.0;

          /* '<S45>:81:1' EnableTargetTorque = 0; */
          Walking01_withElmos_B.EnableTargetTorque_f = 0.0;

          /* '<S45>:81:3' FaultDetected = 1; */
          Walking01_withElmos_B.FaultDetected_n = 1.0;
        } else {
          /* '<S45>:89:1' sf_internal_predicateOutput = ... */
          /* '<S45>:89:1' MedullaCommand == 4 || MedullaCommand == 5; */
          if ((Walking01_withElmos_B.MedullaCommandSafe == 4.0) ||
              (Walking01_withElmos_B.MedullaCommandSafe == 5.0)) {
            /* Transition: '<S45>:89' */
            Walking01_withElmos_DW.is_c20_Walking01_withElmos =
              Walking01_wit_IN_FaultRunning_g;

            /* Entry 'FaultRunning': '<S45>:81' */
            /* '<S45>:81:1' ControlWordIndex = 1; */
            Walking01_withElmos_B.ControlWordIndex_j = 1.0;

            /* '<S45>:81:1' EnableTargetTorque = 0; */
            Walking01_withElmos_B.EnableTargetTorque_f = 0.0;

            /* '<S45>:81:3' FaultDetected = 1; */
            Walking01_withElmos_B.FaultDetected_n = 1.0;
          }
        }
        break;

       default:
        /* During 'Start1': '<S45>:79' */
        /* '<S45>:93:1' sf_internal_predicateOutput = ... */
        /* '<S45>:93:1' MedullaCommand == 4 || MedullaCommand == 5; */
        if ((Walking01_withElmos_B.MedullaCommandSafe == 4.0) ||
            (Walking01_withElmos_B.MedullaCommandSafe == 5.0)) {
          /* Transition: '<S45>:93' */
          Walking01_withElmos_DW.is_c20_Walking01_withElmos =
            Walking01_wit_IN_FaultRunning_g;

          /* Entry 'FaultRunning': '<S45>:81' */
          /* '<S45>:81:1' ControlWordIndex = 1; */
          Walking01_withElmos_B.ControlWordIndex_j = 1.0;

          /* '<S45>:81:1' EnableTargetTorque = 0; */
          Walking01_withElmos_B.EnableTargetTorque_f = 0.0;

          /* '<S45>:81:3' FaultDetected = 1; */
          Walking01_withElmos_B.FaultDetected_n = 1.0;
        } else {
          /* '<S45>:85:1' sf_internal_predicateOutput = ... */
          /* '<S45>:85:1' MedullaCommand == 2; */
          if (Walking01_withElmos_B.MedullaCommandSafe == 2.0) {
            /* Transition: '<S45>:85' */
            Walking01_withElmos_DW.is_c20_Walking01_withElmos =
              Walking01_w_IN_Initialization_e;

            /* Entry Internal 'Initialization': '<S45>:87' */
            /* Transition: '<S45>:88' */
            Walking01_withElmos_DW.is_Initialization_h =
              Walking01_IN_SwitchOnDisabled_e;

            /* Entry 'SwitchOnDisabled': '<S45>:73' */
            /* '<S45>:73:1' ControlWordIndex = 1; */
            Walking01_withElmos_B.ControlWordIndex_j = 1.0;

            /* '<S45>:73:1' Timeout = 0; */
            Walking01_withElmos_DW.Timeout_i = 0.0;

            /* '<S45>:73:3' EnableTargetTorque = 0; */
            Walking01_withElmos_B.EnableTargetTorque_f = 0.0;
          }
        }
        break;
      }
    }

    /* End of Chart: '<S34>/Chart' */

    /* Level2 S-Function Block: '<S82>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[112];
      sfcnOutputs(rts, 0);
    }

    /* RelationalOperator: '<S95>/Compare' incorporates:
     *  Constant: '<S95>/Constant'
     *  S-Function (sfix_bitop): '<S85>/Bitwise Operator'
     */
    Walking01_withElmos_B.Compare_n4 =
      ((Walking01_withElmos_B.EtherCATPDOReceive5_p & ((uint16_T)79U)) ==
       ((uint16_T)64U));

    /* RelationalOperator: '<S96>/Compare' incorporates:
     *  Constant: '<S96>/Constant'
     *  S-Function (sfix_bitop): '<S86>/Bitwise Operator'
     */
    Walking01_withElmos_B.Compare_f =
      ((Walking01_withElmos_B.EtherCATPDOReceive5_p & ((uint16_T)111U)) ==
       ((uint16_T)39U));

    /* RelationalOperator: '<S97>/Compare' incorporates:
     *  Constant: '<S97>/Constant'
     *  S-Function (sfix_bitop): '<S87>/Bitwise Operator'
     */
    Walking01_withElmos_B.Compare_co =
      ((Walking01_withElmos_B.EtherCATPDOReceive5_p & ((uint16_T)111U)) ==
       ((uint16_T)33U));

    /* RelationalOperator: '<S98>/Compare' incorporates:
     *  Constant: '<S98>/Constant'
     *  S-Function (sfix_bitop): '<S88>/Bitwise Operator'
     */
    Walking01_withElmos_B.Compare_ju =
      ((Walking01_withElmos_B.EtherCATPDOReceive5_p & ((uint16_T)8U)) ==
       ((uint16_T)8U));

    /* Chart: '<S36>/Chart' */
    /* Gateway: DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_2L/Chart */
    Walking01_withElmos_DW.sfEvent_p = -1;

    /* During: DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_2L/Chart */
    if (Walking01_withElmos_DW.is_active_c23_Walking01_withElm == 0U) {
      /* Entry: DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_2L/Chart */
      Walking01_withElmos_DW.is_active_c23_Walking01_withElm = 1U;

      /* Entry Internal: DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_2L/Chart */
      /* Transition: '<S81>:86' */
      Walking01_withElmos_DW.is_c23_Walking01_withElmos =
        Walking01_withElmos_IN_Start1_d;

      /* Entry 'Start1': '<S81>:76' */
      /* '<S81>:76:1' ControlWordIndex = 0; */
      Walking01_withElmos_B.ControlWordIndex = 0.0;

      /* '<S81>:76:1' EnableTargetTorque = 0; */
      Walking01_withElmos_B.EnableTargetTorque = 0.0;

      /* '<S81>:76:3' FaultDetected = 0; */
      Walking01_withElmos_B.FaultDetected = 0.0;
    } else {
      switch (Walking01_withElmos_DW.is_c23_Walking01_withElmos) {
       case Walking01_wit_IN_FaultRunning_g:
        /* During 'FaultRunning': '<S81>:88' */
        break;

       case Walking01_w_IN_Initialization_e:
        /* During 'Initialization': '<S81>:81' */
        /* '<S81>:73:1' sf_internal_predicateOutput = ... */
        /* '<S81>:73:1' MedullaCommand == 4 || MedullaCommand == 5; */
        if ((Walking01_withElmos_B.MedullaCommandSafe == 4.0) ||
            (Walking01_withElmos_B.MedullaCommandSafe == 5.0)) {
          /* Transition: '<S81>:73' */
          /* Exit Internal 'Initialization': '<S81>:81' */
          Walking01_withElmos_DW.is_Initialization =
            Walking01__IN_NO_ACTIVE_CHILD_j;
          Walking01_withElmos_DW.is_c23_Walking01_withElmos =
            Walking01_wit_IN_FaultRunning_g;

          /* Entry 'FaultRunning': '<S81>:88' */
          /* '<S81>:88:1' ControlWordIndex = 1; */
          Walking01_withElmos_B.ControlWordIndex = 1.0;

          /* '<S81>:88:1' EnableTargetTorque = 0; */
          Walking01_withElmos_B.EnableTargetTorque = 0.0;

          /* '<S81>:88:3' FaultDetected = 1; */
          Walking01_withElmos_B.FaultDetected = 1.0;
        } else {
          switch (Walking01_withElmos_DW.is_Initialization) {
           case Walking01_withElmos_IN_Fault_d:
            /* During 'Fault': '<S81>:82' */
            /* '<S81>:72:1' sf_internal_predicateOutput = ... */
            /* '<S81>:72:1' Timeout >=20; */
            if (Walking01_withElmos_DW.Timeout >= 20.0) {
              /* Transition: '<S81>:72' */
              Walking01_withElmos_DW.is_Initialization =
                Walking01_withElmos_IN_Fault_d;

              /* Entry 'Fault': '<S81>:82' */
              /* '<S81>:82:1' ControlWordIndex = 3; */
              Walking01_withElmos_B.ControlWordIndex = 3.0;

              /* '<S81>:82:1' EnableTargetTorque = 0; */
              Walking01_withElmos_B.EnableTargetTorque = 0.0;

              /* '<S81>:82:3' Timeout = 0; */
              Walking01_withElmos_DW.Timeout = 0.0;
            } else {
              /* '<S81>:87:1' sf_internal_predicateOutput = ... */
              /* '<S81>:87:1' SwitchOnDisabledMode == 1; */
              if (Walking01_withElmos_B.Compare_n4 == 1) {
                /* Transition: '<S81>:87' */
                Walking01_withElmos_DW.is_Initialization =
                  Walking01_IN_SwitchOnDisabled_e;

                /* Entry 'SwitchOnDisabled': '<S81>:75' */
                /* '<S81>:75:1' ControlWordIndex = 1; */
                Walking01_withElmos_B.ControlWordIndex = 1.0;

                /* '<S81>:75:1' Timeout = 0; */
                Walking01_withElmos_DW.Timeout = 0.0;

                /* '<S81>:75:3' EnableTargetTorque = 0; */
                Walking01_withElmos_B.EnableTargetTorque = 0.0;
              } else {
                /* '<S81>:82:4' Timeout = Timeout + 1; */
                Walking01_withElmos_DW.Timeout++;

                /* '<S81>:82:5' ControlWordIndex = 0; */
                Walking01_withElmos_B.ControlWordIndex = 0.0;
              }
            }
            break;

           case Walking01__IN_ReadyToSwitchOn_n:
            /* During 'ReadyToSwitchOn': '<S81>:90' */
            /* '<S81>:92:1' sf_internal_predicateOutput = ... */
            /* '<S81>:92:1' FaultMode == 1; */
            if (Walking01_withElmos_B.Compare_ju == 1) {
              /* Transition: '<S81>:92' */
              Walking01_withElmos_DW.is_Initialization =
                Walking01_withElmos_IN_Fault_d;

              /* Entry 'Fault': '<S81>:82' */
              /* '<S81>:82:1' ControlWordIndex = 3; */
              Walking01_withElmos_B.ControlWordIndex = 3.0;

              /* '<S81>:82:1' EnableTargetTorque = 0; */
              Walking01_withElmos_B.EnableTargetTorque = 0.0;

              /* '<S81>:82:3' Timeout = 0; */
              Walking01_withElmos_DW.Timeout = 0.0;
            } else {
              /* '<S81>:77:1' sf_internal_predicateOutput = ... */
              /* '<S81>:77:1' SwitchOnDisabledMode == 1; */
              if (Walking01_withElmos_B.Compare_n4 == 1) {
                /* Transition: '<S81>:77' */
                Walking01_withElmos_DW.is_Initialization =
                  Walking01_IN_SwitchOnDisabled_e;

                /* Entry 'SwitchOnDisabled': '<S81>:75' */
                /* '<S81>:75:1' ControlWordIndex = 1; */
                Walking01_withElmos_B.ControlWordIndex = 1.0;

                /* '<S81>:75:1' Timeout = 0; */
                Walking01_withElmos_DW.Timeout = 0.0;

                /* '<S81>:75:3' EnableTargetTorque = 0; */
                Walking01_withElmos_B.EnableTargetTorque = 0.0;
              } else {
                /* Transition: '<S81>:78' */
                Walking01_withElmos_DW.is_Initialization =
                  Walking01__IN_NO_ACTIVE_CHILD_j;
                Walking01_withElmos_DW.is_c23_Walking01_withElmos =
                  Walking01_withElmo_IN_Running_j;

                /* Entry 'Running': '<S81>:85' */
                /* '<S81>:85:1' ControlWordIndex = 2; */
                Walking01_withElmos_B.ControlWordIndex = 2.0;

                /* '<S81>:85:1' EnableTargetTorque = 1; */
                Walking01_withElmos_B.EnableTargetTorque = 1.0;
              }
            }
            break;

           default:
            /* During 'SwitchOnDisabled': '<S81>:75' */
            /* '<S81>:89:1' sf_internal_predicateOutput = ... */
            /* '<S81>:89:1' ReadyToSwitchOnMode == 1; */
            if (Walking01_withElmos_B.Compare_co == 1) {
              /* Transition: '<S81>:89' */
              Walking01_withElmos_DW.is_Initialization =
                Walking01__IN_ReadyToSwitchOn_n;

              /* Entry 'ReadyToSwitchOn': '<S81>:90' */
              /* '<S81>:90:1' ControlWordIndex = 2; */
              Walking01_withElmos_B.ControlWordIndex = 2.0;

              /* '<S81>:90:1' Timeout = 0; */
              Walking01_withElmos_DW.Timeout = 0.0;

              /* '<S81>:90:3' EnableTargetTorque = 0; */
              Walking01_withElmos_B.EnableTargetTorque = 0.0;
            } else {
              /* '<S81>:83:1' sf_internal_predicateOutput = ... */
              /* '<S81>:83:1' FaultMode == 1; */
              if (Walking01_withElmos_B.Compare_ju == 1) {
                /* Transition: '<S81>:83' */
                Walking01_withElmos_DW.is_Initialization =
                  Walking01_withElmos_IN_Fault_d;

                /* Entry 'Fault': '<S81>:82' */
                /* '<S81>:82:1' ControlWordIndex = 3; */
                Walking01_withElmos_B.ControlWordIndex = 3.0;

                /* '<S81>:82:1' EnableTargetTorque = 0; */
                Walking01_withElmos_B.EnableTargetTorque = 0.0;

                /* '<S81>:82:3' Timeout = 0; */
                Walking01_withElmos_DW.Timeout = 0.0;
              } else {
                /* '<S81>:75:3' Timeout = Timeout + 1; */
                Walking01_withElmos_DW.Timeout++;
              }
            }
            break;
          }
        }
        break;

       case Walking01_withElmo_IN_Running_j:
        /* During 'Running': '<S81>:85' */
        /* '<S81>:79:1' sf_internal_predicateOutput = ... */
        /* '<S81>:79:1' FaultMode == 1; */
        if (Walking01_withElmos_B.Compare_ju == 1) {
          /* Transition: '<S81>:79' */
          Walking01_withElmos_DW.is_c23_Walking01_withElmos =
            Walking01_wit_IN_FaultRunning_g;

          /* Entry 'FaultRunning': '<S81>:88' */
          /* '<S81>:88:1' ControlWordIndex = 1; */
          Walking01_withElmos_B.ControlWordIndex = 1.0;

          /* '<S81>:88:1' EnableTargetTorque = 0; */
          Walking01_withElmos_B.EnableTargetTorque = 0.0;

          /* '<S81>:88:3' FaultDetected = 1; */
          Walking01_withElmos_B.FaultDetected = 1.0;
        } else {
          /* '<S81>:74:1' sf_internal_predicateOutput = ... */
          /* '<S81>:74:1' MedullaCommand == 4 || MedullaCommand == 5; */
          if ((Walking01_withElmos_B.MedullaCommandSafe == 4.0) ||
              (Walking01_withElmos_B.MedullaCommandSafe == 5.0)) {
            /* Transition: '<S81>:74' */
            Walking01_withElmos_DW.is_c23_Walking01_withElmos =
              Walking01_wit_IN_FaultRunning_g;

            /* Entry 'FaultRunning': '<S81>:88' */
            /* '<S81>:88:1' ControlWordIndex = 1; */
            Walking01_withElmos_B.ControlWordIndex = 1.0;

            /* '<S81>:88:1' EnableTargetTorque = 0; */
            Walking01_withElmos_B.EnableTargetTorque = 0.0;

            /* '<S81>:88:3' FaultDetected = 1; */
            Walking01_withElmos_B.FaultDetected = 1.0;
          }
        }
        break;

       default:
        /* During 'Start1': '<S81>:76' */
        /* '<S81>:84:1' sf_internal_predicateOutput = ... */
        /* '<S81>:84:1' MedullaCommand == 4 || MedullaCommand == 5; */
        if ((Walking01_withElmos_B.MedullaCommandSafe == 4.0) ||
            (Walking01_withElmos_B.MedullaCommandSafe == 5.0)) {
          /* Transition: '<S81>:84' */
          Walking01_withElmos_DW.is_c23_Walking01_withElmos =
            Walking01_wit_IN_FaultRunning_g;

          /* Entry 'FaultRunning': '<S81>:88' */
          /* '<S81>:88:1' ControlWordIndex = 1; */
          Walking01_withElmos_B.ControlWordIndex = 1.0;

          /* '<S81>:88:1' EnableTargetTorque = 0; */
          Walking01_withElmos_B.EnableTargetTorque = 0.0;

          /* '<S81>:88:3' FaultDetected = 1; */
          Walking01_withElmos_B.FaultDetected = 1.0;
        } else {
          /* '<S81>:80:1' sf_internal_predicateOutput = ... */
          /* '<S81>:80:1' MedullaCommand == 2; */
          if (Walking01_withElmos_B.MedullaCommandSafe == 2.0) {
            /* Transition: '<S81>:80' */
            Walking01_withElmos_DW.is_c23_Walking01_withElmos =
              Walking01_w_IN_Initialization_e;

            /* Entry Internal 'Initialization': '<S81>:81' */
            /* Transition: '<S81>:94' */
            Walking01_withElmos_DW.is_Initialization =
              Walking01_IN_SwitchOnDisabled_e;

            /* Entry 'SwitchOnDisabled': '<S81>:75' */
            /* '<S81>:75:1' ControlWordIndex = 1; */
            Walking01_withElmos_B.ControlWordIndex = 1.0;

            /* '<S81>:75:1' Timeout = 0; */
            Walking01_withElmos_DW.Timeout = 0.0;

            /* '<S81>:75:3' EnableTargetTorque = 0; */
            Walking01_withElmos_B.EnableTargetTorque = 0.0;
          }
        }
        break;
      }
    }

    /* End of Chart: '<S36>/Chart' */

    /* Outport: '<Root>/FaultDetected' */
    Walking01_withElmos_Y.FaultDetected[0] =
      Walking01_withElmos_B.sf_Chart.FaultDetected;
    Walking01_withElmos_Y.FaultDetected[1] =
      Walking01_withElmos_B.sf_Chart_b.FaultDetected;
    Walking01_withElmos_Y.FaultDetected[2] =
      Walking01_withElmos_B.FaultDetected_n;
    Walking01_withElmos_Y.FaultDetected[3] = Walking01_withElmos_B.FaultDetected;

    /* Delay: '<S4>/Resettable Delay' incorporates:
     *  Constant: '<S4>/ResetExecutionDelaySteps'
     *  Constant: '<S8>/Constant'
     *  RelationalOperator: '<S8>/Compare'
     */
    if (Walking01_withElmos_B.TaskExecutionTime >= 0.0005) {
      Walking01_withElmos_DW.icLoad = 1U;
    }

    if (Walking01_withElmos_DW.icLoad != 0) {
      Walking01_withElmos_DW.ResettableDelay_DSTATE = 50.0;
    }

    HalfMaxTicks_idx_0 = Walking01_withElmos_DW.ResettableDelay_DSTATE;

    /* Outputs for Enabled SubSystem: '<S4>/Reset CPU Overload Count' incorporates:
     *  EnablePort: '<S11>/Enable'
     */
    /* RelationalOperator: '<S10>/Compare' incorporates:
     *  Constant: '<S10>/Constant'
     *  Delay: '<S4>/Resettable Delay'
     */
    if (Walking01_withElmos_DW.ResettableDelay_DSTATE == 0.0) {
      /* Level2 S-Function Block: '<S12>/xPC Set Overload Counter' (xpcsetoverload) */
      {
        SimStruct *rts = Walking01_withElmos_M->childSfunctions[0];
        sfcnOutputs(rts, 0);
      }

      srUpdateBC(Walking01_withElmos_DW.ResetCPUOverloadCount_SubsysRan);
    }

    /* End of RelationalOperator: '<S10>/Compare' */
    /* End of Outputs for SubSystem: '<S4>/Reset CPU Overload Count' */

    /* Bias: '<S4>/Bias' */
    Walking01_withElmos_B.Bias = HalfMaxTicks_idx_0 + (-1.0);

    /* Saturate: '<S13>/Current Saturation' */
    for (i = 0; i < 6; i++) {
      if (L2fh[i] > 50.0) {
        RefAngle[i] = 50.0;
      } else if (L2fh[i] < (-50.0)) {
        RefAngle[i] = (-50.0);
      } else {
        RefAngle[i] = L2fh[i];
      }
    }

    /* End of Saturate: '<S13>/Current Saturation' */

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[113];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[114];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[115];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[116];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[117];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[118];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[119];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[120];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[121];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[122];
      sfcnOutputs(rts, 0);
    }

    /* MATLAB Function: '<S19>/ConvertAmpCurrent' incorporates:
     *  DataTypeConversion: '<S19>/Data Type Conversion111'
     *  DataTypeConversion: '<S19>/Data Type Conversion126'
     *  DataTypeConversion: '<S19>/Data Type Conversion21'
     *  DataTypeConversion: '<S19>/Data Type Conversion45'
     *  DataTypeConversion: '<S19>/Data Type Conversion69'
     *  DataTypeConversion: '<S19>/Data Type Conversion93'
     */
    /* MATLAB Function 'DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/ConvertAmpCurrent': '<S26>:1' */
    /* '<S26>:1:4' measuredCurrent = (adc_value) * 60.0 / 8192; */
    rtb_measuredCurrent[0] = (real_T)Walking01_withElmos_B.EtherCATRxVar6_n *
      60.0 / 8192.0;
    rtb_measuredCurrent[1] = (real_T)Walking01_withElmos_B.EtherCATRxVar7_g *
      60.0 / 8192.0;
    rtb_measuredCurrent[2] = (real_T)Walking01_withElmos_B.EtherCATRxVar6_o *
      60.0 / 8192.0;
    rtb_measuredCurrent[3] = (real_T)Walking01_withElmos_B.EtherCATRxVar7_d *
      60.0 / 8192.0;
    rtb_measuredCurrent[4] = (real_T)Walking01_withElmos_B.EtherCATRxVar * 60.0 /
      8192.0;
    rtb_measuredCurrent[5] = (real_T)Walking01_withElmos_B.EtherCATRxVar6_b *
      60.0 / 8192.0;
    rtb_measuredCurrent[6] = (real_T)Walking01_withElmos_B.EtherCATRxVar7_b *
      60.0 / 8192.0;
    rtb_measuredCurrent[7] = (real_T)Walking01_withElmos_B.EtherCATRxVar6_m *
      60.0 / 8192.0;
    rtb_measuredCurrent[8] = (real_T)Walking01_withElmos_B.EtherCATRxVar7_gy *
      60.0 / 8192.0;
    rtb_measuredCurrent[9] = (real_T)Walking01_withElmos_B.EtherCATRxVar_i *
      60.0 / 8192.0;

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[123];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[124];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[125];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[126];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[127];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[128];
      sfcnOutputs(rts, 0);
    }

    /* MATLAB Function: '<S19>/ConvertLogicVoltage' incorporates:
     *  DataTypeConversion: '<S19>/Data Type Conversion103'
     *  DataTypeConversion: '<S19>/Data Type Conversion118'
     *  DataTypeConversion: '<S19>/Data Type Conversion14'
     *  DataTypeConversion: '<S19>/Data Type Conversion38'
     *  DataTypeConversion: '<S19>/Data Type Conversion62'
     *  DataTypeConversion: '<S19>/Data Type Conversion86'
     */
    /* MATLAB Function 'DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/ConvertLogicVoltage': '<S27>:1' */
    /* '<S27>:1:4' MEDULLA_ADC_MAX_VOLTS     = 2.70; */
    /* '<S27>:1:5' MEDULLA_ADC_OFFSET_COUNTS = 172; */
    /* '<S27>:1:7' logicVoltage = (adc_value - MEDULLA_ADC_OFFSET_COUNTS) * (MEDULLA_ADC_MAX_VOLTS/(4095.0))  * 6.0; */
    rtb_logicVoltage[0] = ((real_T)Walking01_withElmos_B.EtherCATRxVar10_c -
      172.0) * 0.00065934065934065934 * 6.0;
    rtb_logicVoltage[1] = ((real_T)Walking01_withElmos_B.EtherCATRxVar10_f -
      172.0) * 0.00065934065934065934 * 6.0;
    rtb_logicVoltage[2] = ((real_T)Walking01_withElmos_B.EtherCATRxVar6_a -
      172.0) * 0.00065934065934065934 * 6.0;
    rtb_logicVoltage[3] = ((real_T)Walking01_withElmos_B.EtherCATRxVar10_b -
      172.0) * 0.00065934065934065934 * 6.0;
    rtb_logicVoltage[4] = ((real_T)Walking01_withElmos_B.EtherCATRxVar10_g -
      172.0) * 0.00065934065934065934 * 6.0;
    rtb_logicVoltage[5] = ((real_T)Walking01_withElmos_B.EtherCATRxVar6_f -
      172.0) * 0.00065934065934065934 * 6.0;

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[129];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[130];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[131];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[132];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[133];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[134];
      sfcnOutputs(rts, 0);
    }

    /* MATLAB Function: '<S19>/ConvertMotorVoltage' incorporates:
     *  DataTypeConversion: '<S19>/Data Type Conversion101'
     *  DataTypeConversion: '<S19>/Data Type Conversion116'
     *  DataTypeConversion: '<S19>/Data Type Conversion13'
     *  DataTypeConversion: '<S19>/Data Type Conversion37'
     *  DataTypeConversion: '<S19>/Data Type Conversion61'
     *  DataTypeConversion: '<S19>/Data Type Conversion85'
     */
    /* MATLAB Function 'DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/ConvertMotorVoltage': '<S28>:1' */
    /* '<S28>:1:4' MOTOR_VOLTAGE_C_OFFSET    = 1300.0; */
    /* '<S28>:1:5' MOTOR_VOLTAGE_V_CAL       = 60.2; */
    /* '<S28>:1:6' MOTOR_VOLTAGE_C_CAL       = 3600.0; */
    /* '<S28>:1:8' motorVoltage = (adc_value - MOTOR_VOLTAGE_C_OFFSET)*MOTOR_VOLTAGE_V_CAL/(MOTOR_VOLTAGE_C_CAL-MOTOR_VOLTAGE_C_OFFSET); */
    rtb_motorVoltage[0] = ((real_T)Walking01_withElmos_B.EtherCATRxVar11_b -
      1300.0) * 60.2 / 2300.0;
    rtb_motorVoltage[1] = ((real_T)Walking01_withElmos_B.EtherCATRxVar11_a -
      1300.0) * 60.2 / 2300.0;
    rtb_motorVoltage[2] = ((real_T)Walking01_withElmos_B.EtherCATRxVar1_p -
      1300.0) * 60.2 / 2300.0;
    rtb_motorVoltage[3] = ((real_T)Walking01_withElmos_B.EtherCATRxVar11_h -
      1300.0) * 60.2 / 2300.0;
    rtb_motorVoltage[4] = ((real_T)Walking01_withElmos_B.EtherCATRxVar11_l -
      1300.0) * 60.2 / 2300.0;
    rtb_motorVoltage[5] = ((real_T)Walking01_withElmos_B.EtherCATRxVar1_m -
      1300.0) * 60.2 / 2300.0;

    /* S-Function (sdspcount2): '<S19>/Counter' */
    rtb_Counter_o2 = false;
    rtb_DigitalClock_a = Walking01_withElmos_DW.Counter_Count;
    if (Walking01_withElmos_DW.Counter_Count == ((uint16_T)32U)) {
      rtb_Counter_o2 = true;
    }

    if (Walking01_withElmos_DW.Counter_Count < ((uint16_T)65535U)) {
      Walking01_withElmos_DW.Counter_Count++;
    } else {
      Walking01_withElmos_DW.Counter_Count = 0U;
    }

    /* End of S-Function (sdspcount2): '<S19>/Counter' */

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[135];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion10' */
    rtb_DataTypeConversion10 = Walking01_withElmos_B.EtherCATRxVar5_n;

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[136];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion108' */
    rtb_DataTypeConversion108 = Walking01_withElmos_B.EtherCATRxVar5_o;

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[137];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion109' */
    rtb_DataTypeConversion109 = Walking01_withElmos_B.EtherCATRxVar3_h;

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[138];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion11' */
    rtb_DataTypeConversion11 = Walking01_withElmos_B.EtherCATRxVar9_p;

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[139];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion110' */
    rtb_DataTypeConversion110 = Walking01_withElmos_B.EtherCATRxVar17_j;

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[140];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion12' */
    rtb_DataTypeConversion12 = Walking01_withElmos_B.EtherCATRxVar1_h;

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[141];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion123' */
    rtb_DataTypeConversion123 = Walking01_withElmos_B.EtherCATRxVar5_d;

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[142];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion124' */
    rtb_DataTypeConversion124 = Walking01_withElmos_B.EtherCATRxVar3_c;

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[143];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion125' */
    rtb_DataTypeConversion125 = Walking01_withElmos_B.EtherCATRxVar17_p;

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[144];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion16' */
    rtb_DataTypeConversion16 = Walking01_withElmos_B.EtherCATRxVar16_k;

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[145];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion2' */
    rtb_DataTypeConversion2 = Walking01_withElmos_B.EtherCATRxVar23;

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[146];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[147];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion23' */
    rtb_DataTypeConversion23[0] = Walking01_withElmos_B.EtherCATRxVar2_o;
    rtb_DataTypeConversion23[1] = Walking01_withElmos_B.EtherCATRxVar3_j;

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[148];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion27' */
    rtb_DataTypeConversion27 = Walking01_withElmos_B.EtherCATRxVar23_c;

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[149];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion29' */
    rtb_DataTypeConversion29 = Walking01_withElmos_B.EtherCATRxVar20;

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[150];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion34' */
    rtb_DataTypeConversion34 = Walking01_withElmos_B.EtherCATRxVar5_l;

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[151];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion35' */
    rtb_DataTypeConversion35 = Walking01_withElmos_B.EtherCATRxVar9_a;

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[152];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion36' */
    rtb_DataTypeConversion36 = Walking01_withElmos_B.EtherCATRxVar1_b;

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[153];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[154];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion47' */
    rtb_DataTypeConversion47[0] = Walking01_withElmos_B.EtherCATRxVar2_m;
    rtb_DataTypeConversion47[1] = Walking01_withElmos_B.EtherCATRxVar3_o;

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[155];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion5' */
    rtb_DataTypeConversion5 = Walking01_withElmos_B.EtherCATRxVar20_c;

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[156];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion51' */
    rtb_DataTypeConversion51 = Walking01_withElmos_B.EtherCATRxVar23_e;

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[157];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion53' */
    rtb_DataTypeConversion53 = Walking01_withElmos_B.EtherCATRxVar20_p;

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[158];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion58' */
    rtb_DataTypeConversion58 = Walking01_withElmos_B.EtherCATRxVar5_k;

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[159];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion59' */
    rtb_DataTypeConversion59 = Walking01_withElmos_B.EtherCATRxVar9_i;

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[160];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion60' */
    rtb_DataTypeConversion60 = Walking01_withElmos_B.EtherCATRxVar1_f;

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[161];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[162];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion71' */
    rtb_DataTypeConversion71[0] = Walking01_withElmos_B.EtherCATRxVar2_n;
    rtb_DataTypeConversion71[1] = Walking01_withElmos_B.EtherCATRxVar3_c4;

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[163];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion75' */
    rtb_DataTypeConversion75 = Walking01_withElmos_B.EtherCATRxVar23_p;

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[164];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion77' */
    rtb_DataTypeConversion77 = Walking01_withElmos_B.EtherCATRxVar20_l;

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[165];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion82' */
    rtb_DataTypeConversion82 = Walking01_withElmos_B.EtherCATRxVar5_p;

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[166];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion83' */
    rtb_DataTypeConversion83 = Walking01_withElmos_B.EtherCATRxVar9_j;

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[167];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion84' */
    rtb_DataTypeConversion84 = Walking01_withElmos_B.EtherCATRxVar1_pm;

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[168];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[169];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S19>/Data Type Conversion95' */
    rtb_DataTypeConversion95[0] = Walking01_withElmos_B.EtherCATRxVar2_p;
    rtb_DataTypeConversion95[1] = Walking01_withElmos_B.EtherCATRxVar3_k;

    /* DataTypeConversion: '<S31>/Data Type Conversion3' */
    if (Walking01_withElmos_B.MedullaCommandSafe < 0.0) {
      HalfMaxTicks_idx_1 = ceil(Walking01_withElmos_B.MedullaCommandSafe);
    } else {
      HalfMaxTicks_idx_1 = floor(Walking01_withElmos_B.MedullaCommandSafe);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 256.0);
    }

    Walking01_withElmos_B.DataTypeConversion3 = (uint8_T)(HalfMaxTicks_idx_1 <
      0.0 ? (int32_T)(uint8_T)-(int8_T)(uint8_T)-HalfMaxTicks_idx_1 : (int32_T)
      (uint8_T)HalfMaxTicks_idx_1);

    /* End of DataTypeConversion: '<S31>/Data Type Conversion3' */

    /* Level2 S-Function Block: '<S31>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[170];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S31>/Data Type Conversion4' */
    if (rtb_DigitalClock_a < 0.0) {
      HalfMaxTicks_idx_1 = ceil(rtb_DigitalClock_a);
    } else {
      HalfMaxTicks_idx_1 = floor(rtb_DigitalClock_a);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 65536.0);
    }

    Walking01_withElmos_B.DataTypeConversion4 = (uint16_T)(HalfMaxTicks_idx_1 <
      0.0 ? (int32_T)(uint16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_1 :
      (int32_T)(uint16_T)HalfMaxTicks_idx_1);

    /* End of DataTypeConversion: '<S31>/Data Type Conversion4' */

    /* Level2 S-Function Block: '<S31>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[171];
      sfcnOutputs(rts, 0);
    }

    /* MATLAB Function: '<S13>/convert_mtr_current_to_pwm' incorporates:
     *  Constant: '<S13>/MotorParameters'
     */
    /* MATLAB Function 'DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/convert_mtr_current_to_pwm': '<S23>:1' */
    /* This function takes motor torque command inputs and outputs */
    /* pwm commands (for the Medulla) in UMich convention */
    /* '<S23>:1:6' y = zeros(6,1); */
    for (i = 0; i < 6; i++) {
      L2fh[i] = 0.0;
    }

    /* '<S23>:1:8' if (Reset) */
    if (!Walking01_withElmos_B.LogicalOperator1) {
      /* The inputs, which are commanded motor torques  */
      /* '<S23>:1:13' leg_motor_1R_torque_cmd = u(1); */
      /* '<S23>:1:14' leg_motor_2R_torque_cmd = u(2); */
      /* '<S23>:1:15' hip_motor_3R_torque_cmd = u(3); */
      /* '<S23>:1:16' leg_motor_1L_torque_cmd = u(4); */
      /* '<S23>:1:17' leg_motor_2L_torque_cmd = u(5); */
      /* '<S23>:1:18' hip_motor_3L_torque_cmd = u(6); */
      /* Parameters determined experimentally at U Mich */
      /* '<S23>:1:21' UMich_LEFT_MOTOR_HIP_DIRECTION = params(1); */
      /* The direction for the left hip motor. (UMich convention) */
      /* '<S23>:1:22' UMich_RIGHT_MOTOR_HIP_DIRECTION = params(2); */
      /* The direction for the right hip motor. (UMich convention) */
      /*  The parameters, from http://code.google.com/p/atrias/source/browse/robot_definitions/ */
      /* From robot_invariant_defs.h */
      /* '<S23>:1:26' MTR_MAX_COUNT = params(3); */
      /* The maximum commanded amplifier value. This is the maximum value sent to the Medullas for the amplifier command. */
      /* From biped2_variant_defs.h */
      /* '<S23>:1:28' MTR_MAX_TORQUE = params(4); */
      /* Maximum motor torque for scaling */
      /* '<S23>:1:29' MTR_HIP_MAX_TORQUE = params(5); */
      /* Maximum hip motor torque for scaling */
      /* From leg3_definitions.h (corresponds to our left leg) */
      /* (Note that A=shin and B=thigh for OSU convention) */
      /* '<S23>:1:32' LEG3_MOTOR_A_DIRECTION = params(6); */
      /* '<S23>:1:33' LEG3_MOTOR_B_DIRECTION = params(7); */
      /* From leg4_definitions.h (corresponds to our right leg) */
      /* (Note that A=shin and B=thigh for OSU convention) */
      /* '<S23>:1:36' LEG4_MOTOR_A_DIRECTION = params(8); */
      /* '<S23>:1:37' LEG4_MOTOR_B_DIRECTION = params(9); */
      /* '<S23>:1:39' leg_torque_to_pwm = MTR_MAX_COUNT/MTR_MAX_TORQUE; */
      HalfMaxTicks_idx_0 = 19900.0 / 60.0;

      /* '<S23>:1:40' hip_torque_to_pwm = MTR_MAX_COUNT/MTR_HIP_MAX_TORQUE; */
      HalfMaxTicks_idx_1 = 19900.0 / 60.0;

      /* Convert leg_motor_1L_torque_cmd */
      /* '<S23>:1:43' leg_motor_1L_direction = LEG3_MOTOR_A_DIRECTION; */
      /* '<S23>:1:44' y(1) = motor_torque_to_pwm(leg_motor_1L_direction,leg_torque_to_pwm,leg_motor_1L_torque_cmd); */
      /* '<S23>:1:69' motor_pwm = motor_direction*torque_to_pwm_const*motor_torque_cmd; */
      L2fh[0] = (-1.0) * HalfMaxTicks_idx_0 * RefAngle[3];

      /* Convert leg_motor_2L_torque_cmd */
      /* '<S23>:1:47' leg_motor_2L_direction = LEG3_MOTOR_B_DIRECTION; */
      /* '<S23>:1:48' y(2) = motor_torque_to_pwm(leg_motor_2L_direction,leg_torque_to_pwm,leg_motor_2L_torque_cmd); */
      /* '<S23>:1:69' motor_pwm = motor_direction*torque_to_pwm_const*motor_torque_cmd; */
      L2fh[1] = 1.0 * HalfMaxTicks_idx_0 * RefAngle[4];

      /* Convert leg_motor_1R_torque_cmd */
      /* '<S23>:1:51' leg_motor_1R_direction = LEG4_MOTOR_A_DIRECTION; */
      /* '<S23>:1:52' y(3) = motor_torque_to_pwm(leg_motor_1R_direction,leg_torque_to_pwm,leg_motor_1R_torque_cmd); */
      /* '<S23>:1:69' motor_pwm = motor_direction*torque_to_pwm_const*motor_torque_cmd; */
      L2fh[2] = (-1.0) * HalfMaxTicks_idx_0 * RefAngle[0];

      /* Convert leg_motor_2R_torque_cmd */
      /* '<S23>:1:55' leg_motor_2R_direction = LEG4_MOTOR_B_DIRECTION; */
      /* '<S23>:1:56' y(4) = motor_torque_to_pwm(leg_motor_2R_direction,leg_torque_to_pwm,leg_motor_2R_torque_cmd); */
      /* '<S23>:1:69' motor_pwm = motor_direction*torque_to_pwm_const*motor_torque_cmd; */
      L2fh[3] = 1.0 * HalfMaxTicks_idx_0 * RefAngle[1];

      /* Convert hip_motor_3R_torque_cmd */
      /* '<S23>:1:59' hip_motor_3R_direction = UMich_RIGHT_MOTOR_HIP_DIRECTION; */
      /* Verified experimentally */
      /* '<S23>:1:60' y(5) = motor_torque_to_pwm(hip_motor_3R_direction,hip_torque_to_pwm,hip_motor_3R_torque_cmd); */
      /* '<S23>:1:69' motor_pwm = motor_direction*torque_to_pwm_const*motor_torque_cmd; */
      L2fh[4] = (-1.0) * HalfMaxTicks_idx_1 * RefAngle[2];

      /* Convert hip_motor_3L_torque_cmd */
      /* '<S23>:1:63' hip_motor_3L_direction = UMich_LEFT_MOTOR_HIP_DIRECTION; */
      /* Verified experimentally */
      /* '<S23>:1:64' y(6) = motor_torque_to_pwm(hip_motor_3L_direction,hip_torque_to_pwm,hip_motor_3L_torque_cmd); */
      /* '<S23>:1:69' motor_pwm = motor_direction*torque_to_pwm_const*motor_torque_cmd; */
      L2fh[5] = (-1.0) * HalfMaxTicks_idx_1 * RefAngle[5];
    }

    /* End of MATLAB Function: '<S13>/convert_mtr_current_to_pwm' */

    /* DataTypeConversion: '<S31>/Data Type Conversion5' */
    if (L2fh[5] < 0.0) {
      HalfMaxTicks_idx_1 = ceil(L2fh[5]);
    } else {
      HalfMaxTicks_idx_1 = floor(L2fh[5]);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 4.294967296E+9);
    }

    Walking01_withElmos_B.DataTypeConversion5 = HalfMaxTicks_idx_1 < 0.0 ?
      -(int32_T)(uint32_T)-HalfMaxTicks_idx_1 : (int32_T)(uint32_T)
      HalfMaxTicks_idx_1;

    /* End of DataTypeConversion: '<S31>/Data Type Conversion5' */

    /* Level2 S-Function Block: '<S31>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[172];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S32>/Data Type Conversion3' */
    if (Walking01_withElmos_B.MedullaCommandSafe < 0.0) {
      HalfMaxTicks_idx_1 = ceil(Walking01_withElmos_B.MedullaCommandSafe);
    } else {
      HalfMaxTicks_idx_1 = floor(Walking01_withElmos_B.MedullaCommandSafe);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 256.0);
    }

    Walking01_withElmos_B.DataTypeConversion3_i = (uint8_T)(HalfMaxTicks_idx_1 <
      0.0 ? (int32_T)(uint8_T)-(int8_T)(uint8_T)-HalfMaxTicks_idx_1 : (int32_T)
      (uint8_T)HalfMaxTicks_idx_1);

    /* End of DataTypeConversion: '<S32>/Data Type Conversion3' */

    /* Level2 S-Function Block: '<S32>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[173];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S32>/Data Type Conversion4' */
    if (rtb_DigitalClock_a < 0.0) {
      HalfMaxTicks_idx_1 = ceil(rtb_DigitalClock_a);
    } else {
      HalfMaxTicks_idx_1 = floor(rtb_DigitalClock_a);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 65536.0);
    }

    Walking01_withElmos_B.DataTypeConversion4_h = (uint16_T)(HalfMaxTicks_idx_1 <
      0.0 ? (int32_T)(uint16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_1 :
      (int32_T)(uint16_T)HalfMaxTicks_idx_1);

    /* End of DataTypeConversion: '<S32>/Data Type Conversion4' */

    /* Level2 S-Function Block: '<S32>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[174];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S32>/Data Type Conversion5' */
    if (L2fh[4] < 0.0) {
      HalfMaxTicks_idx_1 = ceil(L2fh[4]);
    } else {
      HalfMaxTicks_idx_1 = floor(L2fh[4]);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 4.294967296E+9);
    }

    Walking01_withElmos_B.DataTypeConversion5_e = HalfMaxTicks_idx_1 < 0.0 ?
      -(int32_T)(uint32_T)-HalfMaxTicks_idx_1 : (int32_T)(uint32_T)
      HalfMaxTicks_idx_1;

    /* End of DataTypeConversion: '<S32>/Data Type Conversion5' */

    /* Level2 S-Function Block: '<S32>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[175];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[176];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[177];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[178];
      sfcnOutputs(rts, 0);
    }

    /* MATLAB Function: '<S33>/TypecastAndCast1' */
    Walking01_with_TypecastAndCast1(Walking01_withElmos_B.EtherCATRxVar9,
      Walking01_withElmos_B.EtherCATRxVar11,
      Walking01_withElmos_B.EtherCATRxVar12,
      &Walking01_withElmos_B.sf_TypecastAndCast1);

    /* DataTypeConversion: '<S33>/Data Type Conversion3' */
    if (Walking01_withElmos_B.MedullaCommandSafe < 0.0) {
      HalfMaxTicks_idx_1 = ceil(Walking01_withElmos_B.MedullaCommandSafe);
    } else {
      HalfMaxTicks_idx_1 = floor(Walking01_withElmos_B.MedullaCommandSafe);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 256.0);
    }

    Walking01_withElmos_B.DataTypeConversion3_j = (uint8_T)(HalfMaxTicks_idx_1 <
      0.0 ? (int32_T)(uint8_T)-(int8_T)(uint8_T)-HalfMaxTicks_idx_1 : (int32_T)
      (uint8_T)HalfMaxTicks_idx_1);

    /* End of DataTypeConversion: '<S33>/Data Type Conversion3' */

    /* Level2 S-Function Block: '<S33>/EtherCAT Tx Var ' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[179];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S33>/Data Type Conversion4' */
    if (rtb_DigitalClock_a < 0.0) {
      HalfMaxTicks_idx_1 = ceil(rtb_DigitalClock_a);
    } else {
      HalfMaxTicks_idx_1 = floor(rtb_DigitalClock_a);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 65536.0);
    }

    Walking01_withElmos_B.DataTypeConversion4_a = (uint16_T)(HalfMaxTicks_idx_1 <
      0.0 ? (int32_T)(uint16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_1 :
      (int32_T)(uint16_T)HalfMaxTicks_idx_1);

    /* End of DataTypeConversion: '<S33>/Data Type Conversion4' */

    /* Level2 S-Function Block: '<S33>/EtherCAT Tx Var 1' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[180];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S33>/Data Type Conversion1' incorporates:
     *  Constant: '<S5>/ResetYaw1'
     */
    if (Walking01_withElmos_P.IMUCommand < 0.0) {
      HalfMaxTicks_idx_1 = ceil(Walking01_withElmos_P.IMUCommand);
    } else {
      HalfMaxTicks_idx_1 = floor(Walking01_withElmos_P.IMUCommand);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 65536.0);
    }

    Walking01_withElmos_B.DataTypeConversion1_l = (uint16_T)(HalfMaxTicks_idx_1 <
      0.0 ? (int32_T)(uint16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_1 :
      (int32_T)(uint16_T)HalfMaxTicks_idx_1);

    /* End of DataTypeConversion: '<S33>/Data Type Conversion1' */

    /* Level2 S-Function Block: '<S33>/EtherCAT Tx Var 2' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[181];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S46>/EtherCAT PDO Receive2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[182];
      sfcnOutputs(rts, 0);
    }

    /* Switch: '<S34>/Switch' incorporates:
     *  Constant: '<S34>/Constant1'
     *  DataTypeConversion: '<S47>/Data Type Conversion6'
     */
    if (Walking01_withElmos_B.EnableTargetTorque_f > 0.0) {
      /* DataTypeConversion: '<S47>/Data Type Conversion6' incorporates:
       *  Constant: '<S34>/MaxRatedCurrent'
       *  Fcn: '<S47>/Fcn'
       *  SignalConversion: '<S47>/ConcatBufferAtVector ConcatenateIn1'
       *  SignalConversion: '<S47>/ConcatBufferAtVector ConcatenateIn2'
       */
      HalfMaxTicks_idx_1 = floor(RefAngle[0] * 1000.0 / 25.0);
      if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
        HalfMaxTicks_idx_1 = 0.0;
      } else {
        HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 65536.0);
      }

      Walking01_withElmos_B.Switch = (int16_T)(HalfMaxTicks_idx_1 < 0.0 ?
        (int32_T)(int16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_1 : (int32_T)
        (int16_T)(uint16_T)HalfMaxTicks_idx_1);
    } else {
      Walking01_withElmos_B.Switch = 0;
    }

    /* End of Switch: '<S34>/Switch' */

    /* Level2 S-Function Block: '<S46>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[183];
      sfcnOutputs(rts, 0);
    }

    /* SwitchCase: '<S48>/Switch Case' */
    if (Walking01_withElmos_B.ControlWordIndex_j < 0.0) {
      HalfMaxTicks_idx_1 = ceil(Walking01_withElmos_B.ControlWordIndex_j);
    } else {
      HalfMaxTicks_idx_1 = floor(Walking01_withElmos_B.ControlWordIndex_j);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 4.294967296E+9);
    }

    switch (HalfMaxTicks_idx_1 < 0.0 ? -(int32_T)(uint32_T)-HalfMaxTicks_idx_1 :
            (int32_T)(uint32_T)HalfMaxTicks_idx_1) {
     case 1:
      /* Outputs for IfAction SubSystem: '<S48>/ShutdownControlWord' incorporates:
       *  ActionPort: '<S58>/Action Port'
       */
      Walking01_w_ShutdownControlWord(&Walking01_withElmos_B.Merge);

      /* End of Outputs for SubSystem: '<S48>/ShutdownControlWord' */
      break;

     case 2:
      /* Outputs for IfAction SubSystem: '<S48>/EnableControlWord' incorporates:
       *  ActionPort: '<S55>/Action Port'
       */
      Walking01_wit_EnableControlWord(&Walking01_withElmos_B.Merge);

      /* End of Outputs for SubSystem: '<S48>/EnableControlWord' */
      break;

     case 3:
      /* Outputs for IfAction SubSystem: '<S48>/FaultReset' incorporates:
       *  ActionPort: '<S56>/Action Port'
       */
      Walking01_withElmos_FaultReset(&Walking01_withElmos_B.Merge);

      /* End of Outputs for SubSystem: '<S48>/FaultReset' */
      break;

     default:
      /* Outputs for IfAction SubSystem: '<S48>/NothingControlWord' incorporates:
       *  ActionPort: '<S57>/Action Port'
       */
      Walking01_wi_NothingControlWord(&Walking01_withElmos_B.Merge);

      /* End of Outputs for SubSystem: '<S48>/NothingControlWord' */
      break;
    }

    /* End of SwitchCase: '<S48>/Switch Case' */

    /* Level2 S-Function Block: '<S46>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[184];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S46>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[185];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S64>/EtherCAT PDO Receive2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[186];
      sfcnOutputs(rts, 0);
    }

    /* Switch: '<S35>/Switch' incorporates:
     *  Constant: '<S35>/Constant1'
     *  DataTypeConversion: '<S65>/Data Type Conversion6'
     */
    if (Walking01_withElmos_B.sf_Chart.EnableTargetTorque > 0.0) {
      /* DataTypeConversion: '<S65>/Data Type Conversion6' incorporates:
       *  Constant: '<S35>/MaxRatedCurrent'
       *  Fcn: '<S65>/Fcn'
       *  SignalConversion: '<S65>/ConcatBufferAtVector ConcatenateIn1'
       *  SignalConversion: '<S65>/ConcatBufferAtVector ConcatenateIn2'
       */
      HalfMaxTicks_idx_1 = floor(RefAngle[2] * 1000.0 / 25.0);
      if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
        HalfMaxTicks_idx_1 = 0.0;
      } else {
        HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 65536.0);
      }

      Walking01_withElmos_B.Switch_a = (int16_T)(HalfMaxTicks_idx_1 < 0.0 ?
        (int32_T)(int16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_1 : (int32_T)
        (int16_T)(uint16_T)HalfMaxTicks_idx_1);
    } else {
      Walking01_withElmos_B.Switch_a = 0;
    }

    /* End of Switch: '<S35>/Switch' */

    /* Level2 S-Function Block: '<S64>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[187];
      sfcnOutputs(rts, 0);
    }

    /* SwitchCase: '<S66>/Switch Case' */
    if (Walking01_withElmos_B.sf_Chart.ControlWordIndex < 0.0) {
      HalfMaxTicks_idx_1 = ceil(Walking01_withElmos_B.sf_Chart.ControlWordIndex);
    } else {
      HalfMaxTicks_idx_1 = floor(Walking01_withElmos_B.sf_Chart.ControlWordIndex);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 4.294967296E+9);
    }

    switch (HalfMaxTicks_idx_1 < 0.0 ? -(int32_T)(uint32_T)-HalfMaxTicks_idx_1 :
            (int32_T)(uint32_T)HalfMaxTicks_idx_1) {
     case 1:
      /* Outputs for IfAction SubSystem: '<S66>/ShutdownControlWord' incorporates:
       *  ActionPort: '<S76>/Action Port'
       */
      Walking01_w_ShutdownControlWord(&Walking01_withElmos_B.Merge_l);

      /* End of Outputs for SubSystem: '<S66>/ShutdownControlWord' */
      break;

     case 2:
      /* Outputs for IfAction SubSystem: '<S66>/EnableControlWord' incorporates:
       *  ActionPort: '<S73>/Action Port'
       */
      Walking01_wit_EnableControlWord(&Walking01_withElmos_B.Merge_l);

      /* End of Outputs for SubSystem: '<S66>/EnableControlWord' */
      break;

     case 3:
      /* Outputs for IfAction SubSystem: '<S66>/FaultReset' incorporates:
       *  ActionPort: '<S74>/Action Port'
       */
      Walking01_withElmos_FaultReset(&Walking01_withElmos_B.Merge_l);

      /* End of Outputs for SubSystem: '<S66>/FaultReset' */
      break;

     default:
      /* Outputs for IfAction SubSystem: '<S66>/NothingControlWord' incorporates:
       *  ActionPort: '<S75>/Action Port'
       */
      Walking01_wi_NothingControlWord(&Walking01_withElmos_B.Merge_l);

      /* End of Outputs for SubSystem: '<S66>/NothingControlWord' */
      break;
    }

    /* End of SwitchCase: '<S66>/Switch Case' */

    /* Level2 S-Function Block: '<S64>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[188];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S64>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[189];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S82>/EtherCAT PDO Receive2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[190];
      sfcnOutputs(rts, 0);
    }

    /* Switch: '<S36>/Switch' incorporates:
     *  Constant: '<S36>/Constant1'
     *  DataTypeConversion: '<S83>/Data Type Conversion6'
     */
    if (Walking01_withElmos_B.EnableTargetTorque > 0.0) {
      /* DataTypeConversion: '<S83>/Data Type Conversion6' incorporates:
       *  Constant: '<S36>/MaxRatedCurrent'
       *  Fcn: '<S83>/Fcn'
       *  SignalConversion: '<S83>/ConcatBufferAtVector ConcatenateIn1'
       *  SignalConversion: '<S83>/ConcatBufferAtVector ConcatenateIn2'
       */
      HalfMaxTicks_idx_1 = floor(RefAngle[1] * 1000.0 / 25.0);
      if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
        HalfMaxTicks_idx_1 = 0.0;
      } else {
        HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 65536.0);
      }

      Walking01_withElmos_B.Switch_d = (int16_T)(HalfMaxTicks_idx_1 < 0.0 ?
        (int32_T)(int16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_1 : (int32_T)
        (int16_T)(uint16_T)HalfMaxTicks_idx_1);
    } else {
      Walking01_withElmos_B.Switch_d = 0;
    }

    /* End of Switch: '<S36>/Switch' */

    /* Level2 S-Function Block: '<S82>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[191];
      sfcnOutputs(rts, 0);
    }

    /* SwitchCase: '<S84>/Switch Case' */
    if (Walking01_withElmos_B.ControlWordIndex < 0.0) {
      HalfMaxTicks_idx_1 = ceil(Walking01_withElmos_B.ControlWordIndex);
    } else {
      HalfMaxTicks_idx_1 = floor(Walking01_withElmos_B.ControlWordIndex);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 4.294967296E+9);
    }

    switch (HalfMaxTicks_idx_1 < 0.0 ? -(int32_T)(uint32_T)-HalfMaxTicks_idx_1 :
            (int32_T)(uint32_T)HalfMaxTicks_idx_1) {
     case 1:
      /* Outputs for IfAction SubSystem: '<S84>/ShutdownControlWord' incorporates:
       *  ActionPort: '<S94>/Action Port'
       */
      Walking01_w_ShutdownControlWord(&Walking01_withElmos_B.Merge_h);

      /* End of Outputs for SubSystem: '<S84>/ShutdownControlWord' */
      break;

     case 2:
      /* Outputs for IfAction SubSystem: '<S84>/EnableControlWord' incorporates:
       *  ActionPort: '<S91>/Action Port'
       */
      Walking01_wit_EnableControlWord(&Walking01_withElmos_B.Merge_h);

      /* End of Outputs for SubSystem: '<S84>/EnableControlWord' */
      break;

     case 3:
      /* Outputs for IfAction SubSystem: '<S84>/FaultReset' incorporates:
       *  ActionPort: '<S92>/Action Port'
       */
      Walking01_withElmos_FaultReset(&Walking01_withElmos_B.Merge_h);

      /* End of Outputs for SubSystem: '<S84>/FaultReset' */
      break;

     default:
      /* Outputs for IfAction SubSystem: '<S84>/NothingControlWord' incorporates:
       *  ActionPort: '<S93>/Action Port'
       */
      Walking01_wi_NothingControlWord(&Walking01_withElmos_B.Merge_h);

      /* End of Outputs for SubSystem: '<S84>/NothingControlWord' */
      break;
    }

    /* End of SwitchCase: '<S84>/Switch Case' */

    /* Level2 S-Function Block: '<S82>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[192];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S82>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[193];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S100>/EtherCAT PDO Receive2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[194];
      sfcnOutputs(rts, 0);
    }

    /* Switch: '<S37>/Switch' incorporates:
     *  Constant: '<S37>/Constant1'
     *  DataTypeConversion: '<S101>/Data Type Conversion6'
     */
    if (Walking01_withElmos_B.sf_Chart_b.EnableTargetTorque > 0.0) {
      /* DataTypeConversion: '<S101>/Data Type Conversion6' incorporates:
       *  Constant: '<S37>/MaxRatedCurrent'
       *  Fcn: '<S101>/Fcn'
       *  SignalConversion: '<S101>/ConcatBufferAtVector ConcatenateIn1'
       *  SignalConversion: '<S101>/ConcatBufferAtVector ConcatenateIn2'
       */
      HalfMaxTicks_idx_1 = floor(RefAngle[3] * 1000.0 / 25.0);
      if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
        HalfMaxTicks_idx_1 = 0.0;
      } else {
        HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 65536.0);
      }

      Walking01_withElmos_B.Switch_i = (int16_T)(HalfMaxTicks_idx_1 < 0.0 ?
        (int32_T)(int16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_1 : (int32_T)
        (int16_T)(uint16_T)HalfMaxTicks_idx_1);
    } else {
      Walking01_withElmos_B.Switch_i = 0;
    }

    /* End of Switch: '<S37>/Switch' */

    /* Level2 S-Function Block: '<S100>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[195];
      sfcnOutputs(rts, 0);
    }

    /* SwitchCase: '<S102>/Switch Case' */
    if (Walking01_withElmos_B.sf_Chart_b.ControlWordIndex < 0.0) {
      HalfMaxTicks_idx_1 = ceil
        (Walking01_withElmos_B.sf_Chart_b.ControlWordIndex);
    } else {
      HalfMaxTicks_idx_1 = floor
        (Walking01_withElmos_B.sf_Chart_b.ControlWordIndex);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 4.294967296E+9);
    }

    switch (HalfMaxTicks_idx_1 < 0.0 ? -(int32_T)(uint32_T)-HalfMaxTicks_idx_1 :
            (int32_T)(uint32_T)HalfMaxTicks_idx_1) {
     case 1:
      /* Outputs for IfAction SubSystem: '<S102>/ShutdownControlWord' incorporates:
       *  ActionPort: '<S112>/Action Port'
       */
      Walking01_w_ShutdownControlWord(&Walking01_withElmos_B.Merge_e);

      /* End of Outputs for SubSystem: '<S102>/ShutdownControlWord' */
      break;

     case 2:
      /* Outputs for IfAction SubSystem: '<S102>/EnableControlWord' incorporates:
       *  ActionPort: '<S109>/Action Port'
       */
      Walking01_wit_EnableControlWord(&Walking01_withElmos_B.Merge_e);

      /* End of Outputs for SubSystem: '<S102>/EnableControlWord' */
      break;

     case 3:
      /* Outputs for IfAction SubSystem: '<S102>/FaultReset' incorporates:
       *  ActionPort: '<S110>/Action Port'
       */
      Walking01_withElmos_FaultReset(&Walking01_withElmos_B.Merge_e);

      /* End of Outputs for SubSystem: '<S102>/FaultReset' */
      break;

     default:
      /* Outputs for IfAction SubSystem: '<S102>/NothingControlWord' incorporates:
       *  ActionPort: '<S111>/Action Port'
       */
      Walking01_wi_NothingControlWord(&Walking01_withElmos_B.Merge_e);

      /* End of Outputs for SubSystem: '<S102>/NothingControlWord' */
      break;
    }

    /* End of SwitchCase: '<S102>/Switch Case' */

    /* Level2 S-Function Block: '<S100>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[196];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S100>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[197];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S38>/Data Type Conversion3' */
    if (Walking01_withElmos_B.MedullaCommandSafe < 0.0) {
      HalfMaxTicks_idx_1 = ceil(Walking01_withElmos_B.MedullaCommandSafe);
    } else {
      HalfMaxTicks_idx_1 = floor(Walking01_withElmos_B.MedullaCommandSafe);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 256.0);
    }

    Walking01_withElmos_B.DataTypeConversion3_f = (uint8_T)(HalfMaxTicks_idx_1 <
      0.0 ? (int32_T)(uint8_T)-(int8_T)(uint8_T)-HalfMaxTicks_idx_1 : (int32_T)
      (uint8_T)HalfMaxTicks_idx_1);

    /* End of DataTypeConversion: '<S38>/Data Type Conversion3' */

    /* Level2 S-Function Block: '<S38>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[198];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S38>/Data Type Conversion4' */
    if (rtb_DigitalClock_a < 0.0) {
      HalfMaxTicks_idx_1 = ceil(rtb_DigitalClock_a);
    } else {
      HalfMaxTicks_idx_1 = floor(rtb_DigitalClock_a);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 65536.0);
    }

    Walking01_withElmos_B.DataTypeConversion4_k = (uint16_T)(HalfMaxTicks_idx_1 <
      0.0 ? (int32_T)(uint16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_1 :
      (int32_T)(uint16_T)HalfMaxTicks_idx_1);

    /* End of DataTypeConversion: '<S38>/Data Type Conversion4' */

    /* Level2 S-Function Block: '<S38>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[199];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S38>/Data Type Conversion5' */
    if (L2fh[0] < 0.0) {
      HalfMaxTicks_idx_1 = ceil(L2fh[0]);
    } else {
      HalfMaxTicks_idx_1 = floor(L2fh[0]);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 4.294967296E+9);
    }

    Walking01_withElmos_B.DataTypeConversion5_n = HalfMaxTicks_idx_1 < 0.0 ?
      -(int32_T)(uint32_T)-HalfMaxTicks_idx_1 : (int32_T)(uint32_T)
      HalfMaxTicks_idx_1;

    /* End of DataTypeConversion: '<S38>/Data Type Conversion5' */

    /* Level2 S-Function Block: '<S38>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[200];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S39>/Data Type Conversion3' */
    if (Walking01_withElmos_B.MedullaCommandSafe < 0.0) {
      HalfMaxTicks_idx_1 = ceil(Walking01_withElmos_B.MedullaCommandSafe);
    } else {
      HalfMaxTicks_idx_1 = floor(Walking01_withElmos_B.MedullaCommandSafe);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 256.0);
    }

    Walking01_withElmos_B.DataTypeConversion3_g = (uint8_T)(HalfMaxTicks_idx_1 <
      0.0 ? (int32_T)(uint8_T)-(int8_T)(uint8_T)-HalfMaxTicks_idx_1 : (int32_T)
      (uint8_T)HalfMaxTicks_idx_1);

    /* End of DataTypeConversion: '<S39>/Data Type Conversion3' */

    /* Level2 S-Function Block: '<S39>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[201];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S39>/Data Type Conversion4' */
    if (rtb_DigitalClock_a < 0.0) {
      HalfMaxTicks_idx_1 = ceil(rtb_DigitalClock_a);
    } else {
      HalfMaxTicks_idx_1 = floor(rtb_DigitalClock_a);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 65536.0);
    }

    Walking01_withElmos_B.DataTypeConversion4_i = (uint16_T)(HalfMaxTicks_idx_1 <
      0.0 ? (int32_T)(uint16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_1 :
      (int32_T)(uint16_T)HalfMaxTicks_idx_1);

    /* End of DataTypeConversion: '<S39>/Data Type Conversion4' */

    /* Level2 S-Function Block: '<S39>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[202];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S39>/Data Type Conversion5' */
    if (L2fh[2] < 0.0) {
      HalfMaxTicks_idx_1 = ceil(L2fh[2]);
    } else {
      HalfMaxTicks_idx_1 = floor(L2fh[2]);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 4.294967296E+9);
    }

    Walking01_withElmos_B.DataTypeConversion5_b = HalfMaxTicks_idx_1 < 0.0 ?
      -(int32_T)(uint32_T)-HalfMaxTicks_idx_1 : (int32_T)(uint32_T)
      HalfMaxTicks_idx_1;

    /* End of DataTypeConversion: '<S39>/Data Type Conversion5' */

    /* Level2 S-Function Block: '<S39>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[203];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S40>/Data Type Conversion3' */
    if (Walking01_withElmos_B.MedullaCommandSafe < 0.0) {
      HalfMaxTicks_idx_1 = ceil(Walking01_withElmos_B.MedullaCommandSafe);
    } else {
      HalfMaxTicks_idx_1 = floor(Walking01_withElmos_B.MedullaCommandSafe);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 256.0);
    }

    Walking01_withElmos_B.DataTypeConversion3_o = (uint8_T)(HalfMaxTicks_idx_1 <
      0.0 ? (int32_T)(uint8_T)-(int8_T)(uint8_T)-HalfMaxTicks_idx_1 : (int32_T)
      (uint8_T)HalfMaxTicks_idx_1);

    /* End of DataTypeConversion: '<S40>/Data Type Conversion3' */

    /* Level2 S-Function Block: '<S40>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[204];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S40>/Data Type Conversion4' */
    if (rtb_DigitalClock_a < 0.0) {
      HalfMaxTicks_idx_1 = ceil(rtb_DigitalClock_a);
    } else {
      HalfMaxTicks_idx_1 = floor(rtb_DigitalClock_a);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 65536.0);
    }

    Walking01_withElmos_B.DataTypeConversion4_n = (uint16_T)(HalfMaxTicks_idx_1 <
      0.0 ? (int32_T)(uint16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_1 :
      (int32_T)(uint16_T)HalfMaxTicks_idx_1);

    /* End of DataTypeConversion: '<S40>/Data Type Conversion4' */

    /* Level2 S-Function Block: '<S40>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[205];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S40>/Data Type Conversion5' */
    if (L2fh[1] < 0.0) {
      HalfMaxTicks_idx_1 = ceil(L2fh[1]);
    } else {
      HalfMaxTicks_idx_1 = floor(L2fh[1]);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 4.294967296E+9);
    }

    Walking01_withElmos_B.DataTypeConversion5_by = HalfMaxTicks_idx_1 < 0.0 ?
      -(int32_T)(uint32_T)-HalfMaxTicks_idx_1 : (int32_T)(uint32_T)
      HalfMaxTicks_idx_1;

    /* End of DataTypeConversion: '<S40>/Data Type Conversion5' */

    /* Level2 S-Function Block: '<S40>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[206];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S41>/Data Type Conversion3' */
    if (Walking01_withElmos_B.MedullaCommandSafe < 0.0) {
      HalfMaxTicks_idx_1 = ceil(Walking01_withElmos_B.MedullaCommandSafe);
    } else {
      HalfMaxTicks_idx_1 = floor(Walking01_withElmos_B.MedullaCommandSafe);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 256.0);
    }

    Walking01_withElmos_B.DataTypeConversion3_f2 = (uint8_T)(HalfMaxTicks_idx_1 <
      0.0 ? (int32_T)(uint8_T)-(int8_T)(uint8_T)-HalfMaxTicks_idx_1 : (int32_T)
      (uint8_T)HalfMaxTicks_idx_1);

    /* End of DataTypeConversion: '<S41>/Data Type Conversion3' */

    /* Level2 S-Function Block: '<S41>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[207];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S41>/Data Type Conversion4' */
    if (rtb_DigitalClock_a < 0.0) {
      HalfMaxTicks_idx_1 = ceil(rtb_DigitalClock_a);
    } else {
      HalfMaxTicks_idx_1 = floor(rtb_DigitalClock_a);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 65536.0);
    }

    Walking01_withElmos_B.DataTypeConversion4_o = (uint16_T)(HalfMaxTicks_idx_1 <
      0.0 ? (int32_T)(uint16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_1 :
      (int32_T)(uint16_T)HalfMaxTicks_idx_1);

    /* End of DataTypeConversion: '<S41>/Data Type Conversion4' */

    /* Level2 S-Function Block: '<S41>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[208];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S41>/Data Type Conversion5' */
    if (L2fh[3] < 0.0) {
      HalfMaxTicks_idx_1 = ceil(L2fh[3]);
    } else {
      HalfMaxTicks_idx_1 = floor(L2fh[3]);
    }

    if (rtIsNaN(HalfMaxTicks_idx_1) || rtIsInf(HalfMaxTicks_idx_1)) {
      HalfMaxTicks_idx_1 = 0.0;
    } else {
      HalfMaxTicks_idx_1 = fmod(HalfMaxTicks_idx_1, 4.294967296E+9);
    }

    Walking01_withElmos_B.DataTypeConversion5_a = HalfMaxTicks_idx_1 < 0.0 ?
      -(int32_T)(uint32_T)-HalfMaxTicks_idx_1 : (int32_T)(uint32_T)
      HalfMaxTicks_idx_1;

    /* End of DataTypeConversion: '<S41>/Data Type Conversion5' */

    /* Level2 S-Function Block: '<S41>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[209];
      sfcnOutputs(rts, 0);
    }

    /* Reshape: '<S13>/Reshape' */
    memcpy(&rtb_Reshape[0], &Walking01_withElmos_B.sf_ComputeEulerAngles.Rk[0],
           9U * sizeof(real_T));

    /* DigitalClock: '<S14>/Digital Clock' */
    rtb_DigitalClock_a = Walking01_withElmos_M->Timing.t[0];

    /* Logic: '<S14>/Logical Operator2' incorporates:
     *  Constant: '<S119>/Constant'
     *  Constant: '<S120>/Constant'
     *  Constant: '<S121>/Constant'
     *  Logic: '<S14>/Logical Operator'
     *  RelationalOperator: '<S119>/Compare'
     *  RelationalOperator: '<S120>/Compare'
     *  RelationalOperator: '<S121>/Compare'
     */
    Walking01_withElmos_B.LogicalOperator2 = (((rtb_DigitalClock_a <= 12.0) ||
      (Walking01_withElmos_B.DataTypeConversion97[1] != 8.0) ||
      (Walking01_withElmos_B.DataTypeConversion97[2] > 0.0)) && rtb_UnitDelay_m);

    /* user code (Output function Trailer for TID0) */
    {
      int32_T data[6]= { 0 };

      /*------------ S-Function Block: <S19>/EtherCAT Init  Write Process Data ,Run Admin Tasks and then Write Acyclic Data------------*/
      //xpcEtherCATSetOPState(0);
      xpcEtherCATWriteProcessData(0,NULL);
      xpcEtherCATExecAdminJobs(0);
      xpcEtherCATWriteAcyclicData(0);
      mwErrorGet((int_T)0,
                 &data[0], &data[1], &data[2], &data[3],&data[4],&data[5]);
      memcpy(&Walking01_withElmos_B.EtherCATInit[0], data,6*sizeof(int32_T));
      mwErrorClear( (int_T)0 );

      // Clear all momentary triggered values
    }
  }
}

/* Model update function for TID0 */
void Walking01_withElmos_update0(void) /* Sample time: [0.0005s, 0.0s] */
{
  /* local scratch DWork variables */
  int32_T ForEach_itr;
  int32_T ForEach_itr_n;
  int32_T i;

  /* Update for UnitDelay: '<S13>/Unit Delay1' */
  Walking01_withElmos_DW.UnitDelay1_DSTATE[0] =
    Walking01_withElmos_B.DataTypeConversion57;
  Walking01_withElmos_DW.UnitDelay1_DSTATE[1] =
    Walking01_withElmos_B.DataTypeConversion81;
  Walking01_withElmos_DW.UnitDelay1_DSTATE[2] =
    Walking01_withElmos_B.DataTypeConversion9;
  Walking01_withElmos_DW.UnitDelay1_DSTATE[3] =
    Walking01_withElmos_B.DataTypeConversion33;
  Walking01_withElmos_DW.UnitDelay1_DSTATE[4] =
    Walking01_withElmos_B.DataTypeConversion104;
  Walking01_withElmos_DW.UnitDelay1_DSTATE[5] =
    Walking01_withElmos_B.DataTypeConversion119;
  Walking01_withElmos_DW.UnitDelay1_DSTATE[6] =
    Walking01_withElmos_ConstB.DataTypeConversion141[0];
  Walking01_withElmos_DW.UnitDelay1_DSTATE[7] =
    Walking01_withElmos_ConstB.DataTypeConversion141[1];
  Walking01_withElmos_DW.UnitDelay1_DSTATE[8] =
    Walking01_withElmos_ConstB.DataTypeConversion141[2];

  /* Update for UnitDelay: '<S14>/Unit Delay' */
  Walking01_withElmos_DW.UnitDelay_DSTATE_n =
    Walking01_withElmos_B.LogicalOperator2;

  /* Update for UnitDelay: '<S13>/Unit Delay' */
  memcpy(&Walking01_withElmos_DW.UnitDelay_DSTATE[0],
         &Walking01_withElmos_B.Rollover[0], 9U * sizeof(real_T));

  /* Update for UnitDelay: '<S13>/Unit Delay2' */
  for (i = 0; i < 6; i++) {
    Walking01_withElmos_DW.UnitDelay2_DSTATE[i] =
      Walking01_withElmos_B.IncCalTick[i];
  }

  /* End of Update for UnitDelay: '<S13>/Unit Delay2' */

  /* Update for Iterator SubSystem: '<S13>/EncoderFilters' */
  for (ForEach_itr_n = 0; ForEach_itr_n < 19; ForEach_itr_n++) {
    /* Update for UnitDelay: '<S24>/Unit Delay' */
    Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n].UnitDelay_DSTATE =
      Walking01_withElmos_B.CoreSubsys[ForEach_itr_n].DiscreteStateSpace;

    /* Update for DiscreteStateSpace: '<S24>/Discrete State-Space' */
    {
      real_T xnew[4];
      xnew[0] = (0.46304266393748467)*
        Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n].
        DiscreteStateSpace_DSTATE[0]
        + (-0.63594626071947846)*Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n]
        .DiscreteStateSpace_DSTATE[1]
        + (-0.12234344732945052)*Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n]
        .DiscreteStateSpace_DSTATE[2]
        + (0.1094057318017978)*Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n].
        DiscreteStateSpace_DSTATE[3];
      xnew[0] += (-28.713783606978346)*
        Walking01_withElmos_B.CoreSubsys[ForEach_itr_n].
        sf_AnomalyDetection.q_clean;
      xnew[1] = (0.63594626071947924)*
        Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n].
        DiscreteStateSpace_DSTATE[0]
        + (-0.20017592633062919)*Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n]
        .DiscreteStateSpace_DSTATE[1]
        + (0.37218968207880138)*Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n]
        .DiscreteStateSpace_DSTATE[2]
        + (-0.15006598182651554)*Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n]
        .DiscreteStateSpace_DSTATE[3];
      xnew[1] += (24.40463328262317)*
        Walking01_withElmos_B.CoreSubsys[ForEach_itr_n].
        sf_AnomalyDetection.q_clean;
      xnew[2] = (-0.1223434473294493)*
        Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n].
        DiscreteStateSpace_DSTATE[0]
        + (-0.372189682078801)*Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n].
        DiscreteStateSpace_DSTATE[1]
        + (-0.76419956064117567)*Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n]
        .DiscreteStateSpace_DSTATE[2]
        + (-0.16574841449649924)*Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n]
        .DiscreteStateSpace_DSTATE[3];
      xnew[2] += (12.020156246194285)*
        Walking01_withElmos_B.CoreSubsys[ForEach_itr_n].
        sf_AnomalyDetection.q_clean;
      xnew[3] = (-0.10940573180179754)*
        Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n].
        DiscreteStateSpace_DSTATE[0]
        + (-0.15006598182651545)*Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n]
        .DiscreteStateSpace_DSTATE[1]
        + (0.16574841449649974)*Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n]
        .DiscreteStateSpace_DSTATE[2]
        + (0.50133282303432036)*Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n]
        .DiscreteStateSpace_DSTATE[3];
      xnew[3] += (1.3967204886477269)*
        Walking01_withElmos_B.CoreSubsys[ForEach_itr_n].
        sf_AnomalyDetection.q_clean;
      (void) memcpy(&Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n].
                    DiscreteStateSpace_DSTATE[0], xnew,
                    sizeof(real_T)*4);
    }
  }

  /* End of Update for SubSystem: '<S13>/EncoderFilters' */

  /* Update for UnitDelay: '<S13>/Unit Delay4' */
  memcpy(&Walking01_withElmos_DW.UnitDelay4_DSTATE[0],
         &Walking01_withElmos_B.sf_ComputeEulerAngles.R0[0], 9U * sizeof(real_T));

  /* Update for UnitDelay: '<S13>/Unit Delay3' */
  Walking01_withElmos_DW.UnitDelay3_DSTATE[0] =
    Walking01_withElmos_B.sf_ComputeEulerAngles.YawRollover[0];
  Walking01_withElmos_DW.UnitDelay3_DSTATE[1] =
    Walking01_withElmos_B.sf_ComputeEulerAngles.YawRollover[1];

  /* Update for DiscreteStateSpace: '<S214>/Discrete State-Space' */
  {
    real_T xnew[4];
    xnew[0] = (0.46304266393748467)*
      Walking01_withElmos_DW.DiscreteStateSpace_DSTATE[0]
      + (-0.63594626071947846)*Walking01_withElmos_DW.DiscreteStateSpace_DSTATE
      [1]
      + (-0.12234344732945052)*Walking01_withElmos_DW.DiscreteStateSpace_DSTATE
      [2]
      + (0.1094057318017978)*Walking01_withElmos_DW.DiscreteStateSpace_DSTATE[3];
    xnew[0] += (-28.713783606978346)*Walking01_withElmos_B.TKA[0];
    xnew[1] = (0.63594626071947924)*
      Walking01_withElmos_DW.DiscreteStateSpace_DSTATE[0]
      + (-0.20017592633062919)*Walking01_withElmos_DW.DiscreteStateSpace_DSTATE
      [1]
      + (0.37218968207880138)*Walking01_withElmos_DW.DiscreteStateSpace_DSTATE[2]
      + (-0.15006598182651554)*Walking01_withElmos_DW.DiscreteStateSpace_DSTATE
      [3];
    xnew[1] += (24.40463328262317)*Walking01_withElmos_B.TKA[0];
    xnew[2] = (-0.1223434473294493)*
      Walking01_withElmos_DW.DiscreteStateSpace_DSTATE[0]
      + (-0.372189682078801)*Walking01_withElmos_DW.DiscreteStateSpace_DSTATE[1]
      + (-0.76419956064117567)*Walking01_withElmos_DW.DiscreteStateSpace_DSTATE
      [2]
      + (-0.16574841449649924)*Walking01_withElmos_DW.DiscreteStateSpace_DSTATE
      [3];
    xnew[2] += (12.020156246194285)*Walking01_withElmos_B.TKA[0];
    xnew[3] = (-0.10940573180179754)*
      Walking01_withElmos_DW.DiscreteStateSpace_DSTATE[0]
      + (-0.15006598182651545)*Walking01_withElmos_DW.DiscreteStateSpace_DSTATE
      [1]
      + (0.16574841449649974)*Walking01_withElmos_DW.DiscreteStateSpace_DSTATE[2]
      + (0.50133282303432036)*Walking01_withElmos_DW.DiscreteStateSpace_DSTATE[3];
    xnew[3] += (1.3967204886477269)*Walking01_withElmos_B.TKA[0];
    (void) memcpy(&Walking01_withElmos_DW.DiscreteStateSpace_DSTATE[0], xnew,
                  sizeof(real_T)*4);
  }

  /* Update for DiscreteStateSpace: '<S214>/Discrete State-Space1' */
  {
    real_T xnew[4];
    xnew[0] = (0.46304266393748467)*
      Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE[0]
      + (-0.63594626071947846)*
      Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE[1]
      + (-0.12234344732945052)*
      Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE[2]
      + (0.1094057318017978)*Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE[3];
    xnew[0] += (-28.713783606978346)*Walking01_withElmos_B.TKA[1];
    xnew[1] = (0.63594626071947924)*
      Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE[0]
      + (-0.20017592633062919)*
      Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE[1]
      + (0.37218968207880138)*Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE
      [2]
      + (-0.15006598182651554)*
      Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE[3];
    xnew[1] += (24.40463328262317)*Walking01_withElmos_B.TKA[1];
    xnew[2] = (-0.1223434473294493)*
      Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE[0]
      + (-0.372189682078801)*Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE[1]
      + (-0.76419956064117567)*
      Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE[2]
      + (-0.16574841449649924)*
      Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE[3];
    xnew[2] += (12.020156246194285)*Walking01_withElmos_B.TKA[1];
    xnew[3] = (-0.10940573180179754)*
      Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE[0]
      + (-0.15006598182651545)*
      Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE[1]
      + (0.16574841449649974)*Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE
      [2]
      + (0.50133282303432036)*Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE
      [3];
    xnew[3] += (1.3967204886477269)*Walking01_withElmos_B.TKA[1];
    (void) memcpy(&Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE[0], xnew,
                  sizeof(real_T)*4);
  }

  /* Update for UnitDelay: '<S212>/Delay Input1' */
  Walking01_withElmos_DW.DelayInput1_DSTATE = Walking01_withElmos_B.Compare;

  /* Update for UnitDelay: '<S213>/Delay Input1' */
  Walking01_withElmos_DW.DelayInput1_DSTATE_c = Walking01_withElmos_B.Compare_l;

  /* Update for UnitDelay: '<S200>/Unit Delay' */
  Walking01_withElmos_DW.UnitDelay_DSTATE_d = Walking01_withElmos_B.s;

  /* Update for UnitDelay: '<S200>/Unit Delay1' */
  Walking01_withElmos_DW.UnitDelay1_DSTATE_g = Walking01_withElmos_B.ErrorCount;

  /* Update for DiscreteFilter: '<S21>/Discrete Filter' */
  memcpy(&Walking01_withElmos_DW.DiscreteFilter_states[0],
         &Walking01_withElmos_DW.DiscreteFilter_tmp[0], 30U * sizeof(real_T));

  /* Update for UnitDelay: '<S1>/Unit Delay' */
  Walking01_withElmos_DW.UnitDelay_DSTATE_k =
    Walking01_withElmos_B.SafetyCountOut;

  /* Update for UnitDelay: '<S1>/Unit Delay1' */
  Walking01_withElmos_DW.UnitDelay1_DSTATE_h[0] =
    Walking01_withElmos_B.sf_Chart.FaultDetected;
  Walking01_withElmos_DW.UnitDelay1_DSTATE_h[1] =
    Walking01_withElmos_B.sf_Chart_b.FaultDetected;
  Walking01_withElmos_DW.UnitDelay1_DSTATE_h[2] =
    Walking01_withElmos_B.FaultDetected_n;
  Walking01_withElmos_DW.UnitDelay1_DSTATE_h[3] =
    Walking01_withElmos_B.FaultDetected;

  /* Update for Delay: '<S4>/Resettable Delay' */
  Walking01_withElmos_DW.icLoad = 0U;
  Walking01_withElmos_DW.ResettableDelay_DSTATE = Walking01_withElmos_B.Bias;

  /* Update absolute time */
  /* The "clockTick0" counts the number of times the code of this task has
   * been executed. The absolute time is the multiplication of "clockTick0"
   * and "Timing.stepSize0". Size of "clockTick0" ensures timer will not
   * overflow during the application lifespan selected.
   * Timer of this task consists of two 32 bit unsigned integers.
   * The two integers represent the low bits Timing.clockTick0 and the high bits
   * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment.
   */
  if (!(++Walking01_withElmos_M->Timing.clockTick0)) {
    ++Walking01_withElmos_M->Timing.clockTickH0;
  }

  Walking01_withElmos_M->Timing.t[0] = Walking01_withElmos_M->Timing.clockTick0 *
    Walking01_withElmos_M->Timing.stepSize0 +
    Walking01_withElmos_M->Timing.clockTickH0 *
    Walking01_withElmos_M->Timing.stepSize0 * 4294967296.0;
}

/* Model output function for TID1 */
void Walking01_withElmos_output1(void) /* Sample time: [0.001s, 0.0s] */
{
  /* local block i/o variables */
  real_T rtb_UnitDelay2_i[9];
  real_T rtb_UnitDelay1_m[2];
  real_T rtb_Reshape_d[9];
  real_T rtb_Assignment1[2];
  real_T rtb_OutportBufferForAcceleratio[3];
  real_T rtb_OutportBufferForDeltaAngle[3];
  real_T rtb_OutportBufferForRk[9];
  real_T rtb_OutportBufferForTemperature;
  real_T rtb_OutportBufferForwk[3];
  boolean_T rtb_LogicalOperator_j;
  boolean_T rtb_EnableFT;
  boolean_T y;
  boolean_T x[4];
  uint32_T D32[9];
  uint32_T remainderPolynomial;
  int32_T nextbit;
  uint32_T Utmp1[36];
  uint32_T Stmp1[12];
  uint32_T Stmp2[3];
  real32_T Stmp3[3];
  real32_T b_Stmp3[3];
  boolean_T exitg1;
  real_T Seqk;
  boolean_T GyroValid;
  real_T n;
  real_T w[3];
  real_T x_0;
  real_T b_x;
  int8_T I[9];
  static const int8_T b_a[9] = { 1, 0, 0, 0, 1, 0, 0, 0, 1 };

  int32_T rtb_DataTypeConversion2_l;
  real_T rtb_Assignment[2];
  int32_T rtb_DataTypeConversion;
  int32_T s194_iter;
  uint8_T rtb_DataTypeConversion1_k;
  real_T tmp[9];
  real_T w_0[9];
  real_T b_a_0[9];
  int32_T i;
  uint64_T tmp_0;
  uint16_T tmp_1;
  uint32_T Utmp1_0;
  uint32_T Utmp1_1;

  /* Outputs for Atomic SubSystem: '<S5>/SerialInterfaces' */

  /* Level2 S-Function Block: '<S193>/Board Setup' (board_setup_tews_XR17D15x) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[2];
    sfcnOutputs(rts, 1);
  }

  /* Level2 S-Function Block: '<S193>/Setup3' (setup_tews_XR17D15x) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[3];
    sfcnOutputs(rts, 1);
  }

  /* Level2 S-Function Block: '<S193>/Read HW FIFO' (read_hw_fifo_XR17D15x) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[4];
    sfcnOutputs(rts, 1);
  }

  /* Level2 S-Function Block: '<S193>/FIFO write 1' (fifowrite) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[5];
    sfcnOutputs(rts, 1);
  }

  /* Outputs for Iterator SubSystem: '<S124>/UpdateOrientation' incorporates:
   *  ForIterator: '<S194>/For Iterator'
   */
  for (s194_iter = 0; s194_iter < 2; s194_iter++) {
    /* Level2 S-Function Block: '<S194>/FIFO bin read ' (fiforeadbinhdrmultiple) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[1];
      sfcnOutputs(rts, 1);
    }

    /* MATLAB Function: '<S194>/MATLAB Function' */
    /* MATLAB Function 'DAQ_WITH_SAFETY_IMU/DAQ/SerialInterfaces/KVH/UpdateOrientation/MATLAB Function': '<S196>:1' */
    /* '<S196>:1:3' CMD = [254; 129; 255; 85]; */
    /* hex2dec(['FE';'81';'FF';'55']); */
    /* '<S196>:1:5' Valid = false; */
    GyroValid = false;

    /* '<S196>:1:6' if all(P(1:4) == CMD) */
    x[0] = (Walking01_withElmos_B.FIFObinread[1] == 254U);
    x[1] = (Walking01_withElmos_B.FIFObinread[2] == 129U);
    x[2] = (Walking01_withElmos_B.FIFObinread[3] == 255U);
    x[3] = (Walking01_withElmos_B.FIFObinread[4] == 85U);
    y = true;
    rtb_DataTypeConversion2_l = 0;
    exitg1 = false;
    while ((!exitg1) && (rtb_DataTypeConversion2_l < 4)) {
      if (x[rtb_DataTypeConversion2_l] == 0) {
        y = false;
        exitg1 = true;
      } else {
        rtb_DataTypeConversion2_l++;
      }
    }

    if (y) {
      /* '<S196>:1:7' Valid = kvhCheckCRC(P(1:36)); */
      /*  Loosely based on Code Fragment 3 from */
      /*  http://en.wikipedia.org/wiki/Computation_of_cyclic_redundancy_checks */
      /* 'kvhCheckCRC:6' D32 = parseUint32(D0); */
      /* 'kvhCheckCRC:32' Utmp1 = uint32(reshape(D,4,[])); */
      memcpy(&Utmp1[0], &Walking01_withElmos_B.FIFObinread[1], 36U * sizeof
             (uint32_T));

      /* 'kvhCheckCRC:33' Utmp2 = 16777216*Utmp1(1,:) + 65536*Utmp1(2,:) + 256*Utmp1(3,:) + Utmp1(4,:); */
      /* 'kvhCheckCRC:34' U = Utmp2'; */
      for (nextbit = 0; nextbit < 9; nextbit++) {
        if (Utmp1[nextbit << 2] > 255U) {
          Utmp1_0 = MAX_uint32_T;
        } else {
          Utmp1_0 = Utmp1[nextbit << 2] << 24;
        }

        if (Utmp1[(nextbit << 2) + 1] > 65535U) {
          Utmp1_1 = MAX_uint32_T;
        } else {
          Utmp1_1 = Utmp1[(nextbit << 2) + 1] << 16;
        }

        tmp_0 = (uint64_T)Utmp1_0 + Utmp1_1;
        if (tmp_0 > 4294967295ULL) {
          tmp_0 = 4294967295ULL;
        }

        if (Utmp1[(nextbit << 2) + 2] > 16777215U) {
          Utmp1_0 = MAX_uint32_T;
        } else {
          Utmp1_0 = Utmp1[(nextbit << 2) + 2] << 8;
        }

        tmp_0 = (uint64_T)(uint32_T)tmp_0 + Utmp1_0;
        if (tmp_0 > 4294967295ULL) {
          tmp_0 = 4294967295ULL;
        }

        tmp_0 = (uint64_T)Utmp1[(nextbit << 2) + 3] + (uint32_T)tmp_0;
        if (tmp_0 > 4294967295ULL) {
          tmp_0 = 4294967295ULL;
        }

        D32[nextbit] = (uint32_T)tmp_0;
      }

      /* 'kvhCheckCRC:7' receivedCRC = D32(9); */
      /* 'kvhCheckCRC:8' D32(9) = uint32(0); */
      D32[8] = 0U;

      /* 'kvhCheckCRC:10' generatorPolynomial = uint32(79764919); */
      /*  0x04C11DB7 */
      /* 'kvhCheckCRC:11' xorIn               = uint32(4294967295); */
      /*  0xFFFFFFFF */
      /*  XOR IN = 0xFFFFFFFF */
      /* 'kvhCheckCRC:14' remainderPolynomial = bitxor(D32(1), xorIn); */
      remainderPolynomial = D32[0] ^ MAX_uint32_T;

      /* 'kvhCheckCRC:16' for k=2:9 */
      for (rtb_DataTypeConversion2_l = 0; rtb_DataTypeConversion2_l < 8;
           rtb_DataTypeConversion2_l++) {
        /* 'kvhCheckCRC:17' for l=32:-1:1 */
        for (rtb_DataTypeConversion = 0; rtb_DataTypeConversion < 32;
             rtb_DataTypeConversion++) {
          /* 'kvhCheckCRC:18' nextbit = bitget(D32(k),l); */
          nextbit = ((1U << (31 - rtb_DataTypeConversion) &
                      D32[rtb_DataTypeConversion2_l + 1]) != 0U);

          /* 'kvhCheckCRC:19' if bitget(remainderPolynomial,32) */
          if ((remainderPolynomial & 2147483648U) != 0U) {
            /*  coefficient of xn-1 of remainderPolynomial = 1 */
            /* 'kvhCheckCRC:20' remainderPolynomial = bitxor(bitshift(remainderPolynomial,1)+nextbit, generatorPolynomial); */
            tmp_0 = (uint64_T)(remainderPolynomial << 1U) + nextbit;
            if (tmp_0 > 4294967295ULL) {
              tmp_0 = 4294967295ULL;
            }

            remainderPolynomial = (uint32_T)tmp_0 ^ 79764919U;
          } else {
            /* 'kvhCheckCRC:21' else */
            /* 'kvhCheckCRC:22' remainderPolynomial = bitshift(remainderPolynomial,1)+nextbit; */
            tmp_0 = (uint64_T)(remainderPolynomial << 1U) + nextbit;
            if (tmp_0 > 4294967295ULL) {
              tmp_0 = 4294967295ULL;
            }

            remainderPolynomial = (uint32_T)tmp_0;
          }
        }
      }

      /*  COMPARE */
      /* 'kvhCheckCRC:28' valid = ~bitxor(remainderPolynomial, receivedCRC); */
      if (Utmp1[32] > 255U) {
        Utmp1_0 = MAX_uint32_T;
      } else {
        Utmp1_0 = Utmp1[32] << 24;
      }

      if (Utmp1[33] > 65535U) {
        Utmp1_1 = MAX_uint32_T;
      } else {
        Utmp1_1 = Utmp1[33] << 16;
      }

      tmp_0 = (uint64_T)Utmp1_0 + Utmp1_1;
      if (tmp_0 > 4294967295ULL) {
        tmp_0 = 4294967295ULL;
      }

      if (Utmp1[34] > 16777215U) {
        Utmp1_0 = MAX_uint32_T;
      } else {
        Utmp1_0 = Utmp1[34] << 8;
      }

      tmp_0 = (uint64_T)(uint32_T)tmp_0 + Utmp1_0;
      if (tmp_0 > 4294967295ULL) {
        tmp_0 = 4294967295ULL;
      }

      tmp_0 = (uint64_T)(uint32_T)tmp_0 + Utmp1[35];
      if (tmp_0 > 4294967295ULL) {
        tmp_0 = 4294967295ULL;
      }

      GyroValid = !((remainderPolynomial ^ (uint32_T)tmp_0) != 0U);
    }

    /* '<S196>:1:10' Rotation = parseSingle(P(5:16,:)); */
    /* '<S196>:1:18' Stmp1 = uint32(reshape(D,4,[])); */
    for (rtb_DataTypeConversion2_l = 0; rtb_DataTypeConversion2_l < 12;
         rtb_DataTypeConversion2_l++) {
      Stmp1[rtb_DataTypeConversion2_l] = Walking01_withElmos_B.FIFObinread[5 +
        rtb_DataTypeConversion2_l];
    }

    /* '<S196>:1:19' Stmp2 = 16777216*Stmp1(1,:) + 65536*Stmp1(2,:) + 256*Stmp1(3,:) + Stmp1(4,:); */
    if (Stmp1[0] > 255U) {
      remainderPolynomial = MAX_uint32_T;
    } else {
      remainderPolynomial = Stmp1[0] << 24;
    }

    if (Stmp1[1] > 65535U) {
      Utmp1_0 = MAX_uint32_T;
    } else {
      Utmp1_0 = Stmp1[1] << 16;
    }

    tmp_0 = (uint64_T)remainderPolynomial + Utmp1_0;
    if (tmp_0 > 4294967295ULL) {
      tmp_0 = 4294967295ULL;
    }

    if (Stmp1[2] > 16777215U) {
      remainderPolynomial = MAX_uint32_T;
    } else {
      remainderPolynomial = Stmp1[2] << 8;
    }

    tmp_0 = (uint64_T)(uint32_T)tmp_0 + remainderPolynomial;
    if (tmp_0 > 4294967295ULL) {
      tmp_0 = 4294967295ULL;
    }

    tmp_0 = (uint64_T)(uint32_T)tmp_0 + Stmp1[3];
    if (tmp_0 > 4294967295ULL) {
      tmp_0 = 4294967295ULL;
    }

    Stmp2[0] = (uint32_T)tmp_0;
    if (Stmp1[4] > 255U) {
      remainderPolynomial = MAX_uint32_T;
    } else {
      remainderPolynomial = Stmp1[4] << 24;
    }

    if (Stmp1[5] > 65535U) {
      Utmp1_0 = MAX_uint32_T;
    } else {
      Utmp1_0 = Stmp1[5] << 16;
    }

    tmp_0 = (uint64_T)remainderPolynomial + Utmp1_0;
    if (tmp_0 > 4294967295ULL) {
      tmp_0 = 4294967295ULL;
    }

    if (Stmp1[6] > 16777215U) {
      remainderPolynomial = MAX_uint32_T;
    } else {
      remainderPolynomial = Stmp1[6] << 8;
    }

    tmp_0 = (uint64_T)(uint32_T)tmp_0 + remainderPolynomial;
    if (tmp_0 > 4294967295ULL) {
      tmp_0 = 4294967295ULL;
    }

    tmp_0 = (uint64_T)(uint32_T)tmp_0 + Stmp1[7];
    if (tmp_0 > 4294967295ULL) {
      tmp_0 = 4294967295ULL;
    }

    Stmp2[1] = (uint32_T)tmp_0;
    if (Stmp1[8] > 255U) {
      remainderPolynomial = MAX_uint32_T;
    } else {
      remainderPolynomial = Stmp1[8] << 24;
    }

    if (Stmp1[9] > 65535U) {
      Utmp1_0 = MAX_uint32_T;
    } else {
      Utmp1_0 = Stmp1[9] << 16;
    }

    tmp_0 = (uint64_T)remainderPolynomial + Utmp1_0;
    if (tmp_0 > 4294967295ULL) {
      tmp_0 = 4294967295ULL;
    }

    if (Stmp1[10] > 16777215U) {
      remainderPolynomial = MAX_uint32_T;
    } else {
      remainderPolynomial = Stmp1[10] << 8;
    }

    tmp_0 = (uint64_T)(uint32_T)tmp_0 + remainderPolynomial;
    if (tmp_0 > 4294967295ULL) {
      tmp_0 = 4294967295ULL;
    }

    tmp_0 = (uint64_T)(uint32_T)tmp_0 + Stmp1[11];
    if (tmp_0 > 4294967295ULL) {
      tmp_0 = 4294967295ULL;
    }

    Stmp2[2] = (uint32_T)tmp_0;

    /* '<S196>:1:20' Stmp3 = typecast(Stmp2,'single'); */
    memcpy(&Stmp3[0], &Stmp2[0], (size_t)3 * sizeof(real32_T));

    /* '<S196>:1:21' S = double(Stmp3'); */
    /* '<S196>:1:11' Acceleration = parseSingle(P(17:28,:)); */
    /* '<S196>:1:18' Stmp1 = uint32(reshape(D,4,[])); */
    for (rtb_DataTypeConversion2_l = 0; rtb_DataTypeConversion2_l < 12;
         rtb_DataTypeConversion2_l++) {
      Stmp1[rtb_DataTypeConversion2_l] = Walking01_withElmos_B.FIFObinread[17 +
        rtb_DataTypeConversion2_l];
    }

    /* '<S196>:1:19' Stmp2 = 16777216*Stmp1(1,:) + 65536*Stmp1(2,:) + 256*Stmp1(3,:) + Stmp1(4,:); */
    if (Stmp1[0] > 255U) {
      remainderPolynomial = MAX_uint32_T;
    } else {
      remainderPolynomial = Stmp1[0] << 24;
    }

    if (Stmp1[1] > 65535U) {
      Utmp1_0 = MAX_uint32_T;
    } else {
      Utmp1_0 = Stmp1[1] << 16;
    }

    tmp_0 = (uint64_T)remainderPolynomial + Utmp1_0;
    if (tmp_0 > 4294967295ULL) {
      tmp_0 = 4294967295ULL;
    }

    if (Stmp1[2] > 16777215U) {
      remainderPolynomial = MAX_uint32_T;
    } else {
      remainderPolynomial = Stmp1[2] << 8;
    }

    tmp_0 = (uint64_T)(uint32_T)tmp_0 + remainderPolynomial;
    if (tmp_0 > 4294967295ULL) {
      tmp_0 = 4294967295ULL;
    }

    tmp_0 = (uint64_T)(uint32_T)tmp_0 + Stmp1[3];
    if (tmp_0 > 4294967295ULL) {
      tmp_0 = 4294967295ULL;
    }

    Stmp2[0] = (uint32_T)tmp_0;
    if (Stmp1[4] > 255U) {
      remainderPolynomial = MAX_uint32_T;
    } else {
      remainderPolynomial = Stmp1[4] << 24;
    }

    if (Stmp1[5] > 65535U) {
      Utmp1_0 = MAX_uint32_T;
    } else {
      Utmp1_0 = Stmp1[5] << 16;
    }

    tmp_0 = (uint64_T)remainderPolynomial + Utmp1_0;
    if (tmp_0 > 4294967295ULL) {
      tmp_0 = 4294967295ULL;
    }

    if (Stmp1[6] > 16777215U) {
      remainderPolynomial = MAX_uint32_T;
    } else {
      remainderPolynomial = Stmp1[6] << 8;
    }

    tmp_0 = (uint64_T)(uint32_T)tmp_0 + remainderPolynomial;
    if (tmp_0 > 4294967295ULL) {
      tmp_0 = 4294967295ULL;
    }

    tmp_0 = (uint64_T)(uint32_T)tmp_0 + Stmp1[7];
    if (tmp_0 > 4294967295ULL) {
      tmp_0 = 4294967295ULL;
    }

    Stmp2[1] = (uint32_T)tmp_0;
    if (Stmp1[8] > 255U) {
      remainderPolynomial = MAX_uint32_T;
    } else {
      remainderPolynomial = Stmp1[8] << 24;
    }

    if (Stmp1[9] > 65535U) {
      Utmp1_0 = MAX_uint32_T;
    } else {
      Utmp1_0 = Stmp1[9] << 16;
    }

    tmp_0 = (uint64_T)remainderPolynomial + Utmp1_0;
    if (tmp_0 > 4294967295ULL) {
      tmp_0 = 4294967295ULL;
    }

    if (Stmp1[10] > 16777215U) {
      remainderPolynomial = MAX_uint32_T;
    } else {
      remainderPolynomial = Stmp1[10] << 8;
    }

    tmp_0 = (uint64_T)(uint32_T)tmp_0 + remainderPolynomial;
    if (tmp_0 > 4294967295ULL) {
      tmp_0 = 4294967295ULL;
    }

    tmp_0 = (uint64_T)(uint32_T)tmp_0 + Stmp1[11];
    if (tmp_0 > 4294967295ULL) {
      tmp_0 = 4294967295ULL;
    }

    Stmp2[2] = (uint32_T)tmp_0;

    /* '<S196>:1:20' Stmp3 = typecast(Stmp2,'single'); */
    memcpy(&b_Stmp3[0], &Stmp2[0], (size_t)3 * sizeof(real32_T));

    /* '<S196>:1:21' S = double(Stmp3'); */
    /* '<S196>:1:12' Status = P(29); */
    /* '<S196>:1:13' Sequence = double(P(30)); */
    /* '<S196>:1:14' Temperature = parseInt16(P(31:32)); */
    /* '<S196>:1:25' Stmp1 = uint16(reshape(D,2,[])); */
    remainderPolynomial = Walking01_withElmos_B.FIFObinread[31];
    if (Walking01_withElmos_B.FIFObinread[31] > 65535U) {
      remainderPolynomial = 65535U;
    }

    Utmp1_0 = Walking01_withElmos_B.FIFObinread[32];
    if (Walking01_withElmos_B.FIFObinread[32] > 65535U) {
      Utmp1_0 = 65535U;
    }

    /* '<S196>:1:26' Stmp2 = 256*Stmp1(1,:) + Stmp1(2,:); */
    /* '<S196>:1:27' S = double(Stmp2'); */
    rtb_OutportBufferForDeltaAngle[0] = Stmp3[0];
    rtb_OutportBufferForDeltaAngle[1] = Stmp3[1];
    rtb_OutportBufferForDeltaAngle[2] = Stmp3[2];
    rtb_OutportBufferForAcceleratio[0] = b_Stmp3[0];
    rtb_OutportBufferForAcceleratio[1] = b_Stmp3[1];
    rtb_OutportBufferForAcceleratio[2] = b_Stmp3[2];

    /* Assignment: '<S194>/Assignment' incorporates:
     *  Constant: '<S194>/Constant'
     *  MATLAB Function: '<S194>/MATLAB Function'
     */
    if (s194_iter == 0) {
      rtb_Assignment[0] = 0.0;
      rtb_Assignment[1] = 0.0;
    }

    rtb_Assignment[s194_iter] = Walking01_withElmos_B.FIFObinread[30];

    /* End of Assignment: '<S194>/Assignment' */

    /* Assignment: '<S194>/Assignment1' incorporates:
     *  Constant: '<S194>/Constant2'
     *  DataTypeConversion: '<S194>/Data Type Conversion3'
     */
    if (s194_iter == 0) {
      rtb_Assignment1[0] = 0.0;
      rtb_Assignment1[1] = 0.0;
    }

    rtb_Assignment1[s194_iter] = Walking01_withElmos_B.FIFObinread[0];

    /* End of Assignment: '<S194>/Assignment1' */

    /* DataTypeConversion: '<S194>/Data Type Conversion' incorporates:
     *  MATLAB Function: '<S194>/MATLAB Function'
     */
    rtb_DataTypeConversion = GyroValid;

    /* DataTypeConversion: '<S194>/Data Type Conversion1' incorporates:
     *  MATLAB Function: '<S194>/MATLAB Function'
     */
    rtb_DataTypeConversion1_k = (uint8_T)Walking01_withElmos_B.FIFObinread[29];

    /* DataTypeConversion: '<S194>/Data Type Conversion2' */
    rtb_DataTypeConversion2_l = rtb_DataTypeConversion1_k;

    /* MATLAB Function: '<S194>/EstimateOrientation' incorporates:
     *  UnitDelay: '<S194>/Unit Delay1'
     *  UnitDelay: '<S194>/Unit Delay3'
     */
    /* MATLAB Function 'DAQ_WITH_SAFETY_IMU/DAQ/SerialInterfaces/KVH/UpdateOrientation/EstimateOrientation': '<S195>:1' */
    /* '<S195>:1:2' [Rk, wk, Ak, Seqk] = estimateOrientation(DeltaAngle,Acceleration,Rkm1,wkm1,Akm1,Status,Sequence,Seqkm1,Reset); */
    /*  Estimate the rotation matrix Rk representing the orientation of the */
    /*  IMU with respect to the world at the current time step (step k). */
    /*  */
    /*  Inputs: */
    /*    DeltaAngle: a rotation vector (i.e., a vector whose direction */
    /*    coincides with the axis of rotation and whose magnitude is the */
    /*    rotation angle in radians). */
    /*  */
    /*    Acceleration: IMU-measured acceleration */
    /*  */
    /*    Rkm1: This should be the last value Rk returned from this function. */
    /*    The initial value is ignored as long as (Reset) is true the first */
    /*    time this function is called. */
    /*  */
    /*    wk: This should be the last value wk returned from this function. */
    /*    The initial value can safely be [0; 0; 0] if the robot is at rest */
    /*    initially (or when (Reset) is deasserted). */
    /*  */
    /*    Akm1: This should be the last value Ak returned from this function. */
    /*    The initial value can be either [0; 0; 0] or the initial */
    /*    Acceleration (these yield equivalent results). */
    /*  */
    /*    Status: An 8-bit integer corresponding to the KVH IMU status byte. */
    /*    When the packet CRC fails, this input should be zero. */
    /*  */
    /*    Sequence: Message counter sent by the IMU. This starts at 0 and */
    /*    increments by 1 with each packet sent, up to 127, at which point it */
    /*    rolls over. */
    /*  */
    /*    Seqkm1: Previous Sequence input. */
    /*  */
    /*    Reset: When (Reset) is true, the rotation matrix */
    /*    Rk is computed by assuming the IMU is stationary so that the */
    /*    measured Acceleration is opposite the direction the gravitational */
    /*    force. When (Reset) is true, the acceleration is not used, and the */
    /*    rotation matrix Rk is computed by accumulating DeltaAngle */
    /*    rotations. */
    /*  */
    /*  Outputs: */
    /*  */
    /*    Rk: Orientation matrix representing the current orientation of the */
    /*    IMU with respect to the world frame. Note that when represented */
    /*    with ZYX Euler angles, the initial yaw (i.e., the yaw at when the */
    /*    (Reset) input drops to 0) is arbitrary. If it is desired to have */
    /*    zero yaw in that configuration, this should be handled outside this */
    /*    function. */
    /*  */
    /*    wk: Estimated angular velocity in the IMU frame */
    /*  */
    /*    Ak: The filtered acceleration estimate. This value is only used */
    /*    when (Reset) is true. */
    /*  */
    /*    Seqk: Last valid Sequence number seen. */
    /*  */
    /*  The initial orientation estimate is computed by assuming the robot is */
    /*  stationary in the world frame, so that the measured acceleration is */
    /*  simply due to the gravitational force. When the IMU is upright on a */
    /*  horizontal surface, the measured acceleration (in g's) is roughly */
    /*    Acceleration = [0; 0; 1] */
    /*  When the IMU is at rest in another configuration, the measured */
    /*  Acceleration will be some other unit vector. There is not a unique */
    /*  rotation matrix which maps the measured Acceleration into the world */
    /*  frame z-axis, since any subsequent rotation about the z-axis would */
    /*  leave the Acceleration aligned with the vertical. To account for this */
    /*  non-uniqueness, we represent the initial orientation not with a */
    /*  rotation matrix but with a unit length vector in R^3 (i.e., a point */
    /*  on the 2-sphere S^2). */
    /*  */
    /*  We will compute the initial orientation estimate by filtering the */
    /*  Acceleration when (Reset==1). In order to derive the filter we need */
    /*  to know how to combine points on the 2-sphere in a meaningful way. It */
    /*  turns out that, given a set of points x1, x2, ..., xn in S^2, the */
    /*  normalized sum */
    /*    xhat = (x1 + x2 + ... + xn)/||x1 + x2 + ... + xn|| */
    /*  is another point on the 2-sphere which maximizes the sum of the */
    /*  cosines of the angles between xhat and each xi, i=1,...,n, which is */
    /*  roughly equivalent to minimizing the sum of the angles between xhat */
    /*  and each xi, i=1,...,n. We can also use a weighted sum. Thus it is */
    /*  straightforward to implement a filter on S^2; we need only augment */
    /*  the standard filter with a normalization of the result. */
    /*  */
    /*  Note that the average is well defined only if */
    /*    (x1 + x2 + ... + xn) ~= 0. */
    /*  For the "one-pole filter" used below, assuming */
    /*  (accelFilterAlpha~=0.5), the weighted sum can only be zero if */
    /*  (Acceleration==0) and (Akm1==0). Since (Reset) should be true only */
    /*  when the robot is stationary, we should never have (Acceleration==0). */
    /*  In any case, we guard against the unlikely possibility by checking */
    /*  for zero Acceleration. */
    /*  */
    /*  To compute a rotation matrix which maps a unit vector x1 to the */
    /*  z-axis, we have many choices. For example, we could compute an axis */
    /*  of rotation by taking the cross product between x1 and unit z-vector. */
    /*  Then we have to compute the rotation angle and finally compute the */
    /*  rotation matrix equivalent to this axis-angle representation. If the */
    /*  original unit vector x1 is already aligned with the z-axis, this */
    /*  method cannot be used (in this case the rotation matrix can be taken */
    /*  as the identity; however, we have to choose a tolerance for */
    /*  determining if the two vectors are aligned). A better choice is */
    /*  rotate 180 degrees around an axis half way between x1 and the z-axis. */
    /*  We can easily compute the axis of rotation w as the normalized sum */
    /*    w = (x1+zhat)/||x1+zhat||. */
    /*  The matrix associated with this rotation is */
    /*    R = 2 w*w^T - I. */
    /*  */
    /*  After the initial estimate is computed, we simply update the current */
    /*  estimate by a group operation using the IMU-derived DeltaAngle. Thus */
    /*  we convert DeltaAngle to a rotation matrix R and update R(k) from */
    /*  R(k-1) as */
    /*    Rk = Rkm1 * R */
    /* 'estimateOrientation:114' DT = 0.001; */
    /*  SAMPLE TIME USED TO ESTIMATE ANGULAR VELOCITY wk */
    /* 'estimateOrientation:115' accelFilterAlpha = 0.98; */
    /* 'estimateOrientation:117' Rk = Rkm1; */
    memcpy(&rtb_OutportBufferForRk[0],
           &Walking01_withElmos_DW.UnitDelay1_DSTATE_l[0], 9U * sizeof(real_T));

    /* 'estimateOrientation:118' Ak = Akm1; */
    /* 'estimateOrientation:119' Seqk = Seqkm1; */
    Seqk = Walking01_withElmos_DW.UnitDelay3_DSTATE_j;

    /* Switch: '<S194>/Switch' incorporates:
     *  Constant: '<S194>/Constant1'
     *  MATLAB Function: '<S194>/MATLAB Function'
     */
    /*  Mask the status byte to get accelerometer and gyro status. For now we */
    /*  just ignore invalid data. */
    /* 'estimateOrientation:123' Status = bitxor(Status, uint8(119)); */
    if (!GyroValid) {
      rtb_DataTypeConversion1_k = ((uint8_T)0U);
    }

    /* End of Switch: '<S194>/Switch' */

    /* MATLAB Function: '<S194>/EstimateOrientation' incorporates:
     *  MATLAB Function: '<S194>/MATLAB Function'
     *  UnitDelay: '<S194>/Unit Delay'
     *  UnitDelay: '<S194>/Unit Delay1'
     *  UnitDelay: '<S194>/Unit Delay3'
     */
    rtb_DataTypeConversion1_k ^= 119U;

    /*  invert so '0' means valid */
    /* 'estimateOrientation:124' AccelValid = ~bitand(Status, uint8(112)); */
    /* 'estimateOrientation:125' GyroValid  = ~bitand(Status, uint8(7)); */
    GyroValid = !((rtb_DataTypeConversion1_k & 7) != 0);

    /* 'estimateOrientation:126' SequenceValid = (Sequence>=0 && Sequence<127); */
    /*     %% Estimate angular velocity */
    /* 'estimateOrientation:129' if (GyroValid) */
    if (GyroValid) {
      /* 'estimateOrientation:130' wk = DeltaAngle/DT; */
      Walking01_withElmos_DW.UnitDelay2_DSTATE_p[0] =
        rtb_OutportBufferForDeltaAngle[0] / 0.001;
      Walking01_withElmos_DW.UnitDelay2_DSTATE_p[1] =
        rtb_OutportBufferForDeltaAngle[1] / 0.001;
      Walking01_withElmos_DW.UnitDelay2_DSTATE_p[2] =
        rtb_OutportBufferForDeltaAngle[2] / 0.001;
    } else {
      /* 'estimateOrientation:131' else */
      /* 'estimateOrientation:132' wk = wkm1; */
    }

    /* 'estimateOrientation:136' if (Reset && AccelValid) */
    if (Walking01_withElmos_B.RateTransition3 && (!((rtb_DataTypeConversion1_k &
           112) != 0))) {
      /*         %% Compute initial orientation estimate (modulo yaw) */
      /*  Normalize to ensure Acceleration lies on the 2-sphere S^2 */
      /* 'estimateOrientation:140' normAccel = norm(Acceleration); */
      n = Walking01_withElmos_norm(rtb_OutportBufferForAcceleratio);

      /* 'estimateOrientation:141' if (normAccel < 1e-8) */
      if (n < 1.0E-8) {
        /* 'estimateOrientation:142' Acceleration = [0; 0; 1]; */
        w[0] = 0.0;
        w[1] = 0.0;
        w[2] = 1.0;
      } else {
        /* 'estimateOrientation:143' else */
        /* 'estimateOrientation:144' Acceleration = Acceleration/normAccel; */
        w[0] = rtb_OutportBufferForAcceleratio[0] / n;
        w[1] = rtb_OutportBufferForAcceleratio[1] / n;
        w[2] = rtb_OutportBufferForAcceleratio[2] / n;
      }

      /*  First-order IIR filter with a pole at z=accelFilterAlpha */
      /* 'estimateOrientation:147' Ak = accelFilterAlpha*Akm1 + (1-accelFilterAlpha)*Acceleration; */
      Walking01_withElmos_DW.UnitDelay_DSTATE_p[0] = 0.98 *
        Walking01_withElmos_DW.UnitDelay_DSTATE_p[0] + 0.020000000000000018 * w
        [0];
      Walking01_withElmos_DW.UnitDelay_DSTATE_p[1] = 0.98 *
        Walking01_withElmos_DW.UnitDelay_DSTATE_p[1] + 0.020000000000000018 * w
        [1];
      Walking01_withElmos_DW.UnitDelay_DSTATE_p[2] = 0.98 *
        Walking01_withElmos_DW.UnitDelay_DSTATE_p[2] + 0.020000000000000018 * w
        [2];

      /*  Normalize to ensure Ak lies on the 2-sphere S^2 */
      /*  Assuming (accelFilterAlpha~=0.5), norm(Ak) should never be zero. */
      /* 'estimateOrientation:150' Ak = Ak/norm(Ak); */
      n = Walking01_withElmos_norm(Walking01_withElmos_DW.UnitDelay_DSTATE_p);
      Walking01_withElmos_DW.UnitDelay_DSTATE_p[0] /= n;
      Walking01_withElmos_DW.UnitDelay_DSTATE_p[1] /= n;
      Walking01_withElmos_DW.UnitDelay_DSTATE_p[2] /= n;

      /*  Compute the axis of rotation K and the rotation matrix Rk */
      /* 'estimateOrientation:153' K = Ak + [0; 0; 1]; */
      w[0] = Walking01_withElmos_DW.UnitDelay_DSTATE_p[0];
      w[1] = Walking01_withElmos_DW.UnitDelay_DSTATE_p[1];
      w[2] = Walking01_withElmos_DW.UnitDelay_DSTATE_p[2] + 1.0;

      /* 'estimateOrientation:154' K = K/norm(K); */
      n = Walking01_withElmos_norm(w);
      w[0] = Walking01_withElmos_DW.UnitDelay_DSTATE_p[0] / n;
      w[1] = Walking01_withElmos_DW.UnitDelay_DSTATE_p[1] / n;
      n = (Walking01_withElmos_DW.UnitDelay_DSTATE_p[2] + 1.0) / n;
      w[2] = n;

      /* 'estimateOrientation:155' Rk = 2*(K*K') - eye(3); */
      for (nextbit = 0; nextbit < 9; nextbit++) {
        I[nextbit] = 0;
      }

      I[0] = 1;
      I[4] = 1;
      I[8] = 1;
      for (nextbit = 0; nextbit < 3; nextbit++) {
        w_0[nextbit] = w[nextbit] * w[0];
        w_0[nextbit + 3] = w[nextbit] * w[1];
        w_0[nextbit + 6] = w[nextbit] * n;
      }

      for (nextbit = 0; nextbit < 3; nextbit++) {
        rtb_OutportBufferForRk[3 * nextbit] = w_0[3 * nextbit] * 2.0 - (real_T)
          I[3 * nextbit];
        rtb_OutportBufferForRk[1 + 3 * nextbit] = w_0[3 * nextbit + 1] * 2.0 -
          (real_T)I[3 * nextbit + 1];
        rtb_OutportBufferForRk[2 + 3 * nextbit] = w_0[3 * nextbit + 2] * 2.0 -
          (real_T)I[3 * nextbit + 2];
      }
    } else {
      if (GyroValid && (Walking01_withElmos_B.FIFObinread[30] < 127U)) {
        /* 'estimateOrientation:158' elseif (GyroValid && SequenceValid) */
        /*         %% Update orientation estimate */
        /*  If we missed (n-1) packets, we assume that the angular velocity */
        /*  is constant during that time period. This means the robot should */
        /*  have rotated n times as much as DeltaAngle indicates. If we don't */
        /*  miss any packets, then n = Sequence-Seqkm1 = 1 and we have */
        /*    theta = norm(DeltaAngle). */
        /* 'estimateOrientation:166' Seqk = Sequence; */
        Seqk = Walking01_withElmos_B.FIFObinread[30];

        /* 'estimateOrientation:167' n = Sequence-Seqkm1; */
        n = (real_T)Walking01_withElmos_B.FIFObinread[30] -
          Walking01_withElmos_DW.UnitDelay3_DSTATE_j;

        /* 'estimateOrientation:168' if (n<0) */
        if (n < 0.0) {
          /* 'estimateOrientation:169' n = n+128; */
          n += 128.0;
        }

        /* 'estimateOrientation:172' theta = n*norm(DeltaAngle); */
        n *= Walking01_withElmos_norm(rtb_OutportBufferForDeltaAngle);

        /* 'estimateOrientation:173' if (theta > 3e-8) */
        if (n > 3.0E-8) {
          /*  Avoid division by zero. The threshold 3e-8 (rad/ms) is */
          /*  slighly less than the angular velocity of the Earth on its */
          /*  axis, which is */
          /*    2*pi/(23*3600 + 56*60 + 04.09053)/1000 */
          /*      = 7.292115855377075e-08 (rad/ms) */
          /*  If the measured rotation is less than this, we ignore it. */
          /* 'estimateOrientation:180' w = DeltaAngle/theta; */
          w[0] = rtb_OutportBufferForDeltaAngle[0] / n;
          w[1] = rtb_OutportBufferForDeltaAngle[1] / n;
          w[2] = rtb_OutportBufferForDeltaAngle[2] / n;

          /* 'estimateOrientation:181' S = [0 -w(3) w(2); w(3) 0 -w(1); -w(2) w(1) 0]; */
          /* 'estimateOrientation:182' R = eye(3)*cos(theta) + S*sin(theta) + (1-cos(theta))*(w*w'); */
          x_0 = cos(n);
          b_x = sin(n);
          n = 1.0 - cos(n);

          /* 'estimateOrientation:183' Rk = Rkm1*R; */
          tmp[0] = 0.0;
          tmp[3] = -w[2];
          tmp[6] = w[1];
          tmp[1] = w[2];
          tmp[4] = 0.0;
          tmp[7] = -w[0];
          tmp[2] = -w[1];
          tmp[5] = w[0];
          tmp[8] = 0.0;
          for (nextbit = 0; nextbit < 3; nextbit++) {
            w_0[nextbit] = w[nextbit] * w[0];
            w_0[nextbit + 3] = w[nextbit] * w[1];
            w_0[nextbit + 6] = w[nextbit] * w[2];
          }

          for (nextbit = 0; nextbit < 3; nextbit++) {
            b_a_0[3 * nextbit] = ((real_T)b_a[3 * nextbit] * x_0 + tmp[3 *
                                  nextbit] * b_x) + w_0[3 * nextbit] * n;
            b_a_0[1 + 3 * nextbit] = ((real_T)b_a[3 * nextbit + 1] * x_0 + tmp[3
              * nextbit + 1] * b_x) + w_0[3 * nextbit + 1] * n;
            b_a_0[2 + 3 * nextbit] = ((real_T)b_a[3 * nextbit + 2] * x_0 + tmp[3
              * nextbit + 2] * b_x) + w_0[3 * nextbit + 2] * n;
          }

          for (nextbit = 0; nextbit < 3; nextbit++) {
            for (i = 0; i < 3; i++) {
              rtb_OutportBufferForRk[nextbit + 3 * i] = 0.0;
              rtb_OutportBufferForRk[nextbit + 3 * i] += b_a_0[3 * i] *
                Walking01_withElmos_DW.UnitDelay1_DSTATE_l[nextbit];
              rtb_OutportBufferForRk[nextbit + 3 * i] += b_a_0[3 * i + 1] *
                Walking01_withElmos_DW.UnitDelay1_DSTATE_l[nextbit + 3];
              rtb_OutportBufferForRk[nextbit + 3 * i] += b_a_0[3 * i + 2] *
                Walking01_withElmos_DW.UnitDelay1_DSTATE_l[nextbit + 6];
            }
          }
        }
      }
    }

    /* MATLAB Function: '<S194>/MATLAB Function' */
    if ((uint16_T)remainderPolynomial > 255) {
      tmp_1 = MAX_uint16_T;
    } else {
      tmp_1 = (uint16_T)((uint16_T)remainderPolynomial << 8);
    }

    remainderPolynomial = (uint32_T)tmp_1 + (uint16_T)Utmp1_0;
    if (remainderPolynomial > 65535U) {
      remainderPolynomial = 65535U;
    }

    /* SignalConversion: '<S194>/OutportBufferForTemperature' incorporates:
     *  MATLAB Function: '<S194>/MATLAB Function'
     */
    rtb_OutportBufferForTemperature = remainderPolynomial;

    /* SignalConversion: '<S194>/OutportBufferForwk' */
    rtb_OutportBufferForwk[0] = Walking01_withElmos_DW.UnitDelay2_DSTATE_p[0];
    rtb_OutportBufferForwk[1] = Walking01_withElmos_DW.UnitDelay2_DSTATE_p[1];
    rtb_OutportBufferForwk[2] = Walking01_withElmos_DW.UnitDelay2_DSTATE_p[2];

    /* Update for UnitDelay: '<S194>/Unit Delay1' */
    memcpy(&Walking01_withElmos_DW.UnitDelay1_DSTATE_l[0],
           &rtb_OutportBufferForRk[0], 9U * sizeof(real_T));

    /* Update for UnitDelay: '<S194>/Unit Delay3' incorporates:
     *  MATLAB Function: '<S194>/EstimateOrientation'
     */
    Walking01_withElmos_DW.UnitDelay3_DSTATE_j = Seqk;
  }

  /* End of Outputs for SubSystem: '<S124>/UpdateOrientation' */

  /* Logic: '<S124>/Logical Operator' incorporates:
   *  Constant: '<S15>/ResetYaw'
   */
  rtb_LogicalOperator_j = (Walking01_withElmos_B.RateTransition3 ||
    Walking01_withElmos_P.ResetYaw);

  /* UnitDelay: '<S124>/Unit Delay2' */
  memcpy(&rtb_UnitDelay2_i[0], &Walking01_withElmos_DW.UnitDelay2_DSTATE_o[0],
         9U * sizeof(real_T));

  /* UnitDelay: '<S124>/Unit Delay1' */
  rtb_UnitDelay1_m[0] = Walking01_withElmos_DW.UnitDelay1_DSTATE_c[0];
  rtb_UnitDelay1_m[1] = Walking01_withElmos_DW.UnitDelay1_DSTATE_c[1];

  /* MATLAB Function: '<S124>/ComputeEulerAngles' incorporates:
   *  Constant: '<S124>/KVHOrientation'
   */
  Walking01_wi_ComputeEulerAngles(rtb_OutportBufferForRk, rtb_OutportBufferForwk,
    Walking01_withElmos_ConstP.KVHOrientation_Value, rtb_LogicalOperator_j,
    rtb_UnitDelay2_i, rtb_UnitDelay1_m,
    &Walking01_withElmos_B.sf_ComputeEulerAngles_i);

  /* Reshape: '<S124>/Reshape' */
  memcpy(&rtb_Reshape_d[0], &Walking01_withElmos_B.sf_ComputeEulerAngles_i.Rk[0],
         9U * sizeof(real_T));

  /* Constant: '<S15>/EnableFT' */
  rtb_EnableFT = Walking01_withElmos_P.EnableFT;

  /* End of Outputs for SubSystem: '<S5>/SerialInterfaces' */

  /* Outport: '<Root>/KVHEulerAngles' */
  Walking01_withElmos_Y.KVHEulerAngles[0] =
    Walking01_withElmos_B.sf_ComputeEulerAngles_i.ZYX[0];
  Walking01_withElmos_Y.KVHEulerAngles[1] =
    Walking01_withElmos_B.sf_ComputeEulerAngles_i.ZYX[1];
  Walking01_withElmos_Y.KVHEulerAngles[2] =
    Walking01_withElmos_B.sf_ComputeEulerAngles_i.ZYX[2];

  /* Outport: '<Root>/KVHEulerAngleDeriv' */
  Walking01_withElmos_Y.KVHEulerAngleDeriv[0] =
    Walking01_withElmos_B.sf_ComputeEulerAngles_i.dZYX[0];
  Walking01_withElmos_Y.KVHEulerAngleDeriv[1] =
    Walking01_withElmos_B.sf_ComputeEulerAngles_i.dZYX[1];
  Walking01_withElmos_Y.KVHEulerAngleDeriv[2] =
    Walking01_withElmos_B.sf_ComputeEulerAngles_i.dZYX[2];

  /* Outport: '<Root>/KVHStatus' */
  Walking01_withElmos_Y.KVHStatus = rtb_DataTypeConversion2_l;

  /* Outport: '<Root>/KVHSequence' */
  Walking01_withElmos_Y.KVHSequence[0] = rtb_Assignment[0];
  Walking01_withElmos_Y.KVHSequence[1] = rtb_Assignment[1];

  /* Outport: '<Root>/KVHValid' */
  Walking01_withElmos_Y.KVHValid = rtb_DataTypeConversion;

  /* Level2 S-Function Block: '<S1>/Get Overload Counter 2' (xpcgetoverload) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[211];
    sfcnOutputs(rts, 1);
  }
}

/* Model update function for TID1 */
void Walking01_withElmos_update1(void) /* Sample time: [0.001s, 0.0s] */
{
  /* Update for RateTransition: '<S5>/Rate Transition2' */
  Walking01_withElmos_DW.RateTransition2_Buffer0[0] =
    Walking01_withElmos_B.sf_ComputeEulerAngles_i.ZYX[0];
  Walking01_withElmos_DW.RateTransition2_Buffer0[1] =
    Walking01_withElmos_B.sf_ComputeEulerAngles_i.ZYX[1];
  Walking01_withElmos_DW.RateTransition2_Buffer0[2] =
    Walking01_withElmos_B.sf_ComputeEulerAngles_i.ZYX[2];

  /* Update for RateTransition: '<S5>/Rate Transition1' */
  Walking01_withElmos_DW.RateTransition1_Buffer0[0] =
    Walking01_withElmos_B.sf_ComputeEulerAngles_i.dZYX[0];
  Walking01_withElmos_DW.RateTransition1_Buffer0[1] =
    Walking01_withElmos_B.sf_ComputeEulerAngles_i.dZYX[1];
  Walking01_withElmos_DW.RateTransition1_Buffer0[2] =
    Walking01_withElmos_B.sf_ComputeEulerAngles_i.dZYX[2];

  /* Update for Atomic SubSystem: '<S5>/SerialInterfaces' */
  /* Update for UnitDelay: '<S124>/Unit Delay2' */
  memcpy(&Walking01_withElmos_DW.UnitDelay2_DSTATE_o[0],
         &Walking01_withElmos_B.sf_ComputeEulerAngles_i.R0[0], 9U * sizeof
         (real_T));

  /* Update for UnitDelay: '<S124>/Unit Delay1' */
  Walking01_withElmos_DW.UnitDelay1_DSTATE_c[0] =
    Walking01_withElmos_B.sf_ComputeEulerAngles_i.YawRollover[0];
  Walking01_withElmos_DW.UnitDelay1_DSTATE_c[1] =
    Walking01_withElmos_B.sf_ComputeEulerAngles_i.YawRollover[1];

  /* End of Update for SubSystem: '<S5>/SerialInterfaces' */

  /* Update for RateTransition: '<S1>/Rate Transition1' */
  Walking01_withElmos_DW.RateTransition1_Buffer0_i =
    Walking01_withElmos_B.GetOverloadCounter2;

  /* Update absolute time */
  /* The "clockTick1" counts the number of times the code of this task has
   * been executed. The absolute time is the multiplication of "clockTick1"
   * and "Timing.stepSize1". Size of "clockTick1" ensures timer will not
   * overflow during the application lifespan selected.
   * Timer of this task consists of two 32 bit unsigned integers.
   * The two integers represent the low bits Timing.clockTick1 and the high bits
   * Timing.clockTickH1. When the low bit overflows to 0, the high bits increment.
   */
  if (!(++Walking01_withElmos_M->Timing.clockTick1)) {
    ++Walking01_withElmos_M->Timing.clockTickH1;
  }

  Walking01_withElmos_M->Timing.t[1] = Walking01_withElmos_M->Timing.clockTick1 *
    Walking01_withElmos_M->Timing.stepSize1 +
    Walking01_withElmos_M->Timing.clockTickH1 *
    Walking01_withElmos_M->Timing.stepSize1 * 4294967296.0;
}

/* Model output function for TID2 */
void Walking01_withElmos_output2(void) /* Sample time: [0.002s, 0.0s] */
{
  /* local block i/o variables */
  real_T rtb_DiscreteStateSpace;

  /* local scratch DWork variables */
  int32_T ForEach_itr;

  /* Outputs for Iterator SubSystem: '<S13>/IMUFilters' incorporates:
   *  ForEach: '<S20>/For Each'
   */
  for (ForEach_itr = 0; ForEach_itr < 3; ForEach_itr++) {
    /* ForEachSliceSelector: '<S20>/ImpSel_InsertedFor_q_limits_at_outport_0' incorporates:
     *  Constant: '<S13>/IMUAngleLimits'
     */
    Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].RateTransition6[0] =
      Walking01_withElmos_ConstP.IMUAngleLimits_Value[ForEach_itr];
    Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].RateTransition6[1] =
      Walking01_withElmos_ConstP.IMUAngleLimits_Value[ForEach_itr + 3];

    /* UnitDelay: '<S117>/Unit Delay' */
    Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].UnitDelay =
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].UnitDelay_DSTATE;

    /* RateTransition: '<S117>/Rate Transition5' incorporates:
     *  Constant: '<S13>/IMUThreshold'
     */
    Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].RateTransition5 =
      Walking01_withElmos_P.IMUThreshold;

    /* Chart: '<S117>/AnomalyDetection' incorporates:
     *  Constant: '<S117>/Constant'
     */
    Walking01_wi_AnomalyDetection_h
      (Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].RateTransition,
       Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].UnitDelay,
       Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].RateTransition6,
       Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].RateTransition5,
       Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].RateTransition7, 0.002,
       &Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].sf_AnomalyDetection,
       &Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].sf_AnomalyDetection);

    /* DiscreteStateSpace: '<S117>/Discrete State-Space' */
    {
      rtb_DiscreteStateSpace = (14.356891803485237)*
        Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].
        DiscreteStateSpace_DSTATE[0]
        + (12.202316641308844)*Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].
        DiscreteStateSpace_DSTATE[1]
        + (-6.0100781230950835)*Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .DiscreteStateSpace_DSTATE[2]
        + (0.69836024432306232)*Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .DiscreteStateSpace_DSTATE[3];
      rtb_DiscreteStateSpace += 385.71428571414617*
        Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].
        sf_AnomalyDetection.q_clean;
    }

    /* Switch: '<S117>/Switch' */
    if (Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].RateTransition4 != 0.0)
    {
      Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].Switch =
        Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].RateTransition3;
    } else {
      Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].Switch =
        rtb_DiscreteStateSpace;
    }

    /* End of Switch: '<S117>/Switch' */
  }

  /* End of Outputs for SubSystem: '<S13>/IMUFilters' */

  /* Level2 S-Function Block: '<S1>/Get Overload Counter 1' (xpcgetoverload) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[210];
    sfcnOutputs(rts, 2);
  }
}

/* Model update function for TID2 */
void Walking01_withElmos_update2(void) /* Sample time: [0.002s, 0.0s] */
{
  /* local scratch DWork variables */
  int32_T ForEach_itr;

  /* Update for Iterator SubSystem: '<S13>/IMUFilters' */
  for (ForEach_itr = 0; ForEach_itr < 3; ForEach_itr++) {
    /* Update for UnitDelay: '<S117>/Unit Delay' */
    Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].UnitDelay_DSTATE =
      Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].Switch;

    /* Update for DiscreteStateSpace: '<S117>/Discrete State-Space' */
    {
      real_T xnew[4];
      xnew[0] = (0.4630426639375399)*
        Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].
        DiscreteStateSpace_DSTATE[0]
        + (-0.635946260719451)*Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].
        DiscreteStateSpace_DSTATE[1]
        + (-0.12234344732945235)*Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .DiscreteStateSpace_DSTATE[2]
        + (0.1094057318017565)*Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].
        DiscreteStateSpace_DSTATE[3];
      xnew[0] += (-14.356891803485205)*
        Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].
        sf_AnomalyDetection.q_clean;
      xnew[1] = (0.63594626071944993)*
        Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].
        DiscreteStateSpace_DSTATE[0]
        + (-0.20017592633061451)*Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .DiscreteStateSpace_DSTATE[1]
        + (0.37218968207881631)*Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .DiscreteStateSpace_DSTATE[2]
        + (-0.15006598182646674)*Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .DiscreteStateSpace_DSTATE[3];
      xnew[1] += (12.202316641308878)*
        Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].
        sf_AnomalyDetection.q_clean;
      xnew[2] = (-0.1223434473294534)*
        Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].
        DiscreteStateSpace_DSTATE[0]
        + (-0.37218968207881631)*Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .DiscreteStateSpace_DSTATE[1]
        + (-0.76419956064116012)*Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .DiscreteStateSpace_DSTATE[2]
        + (-0.16574841449646263)*Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .DiscreteStateSpace_DSTATE[3];
      xnew[2] += (6.0100781230950835)*
        Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].
        sf_AnomalyDetection.q_clean;
      xnew[3] = (-0.10940573180175681)*
        Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].
        DiscreteStateSpace_DSTATE[0]
        + (-0.1500659818264668)*Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .DiscreteStateSpace_DSTATE[1]
        + (0.16574841449646255)*Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .DiscreteStateSpace_DSTATE[2]
        + (0.50133282303423377)*Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .DiscreteStateSpace_DSTATE[3];
      xnew[3] += (0.69836024432304777)*
        Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].
        sf_AnomalyDetection.q_clean;
      (void) memcpy(&Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].
                    DiscreteStateSpace_DSTATE[0], xnew,
                    sizeof(real_T)*4);
    }

    /* Update for RateTransition: '<S117>/Rate Transition1' */
    Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
      .RateTransition1_Buffer[Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].
      RateTransition1_ActiveBufIdx == 0] =
      Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].
      sf_AnomalyDetection.q_clean;
    Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].
      RateTransition1_ActiveBufIdx = (int8_T)
      (Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].
       RateTransition1_ActiveBufIdx == 0);

    /* Update for RateTransition: '<S117>/Rate Transition2' */
    Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
      .RateTransition2_Buffer[Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].
      RateTransition2_ActiveBufIdx == 0] =
      Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].Switch;
    Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].
      RateTransition2_ActiveBufIdx = (int8_T)
      (Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].
       RateTransition2_ActiveBufIdx == 0);

    /* Update for RateTransition: '<S117>/Rate Transition8' */
    Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
      .RateTransition8_Buffer[Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].
      RateTransition8_ActiveBufIdx == 0] =
      Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].
      sf_AnomalyDetection.ErrorCount;
    Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].
      RateTransition8_ActiveBufIdx = (int8_T)
      (Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].
       RateTransition8_ActiveBufIdx == 0);
  }

  /* End of Update for SubSystem: '<S13>/IMUFilters' */

  /* Update for RateTransition: '<S1>/Rate Transition' */
  Walking01_withElmos_DW.RateTransition_Buffer0 =
    Walking01_withElmos_B.GetOverloadCounter1;

  /* Update absolute time */
  /* The "clockTick2" counts the number of times the code of this task has
   * been executed. The absolute time is the multiplication of "clockTick2"
   * and "Timing.stepSize2". Size of "clockTick2" ensures timer will not
   * overflow during the application lifespan selected.
   * Timer of this task consists of two 32 bit unsigned integers.
   * The two integers represent the low bits Timing.clockTick2 and the high bits
   * Timing.clockTickH2. When the low bit overflows to 0, the high bits increment.
   */
  if (!(++Walking01_withElmos_M->Timing.clockTick2)) {
    ++Walking01_withElmos_M->Timing.clockTickH2;
  }

  Walking01_withElmos_M->Timing.t[2] = Walking01_withElmos_M->Timing.clockTick2 *
    Walking01_withElmos_M->Timing.stepSize2 +
    Walking01_withElmos_M->Timing.clockTickH2 *
    Walking01_withElmos_M->Timing.stepSize2 * 4294967296.0;
}

/* Model output wrapper function for compatibility with a static main program */
void Walking01_withElmos_output(int_T tid)
{
  switch (tid) {
   case 0 :
    Walking01_withElmos_output0();
    break;

   case 1 :
    Walking01_withElmos_output1();
    break;

   case 2 :
    Walking01_withElmos_output2();
    break;

   default :
    break;
  }
}

/* Model update wrapper function for compatibility with a static main program */
void Walking01_withElmos_update(int_T tid)
{
  switch (tid) {
   case 0 :
    Walking01_withElmos_update0();
    break;

   case 1 :
    Walking01_withElmos_update1();
    break;

   case 2 :
    Walking01_withElmos_update2();
    break;

   default :
    break;
  }
}

/* Model initialize function */
void Walking01_withElmos_initialize(void)
{
  {
    /* local scratch DWork variables */
    int32_T ForEach_itr;
    int32_T ForEach_itr_n;

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[6];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[7];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[8];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[9];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[10];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[11];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[12];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[13];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[14];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[15];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[16];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[17];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[18];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[19];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[20];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[21];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[22];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[23];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[24];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[25];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[26];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[27];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[28];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Start for Iterator SubSystem: '<S13>/EncoderFilters' */
    for (ForEach_itr_n = 0; ForEach_itr_n < 19; ForEach_itr_n++) {
      Walking01_withElmos_B.CoreSubsys[ForEach_itr_n].UnitDelay = 0.0;
      Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n].UnitDelay_DSTATE = 0.0;

      /* Start for Chart: '<S24>/AnomalyDetection' */
      Walking0_AnomalyDetection_Start
        (&Walking01_withElmos_B.CoreSubsys[ForEach_itr_n].sf_AnomalyDetection);

      /* InitializeConditions for UnitDelay: '<S24>/Unit Delay' */
      Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n].UnitDelay_DSTATE = 0.0;

      /* InitializeConditions for Chart: '<S24>/AnomalyDetection' */
      Walking01_AnomalyDetection_Init
        (&Walking01_withElmos_B.CoreSubsys[ForEach_itr_n].sf_AnomalyDetection,
         &Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n].sf_AnomalyDetection);

      /* InitializeConditions for DiscreteStateSpace: '<S24>/Discrete State-Space' */
      Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n]
        .DiscreteStateSpace_DSTATE[0] = (0.0);
      Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n]
        .DiscreteStateSpace_DSTATE[1] = (0.0);
      Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n]
        .DiscreteStateSpace_DSTATE[2] = (0.0);
      Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n]
        .DiscreteStateSpace_DSTATE[3] = (0.0);
    }

    /* End of Start for SubSystem: '<S13>/EncoderFilters' */

    /* Start for RateTransition: '<S5>/Rate Transition2' */
    Walking01_withElmos_B.RateTransition2[0] = 0.0;
    Walking01_withElmos_B.RateTransition2[1] = 0.0;
    Walking01_withElmos_B.RateTransition2[2] = 0.0;

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[29];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[30];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[31];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[32];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[33];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[34];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[35];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[36];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[37];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[38];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[39];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[40];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Start for Iterator SubSystem: '<S13>/IMUFilters' */
    for (ForEach_itr = 0; ForEach_itr < 3; ForEach_itr++) {
      Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].RateTransition = 0.0;
      Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].UnitDelay = 0.0;
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].UnitDelay_DSTATE = 0.0;
      Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].RateTransition6[0] = 0.0;
      Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].RateTransition6[1] = 0.0;
      Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].RateTransition5 = 0.0;
      Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].RateTransition7 = false;
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].RateTransition1_Buffer[0]
        = 0.0;
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].RateTransition1_Buffer[1]
        = 0.0;
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].RateTransition2_Buffer[0]
        = 0.0;
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].RateTransition2_Buffer[1]
        = 0.0;
      Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].RateTransition3 = 0.0;
      Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].RateTransition4 = 0.0;
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].RateTransition8_Buffer[0]
        = 0.0;
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].RateTransition8_Buffer[1]
        = 0.0;
      Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].Switch = 0.0;

      /* Start for Chart: '<S117>/AnomalyDetection' */
      Walkin_AnomalyDetection_g_Start
        (&Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].sf_AnomalyDetection);

      /* InitializeConditions for UnitDelay: '<S117>/Unit Delay' */
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].UnitDelay_DSTATE = 0.0;

      /* InitializeConditions for Chart: '<S117>/AnomalyDetection' */
      Walking_AnomalyDetection_h_Init
        (&Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].sf_AnomalyDetection,
         &Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].sf_AnomalyDetection);

      /* InitializeConditions for DiscreteStateSpace: '<S117>/Discrete State-Space' */
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .DiscreteStateSpace_DSTATE[0] = (0.0);
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .DiscreteStateSpace_DSTATE[1] = (0.0);
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .DiscreteStateSpace_DSTATE[2] = (0.0);
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .DiscreteStateSpace_DSTATE[3] = (0.0);

      /* InitializeConditions for RateTransition: '<S117>/Rate Transition1' */
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].RateTransition1_Buffer[0]
        = 0.0;

      /* InitializeConditions for RateTransition: '<S117>/Rate Transition2' */
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].RateTransition2_Buffer[0]
        = 0.0;

      /* InitializeConditions for RateTransition: '<S117>/Rate Transition8' */
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].RateTransition8_Buffer[0]
        = 0.0;
    }

    /* End of Start for SubSystem: '<S13>/IMUFilters' */

    /* Start for RateTransition: '<S5>/Rate Transition1' */
    Walking01_withElmos_B.RateTransition1[0] = 0.0;
    Walking01_withElmos_B.RateTransition1[1] = 0.0;
    Walking01_withElmos_B.RateTransition1[2] = 0.0;

    /* Start for Constant: '<S202>/EnableTransition' */
    Walking01_withElmos_B.EnableTransition =
      Walking01_withElmos_P.EnableTransition;

    /* Start for Constant: '<S202>/ResetControl' */
    Walking01_withElmos_B.ResetControl = Walking01_withElmos_P.ResetControl;

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[41];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[42];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[43];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[44];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[45];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[46];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[47];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[48];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[49];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[50];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[51];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[52];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[53];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[54];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[55];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[56];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[57];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[58];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[59];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[60];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Start for S-Function (xpcethercatinit): '<S19>/EtherCAT Init ' */
    {
      int_T status = 1;
      char_T *errMsg;
      xpcPCIDevice pciInfo;
      char_T l_errMsg[128];
      int_T j;
      uint8_T *DeviceType;

      /* From LinkOsLayer.h   Intel PRO-100 specific definitions */
      struct EtherCATDevices {
        uint16_T VendorID;
        uint16_T DeviceID;
        uint8_T *DeviceType;
      } EtherCATDeviceTable[] = {
        /* I8254x types */
        { 0x8086, 0xABB1, "I8254x" },  //

        { 0x8086, 0xABB2, "I8254x" },  //

        { 0x8086, 0x1013, "I8254x" },  //  PCI_DEVICE_I82541EI_COPPER

        { 0x8086, 0x1078, "I8254x" },  //  PCI_DEVICE_I82541ER

        { 0x8086, 0x1076, "I8254x" },  //  PCI_DEVICE_I82541GI_COPPER

        { 0x8086, 0x107C, "I8254x" },  //  PCI_DEVICE_I82541PI_DESKTOP

        { 0x8086, 0x1019, "I8254x" },  //  PCI_DEVICE_I82547GI_COPPER

        { 0x8086, 0x1026, "I8254x" },  //  PCI_DEVICE_I82545GM_COPPER

        { 0x8086, 0x10BD, "I8254x" },  //  PCI_DEVICE_I82566L

        { 0x8086, 0x10EA, "I8254x" },  //  PCI_DEVICE_I82577LM

        { 0x8086, 0x10EB, "I8254x" },  //  PCI_DEVICE_I82577LC

        { 0x8086, 0x10A7, "I8254x" },  //  PCI_DEVICE_I82575_ZOAR

        { 0x8086, 0x1075, "I8254x" },  //  PCI_DEVICE_I82547EI

        { 0x8086, 0x108C, "I8254x" },  //  PCI_DEVICE_I82573

        { 0x8086, 0x109A, "I8254x" },  //  PCI_DEVICE_I82573L

        { 0x8086, 0x10B9, "I8254x" },  //  PCI_DEVICE_I82572GI

        { 0x8086, 0x10A4, "I8254x" },  //  PCI_DEVICE_I82571GB_QUAD

        { 0x8086, 0x10D3, "I8254x" },  //  PCI_DEVICE_I82574L

        { 0x8086, 0x1010, "I8254x" },  //  PCI_DEVICE_I82546EB_COPPER_DUAL

        { 0x8086, 0x1079, "I8254x" },  //  PCI_DEVICE_I82546GB_COPPER_DUAL

        { 0x8086, 0x100E, "I8254x" },  //  PCI_DEVICE_I82540EM_DESKTOP

        { 0x8086, 0x105E, "I8254x" },  //  PCI_DEVICE_N1E5132_SERVER

        { 0x8086, 0x10BC, "I8254x" },  //  PCI_DEVICE_I82571GB_QUAD_2

        { 0x8086, 0x10C9, "I8254x" },  //  PCI_DEVICE_I82576

        { 0x8086, 0x10CE, "I8254x" },  //  PCI_DEVICE_I82567V

        { 0x8086, 0x150E, "I8254x" },  //  PCI_DEVICE_I82580_QUAD

        { 0x8086, 0x10F5, "I8254x" },  //  PCI_DEVICE_I82567LM

        { 0x8086, 0x10DE, "I8254x" },  //  PCI_DEVICE_I82567LM3

        { 0x8086, 0x1527, "I8254x" },  //  PCI_DEVICE_I82580_QUAD_FIBRE

        { 0x8086, 0x1501, "I8254x" },  //  PCI_DEVICE_I82567V3

        { 0x8086, 0x108B, "I8254x" },  //  PCI_DEVICE_I82573E

        { 0x8086, 0x107D, "I8254x" },  //  PCI_DEVICE_I82572EI

        { 0x8086, 0x150C, "I8254x" },  //  PCI_DEVICE_I82583V

        { 0x8086, 0x1502, "I8254x" },  //  PCI_DEVICE_I82579LM

        { 0x8086, 0x1503, "I8254x" },  //  PCI_DEVICE_I82579V

        { 0x8086, 0x1526, "I8254x" },  //  PCI_DEVICE_I82576_ET2

        { 0x8086, 0x1521, "I8254x" },  //  PCI_DEVICE_I350

        { 0x8086, 0x1533, "I8254x" },  //  PCI_DEVICE_I210

        { 0x8086, 0x104A, "I8254x" },  //  PCI_DEVICE_I82566DM

        /* I8255x types */
        { 0x8086, 0x103a, "I8255x" },  //  PCI device ID, Intel 82801DB(M) (ICH4) LAN Controller

        { 0x8086, 0x1229, "I8255x" },  //  82557 device ID

        { 0x8086, 0x1209, "I8255x" },  //  82557 ER device ID

        { 0x8086, 0x1050, "I8255x" },  //  PRO/100 VE device ID

        { 0x8086, 0x1039, "I8255x" },  //  82562 VE/VM device ID

        { 0x8086, 0x2449, "I8255x" },  //  82559 ER device ID

        { 0x8086, 0x27DC, "I8255x" },  //  PRO/100 VE device ID

        { 0x8086, 0x1059, "I8255x" },  //  Mobile version of 1229

        { 0x8086, 0x1092, "I8255x" }   //  PRO/100 VE3 device ID
      };

      if (!xpcIsModelInit()) {
        status = xpcGetPciConfigAtSlot( 10, 0, &pciInfo);
        if (status ) {
          sprintf(l_errMsg, "You must specify a bus/slot, not auto search.\n");
          rtmSetErrorStatus(Walking01_withElmos_M, l_errMsg);
          return;
        }

        status = -1;                   // Preset to a failed search.
        DeviceType = "";
        for (j = 0 ; j < sizeof(EtherCATDeviceTable)/sizeof(struct
              EtherCATDevices) ; j++ ) {
          // Search through the device table for the matching vendor/device ID.
          if (( pciInfo.DeviceId == EtherCATDeviceTable[j].DeviceID )
              && ( pciInfo.VendorId == EtherCATDeviceTable[j].VendorID ) ) {
            status = 0;
            DeviceType = EtherCATDeviceTable[j].DeviceType;
            break;
          }
        }

        if (status ) {
          printf("No valid Ethernet board found at bus %d slot %d\n", 10, 0);
          sprintf(l_errMsg, "No valid Ethernet board found.\n");
          rtmSetErrorStatus(Walking01_withElmos_M, l_errMsg);
        } else {
          char *logfile = "c:\\dbglog.txt";
          status = xpcEtherCATinitialize(0, DeviceType, 10, 0, 0, 1,
            xmlCharArr_0, sizeof(xmlCharArr_0),0, 1, logfile, 0.0005);
          if (status != XPC_ECAT_OK) {
            errMsg = xpcPrintEtherCATError(0, 0);
            rtmSetErrorStatus(Walking01_withElmos_M, errMsg);
            return;
          }

          //printf("init status = %08x\n", status );
        }
      }
    }

    /* Start for Atomic SubSystem: '<S5>/SerialInterfaces' */
    /* Level2 S-Function Block: '<S193>/Board Setup' (board_setup_tews_XR17D15x) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[2];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S193>/Setup3' (setup_tews_XR17D15x) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[3];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S193>/Read HW FIFO' (read_hw_fifo_XR17D15x) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[4];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S193>/FIFO write 1' (fifowrite) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[5];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Start for Iterator SubSystem: '<S124>/UpdateOrientation' */

    /* Level2 S-Function Block: '<S194>/FIFO bin read ' (fiforeadbinhdrmultiple) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[1];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* End of Start for SubSystem: '<S124>/UpdateOrientation' */

    /* InitializeConditions for Iterator SubSystem: '<S124>/UpdateOrientation' */
    /* InitializeConditions for UnitDelay: '<S194>/Unit Delay1' */
    memcpy(&Walking01_withElmos_DW.UnitDelay1_DSTATE_l[0],
           Walking01_withElmos_ConstP.pooled23, 9U * sizeof(real_T));

    /* InitializeConditions for UnitDelay: '<S194>/Unit Delay2' */
    Walking01_withElmos_DW.UnitDelay2_DSTATE_p[0] = 0.0;
    Walking01_withElmos_DW.UnitDelay2_DSTATE_p[1] = 0.0;
    Walking01_withElmos_DW.UnitDelay2_DSTATE_p[2] = 0.0;

    /* InitializeConditions for UnitDelay: '<S194>/Unit Delay' */
    Walking01_withElmos_DW.UnitDelay_DSTATE_p[0] = 0.0;
    Walking01_withElmos_DW.UnitDelay_DSTATE_p[1] = 0.0;
    Walking01_withElmos_DW.UnitDelay_DSTATE_p[2] = 0.0;

    /* InitializeConditions for UnitDelay: '<S194>/Unit Delay3' */
    Walking01_withElmos_DW.UnitDelay3_DSTATE_j = 0.0;

    /* End of InitializeConditions for SubSystem: '<S124>/UpdateOrientation' */
    /* End of Start for SubSystem: '<S5>/SerialInterfaces' */
    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[62];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[63];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[64];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[65];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[66];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[67];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[68];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[69];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[70];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[71];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[72];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[73];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[74];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[75];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[76];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[77];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[78];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[79];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[80];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[81];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[82];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[83];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[84];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[85];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[86];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[87];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[88];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[89];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[90];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[91];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S1>/Get Overload Counter ' (xpcgetoverload) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[92];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Start for RateTransition: '<S1>/Rate Transition1' */
    Walking01_withElmos_B.RateTransition1_p = 0U;

    /* Start for RateTransition: '<S1>/Rate Transition' */
    Walking01_withElmos_B.RateTransition = 0U;

    /* Level2 S-Function Block: '<S64>/EtherCAT PDO Receive' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[93];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S100>/EtherCAT PDO Receive' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[94];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S46>/EtherCAT PDO Receive' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[95];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S82>/EtherCAT PDO Receive' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[96];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S64>/EtherCAT PDO Receive3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[97];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S100>/EtherCAT PDO Receive3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[98];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S46>/EtherCAT PDO Receive3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[99];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S82>/EtherCAT PDO Receive3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[100];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S64>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[101];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S100>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[102];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S46>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[103];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S82>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[104];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S64>/EtherCAT PDO Receive4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[105];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S100>/EtherCAT PDO Receive4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[106];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S46>/EtherCAT PDO Receive4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[107];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S82>/EtherCAT PDO Receive4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[108];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S64>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[109];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S100>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[110];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S46>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[111];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S82>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[112];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Start for Enabled SubSystem: '<S4>/Reset CPU Overload Count' */

    /* Level2 S-Function Block: '<S12>/xPC Set Overload Counter' (xpcsetoverload) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[0];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* End of Start for SubSystem: '<S4>/Reset CPU Overload Count' */

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[113];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[114];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[115];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[116];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[117];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[118];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[119];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[120];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[121];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[122];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[123];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[124];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[125];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[126];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[127];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[128];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[129];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[130];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[131];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[132];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[133];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[134];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[135];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[136];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[137];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[138];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[139];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[140];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[141];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[142];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[143];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[144];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[145];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[146];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[147];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[148];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[149];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[150];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[151];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[152];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[153];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[154];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[155];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[156];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[157];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[158];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[159];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[160];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[161];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[162];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[163];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[164];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[165];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[166];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[167];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[168];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[169];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[170];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[171];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S31>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[172];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[173];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[174];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S32>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[175];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[176];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[177];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[178];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Tx Var ' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[179];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Tx Var 1' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[180];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S33>/EtherCAT Tx Var 2' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[181];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S46>/EtherCAT PDO Receive2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[182];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S46>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[183];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S46>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[184];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S46>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[185];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S64>/EtherCAT PDO Receive2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[186];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S64>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[187];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S64>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[188];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S64>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[189];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S82>/EtherCAT PDO Receive2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[190];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S82>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[191];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S82>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[192];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S82>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[193];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S100>/EtherCAT PDO Receive2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[194];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S100>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[195];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S100>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[196];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S100>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[197];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[198];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[199];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S38>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[200];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[201];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[202];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S39>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[203];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[204];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[205];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S40>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[206];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[207];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[208];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S41>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[209];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S1>/Get Overload Counter 1' (xpcgetoverload) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[210];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S1>/Get Overload Counter 2' (xpcgetoverload) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[211];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* ConstCode for Outport: '<Root>/FTStatus' */
    Walking01_withElmos_Y.FTStatus = 0.0;

    /* ConstCode for Outport: '<Root>/FT' */
    Walking01_withElmos_Y.FT = 0.0;
  }

  {
    /* local scratch DWork variables */
    int32_T ForEach_itr;
    int32_T ForEach_itr_n;
    int32_T i;

    /* InitializeConditions for UnitDelay: '<S14>/Unit Delay' */
    Walking01_withElmos_DW.UnitDelay_DSTATE_n = true;
    for (i = 0; i < 9; i++) {
      /* InitializeConditions for UnitDelay: '<S13>/Unit Delay1' */
      Walking01_withElmos_DW.UnitDelay1_DSTATE[i] = 0.0;

      /* InitializeConditions for UnitDelay: '<S13>/Unit Delay' */
      Walking01_withElmos_DW.UnitDelay_DSTATE[i] =
        Walking01_withElmos_ConstP.pooled23[i];
    }

    /* InitializeConditions for UnitDelay: '<S13>/Unit Delay2' */
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_DW.UnitDelay2_DSTATE[i] =
        Walking01_withElmos_ConstP.UnitDelay2_InitialCon[i];
    }

    /* End of InitializeConditions for UnitDelay: '<S13>/Unit Delay2' */

    /* InitializeConditions for Iterator SubSystem: '<S13>/EncoderFilters' */
    for (ForEach_itr_n = 0; ForEach_itr_n < 19; ForEach_itr_n++) {
      /* InitializeConditions for UnitDelay: '<S24>/Unit Delay' */
      Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n].UnitDelay_DSTATE = 0.0;

      /* InitializeConditions for Chart: '<S24>/AnomalyDetection' */
      Walking01_AnomalyDetection_Init
        (&Walking01_withElmos_B.CoreSubsys[ForEach_itr_n].sf_AnomalyDetection,
         &Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n].sf_AnomalyDetection);/* InitializeConditions for DiscreteStateSpace: '<S24>/Discrete State-Space' */
      Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n]
        .DiscreteStateSpace_DSTATE[0] = (0.0);
      Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n]
        .DiscreteStateSpace_DSTATE[1] = (0.0);
      Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n]
        .DiscreteStateSpace_DSTATE[2] = (0.0);
      Walking01_withElmos_DW.CoreSubsys[ForEach_itr_n]
        .DiscreteStateSpace_DSTATE[3] = (0.0);
    }

    /* End of InitializeConditions for SubSystem: '<S13>/EncoderFilters' */

    /* InitializeConditions for RateTransition: '<S5>/Rate Transition2' */
    Walking01_withElmos_DW.RateTransition2_Buffer0[0] = 0.0;
    Walking01_withElmos_DW.RateTransition2_Buffer0[1] = 0.0;
    Walking01_withElmos_DW.RateTransition2_Buffer0[2] = 0.0;

    /* InitializeConditions for UnitDelay: '<S13>/Unit Delay4' */
    memcpy(&Walking01_withElmos_DW.UnitDelay4_DSTATE[0],
           Walking01_withElmos_ConstP.pooled23, 9U * sizeof(real_T));

    /* InitializeConditions for UnitDelay: '<S13>/Unit Delay3' */
    Walking01_withElmos_DW.UnitDelay3_DSTATE[0] = 0.0;
    Walking01_withElmos_DW.UnitDelay3_DSTATE[1] = 0.0;

    /* InitializeConditions for Iterator SubSystem: '<S13>/IMUFilters' */
    for (ForEach_itr = 0; ForEach_itr < 3; ForEach_itr++) {
      /* InitializeConditions for UnitDelay: '<S117>/Unit Delay' */
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].UnitDelay_DSTATE = 0.0;

      /* InitializeConditions for Chart: '<S117>/AnomalyDetection' */
      Walking_AnomalyDetection_h_Init
        (&Walking01_withElmos_B.CoreSubsys_p[ForEach_itr].sf_AnomalyDetection,
         &Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].sf_AnomalyDetection);/* InitializeConditions for DiscreteStateSpace: '<S117>/Discrete State-Space' */
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .DiscreteStateSpace_DSTATE[0] = (0.0);
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .DiscreteStateSpace_DSTATE[1] = (0.0);
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .DiscreteStateSpace_DSTATE[2] = (0.0);
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr]
        .DiscreteStateSpace_DSTATE[3] = (0.0);

      /* InitializeConditions for RateTransition: '<S117>/Rate Transition1' */
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].RateTransition1_Buffer[0]
        = 0.0;

      /* InitializeConditions for RateTransition: '<S117>/Rate Transition2' */
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].RateTransition2_Buffer[0]
        = 0.0;

      /* InitializeConditions for RateTransition: '<S117>/Rate Transition8' */
      Walking01_withElmos_DW.CoreSubsys_p[ForEach_itr].RateTransition8_Buffer[0]
        = 0.0;
    }

    /* End of InitializeConditions for SubSystem: '<S13>/IMUFilters' */

    /* InitializeConditions for RateTransition: '<S5>/Rate Transition1' */
    Walking01_withElmos_DW.RateTransition1_Buffer0[0] = 0.0;
    Walking01_withElmos_DW.RateTransition1_Buffer0[1] = 0.0;
    Walking01_withElmos_DW.RateTransition1_Buffer0[2] = 0.0;

    /* InitializeConditions for DiscreteStateSpace: '<S214>/Discrete State-Space' */
    Walking01_withElmos_DW.DiscreteStateSpace_DSTATE[0] = (0.0);
    Walking01_withElmos_DW.DiscreteStateSpace_DSTATE[1] = (0.0);
    Walking01_withElmos_DW.DiscreteStateSpace_DSTATE[2] = (0.0);
    Walking01_withElmos_DW.DiscreteStateSpace_DSTATE[3] = (0.0);

    /* InitializeConditions for DiscreteStateSpace: '<S214>/Discrete State-Space1' */
    Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE[0] = (0.0);
    Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE[1] = (0.0);
    Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE[2] = (0.0);
    Walking01_withElmos_DW.DiscreteStateSpace1_DSTATE[3] = (0.0);

    /* InitializeConditions for UnitDelay: '<S212>/Delay Input1' */
    Walking01_withElmos_DW.DelayInput1_DSTATE = ((uint8_T)0U);

    /* InitializeConditions for UnitDelay: '<S213>/Delay Input1' */
    Walking01_withElmos_DW.DelayInput1_DSTATE_c = false;

    /* InitializeConditions for Chart: '<S202>/StateLogic' */
    Walking01_withElmos_DW.sfEvent = -1;
    Walking01_withElmos_DW.is_active_Main = 0U;
    Walking01_withElmos_DW.is_Main = Walking01__IN_NO_ACTIVE_CHILD_j;
    Walking01_withElmos_DW.is_active_ControllerMode = 0U;
    Walking01_withElmos_DW.is_ControllerMode = Walking01__IN_NO_ACTIVE_CHILD_j;
    Walking01_withElmos_DW.is_Transition = Walking01__IN_NO_ACTIVE_CHILD_j;
    Walking01_withElmos_DW.temporalCounter_i2 = 0U;
    Walking01_withElmos_DW.is_active_Stage = 0U;
    Walking01_withElmos_DW.is_Stage = Walking01__IN_NO_ACTIVE_CHILD_j;
    Walking01_withElmos_DW.is_active_Support = 0U;
    Walking01_withElmos_DW.is_Support = Walking01__IN_NO_ACTIVE_CHILD_j;
    Walking01_withElmos_DW.temporalCounter_i1 = 0U;
    Walking01_withElmos_DW.is_active_Serialize = 0U;
    Walking01_withElmos_DW.is_active_ControlStatus = 0U;
    Walking01_withElmos_DW.is_ControlStatus = Walking01__IN_NO_ACTIVE_CHILD_j;
    Walking01_withElmos_DW.is_active_SerialState = 0U;
    Walking01_withElmos_DW.is_SerialState = Walking01__IN_NO_ACTIVE_CHILD_j;
    Walking01_withElmos_DW.is_active_c22_LibWalking = 0U;
    memset(&Walking01_withElmos_DW.SerialBuffer[0], 0, 1976U * sizeof(real_T));
    Walking01_withElmos_DW.SerialIdx = 0.0;
    Walking01_withElmos_DW.TransitionStepCount = 0.0;
    Walking01_withElmos_DW.WalkingStepCount = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.EnableSwapOnKAAccel =
      0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.EnableSwapOnKASpring =
      0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.EnableBackwardSwap =
      0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.ImpactThresholdKAAccel =
      0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.ImpactThresholdKASpringAbs
      = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.ImpactThresholdKASpringRel
      = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.SwapThresholdS = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.AllowDoubleSupport =
      0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.UseGaitTransition = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.NumTransitionSteps =
      0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.TransitionThresholdTorsoVel
      = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.KAInjection[0] = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.KAInjection[1] = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.MinDeltaThetaTransition
      = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.StartSecondGaitOnStep =
      0.0;
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_DW.ControlParamsPrev.Supervisory.VBLAParams[i] = 0.0;
    }

    for (i = 0; i < 13; i++) {
      Walking01_withElmos_DW.ControlParamsPrev.Supervisory.BalanceParams[i] =
        0.0;
    }

    for (i = 0; i < 5; i++) {
      Walking01_withElmos_DW.ControlParamsPrev.Supervisory.GaitTweaks[i] = 0.0;
    }

    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.TStepInitial = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.TMaxUpdate = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.RunMode = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.UseAbsoluteSwingLA =
      0.0;
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_DW.ControlParamsPrev.Supervisory.ErrorZeroFactor[i] =
        0.0;
      Walking01_withElmos_DW.ControlParamsPrev.Supervisory.ErrorVelZeroFactor[i]
        = 0.0;
    }

    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.StanceLegInit = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.ControllerModeInit =
      0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.UsePosingControl = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.TPosing = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.TorsoBackAngle = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.TorsoBackOnStep = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.EnergyControlGain = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.EnergyControlPhi0 = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.VelocityControlTorsoMax
      = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.VelocityControlTorsoMin
      = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.VelocityControlTorsoGain
      = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.VelocityControlTorsoV0 =
      0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.MinDeltaTheta = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.Theta0 = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.KThetaPlus = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.KThetaMinus = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.RollPhaseVelocityThresh
      = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.RollPhaseSThresh = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.MaxError = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.MaxErrorVel = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.MaxErrorCount = 0.0;
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_DW.ControlParamsPrev.Supervisory.K1MidStanceUpdate[i] =
        0.0;
      Walking01_withElmos_DW.ControlParamsPrev.Supervisory.K2MidStanceUpdate[i] =
        0.0;
    }

    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.EnableVelocityBasedUpdate
      = 0.0;
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_DW.ControlParamsPrev.Supervisory.VelocityBasedUpdateK1[
        i] = 0.0;
      Walking01_withElmos_DW.ControlParamsPrev.Supervisory.VelocityBasedUpdateK2[
        i] = 0.0;
    }

    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.VelocityBasedUpdateDTheta0
      = 0.0;
    for (i = 0; i < 12; i++) {
      Walking01_withElmos_DW.ControlParamsPrev.Supervisory.VelocityBasedUpdateLimits
        [i] = 0.0;
    }

    Walking01_withElmos_DW.ControlParamsPrev.Supervisory.DesiredYawOffset = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Discrete.TLastUpdate = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Discrete.VelocityControlLADelta =
      0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Discrete.VelocityControlTorsoDelta =
      0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Discrete.VelocityControlHipDistCur =
      0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Discrete.VelocityControlHipDistPrev
      = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Discrete.VirtualSpringMode = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Discrete.VirtualSpringStiffness =
      0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Discrete.VirtualSpringDamping = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Discrete.VirtualSpringModAmplitude =
      0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Discrete.VirtualSpringModRate = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Discrete.VirtualSpringRestPos = 0.0;
    for (i = 0; i < 78; i++) {
      Walking01_withElmos_DW.ControlParamsPrev.Output.H0[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      Walking01_withElmos_DW.ControlParamsPrev.Output.HAlpha[i] = 0.0;
    }

    Walking01_withElmos_DW.ControlParamsPrev.Output.ThetaLimits[0] = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Output.ThetaLimits[1] = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Output.Theta.c0 = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Output.Theta.ct = 0.0;
    for (i = 0; i < 13; i++) {
      Walking01_withElmos_DW.ControlParamsPrev.Output.Theta.cq[i] = 0.0;
    }

    Walking01_withElmos_DW.ControlParamsPrev.Output.Theta.t0 = 0.0;
    for (i = 0; i < 7; i++) {
      Walking01_withElmos_DW.ControlParamsPrev.Output.Theta.cz[i] = 0.0;
    }

    Walking01_withElmos_DW.ControlParamsPrev.Output.SaturateS = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Output.SLimits[0] = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Output.SLimits[1] = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Output.EnforceIncreasingS = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Output.UseCorrection = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Output.SMaxCorrection = 0.0;
    for (i = 0; i < 30; i++) {
      Walking01_withElmos_DW.ControlParamsPrev.Output.HAlphaCorrection[i] = 0.0;
    }

    Walking01_withElmos_DW.ControlParamsPrev.Output.Phi.c0 = 0.0;
    for (i = 0; i < 13; i++) {
      Walking01_withElmos_DW.ControlParamsPrev.Output.Phi.cq[i] = 0.0;
    }

    for (i = 0; i < 20; i++) {
      Walking01_withElmos_DW.ControlParamsPrev.Output.PhiAlpha[i] = 0.0;
    }

    Walking01_withElmos_DW.ControlParamsPrev.Output.SaturateR = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Output.RLimits[0] = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Output.RLimits[1] = 0.0;
    for (i = 0; i < 30; i++) {
      Walking01_withElmos_DW.ControlParamsPrev.Output.HBarAlpha[i] = 0.0;
    }

    for (i = 0; i < 12; i++) {
      Walking01_withElmos_DW.ControlParamsPrev.Output.HBarLimits[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      Walking01_withElmos_DW.ControlParamsPrev.Output.HAlphaStar[i] = 0.0;
    }

    Walking01_withElmos_DW.ControlParamsPrev.Output.YawLimit = 0.0;
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_DW.ControlParamsPrev.Feedback.kp[i] = 0.0;
      Walking01_withElmos_DW.ControlParamsPrev.Feedback.kd[i] = 0.0;
    }

    Walking01_withElmos_DW.ControlParamsPrev.Feedback.epsilon[0] = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.epsilon[1] = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.kff_grav[0] = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.kff_grav[1] = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.delta_grav = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.kff_decoup[0] = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.kff_decoup[1] = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.kd_torso[0] = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.kd_torso[1] = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.kp_2dof = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.kd_2dof = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.kpre_2dof = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.kp_lat = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.kd_lat = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.q3d_min_lat = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.q3d_max_lat = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.w_torso_lat = 0.0;
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_DW.ControlParamsPrev.Feedback.u_ff[i] = 0.0;
    }

    Walking01_withElmos_DW.ControlParamsPrev.Feedback.LateralControlMode = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.DecouplingMode = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.Use2DOF = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.UseDSGravComp = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.lat_bias = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.lat_bias2 = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.linkFeedback = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.RIO = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Feedback.SelectFeedforward = 0.0;
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_DW.ControlParamsPrev.Feedback.FeedforwardGain[i] = 0.0;
    }

    Walking01_withElmos_DW.ControlParamsPrev.Feedback.EnableFeedforwardOnStep =
      0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Saturation.UseQPSaturation = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Saturation.QPWeight[0] = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Saturation.QPWeight[1] = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Saturation.UseKASaturation = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Saturation.KASaturationS1 = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Saturation.KASaturationS2 = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Saturation.KASaturationEarly = 0.0;
    Walking01_withElmos_DW.ControlParamsPrev.Saturation.KASaturationMax = 0.0;
    Walking01_withElmos_DW.ControlStatePrev.ControllerMode = 0.0;
    Walking01_withElmos_DW.ControlStatePrev.SupportState = 0.0;
    Walking01_withElmos_DW.ControlStatePrev.StanceLeg = 0.0;
    Walking01_withElmos_DW.ControlStatePrev.InDoubleSupport = 0.0;
    Walking01_withElmos_DW.ControlStatePrev.RollPhase = 0.0;
    Walking01_withElmos_DW.ControlStatePrev.StepCount = 0.0;
    Walking01_withElmos_DW.ControlStatePrev.Error = 0.0;
    Walking01_withElmos_DW.s = 0.0;
    Walking01_withElmos_DW.SerialBufferBegin = 1.0;
    Walking01_withElmos_DW.SerialBufferEnd = 1.0;
    Walking01_withElmos_DW.theta = 0.0;
    Walking01_withElmos_DW.tLastSend = 0.0;
    Walking01_withElmos_B.ControlState.ControllerMode = 0.0;
    Walking01_withElmos_B.ControlState.SupportState = 0.0;
    Walking01_withElmos_B.ControlState.StanceLeg = 0.0;
    Walking01_withElmos_B.ControlState.InDoubleSupport = 0.0;
    Walking01_withElmos_B.ControlState.RollPhase = 0.0;
    Walking01_withElmos_B.ControlState.StepCount = 0.0;
    Walking01_withElmos_B.ControlState.Error = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.EnableSwapOnKAAccel = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.EnableSwapOnKASpring = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.EnableBackwardSwap = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.ImpactThresholdKAAccel = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.ImpactThresholdKASpringAbs =
      0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.ImpactThresholdKASpringRel =
      0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.SwapThresholdS = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.AllowDoubleSupport = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.UseGaitTransition = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.NumTransitionSteps = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.TransitionThresholdTorsoVel =
      0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.KAInjection[0] = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.KAInjection[1] = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.MinDeltaThetaTransition =
      0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.StartSecondGaitOnStep = 0.0;
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_B.ControlParams.Supervisory.VBLAParams[i] = 0.0;
    }

    for (i = 0; i < 13; i++) {
      Walking01_withElmos_B.ControlParams.Supervisory.BalanceParams[i] = 0.0;
    }

    for (i = 0; i < 5; i++) {
      Walking01_withElmos_B.ControlParams.Supervisory.GaitTweaks[i] = 0.0;
    }

    Walking01_withElmos_B.ControlParams.Supervisory.TStepInitial = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.TMaxUpdate = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.RunMode = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.UseAbsoluteSwingLA = 0.0;
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_B.ControlParams.Supervisory.ErrorZeroFactor[i] = 0.0;
      Walking01_withElmos_B.ControlParams.Supervisory.ErrorVelZeroFactor[i] =
        0.0;
    }

    Walking01_withElmos_B.ControlParams.Supervisory.StanceLegInit = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.ControllerModeInit = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.UsePosingControl = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.TPosing = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.TorsoBackAngle = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.TorsoBackOnStep = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.EnergyControlGain = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.EnergyControlPhi0 = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.VelocityControlTorsoMax =
      0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.VelocityControlTorsoMin =
      0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.VelocityControlTorsoGain =
      0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.VelocityControlTorsoV0 = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.MinDeltaTheta = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.Theta0 = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.KThetaPlus = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.KThetaMinus = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.RollPhaseVelocityThresh =
      0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.RollPhaseSThresh = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.MaxError = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.MaxErrorVel = 0.0;
    Walking01_withElmos_B.ControlParams.Supervisory.MaxErrorCount = 0.0;
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_B.ControlParams.Supervisory.K1MidStanceUpdate[i] = 0.0;
      Walking01_withElmos_B.ControlParams.Supervisory.K2MidStanceUpdate[i] = 0.0;
    }

    Walking01_withElmos_B.ControlParams.Supervisory.EnableVelocityBasedUpdate =
      0.0;
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_B.ControlParams.Supervisory.VelocityBasedUpdateK1[i] =
        0.0;
      Walking01_withElmos_B.ControlParams.Supervisory.VelocityBasedUpdateK2[i] =
        0.0;
    }

    Walking01_withElmos_B.ControlParams.Supervisory.VelocityBasedUpdateDTheta0 =
      0.0;
    for (i = 0; i < 12; i++) {
      Walking01_withElmos_B.ControlParams.Supervisory.VelocityBasedUpdateLimits[i]
        = 0.0;
    }

    Walking01_withElmos_B.ControlParams.Supervisory.DesiredYawOffset = 0.0;
    Walking01_withElmos_B.ControlParams.Discrete.TLastUpdate = 0.0;
    Walking01_withElmos_B.ControlParams.Discrete.VelocityControlLADelta = 0.0;
    Walking01_withElmos_B.ControlParams.Discrete.VelocityControlTorsoDelta = 0.0;
    Walking01_withElmos_B.ControlParams.Discrete.VelocityControlHipDistCur = 0.0;
    Walking01_withElmos_B.ControlParams.Discrete.VelocityControlHipDistPrev =
      0.0;
    Walking01_withElmos_B.ControlParams.Discrete.VirtualSpringMode = 0.0;
    Walking01_withElmos_B.ControlParams.Discrete.VirtualSpringStiffness = 0.0;
    Walking01_withElmos_B.ControlParams.Discrete.VirtualSpringDamping = 0.0;
    Walking01_withElmos_B.ControlParams.Discrete.VirtualSpringModAmplitude = 0.0;
    Walking01_withElmos_B.ControlParams.Discrete.VirtualSpringModRate = 0.0;
    Walking01_withElmos_B.ControlParams.Discrete.VirtualSpringRestPos = 0.0;
    for (i = 0; i < 78; i++) {
      Walking01_withElmos_B.ControlParams.Output.H0[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      Walking01_withElmos_B.ControlParams.Output.HAlpha[i] = 0.0;
    }

    Walking01_withElmos_B.ControlParams.Output.ThetaLimits[0] = 0.0;
    Walking01_withElmos_B.ControlParams.Output.ThetaLimits[1] = 0.0;
    Walking01_withElmos_B.ControlParams.Output.Theta.c0 = 0.0;
    Walking01_withElmos_B.ControlParams.Output.Theta.ct = 0.0;
    for (i = 0; i < 13; i++) {
      Walking01_withElmos_B.ControlParams.Output.Theta.cq[i] = 0.0;
    }

    Walking01_withElmos_B.ControlParams.Output.Theta.t0 = 0.0;
    for (i = 0; i < 7; i++) {
      Walking01_withElmos_B.ControlParams.Output.Theta.cz[i] = 0.0;
    }

    Walking01_withElmos_B.ControlParams.Output.SaturateS = 0.0;
    Walking01_withElmos_B.ControlParams.Output.SLimits[0] = 0.0;
    Walking01_withElmos_B.ControlParams.Output.SLimits[1] = 0.0;
    Walking01_withElmos_B.ControlParams.Output.EnforceIncreasingS = 0.0;
    Walking01_withElmos_B.ControlParams.Output.UseCorrection = 0.0;
    Walking01_withElmos_B.ControlParams.Output.SMaxCorrection = 0.0;
    for (i = 0; i < 30; i++) {
      Walking01_withElmos_B.ControlParams.Output.HAlphaCorrection[i] = 0.0;
    }

    Walking01_withElmos_B.ControlParams.Output.Phi.c0 = 0.0;
    for (i = 0; i < 13; i++) {
      Walking01_withElmos_B.ControlParams.Output.Phi.cq[i] = 0.0;
    }

    for (i = 0; i < 20; i++) {
      Walking01_withElmos_B.ControlParams.Output.PhiAlpha[i] = 0.0;
    }

    Walking01_withElmos_B.ControlParams.Output.SaturateR = 0.0;
    Walking01_withElmos_B.ControlParams.Output.RLimits[0] = 0.0;
    Walking01_withElmos_B.ControlParams.Output.RLimits[1] = 0.0;
    for (i = 0; i < 30; i++) {
      Walking01_withElmos_B.ControlParams.Output.HBarAlpha[i] = 0.0;
    }

    for (i = 0; i < 12; i++) {
      Walking01_withElmos_B.ControlParams.Output.HBarLimits[i] = 0.0;
    }

    for (i = 0; i < 36; i++) {
      Walking01_withElmos_B.ControlParams.Output.HAlphaStar[i] = 0.0;
    }

    Walking01_withElmos_B.ControlParams.Output.YawLimit = 0.0;
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_B.ControlParams.Feedback.kp[i] = 0.0;
      Walking01_withElmos_B.ControlParams.Feedback.kd[i] = 0.0;
    }

    Walking01_withElmos_B.ControlParams.Feedback.epsilon[0] = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.epsilon[1] = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.kff_grav[0] = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.kff_grav[1] = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.delta_grav = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.kff_decoup[0] = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.kff_decoup[1] = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.kd_torso[0] = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.kd_torso[1] = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.kp_2dof = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.kd_2dof = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.kpre_2dof = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.kp_lat = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.kd_lat = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.q3d_min_lat = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.q3d_max_lat = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.w_torso_lat = 0.0;
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_B.ControlParams.Feedback.u_ff[i] = 0.0;
    }

    Walking01_withElmos_B.ControlParams.Feedback.LateralControlMode = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.DecouplingMode = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.Use2DOF = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.UseDSGravComp = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.lat_bias = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.lat_bias2 = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.linkFeedback = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.RIO = 0.0;
    Walking01_withElmos_B.ControlParams.Feedback.SelectFeedforward = 0.0;
    for (i = 0; i < 6; i++) {
      Walking01_withElmos_B.ControlParams.Feedback.FeedforwardGain[i] = 0.0;
    }

    Walking01_withElmos_B.ControlParams.Feedback.EnableFeedforwardOnStep = 0.0;
    Walking01_withElmos_B.ControlParams.Saturation.UseQPSaturation = 0.0;
    Walking01_withElmos_B.ControlParams.Saturation.QPWeight[0] = 0.0;
    Walking01_withElmos_B.ControlParams.Saturation.QPWeight[1] = 0.0;
    Walking01_withElmos_B.ControlParams.Saturation.UseKASaturation = 0.0;
    Walking01_withElmos_B.ControlParams.Saturation.KASaturationS1 = 0.0;
    Walking01_withElmos_B.ControlParams.Saturation.KASaturationS2 = 0.0;
    Walking01_withElmos_B.ControlParams.Saturation.KASaturationEarly = 0.0;
    Walking01_withElmos_B.ControlParams.Saturation.KASaturationMax = 0.0;
    for (i = 0; i < 5; i++) {
      Walking01_withElmos_B.SerialOut[i] = 0.0;
    }

    /* End of InitializeConditions for Chart: '<S202>/StateLogic' */

    /* InitializeConditions for UnitDelay: '<S200>/Unit Delay' */
    Walking01_withElmos_DW.UnitDelay_DSTATE_d = 0.0;

    /* InitializeConditions for Atomic SubSystem: '<S5>/SerialInterfaces' */
    /* InitializeConditions for UnitDelay: '<S124>/Unit Delay2' */
    memcpy(&Walking01_withElmos_DW.UnitDelay2_DSTATE_o[0],
           Walking01_withElmos_ConstP.pooled23, 9U * sizeof(real_T));

    /* InitializeConditions for UnitDelay: '<S124>/Unit Delay1' */
    Walking01_withElmos_DW.UnitDelay1_DSTATE_c[0] = 0.0;
    Walking01_withElmos_DW.UnitDelay1_DSTATE_c[1] = 0.0;

    /* End of InitializeConditions for SubSystem: '<S5>/SerialInterfaces' */

    /* InitializeConditions for UnitDelay: '<S200>/Unit Delay1' */
    Walking01_withElmos_DW.UnitDelay1_DSTATE_g = 0.0;

    /* InitializeConditions for S-Function (sdspcount2): '<S21>/Counter' */
    Walking01_withElmos_DW.Counter_Count_o = ((uint8_T)0U);

    /* InitializeConditions for DiscreteFilter: '<S21>/Discrete Filter' */
    memcpy(&Walking01_withElmos_DW.DiscreteFilter_states[0],
           Walking01_withElmos_ConstP.DiscreteFilter_Initi, 30U * sizeof(real_T));

    /* InitializeConditions for UnitDelay: '<S1>/Unit Delay' */
    Walking01_withElmos_DW.UnitDelay_DSTATE_k = 0.0;

    /* InitializeConditions for UnitDelay: '<S1>/Unit Delay1' */
    Walking01_withElmos_DW.UnitDelay1_DSTATE_h[0] = 0.0;
    Walking01_withElmos_DW.UnitDelay1_DSTATE_h[1] = 0.0;
    Walking01_withElmos_DW.UnitDelay1_DSTATE_h[2] = 0.0;
    Walking01_withElmos_DW.UnitDelay1_DSTATE_h[3] = 0.0;

    /* InitializeConditions for RateTransition: '<S1>/Rate Transition1' */
    Walking01_withElmos_DW.RateTransition1_Buffer0_i = 0U;

    /* InitializeConditions for RateTransition: '<S1>/Rate Transition' */
    Walking01_withElmos_DW.RateTransition_Buffer0 = 0U;

    /* InitializeConditions for Chart: '<S35>/Chart' */
    Walking01_withElmos_Chart_Init(&Walking01_withElmos_DW.sf_Chart);

    /* InitializeConditions for Chart: '<S37>/Chart' */
    Walking01_withElmos_Chart_Init(&Walking01_withElmos_DW.sf_Chart_b);

    /* InitializeConditions for Chart: '<S34>/Chart' */
    Walking01_withElmos_DW.sfEvent_a = -1;
    Walking01_withElmos_DW.is_Initialization_h = Walking01__IN_NO_ACTIVE_CHILD_j;
    Walking01_withElmos_DW.is_active_c20_Walking01_withElm = 0U;
    Walking01_withElmos_DW.is_c20_Walking01_withElmos =
      Walking01__IN_NO_ACTIVE_CHILD_j;

    /* InitializeConditions for Chart: '<S36>/Chart' */
    Walking01_withElmos_DW.sfEvent_p = -1;
    Walking01_withElmos_DW.is_Initialization = Walking01__IN_NO_ACTIVE_CHILD_j;
    Walking01_withElmos_DW.is_active_c23_Walking01_withElm = 0U;
    Walking01_withElmos_DW.is_c23_Walking01_withElmos =
      Walking01__IN_NO_ACTIVE_CHILD_j;

    /* InitializeConditions for Delay: '<S4>/Resettable Delay' */
    Walking01_withElmos_DW.icLoad = 1U;

    /* InitializeConditions for S-Function (sdspcount2): '<S19>/Counter' */
    Walking01_withElmos_DW.Counter_Count = ((uint16_T)0U);
  }
}

/* Model terminate function */
void Walking01_withElmos_terminate(void)
{
  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[6];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[7];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[8];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[9];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[10];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[11];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[12];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[13];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[14];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[15];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var ' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[16];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var ' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[17];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var ' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[18];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var ' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[19];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[20];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[21];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[22];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[23];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[24];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[25];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[26];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[27];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[28];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[29];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[30];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[31];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[32];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[33];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[34];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[35];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[36];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[37];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[38];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[39];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[40];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[41];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[42];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[43];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[44];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[45];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[46];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[47];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[48];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[49];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[50];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[51];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[52];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[53];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[54];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[55];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[56];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[57];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[58];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[59];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[60];
    sfcnTerminate(rts);
  }

  /* Terminate for Atomic SubSystem: '<S5>/SerialInterfaces' */

  /* Level2 S-Function Block: '<S193>/Board Setup' (board_setup_tews_XR17D15x) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[2];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S193>/Setup3' (setup_tews_XR17D15x) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[3];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S193>/Read HW FIFO' (read_hw_fifo_XR17D15x) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[4];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S193>/FIFO write 1' (fifowrite) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[5];
    sfcnTerminate(rts);
  }

  /* Terminate for Iterator SubSystem: '<S124>/UpdateOrientation' */

  /* Level2 S-Function Block: '<S194>/FIFO bin read ' (fiforeadbinhdrmultiple) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[1];
    sfcnTerminate(rts);
  }

  /* End of Terminate for SubSystem: '<S124>/UpdateOrientation' */

  /* End of Terminate for SubSystem: '<S5>/SerialInterfaces' */

  /* Level2 S-Function Block: '<S4>/Task Execution Time ' (xpctimeinfo) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[61];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[62];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[63];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[64];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[65];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[66];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[67];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[68];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[69];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[70];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[71];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[72];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[73];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[74];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[75];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[76];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[77];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[78];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[79];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[80];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[81];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[82];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[83];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[84];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[85];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[86];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[87];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[88];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[89];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[90];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[91];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S1>/Get Overload Counter ' (xpcgetoverload) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[92];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S64>/EtherCAT PDO Receive' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[93];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S100>/EtherCAT PDO Receive' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[94];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S46>/EtherCAT PDO Receive' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[95];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S82>/EtherCAT PDO Receive' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[96];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S64>/EtherCAT PDO Receive3' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[97];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S100>/EtherCAT PDO Receive3' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[98];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S46>/EtherCAT PDO Receive3' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[99];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S82>/EtherCAT PDO Receive3' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[100];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S64>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[101];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S100>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[102];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S46>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[103];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S82>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[104];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S64>/EtherCAT PDO Receive4' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[105];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S100>/EtherCAT PDO Receive4' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[106];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S46>/EtherCAT PDO Receive4' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[107];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S82>/EtherCAT PDO Receive4' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[108];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S64>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[109];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S100>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[110];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S46>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[111];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S82>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[112];
    sfcnTerminate(rts);
  }

  /* Terminate for Enabled SubSystem: '<S4>/Reset CPU Overload Count' */

  /* Level2 S-Function Block: '<S12>/xPC Set Overload Counter' (xpcsetoverload) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[0];
    sfcnTerminate(rts);
  }

  /* End of Terminate for SubSystem: '<S4>/Reset CPU Overload Count' */

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[113];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[114];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[115];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[116];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var ' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[117];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[118];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[119];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[120];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[121];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var ' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[122];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[123];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[124];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[125];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[126];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[127];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[128];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[129];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[130];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[131];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[132];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[133];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[134];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[135];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[136];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[137];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[138];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S32>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[139];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[140];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[141];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[142];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S31>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[143];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[144];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[145];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[146];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[147];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[148];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[149];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[150];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[151];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[152];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[153];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[154];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[155];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[156];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[157];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[158];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[159];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[160];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[161];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[162];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[163];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[164];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[165];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[166];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[167];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[168];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[169];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S31>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[170];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S31>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[171];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S31>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[172];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S32>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[173];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S32>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[174];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S32>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[175];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[176];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[177];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S33>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[178];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S33>/EtherCAT Tx Var ' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[179];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S33>/EtherCAT Tx Var 1' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[180];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S33>/EtherCAT Tx Var 2' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[181];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S46>/EtherCAT PDO Receive2' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[182];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S46>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[183];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S46>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[184];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S46>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[185];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S64>/EtherCAT PDO Receive2' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[186];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S64>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[187];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S64>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[188];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S64>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[189];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S82>/EtherCAT PDO Receive2' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[190];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S82>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[191];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S82>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[192];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S82>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[193];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S100>/EtherCAT PDO Receive2' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[194];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S100>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[195];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S100>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[196];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S100>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[197];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[198];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[199];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S38>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[200];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[201];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[202];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S39>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[203];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[204];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[205];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S40>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[206];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[207];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[208];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S41>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[209];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S1>/Get Overload Counter 1' (xpcgetoverload) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[210];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S1>/Get Overload Counter 2' (xpcgetoverload) */
  {
    SimStruct *rts = Walking01_withElmos_M->childSfunctions[211];
    sfcnTerminate(rts);
  }

  /* user code (Terminate function Trailer) */

  /*------------ S-Function Block: <S19>/EtherCAT Init  Process Shutdown Network ------------*/
  {
    int_T status;
    if (!xpcIsModelInit()) {
      status = xpcEtherCATstop(0, 1000 /* 1 second timeout */
        );
    }
  }
}

/*========================================================================*
 * Start of Classic call interface                                        *
 *========================================================================*/
void MdlOutputs(int_T tid)
{
  Walking01_withElmos_output(tid);
}

void MdlUpdate(int_T tid)
{
  Walking01_withElmos_update(tid);
}

void MdlInitializeSizes(void)
{
}

void MdlInitializeSampleTimes(void)
{
}

void MdlInitialize(void)
{
}

void MdlStart(void)
{
  Walking01_withElmos_initialize();
}

void MdlTerminate(void)
{
  Walking01_withElmos_terminate();
}

/* Registration function */
RT_MODEL_Walking01_withElmos_T *Walking01_withElmos(void)
{
  /* Registration code */

  /* initialize non-finites */
  rt_InitInfAndNaN(sizeof(real_T));

  /* non-finite (run-time) assignments */
  Walking01_withElmos_ConstInitP.EncoderAngleLimits_V[10] = rtMinusInf;
  Walking01_withElmos_ConstInitP.EncoderAngleLimits_V[11] = rtMinusInf;
  Walking01_withElmos_ConstInitP.EncoderAngleLimits_V[12] = rtMinusInf;
  Walking01_withElmos_ConstInitP.EncoderAngleLimits_V[13] = rtMinusInf;
  Walking01_withElmos_ConstInitP.EncoderAngleLimits_V[16] = rtMinusInf;
  Walking01_withElmos_ConstInitP.EncoderAngleLimits_V[29] = rtInf;
  Walking01_withElmos_ConstInitP.EncoderAngleLimits_V[30] = rtInf;
  Walking01_withElmos_ConstInitP.EncoderAngleLimits_V[31] = rtInf;
  Walking01_withElmos_ConstInitP.EncoderAngleLimits_V[32] = rtInf;
  Walking01_withElmos_ConstInitP.EncoderAngleLimits_V[35] = rtInf;

  /* initialize real-time model */
  (void) memset((void *)Walking01_withElmos_M, 0,
                sizeof(RT_MODEL_Walking01_withElmos_T));
  rtsiSetSolverName(&Walking01_withElmos_M->solverInfo,"FixedStepDiscrete");
  Walking01_withElmos_M->solverInfoPtr = (&Walking01_withElmos_M->solverInfo);

  /* Initialize timing info */
  {
    int_T *mdlTsMap = Walking01_withElmos_M->Timing.sampleTimeTaskIDArray;
    mdlTsMap[0] = 0;
    mdlTsMap[1] = 1;
    mdlTsMap[2] = 2;
    Walking01_withElmos_M->Timing.sampleTimeTaskIDPtr = (&mdlTsMap[0]);
    Walking01_withElmos_M->Timing.sampleTimes =
      (&Walking01_withElmos_M->Timing.sampleTimesArray[0]);
    Walking01_withElmos_M->Timing.offsetTimes =
      (&Walking01_withElmos_M->Timing.offsetTimesArray[0]);

    /* task periods */
    Walking01_withElmos_M->Timing.sampleTimes[0] = (0.0005);
    Walking01_withElmos_M->Timing.sampleTimes[1] = (0.001);
    Walking01_withElmos_M->Timing.sampleTimes[2] = (0.002);

    /* task offsets */
    Walking01_withElmos_M->Timing.offsetTimes[0] = (0.0);
    Walking01_withElmos_M->Timing.offsetTimes[1] = (0.0);
    Walking01_withElmos_M->Timing.offsetTimes[2] = (0.0);
  }

  rtmSetTPtr(Walking01_withElmos_M, &Walking01_withElmos_M->Timing.tArray[0]);

  {
    int_T *mdlSampleHits = Walking01_withElmos_M->Timing.sampleHitArray;
    int_T *mdlPerTaskSampleHits =
      Walking01_withElmos_M->Timing.perTaskSampleHitsArray;
    Walking01_withElmos_M->Timing.perTaskSampleHits = (&mdlPerTaskSampleHits[0]);
    mdlSampleHits[0] = 1;
    Walking01_withElmos_M->Timing.sampleHits = (&mdlSampleHits[0]);
  }

  rtmSetTFinal(Walking01_withElmos_M, -1);
  Walking01_withElmos_M->Timing.stepSize0 = 0.0005;
  Walking01_withElmos_M->Timing.stepSize1 = 0.001;
  Walking01_withElmos_M->Timing.stepSize2 = 0.002;

  /* Setup for data logging */
  {
    static RTWLogInfo rt_DataLoggingInfo;
    Walking01_withElmos_M->rtwLogInfo = &rt_DataLoggingInfo;
  }

  /* Setup for data logging */
  {
    rtliSetLogXSignalInfo(Walking01_withElmos_M->rtwLogInfo, (NULL));
    rtliSetLogXSignalPtrs(Walking01_withElmos_M->rtwLogInfo, (NULL));
    rtliSetLogT(Walking01_withElmos_M->rtwLogInfo, "tout");
    rtliSetLogX(Walking01_withElmos_M->rtwLogInfo, "");
    rtliSetLogXFinal(Walking01_withElmos_M->rtwLogInfo, "");
    rtliSetLogVarNameModifier(Walking01_withElmos_M->rtwLogInfo, "rt_");
    rtliSetLogFormat(Walking01_withElmos_M->rtwLogInfo, 0);
    rtliSetLogMaxRows(Walking01_withElmos_M->rtwLogInfo, 0);
    rtliSetLogDecimation(Walking01_withElmos_M->rtwLogInfo, 1);

    /*
     * Set pointers to the data and signal info for each output
     */
    {
      static void * rt_LoggedOutputSignalPtrs[] = {
        &Walking01_withElmos_Y.q[0],
        &Walking01_withElmos_Y.dq[0],
        &Walking01_withElmos_Y.u[0],
        &Walking01_withElmos_Y.y[0],
        &Walking01_withElmos_Y.dy[0],
        &Walking01_withElmos_Y.hd[0],
        &Walking01_withElmos_Y.s,
        &Walking01_withElmos_Y.s_unsaturated,
        &Walking01_withElmos_Y.ds,
        &Walking01_withElmos_Y.theta,
        &Walking01_withElmos_Y.phi,
        &Walking01_withElmos_Y.r,
        &Walking01_withElmos_Y.hdbar[0],
        &Walking01_withElmos_Y.ControlState[0],
        &Walking01_withElmos_Y.SerialOut[0],
        &Walking01_withElmos_Y.u_star[0],
        &Walking01_withElmos_Y.u_pd[0],
        &Walking01_withElmos_Y.Switches,
        &Walking01_withElmos_Y.MedullaState[0],
        &Walking01_withElmos_Y.ErrorFlags[0],
        &Walking01_withElmos_Y.Counters[0],
        &Walking01_withElmos_Y.EtherCATStatus[0],
        &Walking01_withElmos_Y.KVHEulerAngles[0],
        &Walking01_withElmos_Y.KVHEulerAngleDeriv[0],
        &Walking01_withElmos_Y.KVHStatus,
        &Walking01_withElmos_Y.KVHSequence[0],
        &Walking01_withElmos_Y.KVHValid,
        &Walking01_withElmos_Y.AnomalyCounts[0],
        &Walking01_withElmos_Y.MicrostrainEulerAnglesClean[0],
        &Walking01_withElmos_Y.MicrostrainEulerAngleDerivsClea[0],
        &Walking01_withElmos_Y.SafetyState,
        &Walking01_withElmos_Y.MotorCurrentSafe[0],
        &Walking01_withElmos_Y.CPUOverloadRegulator,
        &Walking01_withElmos_Y.CPUOverloadCounter[0],
        &Walking01_withElmos_Y.MedullaCommandSafe,
        &Walking01_withElmos_Y.FTStatus,
        &Walking01_withElmos_Y.FT,
        &Walking01_withElmos_Y.EncoderAnglesDirty[0],
        &Walking01_withElmos_Y.CurrentActual[0],
        &Walking01_withElmos_Y.CurrentDemanded[0],
        &Walking01_withElmos_Y.HallPosition[0],
        &Walking01_withElmos_Y.HallVelocity[0],
        &Walking01_withElmos_Y.FaultDetected[0]
      };

      rtliSetLogYSignalPtrs(Walking01_withElmos_M->rtwLogInfo,
                            ((LogSignalPtrsType)rt_LoggedOutputSignalPtrs));
    }

    {
      static int_T rt_LoggedOutputWidths[] = {
        13,
        13,
        6,
        6,
        6,
        6,
        1,
        1,
        1,
        1,
        1,
        1,
        6,
        7,
        5,
        6,
        6,
        1,
        7,
        7,
        7,
        6,
        3,
        3,
        1,
        2,
        1,
        22,
        3,
        3,
        1,
        6,
        1,
        3,
        1,
        1,
        1,
        19,
        4,
        4,
        4,
        4,
        4
      };

      static int_T rt_LoggedOutputNumDimensions[] = {
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1
      };

      static int_T rt_LoggedOutputDimensions[] = {
        13,
        13,
        6,
        6,
        6,
        6,
        1,
        1,
        1,
        1,
        1,
        1,
        6,
        7,
        5,
        6,
        6,
        1,
        7,
        7,
        7,
        6,
        3,
        3,
        1,
        2,
        1,
        22,
        3,
        3,
        1,
        6,
        1,
        3,
        1,
        1,
        1,
        19,
        4,
        4,
        4,
        4,
        4
      };

      static boolean_T rt_LoggedOutputIsVarDims[] = {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      };

      static void* rt_LoggedCurrentSignalDimensions[] = {
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL)
      };

      static int_T rt_LoggedCurrentSignalDimensionsSize[] = {
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4
      };

      static BuiltInDTypeId rt_LoggedOutputDataTypeIds[] = {
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE
      };

      static int_T rt_LoggedOutputComplexSignals[] = {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      };

      static const char_T *rt_LoggedOutputLabels[] = {
        "q",
        "dq",
        "u",
        "y",
        "dy",
        "hd",
        "s",
        "s_unsat",
        "ds",
        "theta",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "" };

      static const char_T *rt_LoggedOutputBlockNames[] = {
        "Walking01_withElmos/q",
        "Walking01_withElmos/dq",
        "Walking01_withElmos/u",
        "Walking01_withElmos/y",
        "Walking01_withElmos/dy",
        "Walking01_withElmos/hd",
        "Walking01_withElmos/s",
        "Walking01_withElmos/s_unsaturated",
        "Walking01_withElmos/ds",
        "Walking01_withElmos/theta",
        "Walking01_withElmos/phi",
        "Walking01_withElmos/r",
        "Walking01_withElmos/hdbar",
        "Walking01_withElmos/ControlState",
        "Walking01_withElmos/SerialOut",
        "Walking01_withElmos/u_star",
        "Walking01_withElmos/u_pd",
        "Walking01_withElmos/Switches",
        "Walking01_withElmos/MedullaState",
        "Walking01_withElmos/ErrorFlags",
        "Walking01_withElmos/Counters",
        "Walking01_withElmos/EtherCATStatus",
        "Walking01_withElmos/KVHEulerAngles",
        "Walking01_withElmos/KVHEulerAngleDeriv",
        "Walking01_withElmos/KVHStatus",
        "Walking01_withElmos/KVHSequence",
        "Walking01_withElmos/KVHValid",
        "Walking01_withElmos/AnomalyCounts",
        "Walking01_withElmos/MicrostrainEulerAnglesClean",
        "Walking01_withElmos/MicrostrainEulerAngleDerivsClean",
        "Walking01_withElmos/SafetyState",
        "Walking01_withElmos/MotorCurrentSafe",
        "Walking01_withElmos/CPUOverloadRegulator",
        "Walking01_withElmos/CPUOverloadCounter",
        "Walking01_withElmos/MedullaCommandSafe",
        "Walking01_withElmos/FTStatus",
        "Walking01_withElmos/FT",
        "Walking01_withElmos/EncoderAnglesDirty",
        "Walking01_withElmos/CurrentActual",
        "Walking01_withElmos/CurrentDemanded",
        "Walking01_withElmos/HallPosition",
        "Walking01_withElmos/HallVelocity",
        "Walking01_withElmos/FaultDetected" };

      static RTWLogDataTypeConvert rt_RTWLogDataTypeConvert[] = {
        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 }
      };

      static RTWLogSignalInfo rt_LoggedOutputSignalInfo[] = {
        {
          43,
          rt_LoggedOutputWidths,
          rt_LoggedOutputNumDimensions,
          rt_LoggedOutputDimensions,
          rt_LoggedOutputIsVarDims,
          rt_LoggedCurrentSignalDimensions,
          rt_LoggedCurrentSignalDimensionsSize,
          rt_LoggedOutputDataTypeIds,
          rt_LoggedOutputComplexSignals,
          (NULL),

          { rt_LoggedOutputLabels },
          (NULL),
          (NULL),
          (NULL),

          { rt_LoggedOutputBlockNames },

          { (NULL) },
          (NULL),
          rt_RTWLogDataTypeConvert
        }
      };

      rtliSetLogYSignalInfo(Walking01_withElmos_M->rtwLogInfo,
                            rt_LoggedOutputSignalInfo);

      /* set currSigDims field */
      rt_LoggedCurrentSignalDimensions[0] = &rt_LoggedOutputWidths[0];
      rt_LoggedCurrentSignalDimensions[1] = &rt_LoggedOutputWidths[1];
      rt_LoggedCurrentSignalDimensions[2] = &rt_LoggedOutputWidths[2];
      rt_LoggedCurrentSignalDimensions[3] = &rt_LoggedOutputWidths[3];
      rt_LoggedCurrentSignalDimensions[4] = &rt_LoggedOutputWidths[4];
      rt_LoggedCurrentSignalDimensions[5] = &rt_LoggedOutputWidths[5];
      rt_LoggedCurrentSignalDimensions[6] = &rt_LoggedOutputWidths[6];
      rt_LoggedCurrentSignalDimensions[7] = &rt_LoggedOutputWidths[7];
      rt_LoggedCurrentSignalDimensions[8] = &rt_LoggedOutputWidths[8];
      rt_LoggedCurrentSignalDimensions[9] = &rt_LoggedOutputWidths[9];
      rt_LoggedCurrentSignalDimensions[10] = &rt_LoggedOutputWidths[10];
      rt_LoggedCurrentSignalDimensions[11] = &rt_LoggedOutputWidths[11];
      rt_LoggedCurrentSignalDimensions[12] = &rt_LoggedOutputWidths[12];
      rt_LoggedCurrentSignalDimensions[13] = &rt_LoggedOutputWidths[13];
      rt_LoggedCurrentSignalDimensions[14] = &rt_LoggedOutputWidths[14];
      rt_LoggedCurrentSignalDimensions[15] = &rt_LoggedOutputWidths[15];
      rt_LoggedCurrentSignalDimensions[16] = &rt_LoggedOutputWidths[16];
      rt_LoggedCurrentSignalDimensions[17] = &rt_LoggedOutputWidths[17];
      rt_LoggedCurrentSignalDimensions[18] = &rt_LoggedOutputWidths[18];
      rt_LoggedCurrentSignalDimensions[19] = &rt_LoggedOutputWidths[19];
      rt_LoggedCurrentSignalDimensions[20] = &rt_LoggedOutputWidths[20];
      rt_LoggedCurrentSignalDimensions[21] = &rt_LoggedOutputWidths[21];
      rt_LoggedCurrentSignalDimensions[22] = &rt_LoggedOutputWidths[22];
      rt_LoggedCurrentSignalDimensions[23] = &rt_LoggedOutputWidths[23];
      rt_LoggedCurrentSignalDimensions[24] = &rt_LoggedOutputWidths[24];
      rt_LoggedCurrentSignalDimensions[25] = &rt_LoggedOutputWidths[25];
      rt_LoggedCurrentSignalDimensions[26] = &rt_LoggedOutputWidths[26];
      rt_LoggedCurrentSignalDimensions[27] = &rt_LoggedOutputWidths[27];
      rt_LoggedCurrentSignalDimensions[28] = &rt_LoggedOutputWidths[28];
      rt_LoggedCurrentSignalDimensions[29] = &rt_LoggedOutputWidths[29];
      rt_LoggedCurrentSignalDimensions[30] = &rt_LoggedOutputWidths[30];
      rt_LoggedCurrentSignalDimensions[31] = &rt_LoggedOutputWidths[31];
      rt_LoggedCurrentSignalDimensions[32] = &rt_LoggedOutputWidths[32];
      rt_LoggedCurrentSignalDimensions[33] = &rt_LoggedOutputWidths[33];
      rt_LoggedCurrentSignalDimensions[34] = &rt_LoggedOutputWidths[34];
      rt_LoggedCurrentSignalDimensions[35] = &rt_LoggedOutputWidths[35];
      rt_LoggedCurrentSignalDimensions[36] = &rt_LoggedOutputWidths[36];
      rt_LoggedCurrentSignalDimensions[37] = &rt_LoggedOutputWidths[37];
      rt_LoggedCurrentSignalDimensions[38] = &rt_LoggedOutputWidths[38];
      rt_LoggedCurrentSignalDimensions[39] = &rt_LoggedOutputWidths[39];
      rt_LoggedCurrentSignalDimensions[40] = &rt_LoggedOutputWidths[40];
      rt_LoggedCurrentSignalDimensions[41] = &rt_LoggedOutputWidths[41];
      rt_LoggedCurrentSignalDimensions[42] = &rt_LoggedOutputWidths[42];
    }

    rtliSetLogY(Walking01_withElmos_M->rtwLogInfo, "yout");
  }

  /* External mode info */
  Walking01_withElmos_M->Sizes.checksums[0] = (654870487U);
  Walking01_withElmos_M->Sizes.checksums[1] = (1233570073U);
  Walking01_withElmos_M->Sizes.checksums[2] = (4040884438U);
  Walking01_withElmos_M->Sizes.checksums[3] = (4144415613U);

  {
    static const sysRanDType rtAlwaysEnabled = SUBSYS_RAN_BC_ENABLE;
    static RTWExtModeInfo rt_ExtModeInfo;
    static const sysRanDType *systemRan[55];
    Walking01_withElmos_M->extModeInfo = (&rt_ExtModeInfo);
    rteiSetSubSystemActiveVectorAddresses(&rt_ExtModeInfo, systemRan);
    systemRan[0] = &rtAlwaysEnabled;
    systemRan[1] = &rtAlwaysEnabled;
    systemRan[2] = (sysRanDType *)
      &Walking01_withElmos_DW.ResetCPUOverloadCount_SubsysRan;
    systemRan[3] = &rtAlwaysEnabled;
    systemRan[4] = &rtAlwaysEnabled;
    systemRan[5] = &rtAlwaysEnabled;
    systemRan[6] = &rtAlwaysEnabled;
    systemRan[7] = &rtAlwaysEnabled;
    systemRan[8] = &rtAlwaysEnabled;
    systemRan[9] = &rtAlwaysEnabled;
    systemRan[10] = &rtAlwaysEnabled;
    systemRan[11] = &rtAlwaysEnabled;
    systemRan[12] = &rtAlwaysEnabled;
    systemRan[13] = &rtAlwaysEnabled;
    systemRan[14] = &rtAlwaysEnabled;
    systemRan[15] = &rtAlwaysEnabled;
    systemRan[16] = &rtAlwaysEnabled;
    systemRan[17] = (sysRanDType *)
      &Walking01_withElmos_DW.EnableControlWord.EnableControlWord_SubsysRanBC;
    systemRan[18] = (sysRanDType *)
      &Walking01_withElmos_DW.FaultReset.FaultReset_SubsysRanBC;
    systemRan[19] = (sysRanDType *)
      &Walking01_withElmos_DW.NothingControlWord.NothingControlWord_SubsysRanBC;
    systemRan[20] = (sysRanDType *)
      &Walking01_withElmos_DW.ShutdownControlWord.ShutdownControlWord_SubsysRanBC;
    systemRan[21] = &rtAlwaysEnabled;
    systemRan[22] = &rtAlwaysEnabled;
    systemRan[23] = (sysRanDType *)
      &Walking01_withElmos_DW.EnableControlWord_c.EnableControlWord_SubsysRanBC;
    systemRan[24] = (sysRanDType *)
      &Walking01_withElmos_DW.FaultReset_c.FaultReset_SubsysRanBC;
    systemRan[25] = (sysRanDType *)
      &Walking01_withElmos_DW.NothingControlWord_d.NothingControlWord_SubsysRanBC;
    systemRan[26] = (sysRanDType *)
      &Walking01_withElmos_DW.ShutdownControlWord_h.ShutdownControlWord_SubsysRanBC;
    systemRan[27] = &rtAlwaysEnabled;
    systemRan[28] = &rtAlwaysEnabled;
    systemRan[29] = (sysRanDType *)
      &Walking01_withElmos_DW.EnableControlWord_l.EnableControlWord_SubsysRanBC;
    systemRan[30] = (sysRanDType *)
      &Walking01_withElmos_DW.FaultReset_n.FaultReset_SubsysRanBC;
    systemRan[31] = (sysRanDType *)
      &Walking01_withElmos_DW.NothingControlWord_k.NothingControlWord_SubsysRanBC;
    systemRan[32] = (sysRanDType *)
      &Walking01_withElmos_DW.ShutdownControlWord_j.ShutdownControlWord_SubsysRanBC;
    systemRan[33] = &rtAlwaysEnabled;
    systemRan[34] = &rtAlwaysEnabled;
    systemRan[35] = (sysRanDType *)
      &Walking01_withElmos_DW.EnableControlWord_m.EnableControlWord_SubsysRanBC;
    systemRan[36] = (sysRanDType *)
      &Walking01_withElmos_DW.FaultReset_i.FaultReset_SubsysRanBC;
    systemRan[37] = (sysRanDType *)
      &Walking01_withElmos_DW.NothingControlWord_m.NothingControlWord_SubsysRanBC;
    systemRan[38] = (sysRanDType *)
      &Walking01_withElmos_DW.ShutdownControlWord_ju.ShutdownControlWord_SubsysRanBC;
    systemRan[39] = &rtAlwaysEnabled;
    systemRan[40] = &rtAlwaysEnabled;
    systemRan[41] = &rtAlwaysEnabled;
    systemRan[42] = &rtAlwaysEnabled;
    systemRan[43] = &rtAlwaysEnabled;
    systemRan[44] = &rtAlwaysEnabled;
    systemRan[45] = &rtAlwaysEnabled;
    systemRan[46] = &rtAlwaysEnabled;
    systemRan[47] = &rtAlwaysEnabled;
    systemRan[48] = &rtAlwaysEnabled;
    systemRan[49] = &rtAlwaysEnabled;
    systemRan[50] = &rtAlwaysEnabled;
    systemRan[51] = &rtAlwaysEnabled;
    systemRan[52] = &rtAlwaysEnabled;
    systemRan[53] = &rtAlwaysEnabled;
    systemRan[54] = &rtAlwaysEnabled;
    rteiSetModelMappingInfoPtr(Walking01_withElmos_M->extModeInfo,
      &Walking01_withElmos_M->SpecialInfo.mappingInfo);
    rteiSetChecksumsPtr(Walking01_withElmos_M->extModeInfo,
                        Walking01_withElmos_M->Sizes.checksums);
    rteiSetTPtr(Walking01_withElmos_M->extModeInfo, rtmGetTPtr
                (Walking01_withElmos_M));
  }

  Walking01_withElmos_M->solverInfoPtr = (&Walking01_withElmos_M->solverInfo);
  Walking01_withElmos_M->Timing.stepSize = (0.0005);
  rtsiSetFixedStepSize(&Walking01_withElmos_M->solverInfo, 0.0005);
  rtsiSetSolverMode(&Walking01_withElmos_M->solverInfo, SOLVER_MODE_MULTITASKING);

  /* block I/O */
  Walking01_withElmos_M->ModelData.blockIO = ((void *) &Walking01_withElmos_B);
  (void) memset(((void *) &Walking01_withElmos_B), 0,
                sizeof(B_Walking01_withElmos_T));

  {
    Walking01_withElmos_B.FIFOwrite1 = serialfifoground;
  }

  /* parameters */
  Walking01_withElmos_M->ModelData.defaultParam = ((real_T *)
    &Walking01_withElmos_P);

  /* states (dwork) */
  Walking01_withElmos_M->ModelData.dwork = ((void *) &Walking01_withElmos_DW);
  (void) memset((void *)&Walking01_withElmos_DW, 0,
                sizeof(DW_Walking01_withElmos_T));

  /* external outputs */
  Walking01_withElmos_M->ModelData.outputs = (&Walking01_withElmos_Y);
  (void) memset((void *)&Walking01_withElmos_Y, 0,
                sizeof(ExtY_Walking01_withElmos_T));

  /* data type transition information */
  {
    static DataTypeTransInfo dtInfo;
    (void) memset((char_T *) &dtInfo, 0,
                  sizeof(dtInfo));
    Walking01_withElmos_M->SpecialInfo.mappingInfo = (&dtInfo);
    Walking01_withElmos_M->SpecialInfo.xpcData = ((void*) &dtInfo);
    dtInfo.numDataTypes = 33;
    dtInfo.dataTypeSizes = &rtDataTypeSizes[0];
    dtInfo.dataTypeNames = &rtDataTypeNames[0];

    /* Block I/O transition table */
    dtInfo.B = &rtBTransTable;

    /* Parameters transition table */
    dtInfo.P = &rtPTransTable;
  }

  /* Initialize DataMapInfo substructure containing ModelMap for C API */
  Walking01_withElmos_InitializeDataMapInfo(Walking01_withElmos_M);

  /* child S-Function registration */
  {
    RTWSfcnInfo *sfcnInfo = &Walking01_withElmos_M->NonInlinedSFcns.sfcnInfo;
    Walking01_withElmos_M->sfcnInfo = (sfcnInfo);
    rtssSetErrorStatusPtr(sfcnInfo, (&rtmGetErrorStatus(Walking01_withElmos_M)));
    rtssSetNumRootSampTimesPtr(sfcnInfo,
      &Walking01_withElmos_M->Sizes.numSampTimes);
    Walking01_withElmos_M->NonInlinedSFcns.taskTimePtrs[0] = &(rtmGetTPtr
      (Walking01_withElmos_M)[0]);
    Walking01_withElmos_M->NonInlinedSFcns.taskTimePtrs[1] = &(rtmGetTPtr
      (Walking01_withElmos_M)[1]);
    Walking01_withElmos_M->NonInlinedSFcns.taskTimePtrs[2] = &(rtmGetTPtr
      (Walking01_withElmos_M)[2]);
    rtssSetTPtrPtr(sfcnInfo,Walking01_withElmos_M->NonInlinedSFcns.taskTimePtrs);
    rtssSetTStartPtr(sfcnInfo, &rtmGetTStart(Walking01_withElmos_M));
    rtssSetTFinalPtr(sfcnInfo, &rtmGetTFinal(Walking01_withElmos_M));
    rtssSetTimeOfLastOutputPtr(sfcnInfo, &rtmGetTimeOfLastOutput
      (Walking01_withElmos_M));
    rtssSetStepSizePtr(sfcnInfo, &Walking01_withElmos_M->Timing.stepSize);
    rtssSetStopRequestedPtr(sfcnInfo, &rtmGetStopRequested(Walking01_withElmos_M));
    rtssSetDerivCacheNeedsResetPtr(sfcnInfo,
      &Walking01_withElmos_M->ModelData.derivCacheNeedsReset);
    rtssSetZCCacheNeedsResetPtr(sfcnInfo,
      &Walking01_withElmos_M->ModelData.zCCacheNeedsReset);
    rtssSetBlkStateChangePtr(sfcnInfo,
      &Walking01_withElmos_M->ModelData.blkStateChange);
    rtssSetSampleHitsPtr(sfcnInfo, &Walking01_withElmos_M->Timing.sampleHits);
    rtssSetPerTaskSampleHitsPtr(sfcnInfo,
      &Walking01_withElmos_M->Timing.perTaskSampleHits);
    rtssSetSimModePtr(sfcnInfo, &Walking01_withElmos_M->simMode);
    rtssSetSolverInfoPtr(sfcnInfo, &Walking01_withElmos_M->solverInfoPtr);
  }

  Walking01_withElmos_M->Sizes.numSFcns = (212);

  /* register each child */
  {
    (void) memset((void *)
                  &Walking01_withElmos_M->NonInlinedSFcns.childSFunctions[0], 0,
                  212*sizeof(SimStruct));
    Walking01_withElmos_M->childSfunctions =
      (&Walking01_withElmos_M->NonInlinedSFcns.childSFunctionPtrs[0]);

    {
      int_T i;
      for (i = 0; i < 212; i++) {
        Walking01_withElmos_M->childSfunctions[i] =
          (&Walking01_withElmos_M->NonInlinedSFcns.childSFunctions[i]);
      }
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S12>/xPC Set Overload Counter (xpcsetoverload) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[0];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn0.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn0.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn0.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2[0]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[0]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[0]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[0]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn0.inputPortInfo[0]);

        /* port 0 */
        {
          uint32_T const **sfcnUPtrs = (uint32_T const **)
            &Walking01_withElmos_M->NonInlinedSFcns.Sfcn0.UPtrs0;
          sfcnUPtrs[0] = (uint32_T*)
            &Walking01_withElmos_ConstB.DataTypeConversion;
          ssSetInputPortSignalPtrs(rts, 0, (InputPtrsType)&sfcnUPtrs[0]);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "xPC Set\nOverload Counter");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/CPU Overload Regulator/Reset CPU Overload Count/Set Overload Counter 1/xPC Set Overload Counter");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn0.params;
        ssSetSFcnParamsCount(rts, 1);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)Walking01_withElmos_ConstP.pooled3);
      }

      /* registration */
      xpcsetoverload(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S194>/FIFO bin read  (fiforeadbinhdrmultiple) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[1];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn1.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn1.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn1.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2[1]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[1]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[1]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[1]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn1.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking01_withElmos_B.FIFOwrite1);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn1.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 37);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            Walking01_withElmos_B.FIFObinread));
        }
      }

      /* path info */
      ssSetModelName(rts, "FIFO bin read ");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/SerialInterfaces/KVH/UpdateOrientation/FIFO bin read ");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn1.params;
        ssSetSFcnParamsCount(rts, 8);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)Walking01_withElmos_ConstP.pooled15);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled17);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled3);
        ssSetSFcnParam(rts, 3, (mxArray*)
                       Walking01_withElmos_ConstP.FIFObinread_P4_Size);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled15);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled17);
        ssSetSFcnParam(rts, 7, (mxArray*)Walking01_withElmos_ConstP.pooled21);
      }

      /* work vectors */
      ssSetPWork(rts, (void **) &Walking01_withElmos_DW.FIFObinread_PWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn1.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn1.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* PWORK */
        ssSetDWorkWidth(rts, 0, 2);
        ssSetDWorkDataType(rts, 0,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.FIFObinread_PWORK[0]);
      }

      /* registration */
      fiforeadbinhdrmultiple(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 1;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S193>/Board Setup (board_setup_tews_XR17D15x) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[2];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn2.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn2.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn2.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2[2]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[2]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[2]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[2]);
      }

      /* path info */
      ssSetModelName(rts, "Board Setup");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/SerialInterfaces/KVH/Subsystem/Board Setup");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn2.params;
        ssSetSFcnParamsCount(rts, 3);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)Walking01_withElmos_ConstP.pooled25);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled29);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.BoardSetup_IWORK);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn2.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn2.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.BoardSetup_IWORK);
      }

      /* registration */
      board_setup_tews_XR17D15x(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 1;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S193>/Setup3 (setup_tews_XR17D15x) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[3];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn3.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn3.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn3.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2[3]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[3]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[3]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[3]);
      }

      /* path info */
      ssSetModelName(rts, "Setup3");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/SerialInterfaces/KVH/Subsystem/Setup3");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn3.params;
        ssSetSFcnParamsCount(rts, 19);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)Walking01_withElmos_ConstP.pooled25);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled29);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled31);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled17);
        ssSetSFcnParam(rts, 7, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 8, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 9, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 10, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 11, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 12, (mxArray*)Walking01_withElmos_ConstP.pooled31);
        ssSetSFcnParam(rts, 13, (mxArray*)Walking01_withElmos_ConstP.pooled17);
        ssSetSFcnParam(rts, 14, (mxArray*)
                       Walking01_withElmos_ConstP.Setup3_P15_Size);
        ssSetSFcnParam(rts, 15, (mxArray*)
                       Walking01_withElmos_ConstP.Setup3_P16_Size);
        ssSetSFcnParam(rts, 16, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 17, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 18, (mxArray*)Walking01_withElmos_ConstP.pooled17);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.Setup3_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn3.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn3.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 3);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.Setup3_IWORK[0]);
      }

      /* registration */
      setup_tews_XR17D15x(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 1;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S193>/Read HW FIFO (read_hw_fifo_XR17D15x) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[4];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn4.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn4.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn4.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2[4]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[4]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[4]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[4]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn4.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking01_withElmos_ConstP.pooled117);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn4.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 65);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            Walking01_withElmos_B.ReadHWFIFO));
        }
      }

      /* path info */
      ssSetModelName(rts, "Read HW FIFO");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/SerialInterfaces/KVH/Subsystem/Read HW FIFO");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn4.params;
        ssSetSFcnParamsCount(rts, 4);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)Walking01_withElmos_ConstP.pooled25);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled31);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled29);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled33);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.ReadHWFIFO_IWORK);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn4.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn4.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 1);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.ReadHWFIFO_IWORK);
      }

      /* registration */
      read_hw_fifo_XR17D15x(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 1;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S193>/FIFO write 1 (fifowrite) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[5];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn5.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn5.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn5.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2[5]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[5]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[5]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[5]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn5.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, Walking01_withElmos_B.ReadHWFIFO);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 65);
        }
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn5.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((serialfifoptr *)
            &Walking01_withElmos_B.FIFOwrite1));
        }
      }

      /* path info */
      ssSetModelName(rts, "FIFO write 1");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/SerialInterfaces/KVH/Subsystem/FIFO write 1");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn5.params;
        ssSetSFcnParamsCount(rts, 5);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.FIFOwrite1_P1_Size);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled17);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled3);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 4, (mxArray*)
                       Walking01_withElmos_ConstP.FIFOwrite1_P5_Size);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.FIFOwrite1_IWORK[0]);
      ssSetPWork(rts, (void **) &Walking01_withElmos_DW.FIFOwrite1_PWORK);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn5.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn5.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 2);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 3);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.FIFOwrite1_IWORK[0]);

        /* PWORK */
        ssSetDWorkWidth(rts, 1, 1);
        ssSetDWorkDataType(rts, 1,SS_POINTER);
        ssSetDWorkComplexSignal(rts, 1, 0);
        ssSetDWork(rts, 1, &Walking01_withElmos_DW.FIFOwrite1_PWORK);
      }

      /* registration */
      fifowrite(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 1;

      /* set compiled values of dynamic vector attributes */
      ssSetInputPortWidth(rts, 0, 65);
      ssSetInputPortDataType(rts, 0, SS_UINT32);
      ssSetInputPortComplexSignal(rts, 0, 0);
      ssSetInputPortFrameData(rts, 0, 0);
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 4 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[6];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn6.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn6.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn6.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2[6]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[6]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[6]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[6]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn6.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar4));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 4");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 4");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn6.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar4_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar4_P2_Siz);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar4_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn6.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn6.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar4_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 4 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[7];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn7.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn7.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn7.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2[7]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[7]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[7]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[7]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn7.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar4_p));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 4");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 4");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn7.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar4_P1_S_d);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar4_P2_S_h);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar4_IWORK_p[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn7.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn7.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar4_IWORK_p[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 4 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[8];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn8.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn8.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn8.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2[8]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[8]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[8]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[8]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn8.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar4_n));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 4");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 4");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn8.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar4_P1_S_a);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar4_P2_S_b);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar4_IWORK_n[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn8.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn8.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar4_IWORK_n[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 4 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[9];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn9.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn9.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn9.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2[9]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[9]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[9]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[9]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn9.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar4_e));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 4");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 4");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn9.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar4_P1_S_h);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar4_P2_S_e);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar4_IWORK_k[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn9.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn9.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar4_IWORK_k[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 8 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[10];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn10.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn10.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn10.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [10]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[10]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[10]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[10]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn10.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar8));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 8");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 8");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn10.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar8_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar8_P2_Siz);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar8_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn10.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn10.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar8_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 8 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[11];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn11.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn11.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn11.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [11]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[11]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[11]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[11]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn11.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar8_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 8");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 8");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn11.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar8_P1_S_b);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar8_P2_S_f);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar8_IWORK_m[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn11.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn11.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar8_IWORK_m[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 8 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[12];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn12.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn12.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn12.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [12]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[12]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[12]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[12]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn12.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar8_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 8");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 8");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn12.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar8_P1_S_i);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar8_P2_S_n);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar8_IWORK_c[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn12.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn12.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar8_IWORK_c[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 8 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[13];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn13.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn13.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn13.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [13]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[13]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[13]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[13]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn13.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar8_bs));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 8");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 8");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn13.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar8_P1_S_o);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar8_P2_S_i);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar8_IWORK_l[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn13.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn13.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar8_IWORK_l[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S32>/EtherCAT Rx Var 4 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[14];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn14.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn14.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn14.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [14]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[14]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[14]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[14]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn14.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar4_m));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 4");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 4");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn14.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar4_P1_S_f);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar4_P2_S_l);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar4_IWORK_nb
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn14.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn14.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar4_IWORK_nb[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S31>/EtherCAT Rx Var 4 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[15];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn15.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn15.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn15.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [15]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[15]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[15]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[15]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn15.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar4_nd));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 4");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 4");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn15.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar4_P1__de);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar4_P2__bc);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar4_IWORK_l[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn15.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn15.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar4_IWORK_l[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var  (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[16];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn16.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn16.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn16.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [16]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[16]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[16]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[16]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn16.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var ");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var ");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn16.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar_P1_Size);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar_P2_Size);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn16.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn16.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var  (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[17];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn17.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn17.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn17.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [17]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[17]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[17]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[17]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn17.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar_k));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var ");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var ");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn17.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar_P1_Si_c);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar_P2_Si_e);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar_IWORK_b[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn17.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn17.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar_IWORK_b[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var  (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[18];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn18.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn18.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn18.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [18]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[18]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[18]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[18]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn18.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar_o));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var ");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var ");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn18.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar_P1_Si_k);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar_P2_S_e2);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar_IWORK_f[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn18.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn18.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar_IWORK_f[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var  (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[19];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn19.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn19.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn19.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [19]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[19]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[19]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[19]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn19.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar_p));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var ");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var ");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn19.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar_P1_Si_b);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar_P2_Si_m);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar_IWORK_c[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn19.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn19.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar_IWORK_c[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S32>/EtherCAT Rx Var 2 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[20];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn20.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn20.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn20.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [20]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[20]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[20]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[20]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn20.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar2_g));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 2");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 2");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn20.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar2_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar2_P2_Siz);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar2_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn20.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn20.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar2_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S31>/EtherCAT Rx Var 2 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[21];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn21.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn21.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn21.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [21]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[21]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[21]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[21]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn21.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar2_i));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 2");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 2");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn21.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar2_P1_S_n);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar2_P2_S_p);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar2_IWORK_g[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn21.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn21.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar2_IWORK_g[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 18 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[22];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn22.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn22.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn22.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [22]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[22]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[22]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[22]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn22.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar18));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 18");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 18");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn22.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar18_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar18_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar18_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn22.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn22.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar18_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 18 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[23];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn23.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn23.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn23.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [23]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[23]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[23]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[23]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn23.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar18_c));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 18");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 18");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn23.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar18_P1__m);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar18_P2__m);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar18_IWORK_b
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn23.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn23.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar18_IWORK_b[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 18 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[24];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn24.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn24.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn24.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [24]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[24]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[24]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[24]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn24.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar18_i));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 18");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 18");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn24.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar18_P1__e);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar18_P2__o);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar18_IWORK_c
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn24.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn24.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar18_IWORK_c[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 18 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[25];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn25.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn25.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn25.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [25]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[25]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[25]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[25]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn25.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar18_f));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 18");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 18");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn25.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar18_P1__p);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar18_P2__e);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar18_IWORK_m
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn25.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn25.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar18_IWORK_m[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S32>/EtherCAT Rx Var 15 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[26];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn26.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn26.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn26.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [26]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[26]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[26]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[26]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn26.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar15_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 15");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 15");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn26.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar15_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar15_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar15_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn26.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn26.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar15_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S31>/EtherCAT Rx Var 15 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[27];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn27.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn27.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn27.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [27]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[27]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[27]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[27]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn27.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar15_g));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 15");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 15");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn27.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar15_P1__k);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar15_P2__d);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar15_IWORK_m
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn27.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn27.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar15_IWORK_m[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S33>/EtherCAT Rx Var 17 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[28];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn28.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn28.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn28.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [28]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[28]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[28]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[28]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn28.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar17_c));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 17");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 17");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn28.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar17_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar17_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar17_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn28.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn28.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar17_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S33>/EtherCAT Rx Var 6 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[29];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn29.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn29.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn29.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [29]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[29]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[29]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[29]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn29.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar6));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 6");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 6");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn29.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar6_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar6_P2_Siz);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar6_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn29.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn29.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar6_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S33>/EtherCAT Rx Var 1 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[30];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn30.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn30.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn30.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [30]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[30]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[30]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[30]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn30.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar1));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 1");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 1");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn30.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar1_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar1_P2_Siz);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar1_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn30.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn30.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar1_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S33>/EtherCAT Rx Var 2 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[31];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn31.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn31.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn31.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [31]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[31]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[31]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[31]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn31.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar2));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 2");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 2");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn31.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar2_P1_S_h);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar2_P2_S_f);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar2_IWORK_g0
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn31.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn31.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar2_IWORK_g0[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S33>/EtherCAT Rx Var 5 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[32];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn32.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn32.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn32.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [32]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[32]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[32]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[32]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn32.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar5));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 5");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 5");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn32.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar5_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar5_P2_Siz);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar5_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn32.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn32.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar5_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S33>/EtherCAT Rx Var 3 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[33];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn33.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn33.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn33.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [33]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[33]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[33]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[33]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn33.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar3));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 3");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 3");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn33.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar3_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar3_P2_Siz);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar3_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn33.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn33.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar3_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S33>/EtherCAT Rx Var 4 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[34];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn34.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn34.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn34.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [34]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[34]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[34]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[34]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn34.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar4_ph));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 4");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 4");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn34.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar4_P1_S_c);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar4_P2__lp);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar4_IWORK_c[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn34.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn34.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar4_IWORK_c[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S33>/EtherCAT Rx Var 19 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[35];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn35.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn35.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn35.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [35]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[35]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[35]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[35]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn35.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar19));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 19");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 19");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn35.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar19_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar19_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar19_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn35.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn35.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar19_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S33>/EtherCAT Rx Var 7 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[36];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn36.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn36.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn36.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [36]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[36]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[36]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[36]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn36.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar7));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 7");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 7");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn36.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar7_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar7_P2_Siz);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar7_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn36.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn36.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar7_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S33>/EtherCAT Rx Var 8 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[37];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn37.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn37.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn37.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [37]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[37]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[37]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[37]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn37.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar8_m));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 8");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 8");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn37.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar8_P1_S_k);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar8_P2_S_h);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar8_IWORK_d[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn37.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn37.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar8_IWORK_d[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S33>/EtherCAT Rx Var 10 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[38];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn38.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn38.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn38.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [38]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[38]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[38]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[38]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn38.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar10));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 10");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 10");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn38.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar10_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar10_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar10_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn38.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn38.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar10_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S33>/EtherCAT Rx Var 14 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[39];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn39.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn39.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn39.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [39]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[39]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[39]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[39]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn39.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar14));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 14");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 14");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn39.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar14_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar14_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar14_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn39.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn39.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar14_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S33>/EtherCAT Rx Var 13 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[40];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn40.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn40.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn40.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [40]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[40]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[40]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[40]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn40.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar13));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 13");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 13");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn40.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar13_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar13_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar13_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn40.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn40.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar13_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 21 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[41];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn41.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn41.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn41.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [41]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[41]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[41]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[41]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn41.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar21));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 21");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 21");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn41.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar21_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar21_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar21_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn41.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn41.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar21_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 21 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[42];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn42.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn42.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn42.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [42]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[42]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[42]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[42]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn42.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar21_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 21");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 21");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn42.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar21_P1__a);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar21_P2__k);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar21_IWORK_o
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn42.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn42.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar21_IWORK_o[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S32>/EtherCAT Rx Var 18 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[43];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn43.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn43.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn43.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [43]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[43]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[43]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[43]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn43.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar18_j));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 18");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 18");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn43.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar18_P1__c);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar18_P2__l);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar18_IWORK_i
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn43.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn43.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar18_IWORK_i[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 21 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[44];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn44.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn44.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn44.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [44]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[44]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[44]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[44]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn44.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar21_o));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 21");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 21");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn44.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar21_P1__e);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar21_P2__f);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar21_IWORK_i
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn44.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn44.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar21_IWORK_i[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 21 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[45];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn45.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn45.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn45.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [45]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[45]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[45]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[45]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn45.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar21_m));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 21");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 21");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn45.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar21_P1__g);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar21_P2__p);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar21_IWORK_g
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn45.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn45.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar21_IWORK_g[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S31>/EtherCAT Rx Var 18 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[46];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn46.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn46.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn46.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [46]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[46]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[46]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[46]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn46.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar18_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 18");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 18");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn46.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar18_P1__o);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar18_P2__a);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar18_IWORK_j
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn46.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn46.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar18_IWORK_j[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 22 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[47];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn47.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn47.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn47.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [47]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[47]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[47]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[47]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn47.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar22));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 22");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 22");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn47.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar22_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled47);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar22_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn47.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn47.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar22_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 22 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[48];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn48.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn48.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn48.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [48]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[48]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[48]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[48]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn48.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar22_o));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 22");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 22");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn48.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar22_P1__p);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled49);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar22_IWORK_h
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn48.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn48.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar22_IWORK_h[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S32>/EtherCAT Rx Var 19 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[49];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn49.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn49.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn49.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [49]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[49]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[49]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[49]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn49.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar19_o));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 19");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 19");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn49.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar19_P1__e);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled51);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar19_IWORK_i
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn49.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn49.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar19_IWORK_i[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 22 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[50];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn50.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn50.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn50.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [50]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[50]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[50]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[50]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn50.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar22_g));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 22");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 22");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn50.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar22_P1__e);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled53);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar22_IWORK_d
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn50.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn50.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar22_IWORK_d[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 22 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[51];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn51.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn51.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn51.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [51]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[51]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[51]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[51]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn51.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar22_a));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 22");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 22");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn51.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar22_P1__b);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled55);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar22_IWORK_o
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn51.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn51.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar22_IWORK_o[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S31>/EtherCAT Rx Var 19 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[52];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn52.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn52.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn52.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [52]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[52]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[52]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[52]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn52.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar19_i));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 19");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 19");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn52.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar19_P1__f);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled57);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar19_IWORK_m
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn52.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn52.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar19_IWORK_m[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S33>/EtherCAT Rx Var 18 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[53];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn53.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn53.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn53.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [53]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[53]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[53]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[53]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn53.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar18_k));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 18");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 18");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn53.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar18_P1__f);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled59);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar18_IWORK_e
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn53.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn53.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar18_IWORK_e[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 19 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[54];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn54.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn54.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn54.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [54]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[54]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[54]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[54]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn54.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar19_c));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 19");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 19");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn54.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar19_P1__k);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled61);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar19_IWORK_k
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn54.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn54.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar19_IWORK_k[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 19 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[55];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn55.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn55.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn55.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [55]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[55]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[55]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[55]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn55.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar19_m));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 19");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 19");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn55.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar19_P1__m);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled63);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar19_IWORK_h
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn55.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn55.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar19_IWORK_h[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S32>/EtherCAT Rx Var 16 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[56];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn56.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn56.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn56.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [56]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[56]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[56]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[56]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn56.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar16_bt));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 16");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 16");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn56.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar16_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled65);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar16_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn56.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn56.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar16_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 19 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[57];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn57.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn57.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn57.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [57]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[57]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[57]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[57]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn57.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar19_e));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 19");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 19");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn57.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar19_P1__p);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled67);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar19_IWORK_n
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn57.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn57.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar19_IWORK_n[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 19 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[58];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn58.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn58.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn58.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [58]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[58]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[58]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[58]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn58.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar19_d));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 19");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 19");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn58.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar19_P1__a);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled69);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar19_IWORK_j
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn58.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn58.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar19_IWORK_j[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S31>/EtherCAT Rx Var 16 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[59];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn59.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn59.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn59.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [59]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[59]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[59]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[59]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn59.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar16_d));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 16");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 16");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn59.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar16_P1__i);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled71);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar16_IWORK_e
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn59.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn59.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar16_IWORK_e[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S33>/EtherCAT Rx Var 15 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[60];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn60.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn60.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn60.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [60]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[60]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[60]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[60]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn60.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar15_d));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 15");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 15");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn60.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar15_P1__c);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled73);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar15_IWORK_k
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn60.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn60.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar15_IWORK_k[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S4>/Task Execution Time  (xpctimeinfo) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[61];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn61.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn61.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn61.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [61]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[61]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[61]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[61]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn61.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real_T *)
            &Walking01_withElmos_B.TaskExecutionTime));
        }
      }

      /* path info */
      ssSetModelName(rts, "Task Execution\nTime ");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/CPU Overload Regulator/Task Execution Time ");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn61.params;
        ssSetSFcnParamsCount(rts, 2);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* registration */
      xpctimeinfo(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 12 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[62];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn62.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn62.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn62.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [62]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[62]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[62]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[62]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn62.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar12_p));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 12");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 12");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn62.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar12_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar12_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar12_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn62.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn62.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar12_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 13 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[63];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn63.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn63.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn63.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [63]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[63]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[63]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[63]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn63.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar13_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 13");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 13");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn63.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar13_P1__j);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar13_P2__d);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar13_IWORK_e
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn63.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn63.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar13_IWORK_e[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 14 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[64];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn64.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn64.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn64.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [64]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[64]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[64]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[64]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn64.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar14_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 14");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 14");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn64.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar14_P1__a);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar14_P2__h);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar14_IWORK_i
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn64.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn64.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar14_IWORK_i[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 15 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[65];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn65.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn65.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn65.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [65]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[65]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[65]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[65]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn65.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar15));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 15");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 15");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn65.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar15_P1_ks);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar15_P2__a);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar15_IWORK_e
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn65.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn65.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar15_IWORK_e[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 16 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[66];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn66.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn66.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn66.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [66]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[66]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[66]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[66]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn66.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar16));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 16");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 16");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn66.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar16_P1_iu);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar16_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar16_IWORK_d
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn66.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn66.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar16_IWORK_d[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 17 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[67];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn67.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn67.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn67.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [67]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[67]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[67]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[67]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn67.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar17));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 17");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 17");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn67.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar17_P1__f);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar17_P2__b);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar17_IWORK_j
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn67.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn67.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar17_IWORK_j[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 12 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[68];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn68.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn68.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn68.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [68]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[68]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[68]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[68]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn68.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar12_c));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 12");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 12");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn68.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar12_P1__c);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar12_P2__b);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar12_IWORK_p
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn68.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn68.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar12_IWORK_p[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 13 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[69];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn69.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn69.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn69.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [69]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[69]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[69]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[69]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn69.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar13_o));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 13");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 13");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn69.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar13_P1__p);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar13_P2__i);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar13_IWORK_d
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn69.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn69.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar13_IWORK_d[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 14 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[70];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn70.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn70.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn70.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [70]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[70]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[70]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[70]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn70.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar14_g));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 14");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 14");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn70.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar14_P1_ap);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar14_P2__i);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar14_IWORK_n
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn70.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn70.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar14_IWORK_n[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 15 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[71];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn71.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn71.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn71.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [71]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[71]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[71]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[71]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn71.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar15_m));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 15");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 15");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn71.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar15_P1_cb);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar15_P2__f);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar15_IWORK_l
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn71.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn71.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar15_IWORK_l[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 16 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[72];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn72.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn72.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn72.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [72]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[72]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[72]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[72]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn72.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar16_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 16");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 16");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn72.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar16_P1_ih);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar16_P2__k);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar16_IWORK_a
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn72.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn72.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar16_IWORK_a[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 17 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[73];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn73.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn73.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn73.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [73]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[73]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[73]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[73]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn73.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar17_k));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 17");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 17");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn73.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar17_P1__a);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar17_P2__p);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar17_IWORK_m
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn73.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn73.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar17_IWORK_m[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S32>/EtherCAT Rx Var 12 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[74];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn74.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn74.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn74.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [74]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[74]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[74]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[74]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn74.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar12_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 12");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 12");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn74.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar12_P1__m);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar12_P2_bx);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar12_IWORK_c
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn74.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn74.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar12_IWORK_c[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S32>/EtherCAT Rx Var 13 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[75];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn75.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn75.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn75.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [75]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[75]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[75]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[75]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn75.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar13_e));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 13");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 13");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn75.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar13_P1_p5);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar13_P2_ib);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar13_IWORK_k
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn75.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn75.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar13_IWORK_k[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S32>/EtherCAT Rx Var 14 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[76];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn76.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn76.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn76.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [76]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[76]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[76]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[76]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn76.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar14_f));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 14");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 14");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn76.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar14_P1__l);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar14_P2__l);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar14_IWORK_b
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn76.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn76.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar14_IWORK_b[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 12 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[77];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn77.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn77.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn77.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [77]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[77]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[77]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[77]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn77.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar12_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 12");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 12");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn77.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar12_P1__o);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar12_P2__j);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar12_IWORK_a
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn77.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn77.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar12_IWORK_a[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 13 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[78];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn78.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn78.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn78.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [78]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[78]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[78]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[78]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn78.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar13_j));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 13");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 13");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn78.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar13_P1_pb);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar13_P2_dd);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATRxVar13_IWORK_eu[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn78.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn78.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar13_IWORK_eu[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 14 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[79];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn79.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn79.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn79.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [79]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[79]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[79]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[79]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn79.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar14_fm));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 14");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 14");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn79.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar14_P1__p);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar14_P2__g);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar14_IWORK_p
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn79.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn79.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar14_IWORK_p[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 15 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[80];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn80.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn80.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn80.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [80]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[80]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[80]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[80]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn80.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar15_n));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 15");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 15");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn80.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar15_P1__l);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar15_P2__j);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar15_IWORK_p
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn80.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn80.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar15_IWORK_p[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 16 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[81];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn81.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn81.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn81.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [81]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[81]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[81]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[81]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn81.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar16_j));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 16");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 16");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn81.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar16_P1__d);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar16_P2__e);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar16_IWORK_n
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn81.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn81.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar16_IWORK_n[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 17 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[82];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn82.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn82.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn82.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [82]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[82]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[82]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[82]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn82.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar17_l));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 17");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 17");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn82.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar17_P1__i);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar17_P2__h);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar17_IWORK_b
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn82.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn82.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar17_IWORK_b[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 12 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[83];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn83.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn83.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn83.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [83]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[83]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[83]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[83]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn83.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar12_i));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 12");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 12");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn83.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar12_P1__d);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar12_P2__g);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar12_IWORK_l
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn83.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn83.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar12_IWORK_l[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 13 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[84];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn84.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn84.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn84.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [84]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[84]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[84]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[84]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn84.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar13_c));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 13");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 13");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn84.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar13_P1__m);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar13_P2__m);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar13_IWORK_i
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn84.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn84.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar13_IWORK_i[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 14 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[85];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn85.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn85.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn85.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [85]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[85]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[85]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[85]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn85.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar14_n));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 14");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 14");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn85.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar14_P1__n);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar14_P2_ib);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar14_IWORK_f
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn85.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn85.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar14_IWORK_f[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 15 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[86];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn86.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn86.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn86.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [86]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[86]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[86]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[86]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn86.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar15_a));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 15");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 15");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn86.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar15_P1__d);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar15_P2__m);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar15_IWORK_i
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn86.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn86.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar15_IWORK_i[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 16 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[87];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn87.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn87.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn87.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [87]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[87]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[87]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[87]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn87.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar16_a));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 16");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 16");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn87.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar16_P1__p);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar16_P2__o);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATRxVar16_IWORK_nl[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn87.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn87.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar16_IWORK_nl[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 17 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[88];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn88.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn88.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn88.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [88]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[88]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[88]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[88]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn88.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar17_kd));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 17");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 17");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn88.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar17_P1__p);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar17_P2__e);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar17_IWORK_p
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn88.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn88.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar17_IWORK_p[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S31>/EtherCAT Rx Var 12 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[89];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn89.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn89.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn89.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [89]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[89]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[89]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[89]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn89.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar12_pv));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 12");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 12");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn89.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar12_P1__a);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar12_P2__c);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar12_IWORK_n
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn89.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn89.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar12_IWORK_n[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S31>/EtherCAT Rx Var 13 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[90];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn90.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn90.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn90.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [90]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[90]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[90]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[90]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn90.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar13_e0));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 13");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 13");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn90.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar13_P1__b);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar13_P2__f);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar13_IWORK_g
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn90.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn90.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar13_IWORK_g[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S31>/EtherCAT Rx Var 14 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[91];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn91.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn91.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn91.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [91]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[91]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[91]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[91]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn91.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar14_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 14");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 14");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn91.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar14_P1__b);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar14_P2__f);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar14_IWORK_d
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn91.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn91.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar14_IWORK_d[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S1>/Get Overload Counter  (xpcgetoverload) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[92];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn92.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn92.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn92.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [92]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[92]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[92]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[92]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn92.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.GetOverloadCounter));
        }
      }

      /* path info */
      ssSetModelName(rts, "Get Overload\nCounter ");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/Get Overload Counter ");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn92.params;
        ssSetSFcnParamsCount(rts, 1);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* registration */
      xpcgetoverload(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S64>/EtherCAT PDO Receive (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[93];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn93.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn93.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn93.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [93]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[93]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[93]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[93]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn93.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1R/EtherCATSubsystem/EtherCAT PDO Receive");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn93.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive_P1);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive_P2);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn93.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn93.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S100>/EtherCAT PDO Receive (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[94];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn94.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn94.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn94.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [94]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[94]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[94]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[94]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn94.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_2R/EtherCATSubsystem/EtherCAT PDO Receive");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn94.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive__f);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive__e);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive_IWORK_f[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn94.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn94.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive_IWORK_f[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S46>/EtherCAT PDO Receive (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[95];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn95.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn95.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn95.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [95]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[95]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[95]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[95]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn95.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive_n));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1L/EtherCATSubsystem/EtherCAT PDO Receive");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn95.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive__g);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive__l);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive_IWORK_d[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn95.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn95.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive_IWORK_d[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S82>/EtherCAT PDO Receive (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[96];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn96.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn96.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn96.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [96]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[96]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[96]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[96]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn96.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive_nq));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_2L/EtherCATSubsystem/EtherCAT PDO Receive");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn96.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive__p);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive__k);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive_IWORK_o[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn96.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn96.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive_IWORK_o[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S64>/EtherCAT PDO Receive3 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[97];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn97.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn97.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn97.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [97]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[97]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[97]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[97]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn97.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive3));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive3");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1R/EtherCATSubsystem/EtherCAT PDO Receive3");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn97.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive3_P);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive3_i);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive3_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn97.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn97.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive3_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S100>/EtherCAT PDO Receive3 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[98];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn98.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn98.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn98.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [98]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[98]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[98]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[98]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn98.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive3_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive3");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_2R/EtherCATSubsystem/EtherCAT PDO Receive3");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn98.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive3_l);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive3_e);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive3_IWORK_n[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn98.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn98.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive3_IWORK_n[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S46>/EtherCAT PDO Receive3 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[99];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn99.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn99.sfcnOffset;
      int_T *sfcnTsMap = Walking01_withElmos_M->NonInlinedSFcns.Sfcn99.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [99]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[99]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[99]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[99]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn99.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive3_j));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive3");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1L/EtherCATSubsystem/EtherCAT PDO Receive3");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn99.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive3_c);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive_ef);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive3_IWORK_b[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn99.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn99.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive3_IWORK_b[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S82>/EtherCAT PDO Receive3 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[100];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn100.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn100.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn100.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [100]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[100]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[100]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[100]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn100.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive3_n));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive3");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_2L/EtherCATSubsystem/EtherCAT PDO Receive3");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn100.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive_e4);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive3_m);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive3_IWORK_l[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn100.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn100.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive3_IWORK_l[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S64>/EtherCAT PDO Receive1 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[101];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn101.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn101.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn101.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [101]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[101]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[101]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[101]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn101.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int32_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive1));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive1");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1R/EtherCATSubsystem/EtherCAT PDO Receive1");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn101.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)Walking01_withElmos_ConstP.pooled77);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled79);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled81);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive1_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn101.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn101.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive1_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S100>/EtherCAT PDO Receive1 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[102];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn102.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn102.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn102.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [102]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[102]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[102]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[102]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn102.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int32_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive1_f));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive1");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_2R/EtherCATSubsystem/EtherCAT PDO Receive1");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn102.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive1_P);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled83);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled81);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive1_IWORK_f[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn102.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn102.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive1_IWORK_f[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S46>/EtherCAT PDO Receive1 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[103];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn103.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn103.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn103.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [103]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[103]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[103]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[103]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn103.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int32_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive1_n));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive1");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1L/EtherCATSubsystem/EtherCAT PDO Receive1");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn103.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive1_b);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled85);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled81);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive1_IWORK_m[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn103.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn103.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive1_IWORK_m[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S82>/EtherCAT PDO Receive1 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[104];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn104.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn104.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn104.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [104]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[104]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[104]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[104]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn104.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int32_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive1_i));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive1");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_2L/EtherCATSubsystem/EtherCAT PDO Receive1");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn104.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)Walking01_withElmos_ConstP.pooled77);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled79);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled81);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive1_IWORK_l[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn104.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn104.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive1_IWORK_l[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S64>/EtherCAT PDO Receive4 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[105];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn105.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn105.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn105.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [105]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[105]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[105]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[105]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn105.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int32_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive4));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive4");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1R/EtherCATSubsystem/EtherCAT PDO Receive4");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn105.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive4_P);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive4_l);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled81);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive4_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn105.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn105.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive4_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S100>/EtherCAT PDO Receive4 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[106];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn106.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn106.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn106.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [106]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[106]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[106]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[106]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn106.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int32_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive4_d));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive4");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_2R/EtherCATSubsystem/EtherCAT PDO Receive4");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn106.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive4_i);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive4_p);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled81);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive4_IWORK_m[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn106.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn106.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive4_IWORK_m[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S46>/EtherCAT PDO Receive4 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[107];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn107.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn107.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn107.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [107]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[107]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[107]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[107]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn107.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int32_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive4_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive4");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1L/EtherCATSubsystem/EtherCAT PDO Receive4");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn107.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive4_d);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive_ie);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled81);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive4_IWORK_b[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn107.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn107.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive4_IWORK_b[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S82>/EtherCAT PDO Receive4 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[108];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn108.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn108.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn108.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [108]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[108]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[108]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[108]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn108.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int32_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive4_p));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive4");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_2L/EtherCATSubsystem/EtherCAT PDO Receive4");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn108.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive4_e);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive4_b);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled81);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive4_IWORK_n[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn108.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn108.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive4_IWORK_n[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S64>/EtherCAT PDO Receive5 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[109];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn109.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn109.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn109.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [109]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[109]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[109]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[109]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn109.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive5));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive5");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1R/EtherCATSubsystem/EtherCAT PDO Receive5");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn109.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive5_P);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled87);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive5_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn109.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn109.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive5_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S100>/EtherCAT PDO Receive5 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[110];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn110.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn110.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn110.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [110]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[110]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[110]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[110]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn110.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive5_d));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive5");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_2R/EtherCATSubsystem/EtherCAT PDO Receive5");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn110.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive5_p);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled89);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive5_IWORK_b[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn110.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn110.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive5_IWORK_b[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S46>/EtherCAT PDO Receive5 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[111];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn111.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn111.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn111.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [111]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[111]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[111]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[111]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn111.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive5_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive5");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1L/EtherCATSubsystem/EtherCAT PDO Receive5");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn111.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive5_h);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled91);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive5_IWORK_c[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn111.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn111.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive5_IWORK_c[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S82>/EtherCAT PDO Receive5 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[112];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn112.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn112.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn112.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [112]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[112]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[112]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[112]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn112.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive5_p));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive5");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_2L/EtherCATSubsystem/EtherCAT PDO Receive5");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn112.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive_hn);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled93);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive5_IWORK_j[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn112.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn112.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive5_IWORK_j[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 6 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[113];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn113.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn113.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn113.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [113]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[113]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[113]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[113]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn113.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking01_withElmos_B.EtherCATRxVar6_n));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 6");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 6");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn113.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar6_P1_S_o);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar6_P2_S_c);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar6_IWORK_l[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn113.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn113.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar6_IWORK_l[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 7 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[114];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn114.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn114.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn114.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [114]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[114]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[114]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[114]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn114.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking01_withElmos_B.EtherCATRxVar7_g));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 7");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 7");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn114.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar7_P1_S_e);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar7_P2_S_n);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar7_IWORK_m[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn114.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn114.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar7_IWORK_m[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 6 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[115];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn115.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn115.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn115.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [115]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[115]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[115]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[115]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn115.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking01_withElmos_B.EtherCATRxVar6_o));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 6");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 6");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn115.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar6_P1_S_g);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar6_P2_S_l);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar6_IWORK_p[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn115.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn115.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar6_IWORK_p[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 7 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[116];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn116.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn116.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn116.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [116]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[116]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[116]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[116]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn116.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking01_withElmos_B.EtherCATRxVar7_d));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 7");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 7");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn116.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar7_P1_S_d);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar7_P2_S_p);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar7_IWORK_n[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn116.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn116.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar7_IWORK_n[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S32>/EtherCAT Rx Var  (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[117];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn117.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn117.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn117.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [117]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[117]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[117]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[117]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn117.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking01_withElmos_B.EtherCATRxVar));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var ");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var ");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn117.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar_P1_Si_e);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar_P2_Si_a);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar_IWORK_o[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn117.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn117.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar_IWORK_o[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 6 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[118];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn118.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn118.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn118.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [118]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[118]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[118]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[118]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn118.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking01_withElmos_B.EtherCATRxVar6_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 6");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 6");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn118.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar6_P1_S_i);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar6_P2_S_o);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar6_IWORK_e[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn118.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn118.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar6_IWORK_e[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 7 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[119];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn119.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn119.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn119.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [119]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[119]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[119]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[119]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn119.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking01_withElmos_B.EtherCATRxVar7_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 7");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 7");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn119.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar7_P1_S_m);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar7_P2_S_f);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar7_IWORK_mw
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn119.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn119.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar7_IWORK_mw[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 6 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[120];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn120.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn120.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn120.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [120]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[120]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[120]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[120]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn120.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking01_withElmos_B.EtherCATRxVar6_m));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 6");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 6");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn120.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar6_P1__ie);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar6_P2_S_e);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar6_IWORK_j[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn120.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn120.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar6_IWORK_j[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 7 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[121];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn121.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn121.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn121.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [121]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[121]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[121]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[121]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn121.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking01_withElmos_B.EtherCATRxVar7_gy));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 7");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 7");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn121.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar7_P1_S_p);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar7_P2_S_b);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar7_IWORK_a[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn121.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn121.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar7_IWORK_a[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S31>/EtherCAT Rx Var  (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[122];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn122.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn122.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn122.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [122]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[122]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[122]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[122]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn122.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking01_withElmos_B.EtherCATRxVar_i));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var ");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var ");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn122.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar_P1_Si_d);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar_P2_Si_n);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar_IWORK_h[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn122.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn122.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar_IWORK_h[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 10 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[123];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn123.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn123.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn123.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [123]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[123]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[123]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[123]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn123.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar10_c));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 10");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 10");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn123.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar10_P1__i);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar10_P2__d);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar10_IWORK_a
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn123.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn123.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar10_IWORK_a[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 10 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[124];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn124.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn124.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn124.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [124]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[124]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[124]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[124]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn124.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar10_f));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 10");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 10");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn124.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar10_P1__o);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar10_P2__b);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar10_IWORK_h
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn124.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn124.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar10_IWORK_h[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S32>/EtherCAT Rx Var 6 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[125];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn125.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn125.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn125.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [125]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[125]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[125]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[125]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn125.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar6_a));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 6");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 6");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn125.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar6_P1_S_p);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar6_P2__ce);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar6_IWORK_pu
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn125.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn125.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar6_IWORK_pu[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 10 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[126];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn126.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn126.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn126.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [126]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[126]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[126]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[126]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn126.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar10_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 10");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 10");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn126.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar10_P1__g);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar10_P2__o);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar10_IWORK_c
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn126.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn126.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar10_IWORK_c[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 10 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[127];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn127.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn127.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn127.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [127]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[127]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[127]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[127]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn127.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar10_g));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 10");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 10");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn127.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar10_P1_ib);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar10_P2__a);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar10_IWORK_n
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn127.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn127.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar10_IWORK_n[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S31>/EtherCAT Rx Var 6 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[128];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn128.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn128.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn128.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [128]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[128]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[128]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[128]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn128.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar6_f));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 6");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 6");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn128.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar6_P1_S_j);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar6_P2_S_k);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar6_IWORK_n[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn128.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn128.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar6_IWORK_n[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 11 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[129];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn129.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn129.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn129.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [129]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[129]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[129]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[129]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn129.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar11_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 11");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 11");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn129.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar11_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar11_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar11_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn129.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn129.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar11_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 11 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[130];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn130.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn130.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn130.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [130]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[130]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[130]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[130]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn130.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar11_a));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 11");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 11");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn130.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar11_P1__m);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar11_P2__m);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar11_IWORK_m
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn130.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn130.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar11_IWORK_m[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S32>/EtherCAT Rx Var 1 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[131];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn131.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn131.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn131.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [131]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[131]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[131]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[131]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn131.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar1_p));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 1");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 1");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn131.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar1_P1_S_h);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar1_P2_S_d);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar1_IWORK_m[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn131.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn131.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar1_IWORK_m[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 11 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[132];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn132.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn132.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn132.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [132]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[132]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[132]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[132]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn132.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar11_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 11");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 11");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn132.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar11_P1__i);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar11_P2__g);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar11_IWORK_g
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn132.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn132.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar11_IWORK_g[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 11 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[133];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn133.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn133.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn133.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [133]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[133]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[133]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[133]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn133.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar11_l));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 11");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 11");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn133.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar11_P1_ic);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar11_P2__b);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar11_IWORK_d
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn133.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn133.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar11_IWORK_d[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S31>/EtherCAT Rx Var 1 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[134];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn134.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn134.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn134.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [134]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[134]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[134]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[134]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn134.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar1_m));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 1");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 1");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn134.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar1_P1_S_d);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar1_P2_S_a);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar1_IWORK_f[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn134.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn134.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar1_IWORK_f[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 5 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[135];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn135.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn135.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn135.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [135]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[135]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[135]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[135]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn135.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar5_n));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 5");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 5");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn135.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar5_P1_S_l);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar5_P2_S_l);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar5_IWORK_d[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn135.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn135.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar5_IWORK_d[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S32>/EtherCAT Rx Var 5 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[136];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn136.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn136.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn136.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [136]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[136]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[136]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[136]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn136.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar5_o));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 5");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 5");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn136.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar5_P1_S_d);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar5_P2_S_o);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar5_IWORK_i[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn136.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn136.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar5_IWORK_i[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S32>/EtherCAT Rx Var 3 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[137];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn137.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn137.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn137.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [137]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[137]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[137]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[137]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn137.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar3_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 3");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 3");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn137.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar3_P1_S_a);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar3_P2_S_d);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar3_IWORK_h[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn137.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn137.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar3_IWORK_h[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 9 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[138];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn138.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn138.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn138.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [138]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[138]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[138]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[138]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn138.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar9_p));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 9");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 9");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn138.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar9_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar9_P2_Siz);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar9_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn138.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn138.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar9_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S32>/EtherCAT Rx Var 17 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[139];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn139.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn139.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn139.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [139]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[139]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[139]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[139]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn139.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar17_j));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 17");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 17");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn139.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar17_P1__b);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled95);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar17_IWORK_i
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn139.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn139.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar17_IWORK_i[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 1 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[140];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn140.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn140.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn140.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [140]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[140]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[140]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[140]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn140.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar1_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 1");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 1");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn140.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar1_P1_S_m);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar1_P2_S_p);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar1_IWORK_n[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn140.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn140.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar1_IWORK_n[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S31>/EtherCAT Rx Var 5 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[141];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn141.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn141.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn141.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [141]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[141]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[141]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[141]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn141.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar5_d));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 5");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 5");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn141.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar5_P1_S_a);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar5_P2_S_m);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar5_IWORK_p[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn141.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn141.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar5_IWORK_p[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S31>/EtherCAT Rx Var 3 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[142];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn142.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn142.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn142.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [142]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[142]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[142]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[142]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn142.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar3_c));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 3");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 3");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn142.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar3_P1_S_i);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar3_P2_S_n);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar3_IWORK_hk
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn142.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn142.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar3_IWORK_hk[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S31>/EtherCAT Rx Var 17 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[143];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn143.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn143.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn143.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [143]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[143]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[143]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[143]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn143.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar17_p));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 17");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 17");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn143.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar17_P1_bu);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled97);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar17_IWORK_a
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn143.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn143.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar17_IWORK_a[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S33>/EtherCAT Rx Var 16 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[144];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn144.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn144.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn144.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [144]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[144]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[144]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[144]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn144.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar16_k));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 16");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 16");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn144.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar16_P1__l);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled99);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar16_IWORK_m
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn144.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn144.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar16_IWORK_m[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 23 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[145];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn145.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn145.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn145.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [145]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[145]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[145]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[145]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn145.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar23));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 23");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 23");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn145.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar23_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar23_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar23_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn145.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn145.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar23_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 2 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[146];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn146.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn146.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn146.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [146]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[146]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[146]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[146]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn146.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar2_o));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 2");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 2");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn146.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar2_P1_S_f);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar2_P2_S_n);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar2_IWORK_o[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn146.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn146.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar2_IWORK_o[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 3 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[147];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn147.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn147.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn147.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [147]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[147]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[147]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[147]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn147.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar3_j));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 3");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 3");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn147.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar3_P1_S_g);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar3_P2_S_c);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar3_IWORK_a[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn147.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn147.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar3_IWORK_a[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 23 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[148];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn148.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn148.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn148.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [148]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[148]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[148]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[148]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn148.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar23_c));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 23");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 23");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn148.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar23_P1__o);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar23_P2__d);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar23_IWORK_k
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn148.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn148.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar23_IWORK_k[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 20 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[149];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn149.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn149.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn149.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [149]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[149]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[149]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[149]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn149.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar20));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 20");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 20");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn149.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar20_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled101);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar20_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn149.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn149.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar20_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 5 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[150];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn150.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn150.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn150.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [150]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[150]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[150]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[150]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn150.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar5_l));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 5");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 5");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn150.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar5_P1_S_k);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar5_P2_S_f);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar5_IWORK_ds
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn150.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn150.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar5_IWORK_ds[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 9 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[151];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn151.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn151.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn151.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [151]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[151]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[151]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[151]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn151.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar9_a));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 9");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 9");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn151.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar9_P1_S_b);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar9_P2_S_a);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar9_IWORK_d[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn151.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn151.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar9_IWORK_d[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 1 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[152];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn152.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn152.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn152.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [152]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[152]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[152]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[152]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn152.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar1_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 1");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 1");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn152.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar1_P1_S_p);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar1_P2__az);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar1_IWORK_a[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn152.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn152.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar1_IWORK_a[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 2 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[153];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn153.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn153.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn153.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [153]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[153]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[153]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[153]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn153.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar2_m));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 2");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 2");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn153.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar2_P1__nz);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar2_P2_S_d);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar2_IWORK_a[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn153.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn153.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar2_IWORK_a[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Rx Var 3 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[154];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn154.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn154.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn154.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [154]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[154]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[154]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[154]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn154.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar3_o));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 3");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 3");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn154.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar3_P1__il);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar3_P2__dw);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar3_IWORK_e[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn154.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn154.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar3_IWORK_e[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Rx Var 20 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[155];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn155.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn155.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn155.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [155]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[155]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[155]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[155]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn155.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar20_c));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 20");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 20");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn155.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar20_P1__m);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled103);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar20_IWORK_e
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn155.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn155.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar20_IWORK_e[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 23 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[156];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn156.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn156.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn156.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [156]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[156]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[156]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[156]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn156.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar23_e));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 23");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 23");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn156.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar23_P1__d);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar23_P2__c);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar23_IWORK_l
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn156.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn156.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar23_IWORK_l[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 20 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[157];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn157.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn157.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn157.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [157]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[157]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[157]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[157]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn157.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar20_p));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 20");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 20");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn157.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar20_P1__c);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled105);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar20_IWORK_c
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn157.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn157.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar20_IWORK_c[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 5 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[158];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn158.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn158.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn158.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [158]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[158]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[158]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[158]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn158.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar5_k));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 5");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 5");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn158.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar5_P1__k3);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar5_P2_S_k);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar5_IWORK_o[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn158.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn158.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar5_IWORK_o[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 9 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[159];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn159.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn159.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn159.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [159]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[159]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[159]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[159]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn159.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar9_i));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 9");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 9");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn159.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar9_P1_S_c);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar9_P2_S_n);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar9_IWORK_j[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn159.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn159.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar9_IWORK_j[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 1 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[160];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn160.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn160.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn160.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [160]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[160]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[160]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[160]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn160.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar1_f));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 1");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 1");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn160.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar1_P1_S_o);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar1_P2_S_j);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar1_IWORK_mc
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn160.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn160.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar1_IWORK_mc[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 2 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[161];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn161.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn161.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn161.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [161]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[161]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[161]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[161]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn161.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar2_n));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 2");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 2");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn161.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar2_P1_S_a);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar2_P2_S_i);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar2_IWORK_p[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn161.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn161.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar2_IWORK_p[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Rx Var 3 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[162];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn162.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn162.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn162.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [162]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[162]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[162]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[162]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn162.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar3_c4));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 3");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 3");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn162.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar3_P1_S_d);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar3_P2_S_a);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar3_IWORK_j[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn162.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn162.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar3_IWORK_j[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 23 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[163];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn163.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn163.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn163.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [163]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[163]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[163]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[163]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn163.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar23_p));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 23");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 23");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn163.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar23_P1__n);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar23_P2__p);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATRxVar23_IWORK_l4[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn163.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn163.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar23_IWORK_l4[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 20 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[164];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn164.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn164.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn164.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [164]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[164]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[164]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[164]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn164.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking01_withElmos_B.EtherCATRxVar20_l));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 20");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 20");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn164.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar20_P1_mp);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled107);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar20_IWORK_i
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn164.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn164.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar20_IWORK_i[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 5 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[165];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn165.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn165.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn165.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [165]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[165]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[165]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[165]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn165.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar5_p));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 5");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 5");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn165.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar5_P1_S_b);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar5_P2_S_j);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar5_IWORK_h[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn165.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn165.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar5_IWORK_h[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 9 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[166];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn166.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn166.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn166.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [166]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[166]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[166]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[166]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn166.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar9_j));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 9");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 9");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn166.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar9_P1__bg);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar9_P2_S_l);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar9_IWORK_f[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn166.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn166.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar9_IWORK_f[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 1 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[167];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn167.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn167.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn167.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [167]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[167]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[167]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[167]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn167.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar1_pm));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 1");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 1");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn167.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar1_P1_S_f);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar1_P2__dj);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar1_IWORK_ff
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn167.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn167.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar1_IWORK_ff[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 2 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[168];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn168.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn168.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn168.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [168]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[168]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[168]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[168]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn168.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar2_p));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 2");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 2");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn168.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar2_P1_S_d);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar2_P2_S_l);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar2_IWORK_h[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn168.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn168.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar2_IWORK_h[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Rx Var 3 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[169];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn169.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn169.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn169.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [169]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[169]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[169]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[169]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn169.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking01_withElmos_B.EtherCATRxVar3_k));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 3");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 3");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn169.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar3_P1_S_k);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar3_P2_S_b);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar3_IWORK_b[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn169.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn169.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar3_IWORK_b[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S31>/EtherCAT Tx Var 3 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[170];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn170.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn170.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn170.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [170]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[170]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[170]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[170]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn170.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0,
                               &Walking01_withElmos_B.DataTypeConversion3);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 3");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Tx Var 3");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn170.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATTxVar3_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled97);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATTxVar3_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn170.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn170.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATTxVar3_IWORK[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S31>/EtherCAT Tx Var 4 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[171];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn171.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn171.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn171.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [171]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[171]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[171]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[171]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn171.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0,
                               &Walking01_withElmos_B.DataTypeConversion4);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 4");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Tx Var 4");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn171.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATTxVar4_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled57);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATTxVar4_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn171.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn171.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATTxVar4_IWORK[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S31>/EtherCAT Tx Var 5 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[172];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn172.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn172.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn172.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [172]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[172]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[172]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[172]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn172.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0,
                               &Walking01_withElmos_B.DataTypeConversion5);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 5");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Tx Var 5");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn172.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATTxVar5_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled71);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled81);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATTxVar5_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn172.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn172.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATTxVar5_IWORK[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S32>/EtherCAT Tx Var 3 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[173];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn173.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn173.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn173.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [173]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[173]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[173]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[173]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn173.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0,
                               &Walking01_withElmos_B.DataTypeConversion3_i);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 3");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Tx Var 3");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn173.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATTxVar3_P1_S_i);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled95);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATTxVar3_IWORK_i[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn173.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn173.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATTxVar3_IWORK_i[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S32>/EtherCAT Tx Var 4 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[174];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn174.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn174.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn174.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [174]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[174]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[174]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[174]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn174.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0,
                               &Walking01_withElmos_B.DataTypeConversion4_h);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 4");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Tx Var 4");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn174.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATTxVar4_P1_S_o);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled51);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATTxVar4_IWORK_l[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn174.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn174.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATTxVar4_IWORK_l[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S32>/EtherCAT Tx Var 5 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[175];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn175.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn175.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn175.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [175]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[175]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[175]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[175]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn175.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0,
                               &Walking01_withElmos_B.DataTypeConversion5_e);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 5");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Tx Var 5");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn175.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATTxVar5_P1_S_a);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled65);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled81);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATTxVar5_IWORK_g[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn175.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn175.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATTxVar5_IWORK_g[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S33>/EtherCAT Rx Var 11 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[176];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn176.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn176.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn176.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [176]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[176]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[176]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[176]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn176.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar11));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 11");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 11");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn176.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar11_P1__p);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar11_P2__p);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar11_IWORK_c
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn176.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn176.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar11_IWORK_c[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S33>/EtherCAT Rx Var 12 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[177];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn177.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn177.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn177.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [177]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[177]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[177]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[177]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn177.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar12));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 12");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 12");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn177.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar12_P1__j);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar12_P2__o);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar12_IWORK_m
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn177.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn177.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar12_IWORK_m[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S33>/EtherCAT Rx Var 9 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[178];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn178.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn178.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn178.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [178]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[178]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[178]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[178]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn178.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.EtherCATRxVar9));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 9");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 9");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn178.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar9_P1_S_j);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATRxVar9_P2__no);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATRxVar9_IWORK_o[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn178.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn178.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATRxVar9_IWORK_o[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S33>/EtherCAT Tx Var  (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[179];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn179.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn179.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn179.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [179]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[179]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[179]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[179]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn179.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0,
                               &Walking01_withElmos_B.DataTypeConversion3_j);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var ");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Tx Var ");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn179.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATTxVar_P1_Size);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled99);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATTxVar_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn179.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn179.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATTxVar_IWORK[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S33>/EtherCAT Tx Var 1 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[180];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn180.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn180.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn180.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [180]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[180]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[180]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[180]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn180.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0,
                               &Walking01_withElmos_B.DataTypeConversion4_a);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 1");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Tx Var 1");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn180.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATTxVar1_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled59);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATTxVar1_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn180.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn180.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATTxVar1_IWORK[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S33>/EtherCAT Tx Var 2 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[181];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn181.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn181.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn181.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [181]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[181]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[181]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[181]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn181.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0,
                               &Walking01_withElmos_B.DataTypeConversion1_l);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 2");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Tx Var 2");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn181.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATTxVar2_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled73);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATTxVar2_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn181.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn181.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATTxVar2_IWORK[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S46>/EtherCAT PDO Receive2 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[182];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn182.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn182.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn182.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [182]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[182]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[182]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[182]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn182.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int8_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive2));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive2");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1L/EtherCATSubsystem/EtherCAT PDO Receive2");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn182.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive2_P);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled109);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive2_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn182.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn182.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive2_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S46>/EtherCAT PDO Transmit (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[183];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn183.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn183.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn183.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [183]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[183]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[183]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[183]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn183.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking01_withElmos_B.Switch);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1L/EtherCATSubsystem/EtherCAT PDO Transmit");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn183.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOTransmit_P);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled85);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOTransmit_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn183.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn183.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOTransmit_IWORK[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S46>/EtherCAT PDO Transmit1 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[184];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn184.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn184.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn184.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [184]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[184]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[184]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[184]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn184.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking01_withElmos_B.Merge);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit1");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1L/EtherCATSubsystem/EtherCAT PDO Transmit1");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn184.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOTransmit1_);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled91);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOTransmit1_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn184.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn184.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOTransmit1_IWORK[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S46>/EtherCAT PDO Transmit2 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[185];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn185.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn185.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn185.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [185]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[185]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[185]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[185]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn185.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking01_withElmos_ConstP.pooled130);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit2");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1L/EtherCATSubsystem/EtherCAT PDO Transmit2");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn185.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOTransmit2_);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled109);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOTransmit2_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn185.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn185.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOTransmit2_IWORK[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S64>/EtherCAT PDO Receive2 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[186];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn186.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn186.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn186.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [186]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[186]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[186]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[186]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn186.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int8_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive2_k));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive2");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1R/EtherCATSubsystem/EtherCAT PDO Receive2");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn186.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive2_h);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled111);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive2_IWORK_p[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn186.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn186.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive2_IWORK_p[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S64>/EtherCAT PDO Transmit (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[187];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn187.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn187.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn187.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [187]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[187]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[187]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[187]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn187.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking01_withElmos_B.Switch_a);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1R/EtherCATSubsystem/EtherCAT PDO Transmit");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn187.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOTransmit_e);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOTransmit_f);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOTransmit_IWORK_i[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn187.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn187.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOTransmit_IWORK_i[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S64>/EtherCAT PDO Transmit1 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[188];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn188.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn188.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn188.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [188]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[188]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[188]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[188]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn188.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking01_withElmos_B.Merge_l);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit1");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1R/EtherCATSubsystem/EtherCAT PDO Transmit1");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn188.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOTransmit_d);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled87);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOTransmit1_IWORK_m[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn188.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn188.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOTransmit1_IWORK_m
                   [0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S64>/EtherCAT PDO Transmit2 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[189];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn189.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn189.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn189.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [189]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[189]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[189]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[189]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn189.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking01_withElmos_ConstP.pooled130);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit2");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_1R/EtherCATSubsystem/EtherCAT PDO Transmit2");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn189.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOTransmi_dz);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled111);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOTransmit2_IWORK_l[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn189.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn189.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOTransmit2_IWORK_l
                   [0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S82>/EtherCAT PDO Receive2 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[190];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn190.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn190.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn190.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [190]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[190]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[190]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[190]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn190.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int8_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive2_l));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive2");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_2L/EtherCATSubsystem/EtherCAT PDO Receive2");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn190.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive2_p);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled113);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive2_IWORK_k[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn190.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn190.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive2_IWORK_k[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S82>/EtherCAT PDO Transmit (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[191];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn191.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn191.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn191.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [191]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[191]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[191]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[191]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn191.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking01_withElmos_B.Switch_d);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_2L/EtherCATSubsystem/EtherCAT PDO Transmit");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn191.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOTransmit_a);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled79);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOTransmit_IWORK_o[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn191.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn191.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOTransmit_IWORK_o[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S82>/EtherCAT PDO Transmit1 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[192];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn192.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn192.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn192.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [192]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[192]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[192]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[192]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn192.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking01_withElmos_B.Merge_h);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit1");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_2L/EtherCATSubsystem/EtherCAT PDO Transmit1");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn192.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOTransmit_n);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled93);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOTransmit1_IWORK_p[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn192.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn192.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOTransmit1_IWORK_p
                   [0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S82>/EtherCAT PDO Transmit2 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[193];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn193.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn193.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn193.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [193]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[193]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[193]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[193]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn193.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking01_withElmos_ConstP.pooled130);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit2");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_2L/EtherCATSubsystem/EtherCAT PDO Transmit2");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn193.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOTransmit_k);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled113);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOTransmit2_IWORK_lo[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn193.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn193.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0,
                   &Walking01_withElmos_DW.EtherCATPDOTransmit2_IWORK_lo[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S100>/EtherCAT PDO Receive2 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[194];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn194.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn194.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn194.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [194]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[194]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[194]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[194]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn194.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int8_T *)
            &Walking01_withElmos_B.EtherCATPDOReceive2_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive2");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_2R/EtherCATSubsystem/EtherCAT PDO Receive2");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn194.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOReceive2_c);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled115);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOReceive2_IWORK_f[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn194.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn194.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOReceive2_IWORK_f[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S100>/EtherCAT PDO Transmit (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[195];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn195.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn195.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn195.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [195]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[195]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[195]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[195]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn195.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking01_withElmos_B.Switch_i);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_2R/EtherCATSubsystem/EtherCAT PDO Transmit");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn195.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOTransmit_p);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled83);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled27);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOTransmit_IWORK_l[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn195.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn195.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOTransmit_IWORK_l[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S100>/EtherCAT PDO Transmit1 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[196];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn196.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn196.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn196.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [196]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[196]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[196]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[196]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn196.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking01_withElmos_B.Merge_e);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit1");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_2R/EtherCATSubsystem/EtherCAT PDO Transmit1");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn196.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOTransmit_i);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled89);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOTransmit1_IWORK_pr[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn196.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn196.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0,
                   &Walking01_withElmos_DW.EtherCATPDOTransmit1_IWORK_pr[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S100>/EtherCAT PDO Transmit2 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[197];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn197.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn197.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn197.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [197]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[197]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[197]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[197]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn197.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking01_withElmos_ConstP.pooled130);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit2");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegElmo_2R/EtherCATSubsystem/EtherCAT PDO Transmit2");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn197.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATPDOTransmit_h);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled115);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking01_withElmos_DW.EtherCATPDOTransmit2_IWORK_m[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn197.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn197.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATPDOTransmit2_IWORK_m
                   [0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Tx Var 3 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[198];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn198.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn198.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn198.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [198]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[198]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[198]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[198]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn198.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0,
                               &Walking01_withElmos_B.DataTypeConversion3_f);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 3");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Tx Var 3");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn198.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATTxVar3_P1__ib);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled103);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATTxVar3_IWORK_ix
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn198.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn198.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATTxVar3_IWORK_ix[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Tx Var 4 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[199];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn199.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn199.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn199.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [199]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[199]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[199]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[199]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn199.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0,
                               &Walking01_withElmos_B.DataTypeConversion4_k);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 4");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Tx Var 4");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn199.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATTxVar4_P1_S_p);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled53);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATTxVar4_IWORK_h[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn199.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn199.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATTxVar4_IWORK_h[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S38>/EtherCAT Tx Var 5 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[200];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn200.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn200.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn200.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [200]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[200]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[200]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[200]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn200.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0,
                               &Walking01_withElmos_B.DataTypeConversion5_n);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 5");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Tx Var 5");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn200.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATTxVar5_P1_S_m);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled67);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled81);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATTxVar5_IWORK_m[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn200.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn200.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATTxVar5_IWORK_m[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Tx Var 3 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[201];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn201.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn201.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn201.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [201]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[201]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[201]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[201]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn201.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0,
                               &Walking01_withElmos_B.DataTypeConversion3_g);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 3");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Tx Var 3");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn201.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATTxVar3_P1_S_f);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled105);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATTxVar3_IWORK_k[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn201.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn201.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATTxVar3_IWORK_k[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Tx Var 4 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[202];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn202.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn202.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn202.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [202]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[202]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[202]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[202]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn202.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0,
                               &Walking01_withElmos_B.DataTypeConversion4_i);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 4");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Tx Var 4");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn202.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATTxVar4_P1_S_i);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled47);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATTxVar4_IWORK_d[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn202.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn202.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATTxVar4_IWORK_d[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S39>/EtherCAT Tx Var 5 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[203];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn203.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn203.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn203.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [203]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[203]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[203]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[203]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn203.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0,
                               &Walking01_withElmos_B.DataTypeConversion5_b);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 5");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Tx Var 5");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn203.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATTxVar5_P1_S_o);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled61);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled81);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATTxVar5_IWORK_e[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn203.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn203.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATTxVar5_IWORK_e[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Tx Var 3 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[204];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn204.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn204.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn204.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [204]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[204]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[204]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[204]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn204.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0,
                               &Walking01_withElmos_B.DataTypeConversion3_o);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 3");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Tx Var 3");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn204.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATTxVar3_P1_S_g);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled101);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATTxVar3_IWORK_j[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn204.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn204.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATTxVar3_IWORK_j[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Tx Var 4 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[205];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn205.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn205.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn205.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [205]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[205]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[205]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[205]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn205.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0,
                               &Walking01_withElmos_B.DataTypeConversion4_n);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 4");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Tx Var 4");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn205.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATTxVar4_P1_S_m);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled55);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATTxVar4_IWORK_e[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn205.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn205.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATTxVar4_IWORK_e[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S40>/EtherCAT Tx Var 5 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[206];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn206.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn206.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn206.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [206]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[206]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[206]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[206]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn206.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0,
                               &Walking01_withElmos_B.DataTypeConversion5_by);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 5");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Tx Var 5");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn206.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATTxVar5_P1_S_h);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled69);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled81);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATTxVar5_IWORK_er
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn206.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn206.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATTxVar5_IWORK_er[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Tx Var 3 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[207];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn207.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn207.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn207.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [207]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[207]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[207]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[207]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn207.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0,
                               &Walking01_withElmos_B.DataTypeConversion3_f2);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 3");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Tx Var 3");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn207.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATTxVar3_P1__iy);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled107);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled35);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATTxVar3_IWORK_f[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn207.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn207.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATTxVar3_IWORK_f[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Tx Var 4 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[208];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn208.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn208.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn208.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [208]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[208]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[208]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[208]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn208.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0,
                               &Walking01_withElmos_B.DataTypeConversion4_o);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 4");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Tx Var 4");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn208.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATTxVar4_P1_S_e);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled49);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled41);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled43);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATTxVar4_IWORK_a[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn208.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn208.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATTxVar4_IWORK_a[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S41>/EtherCAT Tx Var 5 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[209];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn209.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn209.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn209.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [209]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[209]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[209]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[209]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn209.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0,
                               &Walking01_withElmos_B.DataTypeConversion5_a);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 5");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/DAQ/EtherCATNetwork/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Tx Var 5");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn209.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.EtherCATTxVar5_P1_S_j);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking01_withElmos_ConstP.pooled63);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking01_withElmos_ConstP.pooled81);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking01_withElmos_ConstP.pooled37);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking01_withElmos_ConstP.pooled33);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking01_withElmos_ConstP.pooled21);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking01_withElmos_ConstP.pooled39);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking01_withElmos_DW.EtherCATTxVar5_IWORK_n[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn209.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn209.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking01_withElmos_DW.EtherCATTxVar5_IWORK_n[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.0005);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S1>/Get Overload Counter 1 (xpcgetoverload) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[210];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn210.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn210.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn210.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [210]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[210]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[210]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[210]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn210.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.GetOverloadCounter1));
        }
      }

      /* path info */
      ssSetModelName(rts, "Get Overload\nCounter 1");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/Get Overload Counter 1");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn210.params;
        ssSetSFcnParamsCount(rts, 1);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.GetOverloadCounter1_P);
      }

      /* registration */
      xpcgetoverload(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.002);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 2;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking01_withElmos/<S1>/Get Overload Counter 2 (xpcgetoverload) */
    {
      SimStruct *rts = Walking01_withElmos_M->childSfunctions[211];

      /* timing info */
      time_T *sfcnPeriod =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn211.sfcnPeriod;
      time_T *sfcnOffset =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn211.sfcnOffset;
      int_T *sfcnTsMap =
        Walking01_withElmos_M->NonInlinedSFcns.Sfcn211.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking01_withElmos_M->NonInlinedSFcns.blkInfo2
                         [211]);
      }

      ssSetRTWSfcnInfo(rts, Walking01_withElmos_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods2[211]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking01_withElmos_M->
                           NonInlinedSFcns.methods3[211]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts,
                         &Walking01_withElmos_M->NonInlinedSFcns.statesInfo2[211]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn211.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking01_withElmos_B.GetOverloadCounter2));
        }
      }

      /* path info */
      ssSetModelName(rts, "Get Overload\nCounter 2");
      ssSetPath(rts,
                "Walking01_withElmos/DAQ_WITH_SAFETY_IMU/Get Overload Counter 2");
      ssSetRTModel(rts,Walking01_withElmos_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking01_withElmos_M->NonInlinedSFcns.Sfcn211.params;
        ssSetSFcnParamsCount(rts, 1);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking01_withElmos_ConstP.GetOverloadCounter2_P);
      }

      /* registration */
      xpcgetoverload(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 1;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }
  }

  /* Initialize Sizes */
  Walking01_withElmos_M->Sizes.numContStates = (0);/* Number of continuous states */
  Walking01_withElmos_M->Sizes.numY = (205);/* Number of model outputs */
  Walking01_withElmos_M->Sizes.numU = (0);/* Number of model inputs */
  Walking01_withElmos_M->Sizes.sysDirFeedThru = (0);/* The model is not direct feedthrough */
  Walking01_withElmos_M->Sizes.numSampTimes = (3);/* Number of sample times */
  Walking01_withElmos_M->Sizes.numBlocks = (916);/* Number of blocks */
  Walking01_withElmos_M->Sizes.numBlockIO = (305);/* Number of block outputs */
  Walking01_withElmos_M->Sizes.numBlockPrms = (834);/* Sum of parameter "widths" */
  return Walking01_withElmos_M;
}

/*========================================================================*
 * End of Classic call interface                                          *
 *========================================================================*/
