/*
 * Walking_ATRIAS.c
 *
 * Code generation for model "Walking_ATRIAS".
 *
 * Model version              : 1.290
 * Simulink Coder version : 8.7 (R2014b) 08-Sep-2014
 * C source code generated on : Wed Jul 20 18:48:36 2016
 *
 * Target selection: slrt.tlc
 * Note: GRT includes extra infrastructure and instrumentation for prototyping
 * Embedded hardware selection: Generic->32-bit x86 compatible
 * Code generation objectives: Unspecified
 * Validation result: Not run
 */
#include "rt_logging_mmi.h"
#include "Walking_ATRIAS_capi.h"
#include "Walking_ATRIAS.h"
#include "Walking_ATRIAS_private.h"
#include "Walking_ATRIAS_dt.h"

/* Named constants for Chart: '<S63>/Chart' */
#define Walking_ATRIAS_CALL_EVENT      (-1)
#define Walking_ATRIAS_IN_Fault        ((uint8_T)1U)
#define Walking_ATRIAS_IN_FaultRunning ((uint8_T)1U)
#define Walking_ATRIAS_IN_Running      ((uint8_T)3U)
#define Walking_ATRIAS_IN_Start1       ((uint8_T)4U)
#define Walking_ATRIA_IN_Initialization ((uint8_T)2U)
#define Walking_ATRI_IN_NO_ACTIVE_CHILD ((uint8_T)0U)
#define Walking_ATRI_IN_ReadyToSwitchOn ((uint8_T)2U)
#define Walking_ATR_IN_SwitchOnDisabled ((uint8_T)3U)

/* Named constants for Chart: '<S62>/Chart' */
#define Walking_ATRIAS_IN_Fault_l      ((uint8_T)1U)
#define Walking_ATRIAS_IN_Running_j    ((uint8_T)3U)
#define Walking_ATRIAS_IN_Start1_o     ((uint8_T)4U)
#define Walking_ATRIA_IN_FaultRunning_m ((uint8_T)1U)
#define Walking_ATR_IN_Initialization_d ((uint8_T)2U)
#define Walking_AT_IN_NO_ACTIVE_CHILD_b ((uint8_T)0U)
#define Walking_AT_IN_ReadyToSwitchOn_p ((uint8_T)2U)
#define Walking_A_IN_SwitchOnDisabled_j ((uint8_T)3U)

/* Block signals (auto storage) */
B_Walking_ATRIAS_T Walking_ATRIAS_B;

/* Block states (auto storage) */
DW_Walking_ATRIAS_T Walking_ATRIAS_DW;

/* External outputs (root outports fed by signals with auto storage) */
ExtY_Walking_ATRIAS_T Walking_ATRIAS_Y;

/* Real-time model */
RT_MODEL_Walking_ATRIAS_T Walking_ATRIAS_M_;
RT_MODEL_Walking_ATRIAS_T *const Walking_ATRIAS_M = &Walking_ATRIAS_M_;

/* Forward declaration for local functions */
static void Walking_ATRIAS_eml_li_find(const boolean_T x[2], int32_T y_data[],
  int32_T *y_sizes);
static void Walking_ATRIAS_eml_li_find_e(const boolean_T x[9], int32_T y_data[],
  int32_T *y_sizes);
static real_T Walking_ATRIAS_norm(const real_T x[3]);
static void Walking_ATRIAS_eml_sort(const real_T x[5], real_T y[5], int32_T idx
  [5]);
static void Walking_ATRIAS_eml_sort_c(const real_T x[3], real_T y[3], int32_T
  idx[3]);
static void Walking_MARLOBasicSafetyLimits3(const real_T q[13], const real_T dq
  [13], boolean_T violation[34]);
static boolean_T Walking_ATRIAS_any(const boolean_T x[6]);

/*
 * Output and update for action system:
 *    '<S73>/ShutdownControlWord'
 *    '<S90>/ShutdownControlWord'
 *    '<S107>/ShutdownControlWord'
 *    '<S124>/ShutdownControlWord'
 */
void Walking_ATR_ShutdownControlWord(uint16_T *rty_ControlWord)
{
  /* SignalConversion: '<S82>/OutportBufferForControlWord' incorporates:
   *  Constant: '<S82>/Constant'
   */
  *rty_ControlWord = ((uint16_T)6U);
}

/*
 * Output and update for action system:
 *    '<S73>/EnableControlWord'
 *    '<S90>/EnableControlWord'
 *    '<S107>/EnableControlWord'
 *    '<S124>/EnableControlWord'
 */
void Walking_ATRIA_EnableControlWord(uint16_T *rty_ControlWord)
{
  /* SignalConversion: '<S79>/OutportBufferForControlWord' incorporates:
   *  Constant: '<S79>/Constant'
   */
  *rty_ControlWord = ((uint16_T)15U);
}

/*
 * Output and update for action system:
 *    '<S73>/FaultReset'
 *    '<S90>/FaultReset'
 *    '<S107>/FaultReset'
 *    '<S124>/FaultReset'
 */
void Walking_ATRIAS_FaultReset(uint16_T *rty_ControlWord)
{
  /* SignalConversion: '<S80>/OutportBufferForControlWord' incorporates:
   *  Constant: '<S80>/Constant'
   */
  *rty_ControlWord = ((uint16_T)128U);
}

/*
 * Output and update for action system:
 *    '<S73>/NothingControlWord'
 *    '<S90>/NothingControlWord'
 *    '<S107>/NothingControlWord'
 *    '<S124>/NothingControlWord'
 */
void Walking_ATRI_NothingControlWord(uint16_T *rty_ControlWord)
{
  /* SignalConversion: '<S81>/OutportBufferForControlWord' incorporates:
   *  Constant: '<S81>/Constant'
   */
  *rty_ControlWord = ((uint16_T)0U);
}

/*
 * Initial conditions for atomic system:
 *    '<S63>/Chart'
 *    '<S65>/Chart'
 */
void Walking_ATRIAS_Chart_Init(DW_Chart_Walking_ATRIAS_T *localDW)
{
  localDW->sfEvent = Walking_ATRIAS_CALL_EVENT;
  localDW->is_Initialization = Walking_ATRI_IN_NO_ACTIVE_CHILD;
  localDW->is_active_c44_Walking_ATRIAS = 0U;
  localDW->is_c44_Walking_ATRIAS = Walking_ATRI_IN_NO_ACTIVE_CHILD;
}

/*
 * Output and update for atomic system:
 *    '<S63>/Chart'
 *    '<S65>/Chart'
 */
void Walking_ATRIAS_Chart(boolean_T rtu_SwitchOnDisabledMode, boolean_T
  rtu_EnabledMode, boolean_T rtu_ReadyToSwitchOnMode, boolean_T rtu_FaultMode,
  real_T rtu_MedullaCommand, B_Chart_Walking_ATRIAS_T *localB,
  DW_Chart_Walking_ATRIAS_T *localDW)
{
  boolean_T out;

  /* Gateway: Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_1R/Chart */
  localDW->sfEvent = Walking_ATRIAS_CALL_EVENT;

  /* During: Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_1R/Chart */
  if (localDW->is_active_c44_Walking_ATRIAS == 0U) {
    /* Entry: Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_1R/Chart */
    localDW->is_active_c44_Walking_ATRIAS = 1U;

    /* Entry Internal: Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_1R/Chart */
    /* Transition: '<S87>:185' */
    localDW->is_c44_Walking_ATRIAS = Walking_ATRIAS_IN_Start1;

    /* Entry 'Start1': '<S87>:181' */
    localB->ControlWordIndex = 0.0;
    localB->EnableTargetTorque = 0.0;
    localB->FaultDetected = 0.0;
  } else {
    switch (localDW->is_c44_Walking_ATRIAS) {
     case Walking_ATRIAS_IN_FaultRunning:
      /* During 'FaultRunning': '<S87>:171' */
      if (rtu_MedullaCommand == 6.0) {
        /* Transition: '<S87>:190' */
        localDW->is_c44_Walking_ATRIAS = Walking_ATRIAS_IN_Start1;

        /* Entry 'Start1': '<S87>:181' */
        localB->ControlWordIndex = 0.0;
        localB->EnableTargetTorque = 0.0;
        localB->FaultDetected = 0.0;
      }
      break;

     case Walking_ATRIA_IN_Initialization:
      /* During 'Initialization': '<S87>:168' */
      out = ((rtu_MedullaCommand == 4.0) || (rtu_MedullaCommand == 5.0));
      if (out) {
        /* Transition: '<S87>:184' */
        /* Exit Internal 'Initialization': '<S87>:168' */
        localDW->is_Initialization = Walking_ATRI_IN_NO_ACTIVE_CHILD;
        localDW->is_c44_Walking_ATRIAS = Walking_ATRIAS_IN_FaultRunning;

        /* Entry 'FaultRunning': '<S87>:171' */
        localB->ControlWordIndex = 1.0;
        localB->EnableTargetTorque = 0.0;
        localB->FaultDetected = 1.0;
      } else {
        switch (localDW->is_Initialization) {
         case Walking_ATRIAS_IN_Fault:
          /* During 'Fault': '<S87>:187' */
          if (localDW->Timeout >= 20.0) {
            /* Transition: '<S87>:188' */
            localDW->is_Initialization = Walking_ATRIAS_IN_Fault;

            /* Entry 'Fault': '<S87>:187' */
            localB->ControlWordIndex = 3.0;
            localB->EnableTargetTorque = 0.0;
            localDW->Timeout = 0.0;
            localB->FaultDetected = 0.0;
          } else if (rtu_SwitchOnDisabledMode == 1) {
            /* Transition: '<S87>:174' */
            localDW->is_Initialization = Walking_ATR_IN_SwitchOnDisabled;

            /* Entry 'SwitchOnDisabled': '<S87>:183' */
            localB->ControlWordIndex = 1.0;
            localDW->Timeout = 0.0;
            localB->EnableTargetTorque = 0.0;
            localB->FaultDetected = 0.0;
          } else {
            localDW->Timeout++;
            localB->ControlWordIndex = 0.0;
          }
          break;

         case Walking_ATRI_IN_ReadyToSwitchOn:
          /* During 'ReadyToSwitchOn': '<S87>:186' */
          if (rtu_FaultMode == 1) {
            /* Transition: '<S87>:167' */
            localDW->is_Initialization = Walking_ATRIAS_IN_Fault;

            /* Entry 'Fault': '<S87>:187' */
            localB->ControlWordIndex = 3.0;
            localB->EnableTargetTorque = 0.0;
            localDW->Timeout = 0.0;
            localB->FaultDetected = 0.0;
          } else if (rtu_SwitchOnDisabledMode == 1) {
            /* Transition: '<S87>:176' */
            localDW->is_Initialization = Walking_ATR_IN_SwitchOnDisabled;

            /* Entry 'SwitchOnDisabled': '<S87>:183' */
            localB->ControlWordIndex = 1.0;
            localDW->Timeout = 0.0;
            localB->EnableTargetTorque = 0.0;
            localB->FaultDetected = 0.0;
          } else {
            out = (rtu_EnabledMode == 1);
            if (out) {
              /* Transition: '<S87>:182' */
              localDW->is_Initialization = Walking_ATRI_IN_NO_ACTIVE_CHILD;
              localDW->is_c44_Walking_ATRIAS = Walking_ATRIAS_IN_Running;

              /* Entry 'Running': '<S87>:178' */
              localB->FaultDetected = 0.0;
              localB->ControlWordIndex = 2.0;
              localB->EnableTargetTorque = 1.0;
            } else {
              localDW->Timeout++;
            }
          }
          break;

         default:
          /* During 'SwitchOnDisabled': '<S87>:183' */
          if (rtu_ReadyToSwitchOnMode == 1) {
            /* Transition: '<S87>:170' */
            localDW->is_Initialization = Walking_ATRI_IN_ReadyToSwitchOn;

            /* Entry 'ReadyToSwitchOn': '<S87>:186' */
            localB->ControlWordIndex = 2.0;
            localDW->Timeout = 0.0;
            localB->EnableTargetTorque = 0.0;
            localB->FaultDetected = 0.0;
          } else if (rtu_FaultMode == 1) {
            /* Transition: '<S87>:172' */
            localDW->is_Initialization = Walking_ATRIAS_IN_Fault;

            /* Entry 'Fault': '<S87>:187' */
            localB->ControlWordIndex = 3.0;
            localB->EnableTargetTorque = 0.0;
            localDW->Timeout = 0.0;
            localB->FaultDetected = 0.0;
          } else {
            localDW->Timeout++;
          }
          break;
        }
      }
      break;

     case Walking_ATRIAS_IN_Running:
      /* During 'Running': '<S87>:178' */
      if (rtu_FaultMode == 1) {
        /* Transition: '<S87>:169' */
        localDW->is_c44_Walking_ATRIAS = Walking_ATRIAS_IN_FaultRunning;

        /* Entry 'FaultRunning': '<S87>:171' */
        localB->ControlWordIndex = 1.0;
        localB->EnableTargetTorque = 0.0;
        localB->FaultDetected = 1.0;
      } else {
        out = ((rtu_MedullaCommand == 4.0) || (rtu_MedullaCommand == 5.0));
        if (out) {
          /* Transition: '<S87>:189' */
          localDW->is_c44_Walking_ATRIAS = Walking_ATRIAS_IN_FaultRunning;

          /* Entry 'FaultRunning': '<S87>:171' */
          localB->ControlWordIndex = 1.0;
          localB->EnableTargetTorque = 0.0;
          localB->FaultDetected = 1.0;
        }
      }
      break;

     default:
      /* During 'Start1': '<S87>:181' */
      if (rtu_MedullaCommand == 2.0) {
        /* Transition: '<S87>:175' */
        localDW->is_c44_Walking_ATRIAS = Walking_ATRIA_IN_Initialization;

        /* Entry Internal 'Initialization': '<S87>:168' */
        /* Transition: '<S87>:180' */
        localDW->is_Initialization = Walking_ATR_IN_SwitchOnDisabled;

        /* Entry 'SwitchOnDisabled': '<S87>:183' */
        localB->ControlWordIndex = 1.0;
        localDW->Timeout = 0.0;
        localB->EnableTargetTorque = 0.0;
        localB->FaultDetected = 0.0;
      }
      break;
    }
  }
}

/* Function for MATLAB Function: '<S38>/calibrate' */
static void Walking_ATRIAS_eml_li_find(const boolean_T x[2], int32_T y_data[],
  int32_T *y_sizes)
{
  int32_T k;
  k = 0;
  if (x[0]) {
    k = 1;
  }

  if (x[1]) {
    k++;
  }

  *y_sizes = k;
  k = 0;
  if (x[0]) {
    y_data[0] = 1;
    k = 1;
  }

  if (x[1]) {
    y_data[k] = 2;
  }
}

/* Function for MATLAB Function: '<S38>/calibrate' */
static void Walking_ATRIAS_eml_li_find_e(const boolean_T x[9], int32_T y_data[],
  int32_T *y_sizes)
{
  int32_T k;
  int32_T b_i;
  k = 0;
  for (b_i = 0; b_i < 9; b_i++) {
    if (x[b_i]) {
      k++;
    }
  }

  *y_sizes = k;
  k = 0;
  for (b_i = 0; b_i < 9; b_i++) {
    if (x[b_i]) {
      y_data[k] = b_i + 1;
      k++;
    }
  }
}

real_T rt_roundd_snf(real_T u)
{
  real_T y;
  if (fabs(u) < 4.503599627370496E+15) {
    if (u >= 0.5) {
      y = floor(u + 0.5);
    } else if (u > -0.5) {
      y = u * 0.0;
    } else {
      y = ceil(u - 0.5);
    }
  } else {
    y = u;
  }

  return y;
}

/* Function for MATLAB Function: '<S38>/EstimateOrientation' */
static real_T Walking_ATRIAS_norm(const real_T x[3])
{
  real_T y;
  real_T scale;
  real_T absxk;
  real_T t;
  scale = 2.2250738585072014E-308;
  absxk = fabs(x[0]);
  if (absxk > 2.2250738585072014E-308) {
    y = 1.0;
    scale = absxk;
  } else {
    t = absxk / 2.2250738585072014E-308;
    y = t * t;
  }

  absxk = fabs(x[1]);
  if (absxk > scale) {
    t = scale / absxk;
    y = y * t * t + 1.0;
    scale = absxk;
  } else {
    t = absxk / scale;
    y += t * t;
  }

  absxk = fabs(x[2]);
  if (absxk > scale) {
    t = scale / absxk;
    y = y * t * t + 1.0;
    scale = absxk;
  } else {
    t = absxk / scale;
    y += t * t;
  }

  return scale * sqrt(y);
}

real_T rt_atan2d_snf(real_T u0, real_T u1)
{
  real_T y;
  int32_T tmp;
  int32_T tmp_0;
  if (rtIsNaN(u0) || rtIsNaN(u1)) {
    y = (rtNaN);
  } else if (rtIsInf(u0) && rtIsInf(u1)) {
    if (u1 > 0.0) {
      tmp = 1;
    } else {
      tmp = -1;
    }

    if (u0 > 0.0) {
      tmp_0 = 1;
    } else {
      tmp_0 = -1;
    }

    y = atan2(tmp_0, tmp);
  } else if (u1 == 0.0) {
    if (u0 > 0.0) {
      y = RT_PI / 2.0;
    } else if (u0 < 0.0) {
      y = -(RT_PI / 2.0);
    } else {
      y = 0.0;
    }
  } else {
    y = atan2(u0, u1);
  }

  return y;
}

static void Walking_ATRIAS_eml_sort(const real_T x[5], real_T y[5], int32_T idx
  [5])
{
  real_T x_0[5];
  int32_T idx0[5];
  int32_T i2;
  int32_T j;
  int32_T pEnd;
  int32_T p;
  int32_T q;
  int32_T qEnd;
  int32_T kEnd;
  int32_T k;
  real_T b;
  real_T v[5];
  int32_T irow1;
  int32_T irow2;
  boolean_T p_0;
  int32_T i;
  real_T y_0;

  /* Start for MATLABSystem: '<S2>/Controller3' */
  for (irow1 = 0; irow1 < 5; irow1++) {
    x_0[irow1] = x[irow1];
    idx[irow1] = irow1 + 1;
  }

  for (k = 0; k <= 2; k += 2) {
    pEnd = k + 1;
    for (irow1 = 0; irow1 < 5; irow1++) {
      v[irow1] = x_0[irow1];
    }

    y_0 = v[k];
    b = v[pEnd];
    p_0 = (y_0 <= b);
    if (!p_0) {
      p_0 = rtIsNaN(b);
    }

    if (!p_0) {
      pEnd = k + 2;
      idx[k] = pEnd;
      pEnd = k + 1;
      idx[pEnd] = k + 1;
    }
  }

  for (i = 0; i < 5; i++) {
    idx0[i] = 1;
  }

  i = 2;
  while (i < 5) {
    i2 = i << 1;
    j = 1;
    pEnd = 1 + i;
    while (pEnd < 6) {
      p = j - 1;
      q = pEnd - 1;
      qEnd = j + i2;
      if (qEnd > 6) {
        qEnd = 6;
      }

      k = 0;
      kEnd = qEnd - j;
      while (k + 1 <= kEnd) {
        for (irow1 = 0; irow1 < 5; irow1++) {
          v[irow1] = x_0[irow1];
        }

        irow1 = idx[p] - 1;
        irow2 = idx[q] - 1;
        y_0 = v[irow1];
        b = v[irow2];
        p_0 = (y_0 <= b);
        if (!p_0) {
          p_0 = rtIsNaN(b);
        }

        if (p_0) {
          idx0[k] = idx[p];
          p++;
          if (p + 1 == pEnd) {
            while (q + 1 < qEnd) {
              k++;
              idx0[k] = idx[q];
              q++;
            }
          }
        } else {
          idx0[k] = idx[q];
          q++;
          if (q + 1 == qEnd) {
            while (p + 1 < pEnd) {
              k++;
              idx0[k] = idx[p];
              p++;
            }
          }
        }

        k++;
      }

      p = j - 1;
      for (k = 1; k <= kEnd; k++) {
        pEnd = (p + k) - 1;
        idx[pEnd] = idx0[k - 1];
      }

      j = qEnd;
      pEnd = qEnd + i;
    }

    i = i2;
  }

  for (k = 0; k < 5; k++) {
    y_0 = x_0[idx[k] - 1];
    y[k] = y_0;
  }

  /* End of Start for MATLABSystem: '<S2>/Controller3' */
}

static void Walking_ATRIAS_eml_sort_c(const real_T x[3], real_T y[3], int32_T
  idx[3])
{
  real_T a;
  real_T b;
  boolean_T p;
  real_T x_idx_2;
  real_T x_idx_1;
  real_T x_idx_0;

  /* Start for MATLABSystem: '<S2>/Controller3' */
  x_idx_0 = x[0];
  x_idx_1 = x[1];
  x_idx_2 = x[2];
  a = x_idx_0;
  b = x_idx_1;
  p = (a <= b);
  if (!p) {
    p = rtIsNaN(b);
  }

  if (p) {
    a = x_idx_1;
    b = x_idx_2;
    p = (a <= b);
    if (!p) {
      p = rtIsNaN(b);
    }

    if (p) {
      idx[0] = 1;
      idx[1] = 2;
      idx[2] = 3;
      y[0] = x_idx_0;
      y[1] = x_idx_1;
      y[2] = x_idx_2;
    } else {
      a = x_idx_0;
      p = (a <= b);
      if (!p) {
        p = rtIsNaN(b);
      }

      if (p) {
        idx[0] = 1;
        idx[1] = 3;
        idx[2] = 2;
        y[0] = x_idx_0;
        y[1] = x_idx_2;
        y[2] = x_idx_1;
      } else {
        idx[0] = 3;
        idx[1] = 1;
        idx[2] = 2;
        y[0] = x_idx_2;
        y[1] = x_idx_0;
        y[2] = x_idx_1;
      }
    }
  } else {
    b = x_idx_2;
    p = (a <= b);
    if (!p) {
      p = rtIsNaN(b);
    }

    if (p) {
      idx[0] = 2;
      idx[1] = 1;
      idx[2] = 3;
      y[0] = x_idx_1;
      y[1] = x_idx_0;
      y[2] = x_idx_2;
    } else {
      a = x_idx_1;
      p = (a <= b);
      if (!p) {
        p = rtIsNaN(b);
      }

      if (p) {
        idx[0] = 2;
        idx[1] = 3;
        idx[2] = 1;
        y[0] = x_idx_1;
        y[1] = x_idx_2;
        y[2] = x_idx_0;
      } else {
        idx[0] = 3;
        idx[1] = 2;
        idx[2] = 1;
        y[0] = x_idx_2;
        y[1] = x_idx_1;
        y[2] = x_idx_0;
      }
    }
  }

  /* End of Start for MATLABSystem: '<S2>/Controller3' */
}

real_T rt_powd_snf(real_T u0, real_T u1)
{
  real_T y;
  real_T tmp;
  real_T tmp_0;
  if (rtIsNaN(u0) || rtIsNaN(u1)) {
    y = (rtNaN);
  } else {
    tmp = fabs(u0);
    tmp_0 = fabs(u1);
    if (rtIsInf(u1)) {
      if (tmp == 1.0) {
        y = (rtNaN);
      } else if (tmp > 1.0) {
        if (u1 > 0.0) {
          y = (rtInf);
        } else {
          y = 0.0;
        }
      } else if (u1 > 0.0) {
        y = 0.0;
      } else {
        y = (rtInf);
      }
    } else if (tmp_0 == 0.0) {
      y = 1.0;
    } else if (tmp_0 == 1.0) {
      if (u1 > 0.0) {
        y = u0;
      } else {
        y = 1.0 / u0;
      }
    } else if (u1 == 2.0) {
      y = u0 * u0;
    } else if ((u1 == 0.5) && (u0 >= 0.0)) {
      y = sqrt(u0);
    } else if ((u0 < 0.0) && (u1 > floor(u1))) {
      y = (rtNaN);
    } else {
      y = pow(u0, u1);
    }
  }

  return y;
}

/* Function for MATLAB Function: '<S8>/SAFETY' */
static void Walking_MARLOBasicSafetyLimits3(const real_T q[13], const real_T dq
  [13], boolean_T violation[34])
{
  real_T qbar[34];
  real_T dqbar[34];
  static const int8_T b[34] = { 40, 40, 10, 10, 30, 30, 40, 40, 40, 40, 10, 10,
    30, 30, 40, 40, 5, 5, 4, 4, 4, 4, 5, 5, 4, 4, 20, 5, 5, 10, 20, 20, 20, 20 };

  static const int16_T dqmax[34] = { 600, 600, 600, 600, 600, 600, 800, 800, 600,
    600, 600, 600, 600, 600, 800, 800, 600, 600, 600, 600, 1000, 1000, 1000,
    1000, 400, 400, 600, 600, 250, 250, 600, 600, 600, 600 };

  static const uint8_T qmax[34] = { 240U, 240U, 250U, 250U, 230U, 230U, 180U,
    180U, 240U, 240U, 250U, 250U, 230U, 230U, 180U, 180U, 10U, 10U, 5U, 5U, 5U,
    5U, 8U, 8U, 12U, 12U, 70U, 25U, 25U, 20U, 240U, 240U, 240U, 240U };

  static const int8_T c[34] = { 40, 40, 40, 40, 20, 20, 5, 5, 40, 40, 40, 40, 20,
    20, 5, 5, 3, 3, 5, 5, 4, 4, 10, 10, 0, 0, 20, 0, 5, 10, 20, 20, 20, 20 };

  static const int16_T dqmin[34] = { -600, -600, -600, -600, -600, -600, -800,
    -800, -600, -600, -600, -600, -600, -600, -800, -800, -600, -600, -600, -600,
    -1000, -1000, -1000, -1000, -400, -400, -600, -600, -250, -250, -600, -600,
    -600, -600 };

  static const int16_T qmin[34] = { 100, 100, 140, 140, 130, 130, 30, 30, 100,
    100, 140, 140, 130, 130, 30, 30, -4, -4, -10, -10, -8, -8, -20, -20, -20,
    -20, -70, -40, -25, -20, 120, 120, 120, 120 };

  static const real_T a[442] = { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, -0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 0.5,
    0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, -0.5, 0.0, -1.0,
    0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
    0.0, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0,
    0.0, 0.0, -0.5, 0.0, 1.0, 0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0,
    0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, -1.0, 0.0, -0.5, 0.0, -1.0, 0.0, 0.0, -0.5, 0.0, 0.0,
    0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.5, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.5, 0.0, -1.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5,
    0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,
    0.5, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.5, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0, 0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.0, 1.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 };

  real_T a_0[34];
  int32_T i;
  int32_T i_0;
  real_T a_1[34];
  real_T a_2;

  /*  MARLOBASICSAFETYLIMITS3 Checks to see if the configuration and velocity satisfy basic safety limits. */
  /*  % q1 */
  /*  % q2 */
  /*  % qLA */
  /*  % qKA */
  /*  % qgr1 */
  /*  % qgr2 */
  /*  % qgrLA */
  /*  % qgrKA */
  /*  % qsp1 */
  /*  % qsp2 */
  /*  % qspLA */
  /*  % qspKA */
  /*  % q3 */
  /*  % qDLA */
  /*  % q3RL */
  /*  % qxT */
  /*  % qyT */
  /*  % theta */
  /*  % thetagr */
  /*  % minimum q */
  /*  % q1 */
  /*  % q2 */
  /*  % qLA */
  /*  % qKA */
  /*  % qgr1 */
  /*  % qgr2 */
  /*  % qgrLA */
  /*  % qgrKA */
  /*  % qsp1 */
  /*  % qsp2 */
  /*  % qspLA */
  /*  % qspKA */
  /*  % q3 */
  /*  % qDLA */
  /*  % q3RL */
  /*  % qxT */
  /*  % qyT */
  /*  % theta */
  /*  % thetagr */
  /*  % maximum q */
  /*  % q1 */
  /*  % q2 */
  /*  % qLA */
  /*  % qKA */
  /*  % qgr1 */
  /*  % qgr2 */
  /*  % qgrLA */
  /*  % qgrKA */
  /*  % qsp1 */
  /*  % qsp2 */
  /*  % qspLA */
  /*  % qspKA */
  /*  % q3 */
  /*  % qDLA */
  /*  % q3RL */
  /*  % qxT */
  /*  % qyT */
  /*  % theta */
  /*  % thetagr */
  /*  % minimum dq */
  /*  % q1 */
  /*  % q2 */
  /*  % qLA */
  /*  % qKA */
  /*  % qgr1 */
  /*  % qgr2 */
  /*  % qgrLA */
  /*  % qgrKA */
  /*  % qsp1 */
  /*  % qsp2 */
  /*  % qspLA */
  /*  % qspKA */
  /*  % q3 */
  /*  % qDLA */
  /*  % q3RL */
  /*  % qxT */
  /*  % qyT */
  /*  % theta */
  /*  % thetagr */
  /*  % maximum dq */
  /*  % q1 */
  /*  % q2 */
  /*  % qLA */
  /*  % qKA */
  /*  % qgr1 */
  /*  % qgr2 */
  /*  % qgrLA */
  /*  % qgrKA */
  /*  % qsp1 */
  /*  % qsp2 */
  /*  % qspLA */
  /*  % qspKA */
  /*  % q3 */
  /*  % qDLA */
  /*  % q3RL */
  /*  % qxT */
  /*  % qyT */
  /*  % theta */
  /*  % thetagr */
  /*  % minimum q at full negative velocity (dqmin) */
  /*  % q1 */
  /*  % q2 */
  /*  % qLA */
  /*  % qKA */
  /*  % qgr1 */
  /*  % qgr2 */
  /*  % qgrLA */
  /*  % qgrKA */
  /*  % qsp1 */
  /*  % qsp2 */
  /*  % qspLA */
  /*  % qspKA */
  /*  % q3 */
  /*  % qDLA */
  /*  % q3RL */
  /*  % qxT */
  /*  % qyT */
  /*  % theta */
  /*  % thetagr */
  /*  % maximum q at full positive velocity (dqmax) */
  /*  % q1 */
  /*  % q2 */
  /*  % qLA */
  /*  % qKA */
  /*  % qgr1 */
  /*  % qgr2 */
  /*  % qgrLA */
  /*  % qgrKA */
  /*  % qsp1 */
  /*  % qsp2 */
  /*  % qspLA */
  /*  % qspKA */
  /*  % q3 */
  /*  % qDLA */
  /*  % q3RL */
  /*  % qxT */
  /*  % qyT */
  /*  % theta */
  /*  % thetagr */
  /*  Check limits */
  for (i = 0; i < 34; i++) {
    a_0[i] = 0.0;
    for (i_0 = 0; i_0 < 13; i_0++) {
      a_2 = a_0[i];
      a_2 += a[34 * i_0 + i] * q[i_0];
      a_0[i] = a_2;
    }

    qbar[i] = a_0[i] * 180.0 / 3.1415926535897931;
    a_1[i] = 0.0;
    for (i_0 = 0; i_0 < 13; i_0++) {
      a_2 = a_1[i];
      a_2 += a[34 * i_0 + i] * dq[i_0];
      a_1[i] = a_2;
    }

    dqbar[i] = a_1[i] * 180.0 / 3.1415926535897931;
    violation[i] = ((qbar[i] < qmin[i]) || (qbar[i] > qmax[i]) || (dqbar[i] <
      dqmin[i]) || (dqbar[i] > dqmax[i]) || (dqbar[i] * (real_T)c[i] < (qbar[i]
      - (real_T)qmin[i]) * (real_T)dqmin[i]) || (dqbar[i] * (real_T)b[i] >
      ((real_T)qmax[i] - qbar[i]) * (real_T)dqmax[i]));
  }
}

/* Function for MATLAB Function: '<S8>/SAFETY' */
static boolean_T Walking_ATRIAS_any(const boolean_T x[6])
{
  boolean_T y;
  boolean_T b;
  int32_T k;
  boolean_T exitg1;
  y = false;
  k = 0;
  exitg1 = false;
  while ((!exitg1) && (k < 6)) {
    b = (x[k] == 0);
    if (!b) {
      y = true;
      exitg1 = true;
    } else {
      k++;
    }
  }

  return y;
}

/* Model output function */
void Walking_ATRIAS_output(void)
{
  /* local scratch DWork variables */
  int32_T ForEach_itr;
  real_T RefAngle[6];
  real_T AbsUnrolled[2];
  real_T AbsEncoder[2];
  boolean_T iHigh[2];
  real_T NormalizedCountPrev[9];
  real_T NormalizedCount[9];
  real_T x[6];
  boolean_T AccelValid;
  boolean_T GyroValid;
  real_T n;
  real_T w[3];
  boolean_T b;
  uint8_T Status;
  real_T B;
  int8_T I[9];
  static const int8_T b_a[9] = { 1, 0, 0, 0, 1, 0, 0, 0, 1 };

  real_T CurrentYaw;
  real_T y[9];
  int32_T r1;
  int32_T r2;
  real_T maxval;
  real_T a21;
  int32_T rtemp;
  static const int8_T c[13] = { 16, 17, 18, 0, 1, 2, 3, 4, 5, 14, 6, 7, 15 };

  static const int8_T b_0[8] = { 3, 4, 5, 6, 7, 8, 10, 11 };

  real_T x_0[34];
  int32_T exponent;
  int32_T b_exponent;
  static const real_T SS_DYNAMIC_STATE_LIMIT[34] = { 1.0, 2.0, 4.0, 8.0, 16.0,
    32.0, 64.0, 128.0, 256.0, 512.0, 1024.0, 2048.0, 4096.0, 8192.0, 16384.0,
    32768.0, 65536.0, 131072.0, 262144.0, 524288.0, 1.048576E+6, 2.097152E+6,
    4.194304E+6, 8.388608E+6, 1.6777216E+7, 3.3554432E+7, 6.7108864E+7,
    1.34217728E+8, 2.68435456E+8, 5.36870912E+8, 1.073741824E+9, 2.147483648E+9,
    4.294967296E+9, 8.589934592E+9 };

  uint32_T LimitSwitchesVec[6];
  boolean_T isTest5;
  boolean_T isTest8;
  boolean_T isTest11;
  boolean_T isTest12;
  boolean_T isSim;
  real_T u0[13];
  real_T u1[13];
  real_T u2;
  real_T u3[18];
  real_T u4[360];
  real_T u7[11];
  boolean_T p;
  real_T varargin_1;
  Controller3DHZD_obj_2_Walking_T *obj;
  real_T varargout_3[16];
  Controller3DHZD_obj_2_Walking_T *obj_0;
  real_T q_d[4];
  boolean_T p_0;
  PS3Controller_2_Walking_ATRIA_T *obj_1;
  boolean_T buttons[11];
  real_T q_st_mA;
  real_T dq_st_mA;
  real_T q_st_mB;
  real_T dq_st_mB;
  real_T q_st_lA;
  real_T dq_st_lA;
  real_T q_st_lB;
  real_T dq_st_lB;
  real_T q_st_h;
  real_T dq_st_h;
  real_T q_sw_mA;
  real_T dq_sw_mA;
  real_T q_sw_mB;
  real_T dq_sw_mB;
  real_T q_sw_lA;
  real_T dq_sw_lA;
  real_T q_sw_lB;
  real_T dq_sw_lB;
  real_T q_sw_h;
  real_T dq_sw_h;
  real_T q_roll;
  real_T dq_roll;
  real_T q_pitch;
  real_T dq_pitch;
  real_T footHeight;
  real_T l_st_h;
  real_T l_sw_h;
  real_T x_t;
  real_T y_t;
  real_T s_st;
  real_T s_sw;
  real_T alpha;
  real_T dxInput;
  real_T y_sw_tgt;
  real_T L;
  real_T q_sw_h_tgt;
  real_T HAlpha[24];
  real_T HAlpha_norm[24];
  real_T hd2;
  real_T vKneeSpring[2];
  real_T uLegSpring[2];
  real_T hd_q[4];
  real_T dq_d[9];
  real_T dq_0[9];
  real_T delta_dq[4];
  PS3Button_Walking_ATRIAS_T *obj_2;
  Controller3DHZD_obj_2_Walking_T *obj_3;
  real_T y_0;
  real_T y_1;
  real_T y_2;
  real_T y_3;
  real_T y_4;
  real_T hAlphaSet[360];
  real_T hSet[3];
  real_T A[16];
  real_T alpha_0[6];
  int8_T a[36];
  real_T t3;
  real_T t5;
  real_T t11;
  real_T q3R;
  real_T t2;
  real_T t36;
  real_T t30;
  real_T t21;
  real_T t42;
  real_T t51;
  real_T t99;
  real_T minAbs[5];
  real_T dxSet[5];
  real_T HAlpha_hSet[72];
  real_T minAbs_0[3];
  real_T y1[20];
  int32_T ix;
  int32_T iyLead;
  real_T sum_term;
  real_T L_opt_2[4];
  real_T L_opt_3[4];
  real_T L_opt_4[4];
  real_T L_opt_5[4];
  real_T L_opt_6[4];
  real_T L_opt_7[4];
  real_T L_opt_8[4];
  real_T L_opt_9[4];
  real_T L_opt_2_0[4];
  real_T L_opt_3_0[4];
  real_T L_opt_4_0[4];
  real_T L_opt_5_0[4];
  real_T L_opt_6_0[4];
  real_T L_opt_7_0[4];
  real_T L_opt_8_0[4];
  real_T L_opt_9_0[4];
  real_T y_5;
  real_T x_1[5];
  real_T a_0[72];
  real_T x_2[3];
  real_T a_1[24];
  real_T a_min;
  real_T a_max;
  int32_T iidx[5];
  int32_T iidx_0[3];
  real_T A_0[16];
  int8_T ipiv[4];
  int32_T j;
  int32_T mmj;
  int32_T jj;
  int32_T jp1j;
  int32_T c_0;
  real_T rtb_ImpSel_InsertedFor_q_at_out;
  int32_T i;
  static const real_T tmp[5] = { 0.8, 0.4, 0.0, -0.4, -0.8 };

  static const real_T tmp_0[16] = { 0.5, 0.0, 1.0, 0.0, 0.5, 0.0, -1.0, 0.0, 0.0,
    0.5, 0.0, 1.0, 0.0, 0.5, 0.0, -1.0 };

  static const int8_T tmp_1[6] = { 0, 0, 1, 1, 1, 1 };

  static const int8_T tmp_2[5] = { 0, 1, 0, 0, 0 };

  static const real_T tmp_3[16] = { -0.5, -0.0, -1.0, -0.0, -0.5, -0.0, 1.0,
    -0.0, -0.0, -0.5, -0.0, -1.0, -0.0, -0.5, -0.0, 1.0 };

  static const int8_T tmp_4[36] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
    0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 };

  boolean_T RefAngle_0[6];
  boolean_T tmp_5[34];
  boolean_T NormalizedCountPrev_0[9];
  real_T tmp_6[9];
  real_T w_0[9];
  real_T b_a_0[9];
  real_T tmp_7[8];
  real_T tmp_8[9];
  real_T HAlpha_0[6];
  real_T obj_4[6];
  real_T obj_5[6];
  real_T b_data[2];
  real_T c_data[2];
  int32_T d_data[9];
  int32_T e_data[2];
  real_T sum_term_idx_3;
  real_T sum_term_idx_0;
  real_T sum_term_idx_0_0;
  real_T uDamping_idx_3;
  real_T uDamping_idx_2;
  real_T HalfMaxTicks_idx_1;
  real_T CalOffset_idx_1;
  real_T HalfMaxTicks_idx_0;
  real_T CalOffset_idx_0;
  real_T u_Link_idx_3;
  real_T u_Link_idx_2;
  real_T u_Link_idx_1;
  real_T u_Link_idx_0;
  real_T x_re;
  uint32_T tmp_9;
  boolean_T guard1 = false;
  boolean_T exitg1;
  boolean_T exitg2;
  boolean_T exitg3;
  boolean_T exitg4;
  boolean_T exitg5;
  boolean_T exitg6;
  boolean_T exitg7;
  boolean_T exitg8;
  boolean_T exitg9;
  boolean_T exitg10;
  boolean_T exitg11;
  boolean_T exitg12;
  boolean_T exitg13;
  boolean_T exitg14;
  boolean_T exitg15;
  boolean_T exitg16;
  boolean_T exitg17;
  boolean_T exitg18;
  boolean_T exitg19;
  boolean_T exitg20;
  boolean_T exitg21;
  boolean_T exitg22;
  boolean_T exitg23;
  boolean_T exitg24;
  boolean_T exitg25;
  boolean_T exitg26;
  boolean_T exitg27;
  boolean_T exitg28;
  boolean_T exitg29;
  boolean_T exitg30;
  boolean_T exitg31;
  boolean_T exitg32;
  boolean_T exitg33;
  boolean_T exitg34;
  boolean_T exitg35;
  boolean_T exitg36;
  boolean_T exitg37;
  boolean_T exitg38;
  boolean_T exitg39;
  boolean_T exitg40;

  {
    /* user code (Output function Header) */

    /*------------ S-Function Block: <S45>/EtherCAT Init  Process Received Frames ------------*/
    xpcEtherCATReadProcessData(3,NULL);

    /* Reset subsysRan breadcrumbs */
    srClearBC
      (Walking_ATRIAS_DW.ShutdownControlWord.ShutdownControlWord_SubsysRanBC);

    /* Reset subsysRan breadcrumbs */
    srClearBC(Walking_ATRIAS_DW.EnableControlWord.EnableControlWord_SubsysRanBC);

    /* Reset subsysRan breadcrumbs */
    srClearBC(Walking_ATRIAS_DW.FaultReset.FaultReset_SubsysRanBC);

    /* Reset subsysRan breadcrumbs */
    srClearBC
      (Walking_ATRIAS_DW.NothingControlWord.NothingControlWord_SubsysRanBC);

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[0];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion49' */
    Walking_ATRIAS_B.DataTypeConversion49 = Walking_ATRIAS_B.EtherCATRxVar4;

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[1];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion73' */
    Walking_ATRIAS_B.DataTypeConversion73 = Walking_ATRIAS_B.EtherCATRxVar4_l;

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[2];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion3' */
    Walking_ATRIAS_B.DataTypeConversion3 = Walking_ATRIAS_B.EtherCATRxVar4_o;

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[3];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion25' */
    Walking_ATRIAS_B.DataTypeConversion25 = Walking_ATRIAS_B.EtherCATRxVar4_h;

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[4];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion50' */
    Walking_ATRIAS_B.DataTypeConversion50 = Walking_ATRIAS_B.EtherCATRxVar8;

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[5];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion74' */
    Walking_ATRIAS_B.DataTypeConversion74 = Walking_ATRIAS_B.EtherCATRxVar8_b;

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[6];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion1' */
    Walking_ATRIAS_B.DataTypeConversion1 = Walking_ATRIAS_B.EtherCATRxVar8_h;

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[7];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion26' */
    Walking_ATRIAS_B.DataTypeConversion26 = Walking_ATRIAS_B.EtherCATRxVar8_bx;

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[8];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion98' */
    Walking_ATRIAS_B.DataTypeConversion98 = Walking_ATRIAS_B.EtherCATRxVar4_e;

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[9];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion114' */
    Walking_ATRIAS_B.DataTypeConversion114 = Walking_ATRIAS_B.EtherCATRxVar4_j;

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[10];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion57' */
    Walking_ATRIAS_B.DataTypeConversion57 = Walking_ATRIAS_B.EtherCATRxVar_n;

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[11];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion81' */
    Walking_ATRIAS_B.DataTypeConversion81 = Walking_ATRIAS_B.EtherCATRxVar_k;

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[12];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion9' */
    Walking_ATRIAS_B.DataTypeConversion9 = Walking_ATRIAS_B.EtherCATRxVar_nk;

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[13];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion33' */
    Walking_ATRIAS_B.DataTypeConversion33 = Walking_ATRIAS_B.EtherCATRxVar_o;

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[14];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion104' */
    Walking_ATRIAS_B.DataTypeConversion104 = Walking_ATRIAS_B.EtherCATRxVar2_i;

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[15];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion119' */
    Walking_ATRIAS_B.DataTypeConversion119 = Walking_ATRIAS_B.EtherCATRxVar2_p;

    /* UnitDelay: '<S33>/Unit Delay' */
    Walking_ATRIAS_B.UnitDelay_l = Walking_ATRIAS_DW.UnitDelay_DSTATE_b;

    /* Logic: '<S33>/Logical Operator1' incorporates:
     *  Constant: '<S33>/ResetDAQ1'
     */
    Walking_ATRIAS_B.LogicalOperator1 = (false || Walking_ATRIAS_B.UnitDelay_l);
    for (i = 0; i < 9; i++) {
      /* UnitDelay: '<S38>/Unit Delay1' */
      Walking_ATRIAS_B.UnitDelay1[i] = Walking_ATRIAS_DW.UnitDelay1_DSTATE[i];

      /* UnitDelay: '<S38>/Unit Delay' */
      Walking_ATRIAS_B.UnitDelay[i] = Walking_ATRIAS_DW.UnitDelay_DSTATE[i];
    }

    /* UnitDelay: '<S38>/Unit Delay2' */
    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.UnitDelay2[i] = Walking_ATRIAS_DW.UnitDelay2_DSTATE[i];
    }

    /* End of UnitDelay: '<S38>/Unit Delay2' */

    /* SignalConversion: '<S47>/TmpSignal ConversionAt SFunction Inport2' incorporates:
     *  MATLAB Function: '<S38>/calibrate'
     */
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctionI[0] =
      Walking_ATRIAS_B.DataTypeConversion49;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctionI[1] =
      Walking_ATRIAS_B.DataTypeConversion73;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctionI[2] =
      Walking_ATRIAS_B.DataTypeConversion3;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctionI[3] =
      Walking_ATRIAS_B.DataTypeConversion25;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctionI[4] =
      Walking_ATRIAS_B.DataTypeConversion50;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctionI[5] =
      Walking_ATRIAS_B.DataTypeConversion74;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctionI[6] =
      Walking_ATRIAS_B.DataTypeConversion1;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctionI[7] =
      Walking_ATRIAS_B.DataTypeConversion26;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctionI[8] =
      Walking_ATRIAS_B.DataTypeConversion98;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctionI[9] =
      Walking_ATRIAS_B.DataTypeConversion114;

    /* SignalConversion: '<S47>/TmpSignal ConversionAt SFunction Inport3' incorporates:
     *  MATLAB Function: '<S38>/calibrate'
     */
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_d[0] =
      Walking_ATRIAS_B.DataTypeConversion57;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_d[1] =
      Walking_ATRIAS_B.DataTypeConversion81;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_d[2] =
      Walking_ATRIAS_B.DataTypeConversion9;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_d[3] =
      Walking_ATRIAS_B.DataTypeConversion33;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_d[4] =
      Walking_ATRIAS_B.DataTypeConversion104;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_d[5] =
      Walking_ATRIAS_B.DataTypeConversion119;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_d[6] =
      Walking_ATRIAS_ConstB.DataTypeConversion141[0];
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_d[7] =
      Walking_ATRIAS_ConstB.DataTypeConversion141[1];
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_d[8] =
      Walking_ATRIAS_ConstB.DataTypeConversion141[2];

    /* MATLAB Function: '<S38>/calibrate' incorporates:
     *  Constant: '<S38>/Calibration'
     */
    /* MATLAB Function 'Subsystem1/Subsystem/calibrate': '<S47>:1' */
    memcpy(&Walking_ATRIAS_B.VectorConcatenate[0],
           &Walking_ATRIAS_B.TmpSignalConversionAtSFunctionI[0], 10U * sizeof
           (real_T));
    AccelValid = Walking_ATRIAS_B.LogicalOperator1;

    /* This function calibrates the encoder values and converts to radians. */
    /*  Absolute hip encoders might rollover. This is not possible for the */
    /*  linear optical encoders. We solve the rollover problem for the */
    /*  absolute hip encoders by noting that they can only move about 30 */
    /*  degrees, so if the TICK count is very far from the CAL TICK count, we */
    /*  know a rollover has occurred. We can then add or subtract the max */
    /*  tick count to correct the problem. */
    vKneeSpring[0] = Walking_ATRIAS_P.Calibration.AbsMaxTick[8];
    vKneeSpring[1] = Walking_ATRIAS_P.Calibration.AbsMaxTick[9];
    uLegSpring[0] = Walking_ATRIAS_P.Calibration.AbsCalTick[8];
    uLegSpring[1] = Walking_ATRIAS_P.Calibration.AbsCalTick[9];
    AbsEncoder[0] = Walking_ATRIAS_B.TmpSignalConversionAtSFunctionI[8];
    AbsEncoder[1] = Walking_ATRIAS_B.TmpSignalConversionAtSFunctionI[9];

    /*  We solve the rollover problem for the absolute hip encoders by noting */
    /*  that they can only move about 30 degrees, so if the TICK count is */
    /*  very far from the CAL TICK count, we know a rollover has occurred. We */
    /*  can then add or subtract the max tick count to correct the problem. */
    AbsUnrolled[0] = Walking_ATRIAS_B.TmpSignalConversionAtSFunctionI[8];
    AbsUnrolled[1] = Walking_ATRIAS_B.TmpSignalConversionAtSFunctionI[9];

    /*  Find offset of Cal from center of tick range */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_P.Calibration.AbsMaxTick[8] / 2.0;
    HalfMaxTicks_idx_1 = Walking_ATRIAS_P.Calibration.AbsMaxTick[9] / 2.0;
    CalOffset_idx_0 = Walking_ATRIAS_P.Calibration.AbsCalTick[8] -
      HalfMaxTicks_idx_0;
    CalOffset_idx_1 = Walking_ATRIAS_P.Calibration.AbsCalTick[9] -
      HalfMaxTicks_idx_1;

    /*  Find index of elements where the current encoder reading is GREATER */
    /*  than CalOffset ticks above the CalTick. Correct by subtracting */
    /*  MaxTicks (results in a negative number, which is okay). */
    iHigh[0] = ((CalOffset_idx_0 < 0.0) &&
                (Walking_ATRIAS_B.TmpSignalConversionAtSFunctionI[8] >
                 Walking_ATRIAS_P.Calibration.AbsCalTick[8] + HalfMaxTicks_idx_0));
    iHigh[1] = ((CalOffset_idx_1 < 0.0) &&
                (Walking_ATRIAS_B.TmpSignalConversionAtSFunctionI[9] >
                 Walking_ATRIAS_P.Calibration.AbsCalTick[9] + HalfMaxTicks_idx_1));
    Walking_ATRIAS_eml_li_find(iHigh, e_data, &i);
    r1 = i;
    for (rtemp = 0; rtemp < i; rtemp++) {
      b_data[rtemp] = AbsEncoder[e_data[rtemp] - 1];
    }

    Walking_ATRIAS_eml_li_find(iHigh, e_data, &i);
    for (rtemp = 0; rtemp < i; rtemp++) {
      c_data[rtemp] = vKneeSpring[e_data[rtemp] - 1];
    }

    Walking_ATRIAS_eml_li_find(iHigh, e_data, &i);
    for (rtemp = 0; rtemp < r1; rtemp++) {
      AbsUnrolled[e_data[rtemp] - 1] = b_data[rtemp] - c_data[rtemp];
    }

    /*  Find index of elements where the current encoder reading is LESS than */
    /*  CalOffset ticks below the CalTick. Correct by adding MaxTicks */
    /*  (results in a count greater than MaxTicks, which is okay). */
    iHigh[0] = ((CalOffset_idx_0 > 0.0) && (AbsEncoder[0] < uLegSpring[0] -
      HalfMaxTicks_idx_0));
    iHigh[1] = ((CalOffset_idx_1 > 0.0) && (AbsEncoder[1] < uLegSpring[1] -
      HalfMaxTicks_idx_1));
    Walking_ATRIAS_eml_li_find(iHigh, e_data, &i);
    r1 = i;
    for (rtemp = 0; rtemp < i; rtemp++) {
      b_data[rtemp] = AbsUnrolled[e_data[rtemp] - 1];
    }

    Walking_ATRIAS_eml_li_find(iHigh, e_data, &i);
    for (rtemp = 0; rtemp < i; rtemp++) {
      c_data[rtemp] = vKneeSpring[e_data[rtemp] - 1];
    }

    Walking_ATRIAS_eml_li_find(iHigh, e_data, &i);
    for (rtemp = 0; rtemp < r1; rtemp++) {
      AbsUnrolled[e_data[rtemp] - 1] = b_data[rtemp] + c_data[rtemp];
    }

    Walking_ATRIAS_B.VectorConcatenate[8] = AbsUnrolled[0];
    Walking_ATRIAS_B.VectorConcatenate[9] = AbsUnrolled[1];

    /*  Calibrate absolute encoders */
    for (rtemp = 0; rtemp < 10; rtemp++) {
      Walking_ATRIAS_B.VectorConcatenate[rtemp] =
        (Walking_ATRIAS_B.VectorConcatenate[rtemp] -
         Walking_ATRIAS_P.Calibration.AbsCalTick[rtemp]) *
        Walking_ATRIAS_P.Calibration.AbsCalConst[rtemp] +
        Walking_ATRIAS_P.Calibration.AbsCalAngle[rtemp];
    }

    /*  Calibration and rollover count for incremental encoders */
    if (AccelValid) {
      for (i = 0; i < 9; i++) {
        Walking_ATRIAS_B.Rollover[i] = 0.0 * Walking_ATRIAS_B.UnitDelay[i];
      }

      RefAngle[0] = Walking_ATRIAS_B.VectorConcatenate[4] * 50.0;
      RefAngle[1] = Walking_ATRIAS_B.VectorConcatenate[5] * 50.0;
      RefAngle[2] = Walking_ATRIAS_B.VectorConcatenate[6] * 50.0;
      RefAngle[3] = Walking_ATRIAS_B.VectorConcatenate[7] * 50.0;
      RefAngle[4] = Walking_ATRIAS_B.VectorConcatenate[8];
      RefAngle[5] = Walking_ATRIAS_B.VectorConcatenate[9];

      /*  Compute the calibration tick count corresponding to 0 degrees */
      for (i = 0; i < 6; i++) {
        x[i] = Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_d[i] - RefAngle[i]
          / Walking_ATRIAS_P.Calibration.IncCalConst[i];
        Walking_ATRIAS_B.IncCalTick[i] = 0.0;
      }

      for (r1 = 0; r1 < 6; r1++) {
        if (Walking_ATRIAS_P.Calibration.IncMaxTick[r1] == 0.0) {
          n = x[r1];
        } else if (Walking_ATRIAS_P.Calibration.IncMaxTick[r1] == floor
                   (Walking_ATRIAS_P.Calibration.IncMaxTick[r1])) {
          n = x[r1] - floor(x[r1] / Walking_ATRIAS_P.Calibration.IncMaxTick[r1])
            * Walking_ATRIAS_P.Calibration.IncMaxTick[r1];
        } else {
          n = x[r1] / Walking_ATRIAS_P.Calibration.IncMaxTick[r1];
          if (fabs(n - rt_roundd_snf(n)) <= 2.2204460492503131E-16 * fabs(n)) {
            n = 0.0;
          } else {
            n = (n - floor(n)) * Walking_ATRIAS_P.Calibration.IncMaxTick[r1];
          }
        }

        Walking_ATRIAS_B.IncCalTick[r1] = n;
      }

      /* Rollover = floor((IncCalTick-IncTick)./IncMaxTick); */
      for (rtemp = 0; rtemp < 6; rtemp++) {
        HalfMaxTicks_idx_0 = RefAngle[rtemp];
        HalfMaxTicks_idx_0 = ((HalfMaxTicks_idx_0 /
          Walking_ATRIAS_P.Calibration.IncCalConst[rtemp] -
          Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_d[rtemp]) +
                              Walking_ATRIAS_B.IncCalTick[rtemp]) /
          Walking_ATRIAS_P.Calibration.IncMaxTick[rtemp];
        HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
        Walking_ATRIAS_B.Rollover[rtemp] = HalfMaxTicks_idx_0;
      }
    } else {
      /*  Determine if a rollover has occurred on any incremental encoder */
      /*  The determination is made by assuming the encoder shaft has rotated */
      /*  less than half of a revolution since the previous time step. If a */
      /*  rollover is detected on a particular encoder, the corresponding */
      /*  element of Rollover is either +1 or -1, depending on the direction of */
      /*  the rollover */
      /*  */
      /*  To compute the rollover, ticks are normalized by the maximum tick */
      /*  number. This maps all (NormalizedCountPrev, NormalizedCount) pairs */
      /*  into the region [0,1]X[0,1] in the plane. The upper left hand corner */
      /*  corresponds to negative rollover, and the lower right hand corner */
      /*  corresponds to positive rollover. */
      for (i = 0; i < 9; i++) {
        HalfMaxTicks_idx_1 = Walking_ATRIAS_B.UnitDelay1[i] /
          Walking_ATRIAS_P.Calibration.MaxTick[i];
        HalfMaxTicks_idx_0 = Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_d[i]
          / Walking_ATRIAS_P.Calibration.MaxTick[i];
        Walking_ATRIAS_B.Rollover[i] = 0.0;
        NormalizedCountPrev_0[i] = ((HalfMaxTicks_idx_1 < 0.5) &&
          (HalfMaxTicks_idx_0 > HalfMaxTicks_idx_1 + 0.5));
        NormalizedCountPrev[i] = HalfMaxTicks_idx_1;
        NormalizedCount[i] = HalfMaxTicks_idx_0;
      }

      Walking_ATRIAS_eml_li_find_e(NormalizedCountPrev_0, d_data, &i);
      for (rtemp = 0; rtemp < i; rtemp++) {
        Walking_ATRIAS_B.Rollover[d_data[rtemp] - 1] = -1.0;
      }

      for (rtemp = 0; rtemp < 9; rtemp++) {
        NormalizedCountPrev_0[rtemp] = ((NormalizedCountPrev[rtemp] > 0.5) &&
          (NormalizedCount[rtemp] < NormalizedCountPrev[rtemp] - 0.5));
      }

      Walking_ATRIAS_eml_li_find_e(NormalizedCountPrev_0, d_data, &i);
      for (rtemp = 0; rtemp < i; rtemp++) {
        Walking_ATRIAS_B.Rollover[d_data[rtemp] - 1] = 1.0;
      }

      for (rtemp = 0; rtemp < 9; rtemp++) {
        Walking_ATRIAS_B.Rollover[rtemp] += Walking_ATRIAS_B.UnitDelay[rtemp];
      }

      for (i = 0; i < 6; i++) {
        Walking_ATRIAS_B.IncCalTick[i] = Walking_ATRIAS_B.UnitDelay2[i];
      }
    }

    /*  Calibrate incremental encoders */
    /* '<S47>:1:3' */
    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.VectorConcatenate[i + 10] =
        ((Walking_ATRIAS_P.Calibration.MaxTick[i] * Walking_ATRIAS_B.Rollover[i]
          + Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_d[i]) -
         Walking_ATRIAS_B.IncCalTick[i]) *
        Walking_ATRIAS_P.Calibration.IncCalConst[i];
    }

    Walking_ATRIAS_B.VectorConcatenate[16] =
      ((Walking_ATRIAS_P.Calibration.MaxTick[6] * Walking_ATRIAS_B.Rollover[6] +
        Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_d[6]) -
       Walking_ATRIAS_P.Calibration.BoomCalTick[0]) *
      Walking_ATRIAS_P.Calibration.BoomCalConst[0] +
      Walking_ATRIAS_P.Calibration.BoomCalAngle[0];
    Walking_ATRIAS_B.VectorConcatenate[17] =
      ((Walking_ATRIAS_P.Calibration.MaxTick[7] * Walking_ATRIAS_B.Rollover[7] +
        Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_d[7]) -
       Walking_ATRIAS_P.Calibration.BoomCalTick[1]) *
      Walking_ATRIAS_P.Calibration.BoomCalConst[1] +
      Walking_ATRIAS_P.Calibration.BoomCalAngle[1];
    Walking_ATRIAS_B.VectorConcatenate[18] =
      ((Walking_ATRIAS_P.Calibration.MaxTick[8] * Walking_ATRIAS_B.Rollover[8] +
        Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_d[8]) -
       Walking_ATRIAS_P.Calibration.BoomCalTick[2]) *
      Walking_ATRIAS_P.Calibration.BoomCalConst[2] +
      Walking_ATRIAS_P.Calibration.BoomCalAngle[2];

    /* Outputs for Iterator SubSystem: '<S38>/EncoderFilters1' incorporates:
     *  ForEach: '<S43>/For Each'
     */
    for (ForEach_itr = 0; ForEach_itr < 19; ForEach_itr++) {
      /* ForEachSliceSelector: '<S43>/ImpSel_InsertedFor_q_at_outport_0' */
      rtb_ImpSel_InsertedFor_q_at_out =
        Walking_ATRIAS_B.VectorConcatenate[ForEach_itr];

      /* UnitDelay: '<S53>/UD' */
      Walking_ATRIAS_B.CoreSubsys[ForEach_itr].Uk1 =
        Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].UD_DSTATE;

      /* Sum: '<S53>/Diff' */
      Walking_ATRIAS_B.CoreSubsys[ForEach_itr].Diff =
        rtb_ImpSel_InsertedFor_q_at_out -
        Walking_ATRIAS_B.CoreSubsys[ForEach_itr].Uk1;

      /* Gain: '<S52>/Gain1' */
      Walking_ATRIAS_B.CoreSubsys[ForEach_itr].Gain1 = 1000.0 *
        Walking_ATRIAS_B.CoreSubsys[ForEach_itr].Diff;

      /* DiscreteTransferFcn: '<S52>/two_pole_filter' */
      n = Walking_ATRIAS_B.CoreSubsys[ForEach_itr].Gain1;
      n -= (-0.51858890322975937) * Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].
        two_pole_filter_states[0];
      n -= 0.16911891452314495 * Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].
        two_pole_filter_states[1];
      n /= 1.0;
      Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].two_pole_filter_tmp = n;
      n = 0.65053001129338561 * Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].
        two_pole_filter_tmp;
      n += 0.0 * Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].
        two_pole_filter_states[0];
      n += 0.0 * Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].
        two_pole_filter_states[1];
      Walking_ATRIAS_B.CoreSubsys[ForEach_itr].two_pole_filter = n;

      /* UnitDelay: '<S50>/Unit Delay2' */
      Walking_ATRIAS_B.CoreSubsys[ForEach_itr].UnitDelay2 =
        Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].UnitDelay2_DSTATE;

      /* UnitDelay: '<S50>/Unit Delay1' */
      Walking_ATRIAS_B.CoreSubsys[ForEach_itr].UnitDelay1 =
        Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].UnitDelay1_DSTATE;

      /* MATLAB Function: '<S50>/Logic Filter' */
      /* MATLAB Function 'Subsystem1/Subsystem/EncoderFilters1/CheckAndFilterEncoder/Velocity Filter/Logic Filter': '<S51>:1' */
      if (fabs(Walking_ATRIAS_B.CoreSubsys[ForEach_itr].two_pole_filter -
               Walking_ATRIAS_B.CoreSubsys[ForEach_itr].UnitDelay2) * 180.0 /
          3.1415926535897931 > 10.0) {
        /* '<S51>:1:4' */
        /* '<S51>:1:5' */
        HalfMaxTicks_idx_0 = Walking_ATRIAS_B.CoreSubsys[ForEach_itr].UnitDelay1;
        if (!(HalfMaxTicks_idx_0 <= 3.4906585039886591)) {
          HalfMaxTicks_idx_0 = 3.4906585039886591;
        }

        if (HalfMaxTicks_idx_0 >= -3.4906585039886591) {
          Walking_ATRIAS_B.CoreSubsys[ForEach_itr].dq_out = HalfMaxTicks_idx_0;
        } else {
          Walking_ATRIAS_B.CoreSubsys[ForEach_itr].dq_out = -3.4906585039886591;
        }

        /* '<S51>:1:6' */
        Walking_ATRIAS_B.CoreSubsys[ForEach_itr].dq_good =
          Walking_ATRIAS_B.CoreSubsys[ForEach_itr].UnitDelay1;
      } else {
        /* '<S51>:1:8' */
        Walking_ATRIAS_B.CoreSubsys[ForEach_itr].dq_out =
          Walking_ATRIAS_B.CoreSubsys[ForEach_itr].two_pole_filter;

        /* '<S51>:1:9' */
        Walking_ATRIAS_B.CoreSubsys[ForEach_itr].dq_good =
          Walking_ATRIAS_B.CoreSubsys[ForEach_itr].two_pole_filter;
      }

      /* End of MATLAB Function: '<S50>/Logic Filter' */

      /* ForEachSliceAssignment: '<S43>/ImpAsg_InsertedFor_q_clean_at_inport_0' */
      Walking_ATRIAS_B.ImpAsg_InsertedFor_q_clean_at_i[ForEach_itr] =
        rtb_ImpSel_InsertedFor_q_at_out;

      /* ForEachSliceAssignment: '<S43>/ImpAsg_InsertedFor_dq_clean_at_inport_0' */
      Walking_ATRIAS_B.ImpAsg_InsertedFor_dq_clean_at_[ForEach_itr] =
        Walking_ATRIAS_B.CoreSubsys[ForEach_itr].dq_out;
    }

    /* End of Outputs for SubSystem: '<S38>/EncoderFilters1' */

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[16];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[17];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[18];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion20' */
    Walking_ATRIAS_B.DataTypeConversion20[0] = Walking_ATRIAS_B.EtherCATRxVar6;
    Walking_ATRIAS_B.DataTypeConversion20[1] = Walking_ATRIAS_B.EtherCATRxVar1;
    Walking_ATRIAS_B.DataTypeConversion20[2] = Walking_ATRIAS_B.EtherCATRxVar2;

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[19];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[20];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[21];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion22' */
    Walking_ATRIAS_B.DataTypeConversion22[0] = Walking_ATRIAS_B.EtherCATRxVar9;
    Walking_ATRIAS_B.DataTypeConversion22[1] = Walking_ATRIAS_B.EtherCATRxVar11;
    Walking_ATRIAS_B.DataTypeConversion22[2] = Walking_ATRIAS_B.EtherCATRxVar12;

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[22];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion17' */
    Walking_ATRIAS_B.DataTypeConversion17 = Walking_ATRIAS_B.EtherCATRxVar18;

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[23];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion24' */
    Walking_ATRIAS_B.DataTypeConversion24 = Walking_ATRIAS_B.EtherCATRxVar5_hj;

    /* UnitDelay: '<S38>/Unit Delay7' */
    Walking_ATRIAS_B.UnitDelay7[0] = Walking_ATRIAS_DW.UnitDelay7_DSTATE[0];
    Walking_ATRIAS_B.UnitDelay7[1] = Walking_ATRIAS_DW.UnitDelay7_DSTATE[1];
    Walking_ATRIAS_B.UnitDelay7[2] = Walking_ATRIAS_DW.UnitDelay7_DSTATE[2];

    /* UnitDelay: '<S38>/Unit Delay5' */
    Walking_ATRIAS_B.UnitDelay5[0] = Walking_ATRIAS_DW.UnitDelay5_DSTATE[0];
    Walking_ATRIAS_B.UnitDelay5[1] = Walking_ATRIAS_DW.UnitDelay5_DSTATE[1];
    Walking_ATRIAS_B.UnitDelay5[2] = Walking_ATRIAS_DW.UnitDelay5_DSTATE[2];

    /* UnitDelay: '<S38>/Unit Delay8' */
    Walking_ATRIAS_B.UnitDelay8 = Walking_ATRIAS_DW.UnitDelay8_DSTATE;

    /* MATLAB Function: '<S38>/EstimateOrientation' */
    /* MATLAB Function 'Subsystem1/Subsystem/EstimateOrientation': '<S44>:1' */
    w[0] = Walking_ATRIAS_B.DataTypeConversion22[0];
    w[1] = Walking_ATRIAS_B.DataTypeConversion22[1];
    w[2] = Walking_ATRIAS_B.DataTypeConversion22[2];

    /*  Estimate the rotation matrix Rk representing the orientation of the */
    /*  IMU with respect to the world at the current time step (step k). */
    /*  */
    /*  Inputs: */
    /*    DeltaAngle: a rotation vector (i.e., a vector whose direction */
    /*    coincides with the axis of rotation and whose magnitude is the */
    /*    rotation angle in radians). */
    /*  */
    /*    Acceleration: IMU-measured acceleration */
    /*  */
    /*    Rkm1: This should be the last value Rk returned from this function. */
    /*    The initial value is ignored as long as (Reset) is true the first */
    /*    time this function is called. */
    /*  */
    /*    wk: This should be the last value wk returned from this function. */
    /*    The initial value can safely be [0; 0; 0] if the robot is at rest */
    /*    initially (or when (Reset) is deasserted). */
    /*  */
    /*    Akm1: This should be the last value Ak returned from this function. */
    /*    The initial value can be either [0; 0; 0] or the initial */
    /*    Acceleration (these yield equivalent results). */
    /*  */
    /*    Status: An 8-bit integer corresponding to the KVH IMU status byte. */
    /*    When the packet CRC fails, this input should be zero. */
    /*  */
    /*    Sequence: Message counter sent by the IMU. This starts at 0 and */
    /*    increments by 1 with each packet sent, up to 127, at which point it */
    /*    rolls over. */
    /*  */
    /*    Seqkm1: Previous Sequence input. */
    /*  */
    /*    Reset: When (Reset) is true, the rotation matrix */
    /*    Rk is computed by assuming the IMU is stationary so that the */
    /*    measured Acceleration is opposite the direction the gravitational */
    /*    force. When (Reset) is true, the acceleration is not used, and the */
    /*    rotation matrix Rk is computed by accumulating DeltaAngle */
    /*    rotations. */
    /*  */
    /*  Outputs: */
    /*  */
    /*    Rk: Orientation matrix representing the current orientation of the */
    /*    IMU with respect to the world frame. Note that when represented */
    /*    with ZYX Euler angles, the initial yaw (i.e., the yaw at when the */
    /*    (Reset) input drops to 0) is arbitrary. If it is desired to have */
    /*    zero yaw in that configuration, this should be handled outside this */
    /*    function. */
    /*  */
    /*    wk: Estimated angular velocity in the IMU frame */
    /*  */
    /*    Ak: The filtered acceleration estimate. This value is only used */
    /*    when (Reset) is true. */
    /*  */
    /*    Seqk: Last valid Sequence number seen. */
    /*  */
    /*  The initial orientation estimate is computed by assuming the robot is */
    /*  stationary in the world frame, so that the measured acceleration is */
    /*  simply due to the gravitational force. When the IMU is upright on a */
    /*  horizontal surface, the measured acceleration (in g's) is roughly */
    /*    Acceleration = [0; 0; 1] */
    /*  When the IMU is at rest in another configuration, the measured */
    /*  Acceleration will be some other unit vector. There is not a unique */
    /*  rotation matrix which maps the measured Acceleration into the world */
    /*  frame z-axis, since any subsequent rotation about the z-axis would */
    /*  leave the Acceleration aligned with the vertical. To account for this */
    /*  non-uniqueness, we represent the initial orientation not with a */
    /*  rotation matrix but with a unit length vector in R^3 (i.e., a point */
    /*  on the 2-sphere S^2). */
    /*  */
    /*  We will compute the initial orientation estimate by filtering the */
    /*  Acceleration when (Reset==1). In order to derive the filter we need */
    /*  to know how to combine points on the 2-sphere in a meaningful way. It */
    /*  turns out that, given a set of points x1, x2, ..., xn in S^2, the */
    /*  normalized sum */
    /*    xhat = (x1 + x2 + ... + xn)/||x1 + x2 + ... + xn|| */
    /*  is another point on the 2-sphere which maximizes the sum of the */
    /*  cosines of the angles between xhat and each xi, i=1,...,n, which is */
    /*  roughly equivalent to minimizing the sum of the angles between xhat */
    /*  and each xi, i=1,...,n. We can also use a weighted sum. Thus it is */
    /*  straightforward to implement a filter on S^2; we need only augment */
    /*  the standard filter with a normalization of the result. */
    /*  */
    /*  Note that the average is well defined only if */
    /*    (x1 + x2 + ... + xn) ~= 0. */
    /*  For the "one-pole filter" used below, assuming */
    /*  (accelFilterAlpha~=0.5), the weighted sum can only be zero if */
    /*  (Acceleration==0) and (Akm1==0). Since (Reset) should be true only */
    /*  when the robot is stationary, we should never have (Acceleration==0). */
    /*  In any case, we guard against the unlikely possibility by checking */
    /*  for zero Acceleration. */
    /*  */
    /*  To compute a rotation matrix which maps a unit vector x1 to the */
    /*  z-axis, we have many choices. For example, we could compute an axis */
    /*  of rotation by taking the cross product between x1 and unit z-vector. */
    /*  Then we have to compute the rotation angle and finally compute the */
    /*  rotation matrix equivalent to this axis-angle representation. If the */
    /*  original unit vector x1 is already aligned with the z-axis, this */
    /*  method cannot be used (in this case the rotation matrix can be taken */
    /*  as the identity; however, we have to choose a tolerance for */
    /*  determining if the two vectors are aligned). A better choice is */
    /*  rotate 180 degrees around an axis half way between x1 and the z-axis. */
    /*  We can easily compute the axis of rotation w as the normalized sum */
    /*    w = (x1+zhat)/||x1+zhat||. */
    /*  The matrix associated with this rotation is */
    /*    R = 2 w*w^T - I. */
    /*  */
    /*  After the initial estimate is computed, we simply update the current */
    /*  estimate by a group operation using the IMU-derived DeltaAngle. Thus */
    /*  we convert DeltaAngle to a rotation matrix R and update R(k) from */
    /*  R(k-1) as */
    /*    Rk = Rkm1 * R */
    /*  SAMPLE TIME USED TO ESTIMATE ANGULAR VELOCITY wk */
    for (i = 0; i < 9; i++) {
      /* UnitDelay: '<S38>/Unit Delay6' */
      Walking_ATRIAS_B.UnitDelay6[i] = Walking_ATRIAS_DW.UnitDelay6_DSTATE[i];
      Walking_ATRIAS_B.Rk[i] = Walking_ATRIAS_B.UnitDelay6[i];
    }

    Walking_ATRIAS_B.Ak[0] = Walking_ATRIAS_B.UnitDelay5[0];
    Walking_ATRIAS_B.Ak[1] = Walking_ATRIAS_B.UnitDelay5[1];
    Walking_ATRIAS_B.Ak[2] = Walking_ATRIAS_B.UnitDelay5[2];
    a21 = Walking_ATRIAS_B.UnitDelay8;

    /*  Mask the status byte to get accelerometer and gyro status. For now we */
    /*  just ignore invalid data. */
    HalfMaxTicks_idx_0 = rt_roundd_snf(Walking_ATRIAS_B.DataTypeConversion17);
    if (HalfMaxTicks_idx_0 < 256.0) {
      if (HalfMaxTicks_idx_0 >= 0.0) {
        Status = (uint8_T)HalfMaxTicks_idx_0;
      } else {
        Status = 0U;
      }
    } else {
      Status = MAX_uint8_T;
    }

    Status ^= 119U;

    /*  invert so '0' means valid */
    AccelValid = !((Status & 112) != 0);
    GyroValid = !((Status & 7) != 0);
    b = ((Walking_ATRIAS_B.DataTypeConversion24 >= 0.0) &&
         (Walking_ATRIAS_B.DataTypeConversion24 < 127.0));

    /*  To do: why not <= 127 */
    /* 	%% Estimate angular velocity */
    if (GyroValid) {
      Walking_ATRIAS_B.wk[0] = Walking_ATRIAS_B.DataTypeConversion20[0] / 0.001;
      Walking_ATRIAS_B.wk[1] = Walking_ATRIAS_B.DataTypeConversion20[1] / 0.001;
      Walking_ATRIAS_B.wk[2] = Walking_ATRIAS_B.DataTypeConversion20[2] / 0.001;
    } else {
      Walking_ATRIAS_B.wk[0] = Walking_ATRIAS_B.UnitDelay7[0];
      Walking_ATRIAS_B.wk[1] = Walking_ATRIAS_B.UnitDelay7[1];
      Walking_ATRIAS_B.wk[2] = Walking_ATRIAS_B.UnitDelay7[2];
    }

    if (Walking_ATRIAS_B.LogicalOperator1 && AccelValid) {
      /* 		%% Compute initial orientation estimate (modulo yaw) */
      /*  Normalize to ensure Acceleration lies on the 2-sphere S^2 */
      n = Walking_ATRIAS_norm(Walking_ATRIAS_B.DataTypeConversion22);
      if (n < 1.0E-8) {
        w[0] = 0.0;
        w[1] = 0.0;
        w[2] = 1.0;
      } else {
        HalfMaxTicks_idx_0 = w[0];
        HalfMaxTicks_idx_0 /= n;
        w[0] = HalfMaxTicks_idx_0;
        HalfMaxTicks_idx_0 = w[1];
        HalfMaxTicks_idx_0 /= n;
        w[1] = HalfMaxTicks_idx_0;
        HalfMaxTicks_idx_0 = w[2];
        HalfMaxTicks_idx_0 /= n;
        w[2] = HalfMaxTicks_idx_0;
      }

      /*  First-order IIR filter with a pole at z=accelFilterAlpha */
      Walking_ATRIAS_B.Ak[0] = 0.98 * Walking_ATRIAS_B.UnitDelay5[0] +
        0.020000000000000018 * w[0];
      Walking_ATRIAS_B.Ak[1] = 0.98 * Walking_ATRIAS_B.UnitDelay5[1] +
        0.020000000000000018 * w[1];
      Walking_ATRIAS_B.Ak[2] = 0.98 * Walking_ATRIAS_B.UnitDelay5[2] +
        0.020000000000000018 * w[2];

      /*  Normalize to ensure Ak lies on the 2-sphere S^2 */
      /*  Assuming (accelFilterAlpha~=0.5), norm(Ak) should never be zero. */
      B = Walking_ATRIAS_norm(Walking_ATRIAS_B.Ak);
      Walking_ATRIAS_B.Ak[0] /= B;
      Walking_ATRIAS_B.Ak[1] /= B;
      Walking_ATRIAS_B.Ak[2] /= B;

      /*  Compute the axis of rotation K and the rotation matrix Rk */
      w[0] = Walking_ATRIAS_B.Ak[0];
      w[1] = Walking_ATRIAS_B.Ak[1];
      w[2] = Walking_ATRIAS_B.Ak[2] + 1.0;
      n = Walking_ATRIAS_norm(w);
      HalfMaxTicks_idx_0 = w[0];
      HalfMaxTicks_idx_0 /= n;
      w[0] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = w[1];
      HalfMaxTicks_idx_0 /= n;
      w[1] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = w[2];
      HalfMaxTicks_idx_0 /= n;
      w[2] = HalfMaxTicks_idx_0;
      for (rtemp = 0; rtemp < 9; rtemp++) {
        I[rtemp] = 0;
      }

      I[0] = 1;
      I[4] = 1;
      I[8] = 1;
      for (rtemp = 0; rtemp < 3; rtemp++) {
        w_0[rtemp] = w[rtemp] * w[0];
        w_0[rtemp + 3] = w[rtemp] * w[1];
        w_0[rtemp + 6] = w[rtemp] * w[2];
      }

      for (rtemp = 0; rtemp < 3; rtemp++) {
        Walking_ATRIAS_B.Rk[3 * rtemp] = w_0[3 * rtemp] * 2.0 - (real_T)I[3 *
          rtemp];
        Walking_ATRIAS_B.Rk[1 + 3 * rtemp] = w_0[3 * rtemp + 1] * 2.0 - (real_T)
          I[3 * rtemp + 1];
        Walking_ATRIAS_B.Rk[2 + 3 * rtemp] = w_0[3 * rtemp + 2] * 2.0 - (real_T)
          I[3 * rtemp + 2];
      }
    } else {
      if (GyroValid && b) {
        /* 		%% Update orientation estimate */
        /*  If we missed (n-1) packets, we assume that the angular velocity */
        /*  is constant during that time period. This means the robot should */
        /*  have rotated n times as much as DeltaAngle indicates. If we don't */
        /*  miss any packets, then n = Sequence-Seqkm1 = 1 and we have */
        /*    theta = norm(DeltaAngle). */
        a21 = Walking_ATRIAS_B.DataTypeConversion24;
        n = Walking_ATRIAS_B.DataTypeConversion24 - Walking_ATRIAS_B.UnitDelay8;
        if (n < 0.0) {
          n += 128.0;
        }

        /*  To do: count Squence Valid instead of n */
        n *= Walking_ATRIAS_norm(Walking_ATRIAS_B.DataTypeConversion20);
        if (n > 3.0E-8) {
          /*  Avoid division by zero. The threshold 3e-8 (rad/ms) is */
          /*  slighly less than the angular velocity of the Earth on its */
          /*  axis, which is */
          /*    2*pi/(23*3600 + 56*60 + 04.09053)/1000 */
          /*      = 7.292115855377075e-08 (rad/ms) */
          /*  If the measured rotation is less than this, we ignore it. */
          w[0] = Walking_ATRIAS_B.DataTypeConversion20[0] / n;
          w[1] = Walking_ATRIAS_B.DataTypeConversion20[1] / n;
          w[2] = Walking_ATRIAS_B.DataTypeConversion20[2] / n;
          x_re = cos(n);
          CurrentYaw = sin(n);
          t30 = 1.0 - cos(n);
          tmp_6[0] = 0.0;
          tmp_6[3] = -w[2];
          tmp_6[6] = w[1];
          tmp_6[1] = w[2];
          tmp_6[4] = 0.0;
          tmp_6[7] = -w[0];
          tmp_6[2] = -w[1];
          tmp_6[5] = w[0];
          tmp_6[8] = 0.0;
          for (rtemp = 0; rtemp < 3; rtemp++) {
            w_0[rtemp] = w[rtemp] * w[0];
            w_0[rtemp + 3] = w[rtemp] * w[1];
            w_0[rtemp + 6] = w[rtemp] * w[2];
          }

          for (rtemp = 0; rtemp < 3; rtemp++) {
            b_a_0[3 * rtemp] = ((real_T)b_a[3 * rtemp] * x_re + tmp_6[3 * rtemp]
                                * CurrentYaw) + w_0[3 * rtemp] * t30;
            b_a_0[1 + 3 * rtemp] = ((real_T)b_a[3 * rtemp + 1] * x_re + tmp_6[3 *
              rtemp + 1] * CurrentYaw) + w_0[3 * rtemp + 1] * t30;
            b_a_0[2 + 3 * rtemp] = ((real_T)b_a[3 * rtemp + 2] * x_re + tmp_6[3 *
              rtemp + 2] * CurrentYaw) + w_0[3 * rtemp + 2] * t30;
          }

          for (rtemp = 0; rtemp < 3; rtemp++) {
            for (i = 0; i < 3; i++) {
              Walking_ATRIAS_B.Rk[rtemp + 3 * i] = 0.0;
              Walking_ATRIAS_B.Rk[rtemp + 3 * i] += b_a_0[3 * i] *
                Walking_ATRIAS_B.UnitDelay6[rtemp];
              Walking_ATRIAS_B.Rk[rtemp + 3 * i] += b_a_0[3 * i + 1] *
                Walking_ATRIAS_B.UnitDelay6[rtemp + 3];
              Walking_ATRIAS_B.Rk[rtemp + 3 * i] += b_a_0[3 * i + 2] *
                Walking_ATRIAS_B.UnitDelay6[rtemp + 6];
            }
          }
        }
      }
    }

    /* '<S44>:1:2' */
    Walking_ATRIAS_B.Seqk = a21;
    Walking_ATRIAS_B.ValidStates[0] = AccelValid;
    Walking_ATRIAS_B.ValidStates[1] = GyroValid;
    Walking_ATRIAS_B.ValidStates[2] = b;

    /* End of MATLAB Function: '<S38>/EstimateOrientation' */

    /* UnitDelay: '<S38>/Unit Delay10' */
    memcpy(&Walking_ATRIAS_B.UnitDelay10[0],
           &Walking_ATRIAS_DW.UnitDelay10_DSTATE[0], 9U * sizeof(real_T));

    /* UnitDelay: '<S38>/Unit Delay9' */
    Walking_ATRIAS_B.UnitDelay9[0] = Walking_ATRIAS_DW.UnitDelay9_DSTATE[0];
    Walking_ATRIAS_B.UnitDelay9[1] = Walking_ATRIAS_DW.UnitDelay9_DSTATE[1];

    /* MATLAB Function: '<S38>/ComputeEulerAngles1' incorporates:
     *  Constant: '<S38>/KVHOrientation'
     */
    /* MATLAB Function 'Subsystem1/Subsystem/ComputeEulerAngles1': '<S42>:1' */
    /*  Convert from IMU frame to robot frame and compute Euler angles. The */
    /*  yaw angle is zeroed whenever (Reset) is true. */
    if (Walking_ATRIAS_B.LogicalOperator1) {
      /* '<S42>:1:5' */
      /*  Compute the rotation matrix which zeroes the initial yaw */
      /* '<S42>:1:7' */
      for (rtemp = 0; rtemp < 3; rtemp++) {
        for (i = 0; i < 3; i++) {
          y[rtemp + 3 * i] = 0.0;
          y[rtemp + 3 * i] += Walking_ATRIAS_P.Calibration.KVHOrientation[3 * i]
            * Walking_ATRIAS_B.Rk[rtemp];
          y[rtemp + 3 * i] += Walking_ATRIAS_P.Calibration.KVHOrientation[3 * i
            + 1] * Walking_ATRIAS_B.Rk[rtemp + 3];
          y[rtemp + 3 * i] += Walking_ATRIAS_P.Calibration.KVHOrientation[3 * i
            + 2] * Walking_ATRIAS_B.Rk[rtemp + 6];
        }
      }

      /*  M_to_ZYX.m */
      /*  Author: Kevin Galloway */
      /*  Date: 29AUG12 */
      /*  */
      /*  Summary: This function takes a matrix (or array of matrices) M_RW_in and */
      /*  returns the Euler angles based on the ZYX convention. AngX refers to */
      /*  rotation around the X axis, AngY refers to rotation about the Y axis, and */
      /*  AngZ refers to rotation about the Z axis. If M_RW_in is an array of */
      /*  matrices (i.e. a multidimensional array), then AngX, AngY and AngZ */
      /*  will be vectors. */
      /* '<S42>:1:8' */
      n = -rt_atan2d_snf(y[1], y[0]);

      /* '<S42>:1:39' */
      Walking_ATRIAS_B.R0[0] = cos(n);
      Walking_ATRIAS_B.R0[3] = -sin(n);
      Walking_ATRIAS_B.R0[6] = 0.0;
      Walking_ATRIAS_B.R0[1] = sin(n);
      Walking_ATRIAS_B.R0[4] = cos(n);
      Walking_ATRIAS_B.R0[7] = 0.0;
      Walking_ATRIAS_B.R0[2] = 0.0;
      Walking_ATRIAS_B.R0[5] = 0.0;
      Walking_ATRIAS_B.R0[8] = 1.0;
    } else {
      /* '<S42>:1:10' */
      memcpy(&Walking_ATRIAS_B.R0[0], &Walking_ATRIAS_B.UnitDelay10[0], 9U *
             sizeof(real_T));
    }

    /*  Transform from IMU to robot frame and zero initial yaw */
    /* '<S42>:1:14' */
    for (rtemp = 0; rtemp < 3; rtemp++) {
      for (i = 0; i < 3; i++) {
        tmp_6[rtemp + 3 * i] = 0.0;
        tmp_6[rtemp + 3 * i] += Walking_ATRIAS_B.Rk[3 * i] *
          Walking_ATRIAS_B.R0[rtemp];
        tmp_6[rtemp + 3 * i] += Walking_ATRIAS_B.Rk[3 * i + 1] *
          Walking_ATRIAS_B.R0[rtemp + 3];
        tmp_6[rtemp + 3 * i] += Walking_ATRIAS_B.Rk[3 * i + 2] *
          Walking_ATRIAS_B.R0[rtemp + 6];
      }
    }

    for (rtemp = 0; rtemp < 3; rtemp++) {
      for (i = 0; i < 3; i++) {
        Walking_ATRIAS_B.Rk_g[rtemp + 3 * i] = 0.0;
        Walking_ATRIAS_B.Rk_g[rtemp + 3 * i] +=
          Walking_ATRIAS_P.Calibration.KVHOrientation[3 * i] * tmp_6[rtemp];
        Walking_ATRIAS_B.Rk_g[rtemp + 3 * i] +=
          Walking_ATRIAS_P.Calibration.KVHOrientation[3 * i + 1] * tmp_6[rtemp +
          3];
        Walking_ATRIAS_B.Rk_g[rtemp + 3 * i] +=
          Walking_ATRIAS_P.Calibration.KVHOrientation[3 * i + 2] * tmp_6[rtemp +
          6];
      }
    }

    /*  Convert Rk to ZYX Euler angles */
    /* '<S42>:1:17' */
    /*  M_to_ZYX.m */
    /*  Author: Kevin Galloway */
    /*  Date: 29AUG12 */
    /*  */
    /*  Summary: This function takes a matrix (or array of matrices) M_RW_in and */
    /*  returns the Euler angles based on the ZYX convention. AngX refers to */
    /*  rotation around the X axis, AngY refers to rotation about the Y axis, and */
    /*  AngZ refers to rotation about the Z axis. If M_RW_in is an array of */
    /*  matrices (i.e. a multidimensional array), then AngX, AngY and AngZ */
    /*  will be vectors. */
    Walking_ATRIAS_B.ZYX[0] = rt_atan2d_snf(Walking_ATRIAS_B.Rk_g[1],
      Walking_ATRIAS_B.Rk_g[0]);
    Walking_ATRIAS_B.ZYX[1] = asin(-Walking_ATRIAS_B.Rk_g[2]);
    Walking_ATRIAS_B.ZYX[2] = rt_atan2d_snf(Walking_ATRIAS_B.Rk_g[5],
      Walking_ATRIAS_B.Rk_g[8]);

    /*  Unroll yaw */
    /* '<S42>:1:20' */
    /* '<S42>:1:21' */
    /* '<S42>:1:22' */
    CurrentYaw = Walking_ATRIAS_B.ZYX[0];

    /* '<S42>:1:23' */
    /*  Determine if a rollover has occurred on yaw angle If a rollover is */
    /*  detected, the output Rollover is either +1 or -1, depending on the */
    /*  direction of the rollover. */
    if ((Walking_ATRIAS_B.UnitDelay9[1] > 0.0) && (Walking_ATRIAS_B.ZYX[0] <
         Walking_ATRIAS_B.UnitDelay9[1] - 3.1415926535897931)) {
      /* '<S42>:1:47' */
      /* '<S42>:1:48' */
      r2 = 1;
    } else if ((Walking_ATRIAS_B.UnitDelay9[1] < 0.0) && (Walking_ATRIAS_B.ZYX[0]
                > Walking_ATRIAS_B.UnitDelay9[1] + 3.1415926535897931)) {
      /* '<S42>:1:49' */
      /* '<S42>:1:50' */
      r2 = -1;
    } else {
      /* '<S42>:1:52' */
      r2 = 0;
    }

    n = Walking_ATRIAS_B.UnitDelay9[0] + (real_T)r2;

    /* '<S42>:1:24' */
    /* '<S42>:1:25' */
    Walking_ATRIAS_B.ZYX[0] += 6.2831853071795862 * n;

    /*  Compute Euler angle derivatives */
    /* '<S42>:1:28' */
    /* '<S42>:1:29' */
    if (cos(Walking_ATRIAS_B.ZYX[1]) > 0.001) {
      /* '<S42>:1:31' */
      /* '<S42>:1:32' */
      for (rtemp = 0; rtemp < 3; rtemp++) {
        for (i = 0; i < 3; i++) {
          tmp_6[rtemp + 3 * i] = 0.0;
          tmp_6[rtemp + 3 * i] += Walking_ATRIAS_B.Rk[3 * i] *
            Walking_ATRIAS_B.R0[rtemp];
          tmp_6[rtemp + 3 * i] += Walking_ATRIAS_B.Rk[3 * i + 1] *
            Walking_ATRIAS_B.R0[rtemp + 3];
          tmp_6[rtemp + 3 * i] += Walking_ATRIAS_B.Rk[3 * i + 2] *
            Walking_ATRIAS_B.R0[rtemp + 6];
        }
      }

      for (rtemp = 0; rtemp < 3; rtemp++) {
        HalfMaxTicks_idx_0 = tmp_6[rtemp] * Walking_ATRIAS_B.wk[0];
        HalfMaxTicks_idx_0 += tmp_6[rtemp + 3] * Walking_ATRIAS_B.wk[1];
        HalfMaxTicks_idx_0 += tmp_6[rtemp + 6] * Walking_ATRIAS_B.wk[2];
        w[rtemp] = HalfMaxTicks_idx_0;
      }

      y[3] = -sin(Walking_ATRIAS_B.ZYX[0]);
      y[6] = cos(Walking_ATRIAS_B.ZYX[0]) * cos(Walking_ATRIAS_B.ZYX[1]);
      y[4] = cos(Walking_ATRIAS_B.ZYX[0]);
      y[7] = sin(Walking_ATRIAS_B.ZYX[0]) * cos(Walking_ATRIAS_B.ZYX[1]);
      y[2] = 1.0;
      y[5] = 0.0;
      y[8] = -sin(Walking_ATRIAS_B.ZYX[1]);
      r2 = 1;
      i = 0;
      y[1] = 0.0;
      y[0] = 0.0;
      y[7] -= 0.0 * y[8];
      y[6] -= 0.0 * y[8];
      if (fabs(y[3]) > fabs(y[4])) {
        r2 = 0;
        i = 1;
      }

      y[3 + i] /= y[3 + r2];
      y[6 + i] -= y[3 + i] * y[6 + r2];
      Walking_ATRIAS_B.dZYX[0] = w[2];
      Walking_ATRIAS_B.dZYX[1] = w[r2] - Walking_ATRIAS_B.dZYX[0] * 0.0;
      Walking_ATRIAS_B.dZYX[2] = (w[i] - Walking_ATRIAS_B.dZYX[0] * 0.0) - y[3 +
        i] * Walking_ATRIAS_B.dZYX[1];
      Walking_ATRIAS_B.dZYX[2] /= y[6 + i];
      Walking_ATRIAS_B.dZYX[0] -= Walking_ATRIAS_B.dZYX[2] * y[8];
      Walking_ATRIAS_B.dZYX[1] -= y[6 + r2] * Walking_ATRIAS_B.dZYX[2];
      Walking_ATRIAS_B.dZYX[1] /= y[3 + r2];
      Walking_ATRIAS_B.dZYX[0] -= Walking_ATRIAS_B.dZYX[1] * 0.0;
    } else {
      /* '<S42>:1:34' */
      Walking_ATRIAS_B.dZYX[0] = 0.0;
      Walking_ATRIAS_B.dZYX[1] = 0.0;
      Walking_ATRIAS_B.dZYX[2] = 0.0;
    }

    Walking_ATRIAS_B.YawRollover[0] = n;
    Walking_ATRIAS_B.YawRollover[1] = CurrentYaw;

    /* End of MATLAB Function: '<S38>/ComputeEulerAngles1' */

    /* MATLAB Function: '<S37>/GeneralizedCoordinates' incorporates:
     *  Constant: '<S37>/UseIMU'
     *  Constant: '<S8>/GearOffset'
     *  Constant: '<S8>/IMUTorsoOffset'
     */
    /* MATLAB Function 'Subsystem1/StateEstimator/GeneralizedCoordinates': '<S41>:1' */
    /*  q_clean = */
    /*   [qzT; qyT; qxT; q1R; q2R; q1L; q2L; qgr1R; qgr2R; q3R; qgr1L; qgr2L; q3L]; */
    /*  */
    /*  EncoderAngles =  */
    /*   [Leg1R; Leg2R; Leg1L; Leg2L; Motor1R; Motor2R; Motor1L; Motor2L; Hip3R; Hip3L; ...   % ABSOLUTE ENCODERS */
    /*    Inc1R; Inc2R; Inc1L; Inc2L; Inc3R; Inc3L; Boom; Boom; Boom]                         % INCREMENTAL ENCODERS */
    if (Walking_ATRIAS_B.LogicalOperator1) {
      /* '<S41>:1:11' */
      /* '<S41>:1:12' */
      /* '<S41>:1:13' */
      for (i = 0; i < 13; i++) {
        Walking_ATRIAS_B.q_clean[i] = 0.0;
        Walking_ATRIAS_B.dq_clean[i] = 0.0;
      }
    } else {
      /* '<S41>:1:15' */
      /* '<S41>:1:16' */
      for (rtemp = 0; rtemp < 13; rtemp++) {
        Walking_ATRIAS_B.q_clean[rtemp] =
          Walking_ATRIAS_B.ImpAsg_InsertedFor_q_clean_at_i[c[rtemp]];
        Walking_ATRIAS_B.dq_clean[rtemp] =
          Walking_ATRIAS_B.ImpAsg_InsertedFor_dq_clean_at_[c[rtemp]];
      }

      /*  DDA 2015-10-13 */
      /*  Use hip abs encoder. The left inc encoder drift. Still use inc */
      /*  for velocity because the abs velocity is too noisy. Otherwise, */
      /*  add a more restrict filter for that. */
      /* '<S41>:1:22' */
      Walking_ATRIAS_B.q_clean[9] =
        Walking_ATRIAS_B.ImpAsg_InsertedFor_q_clean_at_i[8];
      Walking_ATRIAS_B.q_clean[12] =
        Walking_ATRIAS_B.ImpAsg_InsertedFor_q_clean_at_i[9];

      /*          dq_clean([10 13]) = EncoderVelocities([9 10]); */
      /*  Add offset to gear angles to allow zeroing of spring deflections. */
      /* '<S41>:1:53' */
      HalfMaxTicks_idx_0 = Walking_ATRIAS_P.GearOffsets[0] * 3.1415926535897931 /
        180.0 + Walking_ATRIAS_B.q_clean[7];
      HalfMaxTicks_idx_1 = Walking_ATRIAS_P.GearOffsets[1] * 3.1415926535897931 /
        180.0 + Walking_ATRIAS_B.q_clean[8];
      CalOffset_idx_0 = Walking_ATRIAS_P.GearOffsets[2] * 3.1415926535897931 /
        180.0 + Walking_ATRIAS_B.q_clean[10];
      CalOffset_idx_1 = Walking_ATRIAS_P.GearOffsets[3] * 3.1415926535897931 /
        180.0 + Walking_ATRIAS_B.q_clean[11];
      Walking_ATRIAS_B.q_clean[7] = HalfMaxTicks_idx_0;
      Walking_ATRIAS_B.q_clean[8] = HalfMaxTicks_idx_1;
      Walking_ATRIAS_B.q_clean[10] = CalOffset_idx_0;
      Walking_ATRIAS_B.q_clean[11] = CalOffset_idx_1;
      if (1.0 != 0.0) {
        /* '<S41>:1:56' */
        Walking_ATRIAS_B.q_clean[0] = Walking_ATRIAS_B.ZYX[0];
        Walking_ATRIAS_B.q_clean[1] = Walking_ATRIAS_P.IMUTorsoOffsets[0] *
          3.1415926535897931 / 180.0 + Walking_ATRIAS_B.ZYX[1];
        Walking_ATRIAS_B.q_clean[2] = Walking_ATRIAS_P.IMUTorsoOffsets[1] *
          3.1415926535897931 / 180.0 + Walking_ATRIAS_B.ZYX[2];

        /* '<S41>:1:57' */
        Walking_ATRIAS_B.dq_clean[0] = Walking_ATRIAS_B.dZYX[0];
        Walking_ATRIAS_B.dq_clean[1] = Walking_ATRIAS_B.dZYX[1];
        Walking_ATRIAS_B.dq_clean[2] = Walking_ATRIAS_B.dZYX[2];
      }
    }

    /* End of MATLAB Function: '<S37>/GeneralizedCoordinates' */

    /* MATLAB Function: '<S8>/AdjustForCOMOffset' incorporates:
     *  Constant: '<S8>/TorsoCOMOffsets'
     */
    /* MATLAB Function 'Subsystem1/AdjustForCOMOffset': '<S32>:1' */
    /* '<S32>:1:4' */
    n = Walking_ATRIAS_P.TorsoCOMOffsets[0] * 3.1415926535897931 / 180.0;

    /* '<S32>:1:5' */
    CurrentYaw = Walking_ATRIAS_P.TorsoCOMOffsets[1] * 3.1415926535897931 /
      180.0;

    /* '<S32>:1:7' */
    memcpy(&Walking_ATRIAS_B.q[0], &Walking_ATRIAS_B.q_clean[0], 13U * sizeof
           (real_T));

    /* '<S32>:1:8' */
    Walking_ATRIAS_B.q[1] = Walking_ATRIAS_B.q_clean[1] + n;

    /* '<S32>:1:9' */
    Walking_ATRIAS_B.q[9] -= n;

    /* '<S32>:1:10' */
    Walking_ATRIAS_B.q[12] += n;

    /* '<S32>:1:12' */
    Walking_ATRIAS_B.q[2] += CurrentYaw;

    /* '<S32>:1:13' */
    for (rtemp = 0; rtemp < 8; rtemp++) {
      tmp_7[rtemp] = Walking_ATRIAS_B.q[b_0[rtemp]] - CurrentYaw;
    }

    for (rtemp = 0; rtemp < 8; rtemp++) {
      Walking_ATRIAS_B.q[b_0[rtemp]] = tmp_7[rtemp];
    }

    for (i = 0; i < 13; i++) {
      /* Outport: '<Root>/q' */
      Walking_ATRIAS_Y.q[i] = Walking_ATRIAS_B.q[i];

      /* Outport: '<Root>/dq' */
      Walking_ATRIAS_Y.dq[i] = Walking_ATRIAS_B.dq_clean[i];
    }

    /* End of MATLAB Function: '<S8>/AdjustForCOMOffset' */
    for (i = 0; i < 19; i++) {
      /* Outport: '<Root>/EncoderAnglesClean' */
      Walking_ATRIAS_Y.EncoderAnglesClean[i] =
        Walking_ATRIAS_B.ImpAsg_InsertedFor_q_clean_at_i[i];

      /* Outport: '<Root>/EncoderDerivsClean' */
      Walking_ATRIAS_Y.EncoderDerivsClean[i] =
        Walking_ATRIAS_B.ImpAsg_InsertedFor_dq_clean_at_[i];
    }

    /* Outport: '<Root>/MicrostrainEulerAnglesClean' */
    Walking_ATRIAS_Y.MicrostrainEulerAnglesClean[0] = Walking_ATRIAS_B.ZYX[0];
    Walking_ATRIAS_Y.MicrostrainEulerAnglesClean[1] = Walking_ATRIAS_B.ZYX[1];
    Walking_ATRIAS_Y.MicrostrainEulerAnglesClean[2] = Walking_ATRIAS_B.ZYX[2];

    /* Outport: '<Root>/MicrostrainEulerDerivsClean' */
    Walking_ATRIAS_Y.MicrostrainEulerDerivsClean[0] = Walking_ATRIAS_B.dZYX[0];
    Walking_ATRIAS_Y.MicrostrainEulerDerivsClean[1] = Walking_ATRIAS_B.dZYX[1];
    Walking_ATRIAS_Y.MicrostrainEulerDerivsClean[2] = Walking_ATRIAS_B.dZYX[2];

    /* Outport: '<Root>/AbsTick' */
    Walking_ATRIAS_Y.AbsTick[0] = Walking_ATRIAS_B.DataTypeConversion49;
    Walking_ATRIAS_Y.AbsTick[1] = Walking_ATRIAS_B.DataTypeConversion73;
    Walking_ATRIAS_Y.AbsTick[2] = Walking_ATRIAS_B.DataTypeConversion3;
    Walking_ATRIAS_Y.AbsTick[3] = Walking_ATRIAS_B.DataTypeConversion25;
    Walking_ATRIAS_Y.AbsTick[4] = Walking_ATRIAS_B.DataTypeConversion50;
    Walking_ATRIAS_Y.AbsTick[5] = Walking_ATRIAS_B.DataTypeConversion74;
    Walking_ATRIAS_Y.AbsTick[6] = Walking_ATRIAS_B.DataTypeConversion1;
    Walking_ATRIAS_Y.AbsTick[7] = Walking_ATRIAS_B.DataTypeConversion26;
    Walking_ATRIAS_Y.AbsTick[8] = Walking_ATRIAS_B.DataTypeConversion98;
    Walking_ATRIAS_Y.AbsTick[9] = Walking_ATRIAS_B.DataTypeConversion114;

    /* Outport: '<Root>/IncTick' */
    Walking_ATRIAS_Y.IncTick[0] = Walking_ATRIAS_B.DataTypeConversion57;
    Walking_ATRIAS_Y.IncTick[1] = Walking_ATRIAS_B.DataTypeConversion81;
    Walking_ATRIAS_Y.IncTick[2] = Walking_ATRIAS_B.DataTypeConversion9;
    Walking_ATRIAS_Y.IncTick[3] = Walking_ATRIAS_B.DataTypeConversion33;
    Walking_ATRIAS_Y.IncTick[4] = Walking_ATRIAS_B.DataTypeConversion104;
    Walking_ATRIAS_Y.IncTick[5] = Walking_ATRIAS_B.DataTypeConversion119;
    Walking_ATRIAS_Y.IncTick[6] = Walking_ATRIAS_ConstB.DataTypeConversion141[0];
    Walking_ATRIAS_Y.IncTick[7] = Walking_ATRIAS_ConstB.DataTypeConversion141[1];
    Walking_ATRIAS_Y.IncTick[8] = Walking_ATRIAS_ConstB.DataTypeConversion141[2];

    /* DataTypeConversion: '<S38>/Data Type Conversion7' */
    Walking_ATRIAS_B.DataTypeConversion7[0] = Walking_ATRIAS_B.ValidStates[0];
    Walking_ATRIAS_B.DataTypeConversion7[1] = Walking_ATRIAS_B.ValidStates[1];
    Walking_ATRIAS_B.DataTypeConversion7[2] = Walking_ATRIAS_B.ValidStates[2];

    /* Outport: '<Root>/ValidStates' */
    Walking_ATRIAS_Y.ValidStates[0] = Walking_ATRIAS_B.DataTypeConversion7[0];
    Walking_ATRIAS_Y.ValidStates[1] = Walking_ATRIAS_B.DataTypeConversion7[1];
    Walking_ATRIAS_Y.ValidStates[2] = Walking_ATRIAS_B.DataTypeConversion7[2];
    for (i = 0; i < 9; i++) {
      /* Reshape: '<S38>/Reshape3' */
      Walking_ATRIAS_B.Reshape3[i] = Walking_ATRIAS_B.Rk_g[i];

      /* Outport: '<Root>/RotationMatrix' */
      Walking_ATRIAS_Y.RotationMatrix[i] = Walking_ATRIAS_B.Reshape3[i];
    }

    /* Gain: '<S20>/Gain1' incorporates:
     *  Constant: '<S20>/LegHipTorqueSat'
     */
    for (rtemp = 0; rtemp < 6; rtemp++) {
      Walking_ATRIAS_B.Gain1[rtemp] = 0.0;
      Walking_ATRIAS_B.Gain1[rtemp] += Walking_ATRIAS_ConstP.Gain1_Gain_d[rtemp]
        * Walking_ATRIAS_P.LegHipTorqueLimit[0];
      Walking_ATRIAS_B.Gain1[rtemp] += Walking_ATRIAS_ConstP.Gain1_Gain_d[rtemp
        + 6] * Walking_ATRIAS_P.LegHipTorqueLimit[1];
    }

    /* End of Gain: '<S20>/Gain1' */

    /* Gain: '<S28>/Gain' */
    Walking_ATRIAS_B.Gain[0] = (-1.0) * Walking_ATRIAS_B.q[3];
    Walking_ATRIAS_B.Gain[1] = (-1.0) * Walking_ATRIAS_B.q[7];
    Walking_ATRIAS_B.Gain[2] = (-1.0) * Walking_ATRIAS_B.q[4];
    Walking_ATRIAS_B.Gain[3] = (-1.0) * Walking_ATRIAS_B.q[8];
    Walking_ATRIAS_B.Gain[4] = (-1.0) * Walking_ATRIAS_B.q[5];
    Walking_ATRIAS_B.Gain[5] = (-1.0) * Walking_ATRIAS_B.q[10];
    Walking_ATRIAS_B.Gain[6] = (-1.0) * Walking_ATRIAS_B.q[6];
    Walking_ATRIAS_B.Gain[7] = (-1.0) * Walking_ATRIAS_B.q[11];
    Walking_ATRIAS_B.Gain[8] = (-1.0) * Walking_ATRIAS_B.q[9];
    Walking_ATRIAS_B.Gain[9] = (-1.0) * Walking_ATRIAS_B.q[12];
    Walking_ATRIAS_B.Gain[10] = 1.0 * Walking_ATRIAS_B.q[1];
    Walking_ATRIAS_B.Gain[11] = 1.0 * Walking_ATRIAS_B.q[0];
    Walking_ATRIAS_B.Gain[12] = (-1.0) * Walking_ATRIAS_B.q[2];

    /* Sum: '<S28>/Add' incorporates:
     *  Constant: '<S28>/Constant'
     */
    for (i = 0; i < 13; i++) {
      Walking_ATRIAS_B.Add[i] = Walking_ATRIAS_ConstP.Constant_Value[i] +
        Walking_ATRIAS_B.Gain[i];
    }

    /* End of Sum: '<S28>/Add' */

    /* Gain: '<S29>/Gain' */
    Walking_ATRIAS_B.Gain_a[0] = (-1.0) * Walking_ATRIAS_B.dq_clean[3];
    Walking_ATRIAS_B.Gain_a[1] = (-1.0) * Walking_ATRIAS_B.dq_clean[7];
    Walking_ATRIAS_B.Gain_a[2] = (-1.0) * Walking_ATRIAS_B.dq_clean[4];
    Walking_ATRIAS_B.Gain_a[3] = (-1.0) * Walking_ATRIAS_B.dq_clean[8];
    Walking_ATRIAS_B.Gain_a[4] = (-1.0) * Walking_ATRIAS_B.dq_clean[5];
    Walking_ATRIAS_B.Gain_a[5] = (-1.0) * Walking_ATRIAS_B.dq_clean[10];
    Walking_ATRIAS_B.Gain_a[6] = (-1.0) * Walking_ATRIAS_B.dq_clean[6];
    Walking_ATRIAS_B.Gain_a[7] = (-1.0) * Walking_ATRIAS_B.dq_clean[11];
    Walking_ATRIAS_B.Gain_a[8] = (-1.0) * Walking_ATRIAS_B.dq_clean[9];
    Walking_ATRIAS_B.Gain_a[9] = (-1.0) * Walking_ATRIAS_B.dq_clean[12];
    Walking_ATRIAS_B.Gain_a[10] = 1.0 * Walking_ATRIAS_B.dq_clean[1];
    Walking_ATRIAS_B.Gain_a[11] = 1.0 * Walking_ATRIAS_B.dq_clean[0];
    Walking_ATRIAS_B.Gain_a[12] = (-1.0) * Walking_ATRIAS_B.dq_clean[2];

    /* UnitDelay: '<S27>/Unit Delay' */
    Walking_ATRIAS_B.UnitDelay_m = Walking_ATRIAS_DW.UnitDelay_DSTATE_l;

    /* RelationalOperator: '<S31>/Compare' incorporates:
     *  Constant: '<S31>/Constant'
     */
    Walking_ATRIAS_B.Compare = (Walking_ATRIAS_B.UnitDelay_m <= 1.0);

    /* DiscreteIntegrator: '<S27>/Discrete-Time Integrator1' */
    if ((Walking_ATRIAS_B.Compare &&
         (Walking_ATRIAS_DW.DiscreteTimeIntegrator1_PrevRes <= 0)) ||
        ((!Walking_ATRIAS_B.Compare) &&
         (Walking_ATRIAS_DW.DiscreteTimeIntegrator1_PrevRes == 1))) {
      Walking_ATRIAS_DW.DiscreteTimeIntegrator1_DSTATE = 0.0;
    }

    Walking_ATRIAS_B.DiscreteTimeIntegrator1 =
      Walking_ATRIAS_DW.DiscreteTimeIntegrator1_DSTATE;

    /* End of DiscreteIntegrator: '<S27>/Discrete-Time Integrator1' */

    /* Product: '<S27>/Divide' incorporates:
     *  Constant: '<S2>/Constant5'
     */
    Walking_ATRIAS_B.Divide = Walking_ATRIAS_B.DiscreteTimeIntegrator1 /
      Walking_ATRIAS_P.t0_step;

    /* Constant: '<S2>/Constant3' */
    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.Constant3[i] = Walking_ATRIAS_P.ps3Axes[i];
    }

    /* End of Constant: '<S2>/Constant3' */

    /* Constant: '<S2>/Constant4' */
    memcpy(&Walking_ATRIAS_B.Constant4[0], &Walking_ATRIAS_P.ps3Buttons[0], 11U *
           sizeof(real_T));

    /* MATLABSystem: '<S2>/Controller3' incorporates:
     *  Constant: '<S2>/Constant'
     *  Constant: '<S2>/Constant1'
     *  Constant: '<S2>/Constant6'
     *  Constant: '<S2>/Constant8'
     */
    n = Walking_ATRIAS_P.t0_step;
    CurrentYaw = Walking_ATRIAS_P.step_gain;
    a21 = Walking_ATRIAS_P.kp_st_leg;
    t99 = Walking_ATRIAS_P.kd_st_leg;
    a_max = Walking_ATRIAS_P.kp_sw_leg;
    a_min = Walking_ATRIAS_P.kd_sw_leg;
    t21 = Walking_ATRIAS_P.kp_hip;
    t30 = Walking_ATRIAS_P.kd_hip;
    t36 = Walking_ATRIAS_P.kp_vs;
    t42 = Walking_ATRIAS_P.kd_vs;
    t51 = Walking_ATRIAS_P.kp_yaw;
    u_Link_idx_2 = Walking_ATRIAS_P.kd_yaw;
    u_Link_idx_3 = 1.0;
    q3R = 1.0;
    u_Link_idx_0 = 1.0;
    u_Link_idx_1 = 1.0;
    maxval = Walking_ATRIAS_P.lbForce;
    t11 = Walking_ATRIAS_P.ubForce;
    HalfMaxTicks_idx_0 = Walking_ATRIAS_P.velFilConst;
    sum_term = Walking_ATRIAS_P.dx_gain;
    hd2 = Walking_ATRIAS_P.dx_err_p_gain;
    t3 = Walking_ATRIAS_P.dx_err_d_gain;
    t5 = Walking_ATRIAS_P.dy_gain;
    alpha = Walking_ATRIAS_P.dy_err_p_gain;
    HalfMaxTicks_idx_1 = Walking_ATRIAS_P.dy_err_d_gain;
    t2 = Walking_ATRIAS_P.hip_offset;
    dxInput = Walking_ATRIAS_P.hip_gain;
    isTest5 = Walking_ATRIAS_P.isSetHipConst;
    b = Walking_ATRIAS_P.isTestHipTrack;
    isTest8 = Walking_ATRIAS_P.isTestGravity;
    isTest11 = Walking_ATRIAS_P.isVirtualConstraint;
    isTest12 = Walking_ATRIAS_P.isVCtracking;
    q_sw_h_tgt = 1.0;
    y_sw_tgt = Walking_ATRIAS_P.uHipGravity;
    isSim = Walking_ATRIAS_P.isSim;
    L = 250.0;
    for (i = 0; i < 13; i++) {
      u0[i] = Walking_ATRIAS_B.Add[i];
      u1[i] = Walking_ATRIAS_B.Gain_a[i];
    }

    u2 = 1.0;
    memcpy(&u3[0], &Walking_ATRIAS_P.theta_limits_norm[0], 18U * sizeof(real_T));
    memcpy(&u4[0], &Walking_ATRIAS_P.hAlphaSet[0], 360U * sizeof(real_T));
    sum_term_idx_3 = Walking_ATRIAS_B.Divide;
    for (i = 0; i < 6; i++) {
      RefAngle[i] = Walking_ATRIAS_B.Constant3[i];
    }

    memcpy(&u7[0], &Walking_ATRIAS_B.Constant4[0], 11U * sizeof(real_T));
    CalOffset_idx_0 = Walking_ATRIAS_P.ps3Pov;

    /* Start for MATLABSystem: '<S2>/Controller3' incorporates:
     *  MATLABSystem: '<S2>/Controller3'
     */
    varargin_1 = Walking_ATRIAS_DW.obj.t0_step;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == n);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.t0_step = n;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.t_gain;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == CurrentYaw);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.t_gain = CurrentYaw;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.kp_st_leg;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == a21);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.kp_st_leg = a21;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.kd_st_leg;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == t99);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.kd_st_leg = t99;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.kp_sw_leg;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == a_max);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.kp_sw_leg = a_max;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.kd_sw_leg;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == a_min);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.kd_sw_leg = a_min;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.kp_hip;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == t21);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.kp_hip = t21;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.kd_hip;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == t30);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.kd_hip = t30;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.kp_vs;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == t36);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.kp_vs = t36;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.kd_vs;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == t42);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.kd_vs = t42;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.kp_yaw;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == t51);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.kp_yaw = t51;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.kd_yaw;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == u_Link_idx_2);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.kd_yaw = u_Link_idx_2;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.s_l_A;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == u_Link_idx_3);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.s_l_A = u_Link_idx_3;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.s_l_B;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == q3R);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.s_l_B = q3R;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.s_r_A;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == u_Link_idx_0);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.s_r_A = u_Link_idx_0;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.s_r_B;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == u_Link_idx_1);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.s_r_B = u_Link_idx_1;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.thres_lo;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == maxval);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.thres_lo = maxval;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.thres_hi;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == t11);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.thres_hi = t11;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.tau;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == HalfMaxTicks_idx_0);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.tau = HalfMaxTicks_idx_0;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.dx_gain;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == sum_term);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.dx_gain = sum_term;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.dx_err_p_gain;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == hd2);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.dx_err_p_gain = hd2;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.dx_err_d_gain;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == t3);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.dx_err_d_gain = t3;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.dy_gain;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == t5);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.dy_gain = t5;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.dy_err_p_gain;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == alpha);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.dy_err_p_gain = alpha;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.dy_err_d_gain;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == HalfMaxTicks_idx_1);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.dy_err_d_gain = HalfMaxTicks_idx_1;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.y0_offset;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == t2);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.y0_offset = t2;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.y0_gain;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == dxInput);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.y0_gain = dxInput;
    }

    GyroValid = Walking_ATRIAS_DW.obj.isTest5;
    p = false;
    p_0 = true;
    AccelValid = (GyroValid == isTest5);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.isTest5 = isTest5;
    }

    GyroValid = Walking_ATRIAS_DW.obj.isTest7;
    p = false;
    p_0 = true;
    AccelValid = (GyroValid == b);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.isTest7 = b;
    }

    GyroValid = Walking_ATRIAS_DW.obj.isTest8;
    p = false;
    p_0 = true;
    AccelValid = (GyroValid == isTest8);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.isTest8 = isTest8;
    }

    GyroValid = Walking_ATRIAS_DW.obj.isTest11;
    p = false;
    p_0 = true;
    AccelValid = (GyroValid == isTest11);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.isTest11 = isTest11;
    }

    GyroValid = Walking_ATRIAS_DW.obj.isTest12;
    p = false;
    p_0 = true;
    AccelValid = (GyroValid == isTest12);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.isTest12 = isTest12;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.EnableYawControl;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == q_sw_h_tgt);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.EnableYawControl = q_sw_h_tgt;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.uHipGravity;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == y_sw_tgt);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.uHipGravity = y_sw_tgt;
    }

    GyroValid = Walking_ATRIAS_DW.obj.isSim;
    p = false;
    p_0 = true;
    AccelValid = (GyroValid == isSim);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.isSim = isSim;
    }

    varargin_1 = Walking_ATRIAS_DW.obj.u_lim;
    p = false;
    p_0 = true;
    AccelValid = (varargin_1 == L);
    if (!AccelValid) {
      p_0 = false;
    }

    if (p_0) {
      p = true;
    }

    if (!p) {
      obj = &Walking_ATRIAS_DW.obj;
      obj_0 = obj;
      if (obj_0->isInitialized && (!obj_0->isReleased)) {
        AccelValid = true;
      } else {
        AccelValid = false;
      }

      if (AccelValid) {
        obj->TunablePropsChanged = true;
      }

      Walking_ATRIAS_DW.obj.u_lim = L;
    }

    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->TunablePropsChanged) {
      obj_0->TunablePropsChanged = false;
    }

    /* CONTROLLER Controller superclass. */
    /*  PUBLIC PROPERTIES ===================================================== */
    /*  Simulation flag */
    /*  properties */
    /*  Torque limit (N*m) */
    /*  MARLO */
    /*  properties */
    /*  PROTECTED PROPERTIES ================================================== */
    /*  PS3 controller object */
    /*  Run time (s) */
    /*  Controller run state */
    /*  properties */
    /*  CONSTANT PROPERTIES =================================================== */
    /*  Sample interval time (s) */
    /* MARLO sample time */
    /*  properties */
    /*  ABSTRACT METHODS ====================================================== */
    /*  methods */
    /*  PROTECTED METHODS ===================================================== */
    /* SETUPIMPL Initialize system object. */
    /*  Initialize PS3 controller interface */
    /*  Run controller specific initialization */
    /*  setupImpl */
    /* STEPIMPL System output and state update equations. */
    /*  Initialize control input */
    /*  Simulation overrides */
    /*  Coordinate transformation for simulator */
    u0[8] = -u0[8];
    u1[8] = -u1[8];

    /*  Update PS3 controller */
    obj_1 = &obj->ps3;

    /*  */
    /*  Copyright 2015 Mikhail S. Jones */
    /*  PUBLIC PROPERTIES ===================================================== */
    /*  Joysticks */
    /*  properties */
    /*  PROTECTED PROPERTIES ================================================== */
    /*  Buttons */
    /*  properties */
    /*  PUBLIC METHODS ======================================================== */
    /* PS3CONTROLLER PS3 controller class constructor. */
    /*  Initialize buttons */
    /*  PS3Controller */
    /* UPDATE Update PS3 controller object with controller data. */
    /*  Update joysticks */
    obj_1->leftStickY = -RefAngle[1];
    obj_1->rightStickX = -RefAngle[3];
    obj_1->rightStickY = -RefAngle[4];

    /*  Convert button vector to logical */
    for (i = 0; i < 11; i++) {
      buttons[i] = (u7[i] != 0.0);
    }

    /*  Update button objects */
    obj_2 = &obj_1->select;
    AccelValid = buttons[6];

    /*  */
    /*  Copyright 2015 Mikhail S. Jones */
    /*  PROTECTED PROPERTIES ================================================== */
    /*  Current button state */
    /*  Button was just pushed */
    /*  Button was just released */
    /*  Duration button has been held down */
    /*  Number of button presses */
    /*  Time since initialization (s) */
    /*  Time at which button was last pressed (s) */
    /*  Fixed sample interval time (s) */
    /*  Acceptable interval to count click (s) */
    /*  properties */
    /*  PUBLIC METHODS ======================================================== */
    /* UPDATE Update PS3 button object with controller data. */
    /*  Update time */
    obj_2->time += obj_2->sampleInterval;

    /*  Check if button was pressed */
    if ((!obj_2->value) && AccelValid) {
      p_0 = true;
    } else {
      p_0 = false;
    }

    obj_2->isPressed = p_0;

    /*  Check if button was released */
    /*  Update click duration */
    if (obj_2->isPressed) {
      obj_2->timePressed = obj_2->time;
    } else {
      a_min = obj_2->time - obj_2->timePressed;
      y_5 = (real_T)AccelValid * a_min;
      obj_2->clickDuration = y_5;
    }

    /*  if */
    /*  Update click count */
    if (obj_2->time - obj_2->timePressed < obj_2->clickInterval) {
      obj_2->clickCount += (real_T)obj_2->isPressed;
    } else {
      obj_2->clickCount = 0.0;
    }

    /*  if */
    /*  Update button state */
    obj_2->value = AccelValid;
    obj_2 = &obj_1->l3;
    AccelValid = buttons[8];

    /*  */
    /*  Copyright 2015 Mikhail S. Jones */
    /*  PROTECTED PROPERTIES ================================================== */
    /*  Current button state */
    /*  Button was just pushed */
    /*  Button was just released */
    /*  Duration button has been held down */
    /*  Number of button presses */
    /*  Time since initialization (s) */
    /*  Time at which button was last pressed (s) */
    /*  Fixed sample interval time (s) */
    /*  Acceptable interval to count click (s) */
    /*  properties */
    /*  PUBLIC METHODS ======================================================== */
    /* UPDATE Update PS3 button object with controller data. */
    /*  Update time */
    obj_2->time += obj_2->sampleInterval;

    /*  Check if button was pressed */
    if ((!obj_2->value) && AccelValid) {
      p_0 = true;
    } else {
      p_0 = false;
    }

    obj_2->isPressed = p_0;

    /*  Check if button was released */
    /*  Update click duration */
    if (obj_2->isPressed) {
      obj_2->timePressed = obj_2->time;
    } else {
      a_min = obj_2->time - obj_2->timePressed;
      y_5 = (real_T)AccelValid * a_min;
      obj_2->clickDuration = y_5;
    }

    /*  if */
    /*  Update click count */
    if (obj_2->time - obj_2->timePressed < obj_2->clickInterval) {
      obj_2->clickCount += (real_T)obj_2->isPressed;
    } else {
      obj_2->clickCount = 0.0;
    }

    /*  if */
    /*  Update button state */
    obj_2->value = AccelValid;
    obj_2 = &obj_1->r3;
    AccelValid = buttons[9];

    /*  */
    /*  Copyright 2015 Mikhail S. Jones */
    /*  PROTECTED PROPERTIES ================================================== */
    /*  Current button state */
    /*  Button was just pushed */
    /*  Button was just released */
    /*  Duration button has been held down */
    /*  Number of button presses */
    /*  Time since initialization (s) */
    /*  Time at which button was last pressed (s) */
    /*  Fixed sample interval time (s) */
    /*  Acceptable interval to count click (s) */
    /*  properties */
    /*  PUBLIC METHODS ======================================================== */
    /* UPDATE Update PS3 button object with controller data. */
    /*  Update time */
    obj_2->time += obj_2->sampleInterval;

    /*  Check if button was pressed */
    if ((!obj_2->value) && AccelValid) {
      p_0 = true;
    } else {
      p_0 = false;
    }

    obj_2->isPressed = p_0;

    /*  Check if button was released */
    /*  Update click duration */
    if (obj_2->isPressed) {
      obj_2->timePressed = obj_2->time;
    } else {
      a_min = obj_2->time - obj_2->timePressed;
      y_5 = (real_T)AccelValid * a_min;
      obj_2->clickDuration = y_5;
    }

    /*  if */
    /*  Update click count */
    if (obj_2->time - obj_2->timePressed < obj_2->clickInterval) {
      obj_2->clickCount += (real_T)obj_2->isPressed;
    } else {
      obj_2->clickCount = 0.0;
    }

    /*  if */
    /*  Update button state */
    obj_2->value = AccelValid;
    obj_2 = &obj_1->start;
    AccelValid = buttons[7];

    /*  */
    /*  Copyright 2015 Mikhail S. Jones */
    /*  PROTECTED PROPERTIES ================================================== */
    /*  Current button state */
    /*  Button was just pushed */
    /*  Button was just released */
    /*  Duration button has been held down */
    /*  Number of button presses */
    /*  Time since initialization (s) */
    /*  Time at which button was last pressed (s) */
    /*  Fixed sample interval time (s) */
    /*  Acceptable interval to count click (s) */
    /*  properties */
    /*  PUBLIC METHODS ======================================================== */
    /* UPDATE Update PS3 button object with controller data. */
    /*  Update time */
    obj_2->time += obj_2->sampleInterval;

    /*  Check if button was pressed */
    if ((!obj_2->value) && AccelValid) {
      p_0 = true;
    } else {
      p_0 = false;
    }

    obj_2->isPressed = p_0;

    /*  Check if button was released */
    /*  Update click duration */
    if (obj_2->isPressed) {
      obj_2->timePressed = obj_2->time;
    } else {
      a_min = obj_2->time - obj_2->timePressed;
      y_5 = (real_T)AccelValid * a_min;
      obj_2->clickDuration = y_5;
    }

    /*  if */
    /*  Update click count */
    if (obj_2->time - obj_2->timePressed < obj_2->clickInterval) {
      obj_2->clickCount += (real_T)obj_2->isPressed;
    } else {
      obj_2->clickCount = 0.0;
    }

    /*  if */
    /*  Update button state */
    obj_2->value = AccelValid;
    obj_2 = &obj_1->up;
    AccelValid = (CalOffset_idx_0 == 0.0);

    /*  */
    /*  Copyright 2015 Mikhail S. Jones */
    /*  PROTECTED PROPERTIES ================================================== */
    /*  Current button state */
    /*  Button was just pushed */
    /*  Button was just released */
    /*  Duration button has been held down */
    /*  Number of button presses */
    /*  Time since initialization (s) */
    /*  Time at which button was last pressed (s) */
    /*  Fixed sample interval time (s) */
    /*  Acceptable interval to count click (s) */
    /*  properties */
    /*  PUBLIC METHODS ======================================================== */
    /* UPDATE Update PS3 button object with controller data. */
    /*  Update time */
    obj_2->time += obj_2->sampleInterval;

    /*  Check if button was pressed */
    if ((!obj_2->value) && AccelValid) {
      p_0 = true;
    } else {
      p_0 = false;
    }

    obj_2->isPressed = p_0;

    /*  Check if button was released */
    /*  Update click duration */
    if (obj_2->isPressed) {
      obj_2->timePressed = obj_2->time;
    } else {
      a_min = obj_2->time - obj_2->timePressed;
      y_5 = (real_T)AccelValid * a_min;
      obj_2->clickDuration = y_5;
    }

    /*  if */
    /*  Update click count */
    if (obj_2->time - obj_2->timePressed < obj_2->clickInterval) {
      obj_2->clickCount += (real_T)obj_2->isPressed;
    } else {
      obj_2->clickCount = 0.0;
    }

    /*  if */
    /*  Update button state */
    obj_2->value = AccelValid;
    obj_2 = &obj_1->right;
    AccelValid = (CalOffset_idx_0 == 90.0);

    /*  */
    /*  Copyright 2015 Mikhail S. Jones */
    /*  PROTECTED PROPERTIES ================================================== */
    /*  Current button state */
    /*  Button was just pushed */
    /*  Button was just released */
    /*  Duration button has been held down */
    /*  Number of button presses */
    /*  Time since initialization (s) */
    /*  Time at which button was last pressed (s) */
    /*  Fixed sample interval time (s) */
    /*  Acceptable interval to count click (s) */
    /*  properties */
    /*  PUBLIC METHODS ======================================================== */
    /* UPDATE Update PS3 button object with controller data. */
    /*  Update time */
    obj_2->time += obj_2->sampleInterval;

    /*  Check if button was pressed */
    if ((!obj_2->value) && AccelValid) {
      p_0 = true;
    } else {
      p_0 = false;
    }

    obj_2->isPressed = p_0;

    /*  Check if button was released */
    /*  Update click duration */
    if (obj_2->isPressed) {
      obj_2->timePressed = obj_2->time;
    } else {
      a_min = obj_2->time - obj_2->timePressed;
      y_5 = (real_T)AccelValid * a_min;
      obj_2->clickDuration = y_5;
    }

    /*  if */
    /*  Update click count */
    if (obj_2->time - obj_2->timePressed < obj_2->clickInterval) {
      obj_2->clickCount += (real_T)obj_2->isPressed;
    } else {
      obj_2->clickCount = 0.0;
    }

    /*  if */
    /*  Update button state */
    obj_2->value = AccelValid;
    obj_2 = &obj_1->down;
    AccelValid = (CalOffset_idx_0 == 180.0);

    /*  */
    /*  Copyright 2015 Mikhail S. Jones */
    /*  PROTECTED PROPERTIES ================================================== */
    /*  Current button state */
    /*  Button was just pushed */
    /*  Button was just released */
    /*  Duration button has been held down */
    /*  Number of button presses */
    /*  Time since initialization (s) */
    /*  Time at which button was last pressed (s) */
    /*  Fixed sample interval time (s) */
    /*  Acceptable interval to count click (s) */
    /*  properties */
    /*  PUBLIC METHODS ======================================================== */
    /* UPDATE Update PS3 button object with controller data. */
    /*  Update time */
    obj_2->time += obj_2->sampleInterval;

    /*  Check if button was pressed */
    if ((!obj_2->value) && AccelValid) {
      p_0 = true;
    } else {
      p_0 = false;
    }

    obj_2->isPressed = p_0;

    /*  Check if button was released */
    /*  Update click duration */
    if (obj_2->isPressed) {
      obj_2->timePressed = obj_2->time;
    } else {
      a_min = obj_2->time - obj_2->timePressed;
      y_5 = (real_T)AccelValid * a_min;
      obj_2->clickDuration = y_5;
    }

    /*  if */
    /*  Update click count */
    if (obj_2->time - obj_2->timePressed < obj_2->clickInterval) {
      obj_2->clickCount += (real_T)obj_2->isPressed;
    } else {
      obj_2->clickCount = 0.0;
    }

    /*  if */
    /*  Update button state */
    obj_2->value = AccelValid;
    obj_2 = &obj_1->left;
    AccelValid = (CalOffset_idx_0 == 270.0);

    /*  */
    /*  Copyright 2015 Mikhail S. Jones */
    /*  PROTECTED PROPERTIES ================================================== */
    /*  Current button state */
    /*  Button was just pushed */
    /*  Button was just released */
    /*  Duration button has been held down */
    /*  Number of button presses */
    /*  Time since initialization (s) */
    /*  Time at which button was last pressed (s) */
    /*  Fixed sample interval time (s) */
    /*  Acceptable interval to count click (s) */
    /*  properties */
    /*  PUBLIC METHODS ======================================================== */
    /* UPDATE Update PS3 button object with controller data. */
    /*  Update time */
    obj_2->time += obj_2->sampleInterval;

    /*  Check if button was pressed */
    if ((!obj_2->value) && AccelValid) {
      p_0 = true;
    } else {
      p_0 = false;
    }

    obj_2->isPressed = p_0;

    /*  Check if button was released */
    /*  Update click duration */
    if (obj_2->isPressed) {
      obj_2->timePressed = obj_2->time;
    } else {
      a_min = obj_2->time - obj_2->timePressed;
      y_5 = (real_T)AccelValid * a_min;
      obj_2->clickDuration = y_5;
    }

    /*  if */
    /*  Update click count */
    if (obj_2->time - obj_2->timePressed < obj_2->clickInterval) {
      obj_2->clickCount += (real_T)obj_2->isPressed;
    } else {
      obj_2->clickCount = 0.0;
    }

    /*  if */
    /*  Update button state */
    obj_2->value = AccelValid;
    obj_2 = &obj_1->l2;
    AccelValid = (RefAngle[2] > 0.0);

    /*  */
    /*  Copyright 2015 Mikhail S. Jones */
    /*  PROTECTED PROPERTIES ================================================== */
    /*  Current button state */
    /*  Button was just pushed */
    /*  Button was just released */
    /*  Duration button has been held down */
    /*  Number of button presses */
    /*  Time since initialization (s) */
    /*  Time at which button was last pressed (s) */
    /*  Fixed sample interval time (s) */
    /*  Acceptable interval to count click (s) */
    /*  properties */
    /*  PUBLIC METHODS ======================================================== */
    /* UPDATE Update PS3 button object with controller data. */
    /*  Update time */
    obj_2->time += obj_2->sampleInterval;

    /*  Check if button was pressed */
    if ((!obj_2->value) && AccelValid) {
      p_0 = true;
    } else {
      p_0 = false;
    }

    obj_2->isPressed = p_0;

    /*  Check if button was released */
    /*  Update click duration */
    if (obj_2->isPressed) {
      obj_2->timePressed = obj_2->time;
    } else {
      a_min = obj_2->time - obj_2->timePressed;
      y_5 = (real_T)AccelValid * a_min;
      obj_2->clickDuration = y_5;
    }

    /*  if */
    /*  Update click count */
    if (obj_2->time - obj_2->timePressed < obj_2->clickInterval) {
      obj_2->clickCount += (real_T)obj_2->isPressed;
    } else {
      obj_2->clickCount = 0.0;
    }

    /*  if */
    /*  Update button state */
    obj_2->value = AccelValid;
    obj_2 = &obj_1->r2;
    AccelValid = (RefAngle[5] > 0.0);

    /*  */
    /*  Copyright 2015 Mikhail S. Jones */
    /*  PROTECTED PROPERTIES ================================================== */
    /*  Current button state */
    /*  Button was just pushed */
    /*  Button was just released */
    /*  Duration button has been held down */
    /*  Number of button presses */
    /*  Time since initialization (s) */
    /*  Time at which button was last pressed (s) */
    /*  Fixed sample interval time (s) */
    /*  Acceptable interval to count click (s) */
    /*  properties */
    /*  PUBLIC METHODS ======================================================== */
    /* UPDATE Update PS3 button object with controller data. */
    /*  Update time */
    obj_2->time += obj_2->sampleInterval;

    /*  Check if button was pressed */
    if ((!obj_2->value) && AccelValid) {
      p_0 = true;
    } else {
      p_0 = false;
    }

    obj_2->isPressed = p_0;

    /*  Check if button was released */
    /*  Update click duration */
    if (obj_2->isPressed) {
      obj_2->timePressed = obj_2->time;
    } else {
      a_min = obj_2->time - obj_2->timePressed;
      y_5 = (real_T)AccelValid * a_min;
      obj_2->clickDuration = y_5;
    }

    /*  if */
    /*  Update click count */
    if (obj_2->time - obj_2->timePressed < obj_2->clickInterval) {
      obj_2->clickCount += (real_T)obj_2->isPressed;
    } else {
      obj_2->clickCount = 0.0;
    }

    /*  if */
    /*  Update button state */
    obj_2->value = AccelValid;
    obj_2 = &obj_1->l1;
    AccelValid = buttons[4];

    /*  */
    /*  Copyright 2015 Mikhail S. Jones */
    /*  PROTECTED PROPERTIES ================================================== */
    /*  Current button state */
    /*  Button was just pushed */
    /*  Button was just released */
    /*  Duration button has been held down */
    /*  Number of button presses */
    /*  Time since initialization (s) */
    /*  Time at which button was last pressed (s) */
    /*  Fixed sample interval time (s) */
    /*  Acceptable interval to count click (s) */
    /*  properties */
    /*  PUBLIC METHODS ======================================================== */
    /* UPDATE Update PS3 button object with controller data. */
    /*  Update time */
    obj_2->time += obj_2->sampleInterval;

    /*  Check if button was pressed */
    if ((!obj_2->value) && AccelValid) {
      p_0 = true;
    } else {
      p_0 = false;
    }

    obj_2->isPressed = p_0;

    /*  Check if button was released */
    /*  Update click duration */
    if (obj_2->isPressed) {
      obj_2->timePressed = obj_2->time;
    } else {
      a_min = obj_2->time - obj_2->timePressed;
      y_5 = (real_T)AccelValid * a_min;
      obj_2->clickDuration = y_5;
    }

    /*  if */
    /*  Update click count */
    if (obj_2->time - obj_2->timePressed < obj_2->clickInterval) {
      obj_2->clickCount += (real_T)obj_2->isPressed;
    } else {
      obj_2->clickCount = 0.0;
    }

    /*  if */
    /*  Update button state */
    obj_2->value = AccelValid;
    obj_2 = &obj_1->r1;
    AccelValid = buttons[5];

    /*  */
    /*  Copyright 2015 Mikhail S. Jones */
    /*  PROTECTED PROPERTIES ================================================== */
    /*  Current button state */
    /*  Button was just pushed */
    /*  Button was just released */
    /*  Duration button has been held down */
    /*  Number of button presses */
    /*  Time since initialization (s) */
    /*  Time at which button was last pressed (s) */
    /*  Fixed sample interval time (s) */
    /*  Acceptable interval to count click (s) */
    /*  properties */
    /*  PUBLIC METHODS ======================================================== */
    /* UPDATE Update PS3 button object with controller data. */
    /*  Update time */
    obj_2->time += obj_2->sampleInterval;

    /*  Check if button was pressed */
    if ((!obj_2->value) && AccelValid) {
      p_0 = true;
    } else {
      p_0 = false;
    }

    obj_2->isPressed = p_0;

    /*  Check if button was released */
    /*  Update click duration */
    if (obj_2->isPressed) {
      obj_2->timePressed = obj_2->time;
    } else {
      a_min = obj_2->time - obj_2->timePressed;
      y_5 = (real_T)AccelValid * a_min;
      obj_2->clickDuration = y_5;
    }

    /*  if */
    /*  Update click count */
    if (obj_2->time - obj_2->timePressed < obj_2->clickInterval) {
      obj_2->clickCount += (real_T)obj_2->isPressed;
    } else {
      obj_2->clickCount = 0.0;
    }

    /*  if */
    /*  Update button state */
    obj_2->value = AccelValid;
    obj_2 = &obj_1->triangle;
    AccelValid = buttons[3];

    /*  */
    /*  Copyright 2015 Mikhail S. Jones */
    /*  PROTECTED PROPERTIES ================================================== */
    /*  Current button state */
    /*  Button was just pushed */
    /*  Button was just released */
    /*  Duration button has been held down */
    /*  Number of button presses */
    /*  Time since initialization (s) */
    /*  Time at which button was last pressed (s) */
    /*  Fixed sample interval time (s) */
    /*  Acceptable interval to count click (s) */
    /*  properties */
    /*  PUBLIC METHODS ======================================================== */
    /* UPDATE Update PS3 button object with controller data. */
    /*  Update time */
    obj_2->time += obj_2->sampleInterval;

    /*  Check if button was pressed */
    if ((!obj_2->value) && AccelValid) {
      p_0 = true;
    } else {
      p_0 = false;
    }

    obj_2->isPressed = p_0;

    /*  Check if button was released */
    /*  Update click duration */
    if (obj_2->isPressed) {
      obj_2->timePressed = obj_2->time;
    } else {
      a_min = obj_2->time - obj_2->timePressed;
      y_5 = (real_T)AccelValid * a_min;
      obj_2->clickDuration = y_5;
    }

    /*  if */
    /*  Update click count */
    if (obj_2->time - obj_2->timePressed < obj_2->clickInterval) {
      obj_2->clickCount += (real_T)obj_2->isPressed;
    } else {
      obj_2->clickCount = 0.0;
    }

    /*  if */
    /*  Update button state */
    obj_2->value = AccelValid;
    obj_2 = &obj_1->circle;
    AccelValid = buttons[1];

    /*  */
    /*  Copyright 2015 Mikhail S. Jones */
    /*  PROTECTED PROPERTIES ================================================== */
    /*  Current button state */
    /*  Button was just pushed */
    /*  Button was just released */
    /*  Duration button has been held down */
    /*  Number of button presses */
    /*  Time since initialization (s) */
    /*  Time at which button was last pressed (s) */
    /*  Fixed sample interval time (s) */
    /*  Acceptable interval to count click (s) */
    /*  properties */
    /*  PUBLIC METHODS ======================================================== */
    /* UPDATE Update PS3 button object with controller data. */
    /*  Update time */
    obj_2->time += obj_2->sampleInterval;

    /*  Check if button was pressed */
    if ((!obj_2->value) && AccelValid) {
      p_0 = true;
    } else {
      p_0 = false;
    }

    obj_2->isPressed = p_0;

    /*  Check if button was released */
    /*  Update click duration */
    if (obj_2->isPressed) {
      obj_2->timePressed = obj_2->time;
    } else {
      a_min = obj_2->time - obj_2->timePressed;
      y_5 = (real_T)AccelValid * a_min;
      obj_2->clickDuration = y_5;
    }

    /*  if */
    /*  Update click count */
    if (obj_2->time - obj_2->timePressed < obj_2->clickInterval) {
      obj_2->clickCount += (real_T)obj_2->isPressed;
    } else {
      obj_2->clickCount = 0.0;
    }

    /*  if */
    /*  Update button state */
    obj_2->value = AccelValid;
    obj_2 = &obj_1->cross;
    AccelValid = buttons[0];

    /*  */
    /*  Copyright 2015 Mikhail S. Jones */
    /*  PROTECTED PROPERTIES ================================================== */
    /*  Current button state */
    /*  Button was just pushed */
    /*  Button was just released */
    /*  Duration button has been held down */
    /*  Number of button presses */
    /*  Time since initialization (s) */
    /*  Time at which button was last pressed (s) */
    /*  Fixed sample interval time (s) */
    /*  Acceptable interval to count click (s) */
    /*  properties */
    /*  PUBLIC METHODS ======================================================== */
    /* UPDATE Update PS3 button object with controller data. */
    /*  Update time */
    obj_2->time += obj_2->sampleInterval;

    /*  Check if button was pressed */
    if ((!obj_2->value) && AccelValid) {
      p_0 = true;
    } else {
      p_0 = false;
    }

    obj_2->isPressed = p_0;

    /*  Check if button was released */
    /*  Update click duration */
    if (obj_2->isPressed) {
      obj_2->timePressed = obj_2->time;
    } else {
      a_min = obj_2->time - obj_2->timePressed;
      y_5 = (real_T)AccelValid * a_min;
      obj_2->clickDuration = y_5;
    }

    /*  if */
    /*  Update click count */
    if (obj_2->time - obj_2->timePressed < obj_2->clickInterval) {
      obj_2->clickCount += (real_T)obj_2->isPressed;
    } else {
      obj_2->clickCount = 0.0;
    }

    /*  if */
    /*  Update button state */
    obj_2->value = AccelValid;
    obj_2 = &obj_1->square;
    AccelValid = buttons[2];

    /*  */
    /*  Copyright 2015 Mikhail S. Jones */
    /*  PROTECTED PROPERTIES ================================================== */
    /*  Current button state */
    /*  Button was just pushed */
    /*  Button was just released */
    /*  Duration button has been held down */
    /*  Number of button presses */
    /*  Time since initialization (s) */
    /*  Time at which button was last pressed (s) */
    /*  Fixed sample interval time (s) */
    /*  Acceptable interval to count click (s) */
    /*  properties */
    /*  PUBLIC METHODS ======================================================== */
    /* UPDATE Update PS3 button object with controller data. */
    /*  Update time */
    obj_2->time += obj_2->sampleInterval;

    /*  Check if button was pressed */
    if ((!obj_2->value) && AccelValid) {
      p_0 = true;
    } else {
      p_0 = false;
    }

    obj_2->isPressed = p_0;

    /*  Check if button was released */
    /*  Update click duration */
    if (obj_2->isPressed) {
      obj_2->timePressed = obj_2->time;
    } else {
      a_min = obj_2->time - obj_2->timePressed;
      y_5 = (real_T)AccelValid * a_min;
      obj_2->clickDuration = y_5;
    }

    /*  if */
    /*  Update click count */
    if (obj_2->time - obj_2->timePressed < obj_2->clickInterval) {
      obj_2->clickCount += (real_T)obj_2->isPressed;
    } else {
      obj_2->clickCount = 0.0;
    }

    /*  if */
    /*  Update button state */
    obj_2->value = AccelValid;
    obj_2 = &obj_1->ps;
    AccelValid = buttons[10];

    /*  */
    /*  Copyright 2015 Mikhail S. Jones */
    /*  PROTECTED PROPERTIES ================================================== */
    /*  Current button state */
    /*  Button was just pushed */
    /*  Button was just released */
    /*  Duration button has been held down */
    /*  Number of button presses */
    /*  Time since initialization (s) */
    /*  Time at which button was last pressed (s) */
    /*  Fixed sample interval time (s) */
    /*  Acceptable interval to count click (s) */
    /*  properties */
    /*  PUBLIC METHODS ======================================================== */
    /* UPDATE Update PS3 button object with controller data. */
    /*  Update time */
    obj_2->time += obj_2->sampleInterval;

    /*  Check if button was pressed */
    if ((!obj_2->value) && AccelValid) {
      p_0 = true;
    } else {
      p_0 = false;
    }

    obj_2->isPressed = p_0;

    /*  Check if button was released */
    /*  Update click duration */
    if (obj_2->isPressed) {
      obj_2->timePressed = obj_2->time;
    } else {
      a_min = obj_2->time - obj_2->timePressed;
      y_5 = (real_T)AccelValid * a_min;
      obj_2->clickDuration = y_5;
    }

    /*  if */
    /*  Update click count */
    if (obj_2->time - obj_2->timePressed < obj_2->clickInterval) {
      obj_2->clickCount += (real_T)obj_2->isPressed;
    } else {
      obj_2->clickCount = 0.0;
    }

    /*  if */
    /*  Update button state */
    obj_2->value = AccelValid;

    /*  Parse start button data */
    if (obj->ps3.start.clickDuration > 3.0) {
      obj->isRun = true;
    } else {
      if (obj->ps3.start.isPressed) {
        obj->isRun = false;
      }
    }

    /*  if */
    /*  Parse PS button data */
    isTest5 = obj->ps3.ps.isPressed;

    /*  if */
    /*  Run controller logic */
    if (obj->isRun) {
      obj->runTime += 0.0005;

      /*  Run controller */
      obj_0 = obj;
      obj_0->t += 0.0005;
      obj_3 = obj_0;

      /* MIKHAILCONTROLLER Mikhail's controller. */
      /*  */
      /*  Copyright   2015 Mikhail S. Jones */
      /*  PUBLIC PROPERTIES ===================================================== */
      /*  Step Duration (s) */
      /*  Step Duration Gain */
      /*  Atrias, 0.02 */
      /*  Stance Leg P Gain (N*m/rad) */
      /*  Stance Leg D Gain (N*m*s/rad) */
      /*  Swing Leg P Gain (N*m/rad) */
      /*  Swing Leg D Gain (N*m*s/rad) */
      /*  Hip P Gain (N*m/rad) */
      /*  Hip D Gain (N*m*s/rad) */
      /*  Virtual Spring P Gain (N/m) */
      /*  Virtual Spring D Gain (N/m/s) */
      /*  Virtual Spring P Gain (N/m) */
      /*  Virtual Spring D Gain (N/m/s) */
      /*  Left A Motor Torque Scaling Factor */
      /*  Left B Motor Torque Scaling Factor */
      /*  Right A Motor Torque Scaling Factor */
      /*  Right B Motor Torque Scaling Factor */
      /*  Lower Force Threshold (N) */
      /*  Upper Force Threshold (N) */
      /*  Velocity Filter Time Constant (s) */
      /*  X Velocity Feed-Forward Gain */
      /*  X Velocity Error P Gain */
      /*  X Velocity Error D Gain */
      /*  Y Velocity Feed-Forward Gain */
      /*  Y Velocity Error P Gain */
      /*  Y Velocity Error D Gain */
      /*  Hip Offset (m) */
      /*  Hip Offset Gain */
      /*  Set hip to constant */
      /*  Test hip tracking */
      /*  Test hip gravity compensation */
      /*  Test Virtual Contraint */
      /*  Test VC tracking */
      /*  Enable Yaw Control (m) */
      /*  Hip Gravity Compensation Torque (Nm) */
      /*  properties */
      /*  PROTECTED PROPERTIES ================================================== */
      /*  Current stance leg (1 == Left, -1 == Right) */
      /*  Gait mode */
      /*  Time since last step (s) */
      /*      X Center of Mass Offset (m) */
      /*      Y Center of Mass Offset (m) */
      /*      Z Center of Mass Offset (m) */
      /*  Heading (rad) */
      /*  Estimated X position (m) */
      /*  Estimated Y position (m) */
      /*  Estimated X velocity (m/s) */
      /*  Estimated Y velocity (m/s) */
      /*  Estimated average Y velocity of last step (m/s) */
      /*  Target X velocity (m/s) */
      /*  Target Y velocity (m/s) */
      /*  Estimated X velocity of last step (m/s) */
      /*  Estimated Y velocity of last step (m/s) */
      /*  Storage for passing signals to output function */
      /*  phase variable */
      /*  properties */
      /*  CONSTANT PROPERTIES =================================================== */
      /*  Center of mass offset trim increment (m) */
      /*  Leg rotational spring constant (N*m/rad) */
      /*  MARLO 8 mm spring */
      /*  		ks_leg = 2.6908e+03*(3/2)^3    % MARLO 12 mm spring */
      /*  Torso mass (kg) */
      /*  Total mass (kg) */
      /*  MARLO */
      /*  Leg mass (kg) */
      /*  Gravity */
      /*  Hip length */
      /*  Nominal Leg Length (m) */
      /*  Leg motor coulomb friction */
      /*  Leg motor viscous friction */
      /*  properties */
      /*  PUBLIC METHODS ======================================================== */
      /* USERSETUP Initialize system object. */
      /*  Reset objects */
      /*  Reset parameters */
      /*  				obj.x_offset = 0.02; */
      /*  userSetup */
      /* USEROUTPUT User output function. */
      /*            userOut = []; */
      /*  userOutput */
      /* USERSTEP System output and state update equations. */
      /*  Update stance duration timer */
      /*  Parse PS3 controller data */
      /*  Relabel leg state variables in terms of stance and swing */
      /*  Left */
      /*  Right */
      /*  if */
      /*  Relabel torso state variables */
      /*  Calculate Swing foot height */
      /*  Left */
      /*  Calibrated geometry */
      /*  Store heading for use in hold position mode */
      /*  Hip lengths */
      /*  Compute hip to center of mass distances and velocities */
      /* obj.z_offset*cos(q_pitch)*cos(q_roll)*dq_pitch - obj.x_offset*sin(q_pitch)*dq_pitch + obj.y_offset*cos(q_pitch)*sin(q_roll)*dq_pitch + obj.y_offset*cos(q_roll)*sin(q_pitch)*dq_roll - obj.z_offset*sin(q_pitch)*sin(q_roll)*dq_roll; */
      /* -(obj.z_offset*cos(q_roll) + obj.y_offset*sin(q_roll))*dq_roll; */
      /*  Define relative pitch angle */
      /*  Compute toe to center of mass distances and velocities */
      /*  			obj.dx = (sin(q_pitch)*sin(q_st_lA_est)*dq_pitch)/2 - (cos(q_pitch)*cos(q_st_lB_est)*dq_st_lB_est)/2 - (cos(q_pitch)*cos(q_st_lA_est)*dq_st_lA_est)/2 + (sin(q_pitch)*sin(q_st_lB_est)*dq_pitch)/2 - obj.x_offset*sin(q_pitch)*dq_pitch + obj.z_offset*cos(q_pitch)*cos(q_roll)*dq_pitch + obj.y_offset*cos(q_pitch)*sin(q_roll)*dq_pitch + obj.y_offset*cos(q_roll)*sin(q_pitch)*dq_roll - obj.z_offset*sin(q_pitch)*sin(q_roll)*dq_roll - (cos(q_pitch)*cos(q_roll)*cos(q_st_h)*cos(q_st_lA_est)*dq_pitch)/2 - (cos(q_pitch)*cos(q_roll)*cos(q_st_h)*cos(q_st_lB_est)*dq_pitch)/2 + (cos(q_pitch)*cos(q_st_lA_est)*sin(q_roll)*sin(q_st_h)*dq_pitch)/2 + (cos(q_pitch)*cos(q_st_lB_est)*sin(q_roll)*sin(q_st_h)*dq_pitch)/2 + (cos(q_roll)*cos(q_st_lA_est)*sin(q_pitch)*sin(q_st_h)*dq_roll)/2 + (cos(q_st_h)*cos(q_st_lA_est)*sin(q_pitch)*sin(q_roll)*dq_roll)/2 + (cos(q_roll)*cos(q_st_lB_est)*sin(q_pitch)*sin(q_st_h)*dq_roll)/2 + (cos(q_st_h)*cos(q_st_lB_est)*sin(q_pitch)*sin(q_roll)*dq_roll)/2 + (cos(q_roll)*cos(q_st_lA_est)*sin(q_pitch)*sin(q_st_h)*dq_st_h)/2 + (cos(q_st_h)*cos(q_st_lA_est)*sin(q_pitch)*sin(q_roll)*dq_st_h)/2 + (cos(q_roll)*cos(q_st_lB_est)*sin(q_pitch)*sin(q_st_h)*dq_st_h)/2 + (cos(q_st_h)*cos(q_st_lB_est)*sin(q_pitch)*sin(q_roll)*dq_st_h)/2 + (cos(q_roll)*cos(q_st_h)*sin(q_pitch)*sin(q_st_lA_est)*dq_st_lA_est)/2 + (cos(q_roll)*cos(q_st_h)*sin(q_pitch)*sin(q_st_lB_est)*dq_st_lB_est)/2 - l_st_h*cos(q_pitch)*cos(q_roll)*sin(q_st_h)*dq_pitch - l_st_h*cos(q_pitch)*cos(q_st_h)*sin(q_roll)*dq_pitch - l_st_h*cos(q_roll)*cos(q_st_h)*sin(q_pitch)*dq_roll - l_st_h*cos(q_roll)*cos(q_st_h)*sin(q_pitch)*dq_st_h - (sin(q_pitch)*sin(q_roll)*sin(q_st_h)*sin(q_st_lA_est)*dq_st_lA_est)/2 - (sin(q_pitch)*sin(q_roll)*sin(q_st_h)*sin(q_st_lB_est)*dq_st_lB_est)/2 + l_st_h*sin(q_pitch)*sin(q_roll)*sin(q_st_h)*dq_roll + l_st_h*sin(q_pitch)*sin(q_roll)*sin(q_st_h)*dq_st_h; */
      /*  			obj.dx = (sin(q_pitch_leg)*sin(q_st_lA)*dq_pitch_leg)/2 - (cos(q_pitch_leg)*cos(q_st_lB)*dq_st_lB)/2 - (cos(q_pitch_leg)*cos(q_st_lA)*dq_st_lA)/2 + (sin(q_pitch_leg)*sin(q_st_lB)*dq_pitch_leg)/2 - obj.x_offset*sin(q_pitch_leg)*dq_pitch_leg + obj.z_offset*cos(q_pitch_leg)*cos(q_roll)*dq_pitch_leg + obj.y_offset*cos(q_pitch_leg)*sin(q_roll)*dq_pitch_leg + obj.y_offset*cos(q_roll)*sin(q_pitch_leg)*dq_roll - obj.z_offset*sin(q_pitch_leg)*sin(q_roll)*dq_roll - (cos(q_pitch_leg)*cos(q_roll)*cos(q_st_h)*cos(q_st_lA)*dq_pitch_leg)/2 - (cos(q_pitch_leg)*cos(q_roll)*cos(q_st_h)*cos(q_st_lB)*dq_pitch_leg)/2 + (cos(q_pitch_leg)*cos(q_st_lA)*sin(q_roll)*sin(q_st_h)*dq_pitch_leg)/2 + (cos(q_pitch_leg)*cos(q_st_lB)*sin(q_roll)*sin(q_st_h)*dq_pitch_leg)/2 + (cos(q_roll)*cos(q_st_lA)*sin(q_pitch_leg)*sin(q_st_h)*dq_roll)/2 + (cos(q_st_h)*cos(q_st_lA)*sin(q_pitch_leg)*sin(q_roll)*dq_roll)/2 + (cos(q_roll)*cos(q_st_lB)*sin(q_pitch_leg)*sin(q_st_h)*dq_roll)/2 + (cos(q_st_h)*cos(q_st_lB)*sin(q_pitch_leg)*sin(q_roll)*dq_roll)/2 + (cos(q_roll)*cos(q_st_lA)*sin(q_pitch_leg)*sin(q_st_h)*dq_st_h)/2 + (cos(q_st_h)*cos(q_st_lA)*sin(q_pitch_leg)*sin(q_roll)*dq_st_h)/2 + (cos(q_roll)*cos(q_st_lB)*sin(q_pitch_leg)*sin(q_st_h)*dq_st_h)/2 + (cos(q_st_h)*cos(q_st_lB)*sin(q_pitch_leg)*sin(q_roll)*dq_st_h)/2 + (cos(q_roll)*cos(q_st_h)*sin(q_pitch_leg)*sin(q_st_lA)*dq_st_lA)/2 + (cos(q_roll)*cos(q_st_h)*sin(q_pitch_leg)*sin(q_st_lB)*dq_st_lB)/2 - l_st_h*cos(q_pitch_leg)*cos(q_roll)*sin(q_st_h)*dq_pitch_leg - l_st_h*cos(q_pitch_leg)*cos(q_st_h)*sin(q_roll)*dq_pitch_leg - l_st_h*cos(q_roll)*cos(q_st_h)*sin(q_pitch_leg)*dq_roll - l_st_h*cos(q_roll)*cos(q_st_h)*sin(q_pitch_leg)*dq_st_h - (sin(q_pitch_leg)*sin(q_roll)*sin(q_st_h)*sin(q_st_lA)*dq_st_lA)/2 - (sin(q_pitch_leg)*sin(q_roll)*sin(q_st_h)*sin(q_st_lB)*dq_st_lB)/2 + l_st_h*sin(q_pitch_leg)*sin(q_roll)*sin(q_st_h)*dq_roll + l_st_h*sin(q_pitch_leg)*sin(q_roll)*sin(q_st_h)*dq_st_h; */
      /*  Full Derivation */
      /*  			obj.dy = l_st_h*cos(q_roll)*sin(q_st_h)*dq_roll - obj.y_offset*sin(q_roll)*dq_roll - (cos(q_st_lA)*sin(q_roll)*sin(q_st_h)*dq_roll)/2 - (cos(q_st_lB)*sin(q_roll)*sin(q_st_h)*dq_roll)/2 - (cos(q_st_lA)*sin(q_roll)*sin(q_st_h)*dq_st_h)/2 - (cos(q_st_lB)*sin(q_roll)*sin(q_st_h)*dq_st_h)/2 - (cos(q_roll)*sin(q_st_h)*sin(q_st_lA)*dq_st_lA)/2 - (cos(q_st_h)*sin(q_roll)*sin(q_st_lA)*dq_st_lA)/2 - (cos(q_roll)*sin(q_st_h)*sin(q_st_lB)*dq_st_lB)/2 - (cos(q_st_h)*sin(q_roll)*sin(q_st_lB)*dq_st_lB)/2 - obj.z_offset*cos(q_roll)*dq_roll + l_st_h*cos(q_st_h)*sin(q_roll)*dq_roll + l_st_h*cos(q_roll)*sin(q_st_h)*dq_st_h + l_st_h*cos(q_st_h)*sin(q_roll)*dq_st_h + (cos(q_roll)*cos(q_st_h)*cos(q_st_lA)*dq_roll)/2 + (cos(q_roll)*cos(q_st_h)*cos(q_st_lB)*dq_roll)/2 + (cos(q_roll)*cos(q_st_h)*cos(q_st_lA)*dq_st_h)/2 + (cos(q_roll)*cos(q_st_h)*cos(q_st_lB)*dq_st_h)/2; */
      /*  No torso offset */
      /*  Estimated GRF */
      /*  Scaling factors representing a normalized vertical GRF */
      /*  Compute smoothing factor based on confidence leg is on the ground */
      /*  Filter velocity estimate, ignoring bad (large) values */
      /*  Update CoM position estimates */
      /*  Step duration */
      /*  Define a time variant parameter normalized between 0 and 1 */
      /*  Compute state phase variable */
      /*  			dxSet = -1.2:0.4:1.2;   %RoughtGround_LK_18-Mar-2016 */
      /*  			hSet = -0.1:0.1:0.1; */
      /*  			dxSet = 1.6:-0.4:-1.6;   %NormalData_LK_12-Apr-2016 */
      /* NormalData2_LK_12-Apr-2016 */
      /*  interpolate Bezier */
      /*        alpha_L = scaleFactor(obj.dx_est, 0.4, 0.8)*50*(abs(obj.dx_est_last-obj.dx_est)<0.15); */
      /*  			alpha_L = scaleFactor(abs((obj.dx_est + obj.dx_tgt)/2), 0.4, 1)*10*(abs(obj.dx_est - obj.dx_tgt)<0.4); */
      /*  Phase Estimator */
      /*  Compute Swing Leg Target Positions -------------------------------- */
      /*  Target swing leg foot placement policy */
      /*  Smooth clamp target swing leg foot placement */
      /*  Target swing leg foot placement policy */
      /*  Smooth clamp target swing leg foot placement */
      /*  			y_sw_tgt = atans(y_sw_tgt, 1, 0.5); */
      /*  Target swing leg cartesian position and velocity */
      /*  Target swing hip angle and velocity */
      /*                    q_sw_h_tgt = real(asin((y_sw + y_t)/L) - asin(l_sw_h/L) - q_roll); */
      /*        dq_sw_h_tgt = real((dy_sw + dy_t)/(L *sqrt(1 - (y_sw + y_t)^2/L^2)) - dq_roll); */
      /*  Clamp swing hip angles to avoid mechanical limits */
      /*  for MARLO */
      /*  Compute Control Inputs ------------------------------------------- */
      /*  Hip feed-forward torque for gravity compensation */
      /*  Swing leg hip PD controller */
      /*  TODO: remove s scaling when trajectory is re-enabled */
      /*  Torso stabilization PD controller scaled based on leg force */
      /*  Tracking */
      /*  Test hip gravity compensation */
      /*  DDA controller -------------------------------------------------- */
      /*  Swing leg position */
      /*  just feedforward */
      /*  Define gait select input */
      /*  Left */
      /*  			if obj.contactGround == 1 */
      /*  				hEnd = -hInput; */
      /*  			else */
      /*  				hEnd = -0.01; */
      /*  			end */
      /*  			if (footHeight<=hEnd && s>0.6) */
      /*  				hEnd = footHeight; */
      /*  			end */
      /*  if obj.contactGround == 0 */
      /*  			hEnd = -0.01; */
      /*  			hInput = 0; */
      /*  else */
      /*  						hEnd = -0.03; */
      /*  						hInput = -0.03; */
      /*  end */
      /*  			if obj.tauPhase>=0.9 */
      /*  				hEnd = hEnd - 0.2*(obj.tauPhase - 0.9); */
      /*  			end */
      /*  			hInput = 0; */
      /*  			hEnd = 0 - 0.01*0; */
      /*  Interpolate gaits */
      /*  			HAlpha_norm = interpolateRoughGround(hAlphaSet,dxSet,dxInput, hSet, 0); */
      /*  			HAlpha = HAlpha_norm; */
      /*  feedback + offset, control the speed */
      /*  				HAlpha(2,:) = HAlpha(2,:) + q_sw_offset + q_pitch_leg*(1-s_sw); % feedback + offset, control the speed */
      /*  hybrid invariant */
      /*  Double Support Hack */
      /*  				s_swKnee = 0*(s<doubleRate)+(s-doubleRate)*(1/(1-doubleRate))*(s>=doubleRate); */
      /*  				ds_swKnee = 0*(s<doubleRate)+ds*(1/(1-doubleRate))*(s>=doubleRate); */
      /*  				hd_swKnee = bezierval(HAlpha,s_swKnee); */
      /*  				dhd_swKnee = bezierval(diff(HAlpha,[],2),s_swKnee)*5*ds_swKnee; */
      /*  				hd(4) = hd_swKnee(4); */
      /*  				dhd(4) = dhd_swKnee(4); */
      /*  				HAlpha(4,2) = HAlpha(4,2) - 20*pi/180; */
      /*  				u_sw_KA = u_sw_KA + 200*cos(pi/2*s/doubleRate)*(s<doubleRate);				 */
      /*  Yaw Control */
      /*  					HAlpha(2,5) = HAlpha(2,5) - clamp((obj.dq_yaw_tgt)*obj.kd_yaw, -5*pi/180, 5*pi/180); */
      /*  					HAlpha(2,6) = HAlpha(2,6) - clamp((obj.dq_yaw_tgt)*obj.kd_yaw, -5*pi/180, 5*pi/180); */
      /*  					HAlpha(2,5) = HAlpha(2,5) + clamp((obj.dq_yaw_tgt)*obj.kd_yaw, -5*pi/180, 5*pi/180); */
      /*  					HAlpha(2,6) = HAlpha(2,6) + clamp((obj.dq_yaw_tgt)*obj.kd_yaw, -5*pi/180, 5*pi/180); */
      /*  Desired leg trajectory */
      /*  Extensive Trajectory */
      /*  				hd(4) = hd(4) - min(40*pi/180*(obj.tauPhase - 1), 12*pi/180); */
      /*  				dhd(4) = dhd(4) - 40*pi/180*ds*(obj.tauPhase<1.2); */
      /*  Swing leg placement */
      /*  Neutralize stance leg */
      /*  			hd(1) = hd(1)*(1-s) + (2*pi - (q_st_lA+q_st_lB)/2)*s; */
      /*  			dhd(1) = dhd(1)*(1-s); */
      /*  Torso control override */
      /*  			hd(1) = hd(1)*(1-s_st) + (2*pi - mean([q_st_lA q_st_lB]) - q_pitch)*s_st; */
      /*  			dhd(1) = dhd(1)*(1-s_st) + ( - mean([dq_st_lA dq_st_lB]) - dq_pitch)*s_st; */
      /*  % 			dhd(1) = dhd(1)*(1-s_st) + (  - dq_pitch)*s_st; */
      /*  			hd(2) = hd(2)*(1-s_sw) + (2*pi - mean([q_sw_lA q_sw_lB]) - q_pitch)*s_sw; */
      /*  			dhd(2) = dhd(2)*(1-s_sw) + ( - mean([dq_sw_lA dq_sw_lB]) - dq_pitch)*s_sw; */
      /*  % 			dhd(2) = dhd(2)*(1-s_sw) + (  - dq_pitch)*s_sw; */
      /*  			dhd(1) = dhd(1) + (  - dq_pitch)*s_st; */
      /*  			dhd(2) = dhd(2) + (  - dq_pitch)*s_sw; */
      /*  Virtual knee damping */
      /*  Convert to link coordinate */
      /*  Set leg to constant */
      /*  BMI output chosen */
      /*  			H(3,end-1) = -1/2*5; */
      /*  			H(4,end-1) = 1/2*5; */
      /*  			H(3,end-1) = -1/2*5; */
      /*  			H(4,end-1) = 1/2*5; */
      /*  			if (obj.stanceLeg == -1 && q_sw_h < 0) ||... */
      /*  			   (obj.stanceLeg == 1 && q_sw_h > 0) */
      /*  				H(3,end) = -1/2*100*abs(q_sw_h)*s; */
      /*  				H(4,end) = 1/2*100*abs(q_sw_h)*s; */
      /*  			end */
      /*  Torque output		 */
      /*  QP decision for saturation st GRF */
      /*  % 			if s>0.2 && s<0.8 && s_st > 0 */
      /*  			if s_st > 0 */
      /*  				u_st_KA = max(u_st_A-u_st_B,50); */
      /*  			end */
      /*  penalize leg angle */
      /*  QP decision for saturation sw LA, LK */
      /*  Compute actual leg states */
      /*  Store signals in object for logging */
      /*  			obj.output = [hInput;hEnd]; */
      /*  Set commanded torque vector */
      /*  Left */
      /*  Right */
      /*  if */
      /*  Output */
      /*  Reset guard ----------------------------------------------------- */
      /*        if s >= 1 */
      /*        if (((s >= 0.5 && s_sw >= 1)  || (s >= 1)) && obj.isTest11 == 0) || (s >= 1 && obj.isTest11 == 1) */
      /*        if s >= 0.5 && s_sw >= 1 */
      /*  Save last step information */
      /*  Stair high believe update */
      /*  Left */
      /*  Swap leg, reset time */
      /*  userStep */
      /* PARSEPS3CONTROLLER */
      /*  Parse D-Pad for velocity trimming */
      if (obj_3->ps3.up.isPressed) {
        /*  Trim forward */
        obj_3->x_offset -= 0.005;
      } else if (obj_3->ps3.right.isPressed) {
        /*  Trim right */
        obj_3->y_offset += 0.005;
      } else if (obj_3->ps3.down.isPressed) {
        /*  Trim backward */
        obj_3->x_offset += 0.005;
      } else {
        if (obj_3->ps3.left.isPressed) {
          /*  Trim left */
          obj_3->y_offset -= 0.005;
        }
      }

      /*  if */
      /*  Parse up trigger to do yaw control */
      if (obj_3->ps3.l1.isPressed) {
        obj_3->q_yaw_tgt += 0.087266462599716474;
      } else {
        if (obj_3->ps3.r1.isPressed) {
          obj_3->q_yaw_tgt -= 0.087266462599716474;
        }
      }

      /*  Parse gait modes */
      if (obj_3->ps3.cross.isPressed) {
        obj_3->gaitMode = Cross;
      } else if (obj_3->ps3.circle.isPressed) {
        obj_3->gaitMode = Circle;
      } else if (obj_3->ps3.triangle.isPressed) {
        obj_3->gaitMode = Triangle;
      } else {
        if (obj_3->ps3.square.isPressed) {
          obj_3->gaitMode = Square;
        }
      }

      /*  if */
      /*  Parse select button for reset home */
      if (obj_3->ps3.select.isPressed) {
        obj_3->x_est = 0.0;
        obj_3->y_est = 0.0;
        obj_3->yawReset = u0[11];
      }

      /*  if */
      /*  Parse left joystick data for X Velocity */
      t30 = obj_3->ps3.leftStickY;

      /* CLAMP Clamp value between two bounds. */
      /*  */
      /*  Copyright 2015 Mikhail S. Jones */
      /*  Find which limit is min and max */
      a_min = -1.0;

      /*  Clamp value between limits */
      if (t30 <= 1.0) {
        t99 = t30;
      } else {
        t99 = 1.0;
      }

      if (t99 >= -1.0) {
        CurrentYaw = t99;
      } else {
        CurrentYaw = -1.0;
      }

      /*  clamp */
      /*  Parse right joystick data for Y Velocity */
      t30 = obj_3->ps3.rightStickX;

      /* CLAMP Clamp value between two bounds. */
      /*  */
      /*  Copyright 2015 Mikhail S. Jones */
      /*  Find which limit is min and max */
      /*  Clamp value between limits */
      if (t30 <= 1.0) {
        t99 = t30;
      } else {
        t99 = 1.0;
      }

      if (t99 >= -1.0) {
        a21 = t99;
      } else {
        a21 = -1.0;
      }

      /*  clamp */
      /*  Parse right joystick data for Y Velocity */
      t30 = obj_3->ps3.rightStickY;

      /* CLAMP Clamp value between two bounds. */
      /*  */
      /*  Copyright 2015 Mikhail S. Jones */
      /*  Find which limit is min and max */
      /*  Clamp value between limits */
      if (t30 <= 1.0) {
        t99 = t30;
      } else {
        t99 = 1.0;
      }

      if (t99 >= -1.0) {
        a_min = t99;
      }

      /*  clamp */
      obj_3->dq_yaw_tgt = a_min;

      /*  Set gait mode specific tweaks */
      /*  use PS3 controller */
      switch (obj_3->gaitMode) {
       case Cross:
        /*  Hold position mode */
        x_re = obj_3->q_yaw;
        x_re = cos(x_re);
        CalOffset_idx_1 = obj_3->q_yaw;
        CalOffset_idx_1 = sin(CalOffset_idx_1);
        t30 = (x_re * obj_3->x_est + CalOffset_idx_1 * obj_3->y_est) * -0.2;

        /* CLAMP Clamp value between two bounds. */
        /*  */
        /*  Copyright 2015 Mikhail S. Jones */
        /*  Find which limit is min and max */
        /*  Clamp value between limits */
        if (t30 <= 0.4) {
          t99 = t30;
        } else {
          t99 = 0.4;
        }

        if (t99 >= -0.4) {
          CurrentYaw = t99;
        } else {
          CurrentYaw = -0.4;
        }

        /*  clamp */
        x_re = obj_3->q_yaw;
        x_re = cos(x_re);
        CalOffset_idx_1 = obj_3->q_yaw;
        CalOffset_idx_1 = sin(CalOffset_idx_1);
        t30 = (x_re * obj_3->y_est - CalOffset_idx_1 * obj_3->x_est) * -0.2;

        /* CLAMP Clamp value between two bounds. */
        /*  */
        /*  Copyright 2015 Mikhail S. Jones */
        /*  Find which limit is min and max */
        /*  Clamp value between limits */
        if (t30 <= 0.2) {
          t99 = t30;
        } else {
          t99 = 0.2;
        }

        if (t99 >= -0.2) {
          a21 = t99;
        } else {
          a21 = -0.2;
        }

        /*  clamp */
        break;

       case Circle:
        /*  Robust stand/walk mode */
        CurrentYaw *= 0.8;
        a21 *= 0.4;
        break;

       case Triangle:
        /*  Fast walk/run mode */
        CurrentYaw *= 0.2;
        a21 *= 0.2;
        break;

       default:
        /*  GaitMode.Square */
        /*  Auto hold in place mode */
        x_re = obj_3->ps3.leftStickY;
        y_5 = fabs(x_re);
        guard1 = false;
        if (y_5 > 0.1) {
          guard1 = true;
        } else {
          x_re = obj_3->ps3.rightStickX;
          y_5 = fabs(x_re);
          if (y_5 > 0.1) {
            guard1 = true;
          } else {
            x_re = obj_3->dx_tgt;
            y_5 = fabs(x_re);
            if (y_5 > 0.1) {
              /*                 obj.PressTime = obj.PressTime; % hold current time */
            } else {
              x_re = obj_3->dy_tgt;
              y_5 = fabs(x_re);
              if (y_5 > 0.1) {
                /*                 obj.PressTime = obj.PressTime; % hold current time */
              } else {
                obj_3->PressTime = 0.0;
              }
            }
          }
        }

        if (guard1 == true) {
          obj_3->PressTime += 0.0005;
        }

        x_re = obj_3->dx_tgt;
        y_5 = fabs(x_re);
        if ((y_5 > 0.1) && (obj_3->PressTime > 1.0)) {
          obj_3->x_est = 0.0;
        }

        x_re = obj_3->dy_tgt;
        y_5 = fabs(x_re);
        if ((y_5 > 0.1) && (obj_3->PressTime > 1.0)) {
          obj_3->y_est = 0.0;
        }

        x_re = obj_3->ps3.leftStickY;
        y_5 = fabs(x_re);
        if ((y_5 > 0.1) && (obj_3->PressTime > 1.0)) {
          CurrentYaw *= 0.6;
        } else {
          x_re = obj_3->q_yaw;
          x_re = cos(x_re);
          CalOffset_idx_1 = obj_3->q_yaw;
          CalOffset_idx_1 = sin(CalOffset_idx_1);
          t30 = (x_re * obj_3->x_est + CalOffset_idx_1 * obj_3->y_est) * -0.4;

          /* CLAMP Clamp value between two bounds. */
          /*  */
          /*  Copyright 2015 Mikhail S. Jones */
          /*  Find which limit is min and max */
          /*  Clamp value between limits */
          if (t30 <= 0.4) {
            t99 = t30;
          } else {
            t99 = 0.4;
          }

          if (t99 >= -0.4) {
            CurrentYaw = t99;
          } else {
            CurrentYaw = -0.4;
          }

          /*  clamp */
        }

        x_re = obj_3->ps3.rightStickX;
        y_5 = fabs(x_re);
        if ((y_5 > 0.1) && (obj_3->PressTime > 1.0)) {
          a21 *= 0.2;
        } else {
          x_re = obj_3->q_yaw;
          x_re = cos(x_re);
          CalOffset_idx_1 = obj_3->q_yaw;
          CalOffset_idx_1 = sin(CalOffset_idx_1);
          t30 = (x_re * obj_3->y_est - CalOffset_idx_1 * obj_3->x_est) * -0.2;

          /* CLAMP Clamp value between two bounds. */
          /*  */
          /*  Copyright 2015 Mikhail S. Jones */
          /*  Find which limit is min and max */
          /*  Clamp value between limits */
          if (t30 <= 0.2) {
            t99 = t30;
          } else {
            t99 = 0.2;
          }

          if (t99 >= -0.2) {
            a21 = t99;
          } else {
            a21 = -0.2;
          }

          /*  clamp */
        }
        break;
      }

      /*  switch */
      /*        % Simulation overrides */
      /*  Parse right lower trigger for turbo mode */
      if (obj_3->ps3.r2.value) {
        CurrentYaw *= 2.0;
      }

      /*  if */
      /*  Parse left lower trigger for auto speed regulation mode */
      if (obj_3->ps3.l2.value) {
        x_re = obj_3->dy_est_avg;
        y_5 = fabs(x_re);
        if (y_5 >= 0.05) {
          CurrentYaw /= 2.0;
        }

        /*  if */
      }

      /*  if */
      /*  Filter target X velocity command */
      obj_3->dx_tgt += (CurrentYaw - obj_3->dx_tgt) * 0.00024993751562109469;

      /*  Filter target Y velocity command */
      obj_3->dy_tgt += (a21 - obj_3->dy_tgt) * 0.00099900099900099922;
      if (obj_0->stanceLeg == 1.0) {
        q_st_mA = u0[7];
        dq_st_mA = u1[7];
        q_st_mB = u0[5];
        dq_st_mB = u1[5];
        q_st_lA = u0[6];
        dq_st_lA = u1[6];
        q_st_lB = u0[4];
        dq_st_lB = u1[4];
        q_st_h = u0[9];
        dq_st_h = u1[9];
        q_sw_mA = u0[3];
        dq_sw_mA = u1[3];
        q_sw_mB = u0[1];
        dq_sw_mB = u1[1];
        q_sw_lA = u0[2];
        dq_sw_lA = u1[2];
        q_sw_lB = u0[0];
        dq_sw_lB = u1[0];
        q_sw_h = u0[8];
        dq_sw_h = u1[8];
      } else {
        q_st_mA = u0[3];
        dq_st_mA = u1[3];
        q_st_mB = u0[1];
        dq_st_mB = u1[1];
        q_st_lA = u0[2];
        dq_st_lA = u1[2];
        q_st_lB = u0[0];
        dq_st_lB = u1[0];
        q_st_h = u0[8];
        dq_st_h = u1[8];
        q_sw_mA = u0[7];
        dq_sw_mA = u1[7];
        q_sw_mB = u0[5];
        dq_sw_mB = u1[5];
        q_sw_lA = u0[6];
        dq_sw_lA = u1[6];
        q_sw_lB = u0[4];
        dq_sw_lB = u1[4];
        q_sw_h = u0[9];
        dq_sw_h = u1[9];
      }

      q_roll = u0[10];
      dq_roll = u1[10];
      obj_0->q_yaw = u0[11] - obj_0->yawReset;
      obj_0->dq_yaw = u1[11];
      q_pitch = u0[12];
      dq_pitch = u1[12];
      if (obj_0->stanceLeg == 1.0) {
        NormalizedCountPrev[0] = obj_0->q_yaw;
        NormalizedCountPrev[1] = q_roll;
        NormalizedCountPrev[2] = q_pitch;
        NormalizedCountPrev[3] = q_st_lA;
        NormalizedCountPrev[4] = q_st_lB;
        NormalizedCountPrev[5] = q_st_h;
        NormalizedCountPrev[6] = q_sw_lA;
        NormalizedCountPrev[7] = q_sw_lB;
        NormalizedCountPrev[8] = -q_sw_h;
        tmp_8[0] = 0.0;
        tmp_8[1] = 0.0;
        tmp_8[2] = 6.2831853071795862;
        tmp_8[3] = 6.2831853071795862;
        tmp_8[4] = 6.2831853071795862;
        tmp_8[5] = 0.0;
        tmp_8[6] = 6.2831853071795862;
        tmp_8[7] = 6.2831853071795862;
        tmp_8[8] = 0.0;
        for (rtemp = 0; rtemp < 9; rtemp++) {
          HalfMaxTicks_idx_1 = NormalizedCountPrev[rtemp];
          HalfMaxTicks_idx_1 = tmp_8[rtemp] - HalfMaxTicks_idx_1;
          NormalizedCountPrev[rtemp] = HalfMaxTicks_idx_1;
        }
      } else {
        NormalizedCountPrev[0] = obj_0->q_yaw;
        NormalizedCountPrev[1] = -q_roll;
        NormalizedCountPrev[2] = q_pitch;
        NormalizedCountPrev[3] = q_st_lA;
        NormalizedCountPrev[4] = q_st_lB;
        NormalizedCountPrev[5] = -q_st_h;
        NormalizedCountPrev[6] = q_sw_lA;
        NormalizedCountPrev[7] = q_sw_lB;
        NormalizedCountPrev[8] = q_sw_h;
        tmp_8[0] = 0.0;
        tmp_8[1] = 0.0;
        tmp_8[2] = 6.2831853071795862;
        tmp_8[3] = 6.2831853071795862;
        tmp_8[4] = 6.2831853071795862;
        tmp_8[5] = 0.0;
        tmp_8[6] = 6.2831853071795862;
        tmp_8[7] = 6.2831853071795862;
        tmp_8[8] = 0.0;
        for (rtemp = 0; rtemp < 9; rtemp++) {
          HalfMaxTicks_idx_1 = NormalizedCountPrev[rtemp];
          HalfMaxTicks_idx_1 = tmp_8[rtemp] - HalfMaxTicks_idx_1;
          NormalizedCountPrev[rtemp] = HalfMaxTicks_idx_1;
        }
      }

      if ((obj_0->isSim == 0) && (obj_0->stanceLeg == -1.0)) {
        NormalizedCountPrev[8] -= 0.017453292519943295;

        /* MYFILE */
        /*     FOOTHEIGHT = MYFILE(L2,L4,W,Q1L,Q2L,Q3L,Q1R,Q2R,Q3R,QXT,QYT) */
        /*     This function was generated by the Symbolic Math Toolbox version 6.1. */
        /*     12-Apr-2016 16:59:29 */
        CalOffset_idx_0 = NormalizedCountPrev[1];
        HalfMaxTicks_idx_1 = NormalizedCountPrev[2];
        u_Link_idx_2 = NormalizedCountPrev[3];
        u_Link_idx_3 = NormalizedCountPrev[4];
        q3R = NormalizedCountPrev[5];
        u_Link_idx_0 = NormalizedCountPrev[6];
        u_Link_idx_1 = NormalizedCountPrev[7];
        maxval = NormalizedCountPrev[8];
        t2 = CalOffset_idx_0;
        t2 = sin(t2);
        t3 = HalfMaxTicks_idx_1;
        t3 = cos(t3);
        CalOffset_idx_0 = cos(CalOffset_idx_0);
        t5 = maxval;
        t5 = sin(t5);
        maxval = cos(maxval);
        n = t2 * t5;
        CurrentYaw = t3 * CalOffset_idx_0 * maxval;
        a21 = n + CurrentYaw;
        HalfMaxTicks_idx_1 = sin(HalfMaxTicks_idx_1);
        t11 = q3R;
        t11 = sin(t11);
        q3R = cos(q3R);
        CurrentYaw = t2 * t11;
        CurrentYaw -= t3 * CalOffset_idx_0 * q3R;
        x_re = u_Link_idx_1;
        x_re = cos(x_re);
        u_Link_idx_1 = sin(u_Link_idx_1);
        CalOffset_idx_1 = u_Link_idx_0;
        CalOffset_idx_1 = cos(CalOffset_idx_1);
        u_Link_idx_0 = sin(u_Link_idx_0);
        uDamping_idx_2 = u_Link_idx_3;
        uDamping_idx_2 = cos(uDamping_idx_2);
        u_Link_idx_3 = sin(u_Link_idx_3);
        uDamping_idx_3 = u_Link_idx_2;
        uDamping_idx_3 = cos(uDamping_idx_3);
        u_Link_idx_2 = sin(u_Link_idx_2);
        footHeight = (((((t2 * maxval - t3 * CalOffset_idx_0 * t5) * 0.1834 +
                         (t3 * CalOffset_idx_0 * t11 + t2 * q3R) * 0.1834) +
                        (a21 * x_re - CalOffset_idx_0 * HalfMaxTicks_idx_1 *
                         u_Link_idx_1) * 0.5) + (a21 * CalOffset_idx_1 -
          CalOffset_idx_0 * HalfMaxTicks_idx_1 * u_Link_idx_0) * 0.53) +
                      (CalOffset_idx_0 * HalfMaxTicks_idx_1 * u_Link_idx_3 +
                       CurrentYaw * uDamping_idx_2) * 0.5) + (CalOffset_idx_0 *
          HalfMaxTicks_idx_1 * u_Link_idx_2 + CurrentYaw * uDamping_idx_3) *
          0.53;
        footHeight -= 0.015;
      } else if ((obj_0->isSim == 0) && (obj_0->stanceLeg == 1.0)) {
        NormalizedCountPrev[5] -= 0.017453292519943295;

        /* MYFILE */
        /*     FOOTHEIGHT = MYFILE(L2,L4,W,Q1L,Q2L,Q3L,Q1R,Q2R,Q3R,QXT,QYT) */
        /*     This function was generated by the Symbolic Math Toolbox version 6.1. */
        /*     12-Apr-2016 16:59:29 */
        CalOffset_idx_0 = NormalizedCountPrev[1];
        HalfMaxTicks_idx_1 = NormalizedCountPrev[2];
        u_Link_idx_2 = NormalizedCountPrev[3];
        u_Link_idx_3 = NormalizedCountPrev[4];
        q3R = NormalizedCountPrev[5];
        u_Link_idx_0 = NormalizedCountPrev[6];
        u_Link_idx_1 = NormalizedCountPrev[7];
        maxval = NormalizedCountPrev[8];
        t2 = CalOffset_idx_0;
        t2 = sin(t2);
        t3 = HalfMaxTicks_idx_1;
        t3 = cos(t3);
        CalOffset_idx_0 = cos(CalOffset_idx_0);
        t5 = maxval;
        t5 = sin(t5);
        maxval = cos(maxval);
        n = t2 * t5;
        CurrentYaw = t3 * CalOffset_idx_0 * maxval;
        a21 = n + CurrentYaw;
        HalfMaxTicks_idx_1 = sin(HalfMaxTicks_idx_1);
        t11 = q3R;
        t11 = sin(t11);
        q3R = cos(q3R);
        CurrentYaw = t2 * t11;
        CurrentYaw -= t3 * CalOffset_idx_0 * q3R;
        x_re = u_Link_idx_1;
        x_re = cos(x_re);
        u_Link_idx_1 = sin(u_Link_idx_1);
        CalOffset_idx_1 = u_Link_idx_0;
        CalOffset_idx_1 = cos(CalOffset_idx_1);
        u_Link_idx_0 = sin(u_Link_idx_0);
        uDamping_idx_2 = u_Link_idx_3;
        uDamping_idx_2 = cos(uDamping_idx_2);
        u_Link_idx_3 = sin(u_Link_idx_3);
        uDamping_idx_3 = u_Link_idx_2;
        uDamping_idx_3 = cos(uDamping_idx_3);
        u_Link_idx_2 = sin(u_Link_idx_2);
        footHeight = (((((t2 * maxval - t3 * CalOffset_idx_0 * t5) * 0.1834 +
                         (t3 * CalOffset_idx_0 * t11 + t2 * q3R) * 0.1834) +
                        (a21 * x_re - CalOffset_idx_0 * HalfMaxTicks_idx_1 *
                         u_Link_idx_1) * 0.5) + (a21 * CalOffset_idx_1 -
          CalOffset_idx_0 * HalfMaxTicks_idx_1 * u_Link_idx_0) * 0.53) +
                      (CalOffset_idx_0 * HalfMaxTicks_idx_1 * u_Link_idx_3 +
                       CurrentYaw * uDamping_idx_2) * 0.5) + (CalOffset_idx_0 *
          HalfMaxTicks_idx_1 * u_Link_idx_2 + CurrentYaw * uDamping_idx_3) *
          0.53;
        footHeight += 0.012;
      } else {
        /*  Generated by writeOptimizedFunctions (18 Jan 2016 18:49:42) */
        CalOffset_idx_0 = NormalizedCountPrev[1];
        HalfMaxTicks_idx_1 = NormalizedCountPrev[2];
        u_Link_idx_2 = NormalizedCountPrev[3];
        u_Link_idx_3 = NormalizedCountPrev[4];
        q3R = NormalizedCountPrev[5];
        u_Link_idx_0 = NormalizedCountPrev[6];
        u_Link_idx_1 = NormalizedCountPrev[7];
        maxval = NormalizedCountPrev[8];
        t2 = CalOffset_idx_0;
        t2 = cos(t2);
        a_min = q3R;
        a_min = cos(a_min);
        CurrentYaw = HalfMaxTicks_idx_1;
        CurrentYaw = sin(CurrentYaw);
        CalOffset_idx_0 = sin(CalOffset_idx_0);
        HalfMaxTicks_idx_1 = cos(HalfMaxTicks_idx_1);
        q3R = sin(q3R);
        t21 = u_Link_idx_3;
        t21 = sin(t21);
        u_Link_idx_3 = cos(u_Link_idx_3);
        t30 = u_Link_idx_2;
        t30 = sin(t30);
        u_Link_idx_2 = cos(u_Link_idx_2);
        t36 = maxval;
        t36 = cos(t36);
        maxval = sin(maxval);
        t42 = u_Link_idx_1;
        t42 = sin(t42);
        u_Link_idx_1 = cos(u_Link_idx_1);
        t51 = u_Link_idx_0;
        t51 = sin(t51);
        u_Link_idx_0 = cos(u_Link_idx_0);
        t99 = t2 * HalfMaxTicks_idx_1;
        CurrentYaw *= t2;
        a21 = -CalOffset_idx_0 * q3R + t99 * a_min;
        a_max = CalOffset_idx_0 * maxval + t99 * t36;
        n = ((((((((((0.1834 * CalOffset_idx_0 * a_min + 0.1834 * t99 * q3R) +
                     0.5 * CurrentYaw * t21) - 0.5 * a21 * u_Link_idx_3) + 0.55 *
                   CurrentYaw * t30) - 0.55 * a21 * u_Link_idx_2) + 0.1834 *
                 CalOffset_idx_0 * t36) - 0.1834 * t99 * maxval) - 0.5 *
               CurrentYaw * t42) + 0.5 * a_max * u_Link_idx_1) - 0.55 *
             CurrentYaw * t51) + 0.55 * a_max * u_Link_idx_0;
        footHeight = n;
      }

      l_st_h = 0.1831 * obj_0->stanceLeg;
      l_sw_h = -0.1831 * obj_0->stanceLeg;
      x_re = q_pitch;
      x_re = cos(x_re);
      CalOffset_idx_1 = q_roll;
      CalOffset_idx_1 = cos(CalOffset_idx_1);
      uDamping_idx_2 = q_pitch;
      uDamping_idx_2 = sin(uDamping_idx_2);
      uDamping_idx_3 = q_pitch;
      uDamping_idx_3 = sin(uDamping_idx_3);
      t42 = q_roll;
      t42 = sin(t42);
      x_t = (obj_0->z_offset * CalOffset_idx_1 * uDamping_idx_2 +
             obj_0->x_offset * x_re) + obj_0->y_offset * uDamping_idx_3 * t42;
      x_re = q_roll;
      x_re = cos(x_re);
      CalOffset_idx_1 = q_roll;
      CalOffset_idx_1 = sin(CalOffset_idx_1);
      y_t = obj_0->y_offset * x_re - obj_0->z_offset * CalOffset_idx_1;
      x_re = q_pitch;
      x_re = sin(x_re);
      CalOffset_idx_1 = q_st_lA;
      CalOffset_idx_1 = sin(CalOffset_idx_1);
      t30 = x_re * CalOffset_idx_1 * dq_pitch;
      y_5 = t30 / 2.0;
      x_re = q_pitch;
      x_re = cos(x_re);
      CalOffset_idx_1 = q_st_lB;
      CalOffset_idx_1 = cos(CalOffset_idx_1);
      t30 = x_re * CalOffset_idx_1 * dq_st_lB;
      y_0 = t30 / 2.0;
      x_re = q_pitch;
      x_re = cos(x_re);
      CalOffset_idx_1 = q_st_lA;
      CalOffset_idx_1 = cos(CalOffset_idx_1);
      t30 = x_re * CalOffset_idx_1 * dq_st_lA;
      y_1 = t30 / 2.0;
      x_re = q_pitch;
      x_re = sin(x_re);
      CalOffset_idx_1 = q_st_lB;
      CalOffset_idx_1 = sin(CalOffset_idx_1);
      t30 = x_re * CalOffset_idx_1 * dq_pitch;
      y_2 = t30 / 2.0;
      x_re = q_pitch;
      x_re = sin(x_re);
      CalOffset_idx_1 = q_pitch;
      CalOffset_idx_1 = cos(CalOffset_idx_1);
      uDamping_idx_2 = q_roll;
      uDamping_idx_2 = cos(uDamping_idx_2);
      uDamping_idx_3 = q_pitch;
      uDamping_idx_3 = cos(uDamping_idx_3);
      t42 = q_roll;
      t42 = sin(t42);
      t51 = q_roll;
      t51 = cos(t51);
      maxval = q_pitch;
      maxval = sin(maxval);
      t11 = q_pitch;
      t11 = sin(t11);
      t3 = q_roll;
      t3 = sin(t3);
      t5 = q_pitch;
      t5 = cos(t5);
      HalfMaxTicks_idx_0 = q_roll;
      HalfMaxTicks_idx_0 = cos(HalfMaxTicks_idx_0);
      sum_term = q_st_h;
      sum_term = cos(sum_term);
      hd2 = q_st_lA;
      hd2 = cos(hd2);
      t30 = t5 * HalfMaxTicks_idx_0 * sum_term * hd2 * dq_pitch;
      y_3 = t30 / 2.0;
      t5 = q_pitch;
      t5 = cos(t5);
      HalfMaxTicks_idx_0 = q_roll;
      HalfMaxTicks_idx_0 = cos(HalfMaxTicks_idx_0);
      sum_term = q_st_h;
      sum_term = cos(sum_term);
      hd2 = q_st_lB;
      hd2 = cos(hd2);
      t30 = t5 * HalfMaxTicks_idx_0 * sum_term * hd2 * dq_pitch;
      y_4 = t30 / 2.0;
      t5 = q_pitch;
      t5 = cos(t5);
      HalfMaxTicks_idx_0 = q_st_lA;
      HalfMaxTicks_idx_0 = cos(HalfMaxTicks_idx_0);
      sum_term = q_roll;
      sum_term = sin(sum_term);
      hd2 = q_st_h;
      hd2 = sin(hd2);
      t30 = t5 * HalfMaxTicks_idx_0 * sum_term * hd2 * dq_pitch;
      alpha = t30 / 2.0;
      t5 = q_pitch;
      t5 = cos(t5);
      HalfMaxTicks_idx_0 = q_st_lB;
      HalfMaxTicks_idx_0 = cos(HalfMaxTicks_idx_0);
      sum_term = q_roll;
      sum_term = sin(sum_term);
      hd2 = q_st_h;
      hd2 = sin(hd2);
      t30 = t5 * HalfMaxTicks_idx_0 * sum_term * hd2 * dq_pitch;
      HalfMaxTicks_idx_1 = t30 / 2.0;
      t5 = q_roll;
      t5 = cos(t5);
      HalfMaxTicks_idx_0 = q_st_lA;
      HalfMaxTicks_idx_0 = cos(HalfMaxTicks_idx_0);
      sum_term = q_pitch;
      sum_term = sin(sum_term);
      hd2 = q_st_h;
      hd2 = sin(hd2);
      t30 = t5 * HalfMaxTicks_idx_0 * sum_term * hd2 * dq_roll;
      t2 = t30 / 2.0;
      t5 = q_st_h;
      t5 = cos(t5);
      HalfMaxTicks_idx_0 = q_st_lA;
      HalfMaxTicks_idx_0 = cos(HalfMaxTicks_idx_0);
      sum_term = q_pitch;
      sum_term = sin(sum_term);
      hd2 = q_roll;
      hd2 = sin(hd2);
      t30 = t5 * HalfMaxTicks_idx_0 * sum_term * hd2 * dq_roll;
      dxInput = t30 / 2.0;
      t5 = q_roll;
      t5 = cos(t5);
      HalfMaxTicks_idx_0 = q_st_lB;
      HalfMaxTicks_idx_0 = cos(HalfMaxTicks_idx_0);
      sum_term = q_pitch;
      sum_term = sin(sum_term);
      hd2 = q_st_h;
      hd2 = sin(hd2);
      t30 = t5 * HalfMaxTicks_idx_0 * sum_term * hd2 * dq_roll;
      q_sw_h_tgt = t30 / 2.0;
      t5 = q_st_h;
      t5 = cos(t5);
      HalfMaxTicks_idx_0 = q_st_lB;
      HalfMaxTicks_idx_0 = cos(HalfMaxTicks_idx_0);
      sum_term = q_pitch;
      sum_term = sin(sum_term);
      hd2 = q_roll;
      hd2 = sin(hd2);
      t30 = t5 * HalfMaxTicks_idx_0 * sum_term * hd2 * dq_roll;
      y_sw_tgt = t30 / 2.0;
      t5 = q_roll;
      t5 = cos(t5);
      HalfMaxTicks_idx_0 = q_st_lA;
      HalfMaxTicks_idx_0 = cos(HalfMaxTicks_idx_0);
      sum_term = q_pitch;
      sum_term = sin(sum_term);
      hd2 = q_st_h;
      hd2 = sin(hd2);
      t30 = t5 * HalfMaxTicks_idx_0 * sum_term * hd2 * dq_st_h;
      L = t30 / 2.0;
      t5 = q_st_h;
      t5 = cos(t5);
      HalfMaxTicks_idx_0 = q_st_lA;
      HalfMaxTicks_idx_0 = cos(HalfMaxTicks_idx_0);
      sum_term = q_pitch;
      sum_term = sin(sum_term);
      hd2 = q_roll;
      hd2 = sin(hd2);
      t30 = t5 * HalfMaxTicks_idx_0 * sum_term * hd2 * dq_st_h;
      CalOffset_idx_0 = t30 / 2.0;
      t5 = q_roll;
      t5 = cos(t5);
      HalfMaxTicks_idx_0 = q_st_lB;
      HalfMaxTicks_idx_0 = cos(HalfMaxTicks_idx_0);
      sum_term = q_pitch;
      sum_term = sin(sum_term);
      hd2 = q_st_h;
      hd2 = sin(hd2);
      t30 = t5 * HalfMaxTicks_idx_0 * sum_term * hd2 * dq_st_h;
      u_Link_idx_2 = t30 / 2.0;
      t5 = q_st_h;
      t5 = cos(t5);
      HalfMaxTicks_idx_0 = q_st_lB;
      HalfMaxTicks_idx_0 = cos(HalfMaxTicks_idx_0);
      sum_term = q_pitch;
      sum_term = sin(sum_term);
      hd2 = q_roll;
      hd2 = sin(hd2);
      t30 = t5 * HalfMaxTicks_idx_0 * sum_term * hd2 * dq_st_h;
      u_Link_idx_3 = t30 / 2.0;
      t5 = q_roll;
      t5 = cos(t5);
      HalfMaxTicks_idx_0 = q_st_h;
      HalfMaxTicks_idx_0 = cos(HalfMaxTicks_idx_0);
      sum_term = q_pitch;
      sum_term = sin(sum_term);
      hd2 = q_st_lA;
      hd2 = sin(hd2);
      t30 = t5 * HalfMaxTicks_idx_0 * sum_term * hd2 * dq_st_lA;
      q3R = t30 / 2.0;
      t5 = q_roll;
      t5 = cos(t5);
      HalfMaxTicks_idx_0 = q_st_h;
      HalfMaxTicks_idx_0 = cos(HalfMaxTicks_idx_0);
      sum_term = q_pitch;
      sum_term = sin(sum_term);
      hd2 = q_st_lB;
      hd2 = sin(hd2);
      t30 = t5 * HalfMaxTicks_idx_0 * sum_term * hd2 * dq_st_lB;
      u_Link_idx_0 = t30 / 2.0;
      t5 = q_pitch;
      t5 = cos(t5);
      HalfMaxTicks_idx_0 = q_roll;
      HalfMaxTicks_idx_0 = cos(HalfMaxTicks_idx_0);
      sum_term = q_st_h;
      sum_term = sin(sum_term);
      hd2 = q_pitch;
      hd2 = cos(hd2);
      u_Link_idx_1 = q_st_h;
      u_Link_idx_1 = cos(u_Link_idx_1);
      a_max = q_roll;
      a_max = sin(a_max);
      a_min = q_roll;
      a_min = cos(a_min);
      varargin_1 = q_st_h;
      varargin_1 = cos(varargin_1);
      s_st = q_pitch;
      s_st = sin(s_st);
      s_sw = q_roll;
      s_sw = cos(s_sw);
      sum_term_idx_0_0 = q_st_h;
      sum_term_idx_0_0 = cos(sum_term_idx_0_0);
      sum_term_idx_0 = q_pitch;
      sum_term_idx_0 = sin(sum_term_idx_0);
      CurrentYaw = q_pitch;
      CurrentYaw = sin(CurrentYaw);
      a21 = q_roll;
      a21 = sin(a21);
      n = q_st_h;
      n = sin(n);
      t99 = q_st_lA;
      t99 = sin(t99);
      t30 = CurrentYaw * a21 * n * t99 * dq_st_lA;
      B = t30 / 2.0;
      CurrentYaw = q_pitch;
      CurrentYaw = sin(CurrentYaw);
      a21 = q_roll;
      a21 = sin(a21);
      n = q_st_h;
      n = sin(n);
      t99 = q_st_lB;
      t99 = sin(t99);
      t30 = CurrentYaw * a21 * n * t99 * dq_st_lB;
      t21 = t30 / 2.0;
      CurrentYaw = q_pitch;
      CurrentYaw = sin(CurrentYaw);
      a21 = q_roll;
      a21 = sin(a21);
      n = q_st_h;
      n = sin(n);
      t99 = q_pitch;
      t99 = sin(t99);
      t30 = q_roll;
      t30 = sin(t30);
      t36 = q_st_h;
      t36 = sin(t36);
      obj_0->dx = (((((((((((((((((((((((((((((y_5 - y_0) - y_1) + y_2) -
        obj_0->x_offset * x_re * dq_pitch) + obj_0->z_offset * CalOffset_idx_1 *
        uDamping_idx_2 * dq_pitch) + obj_0->y_offset * uDamping_idx_3 * t42 *
        dq_pitch) + obj_0->y_offset * t51 * maxval * dq_roll) - obj_0->z_offset *
        t11 * t3 * dq_roll) - y_3) - y_4) + alpha) + HalfMaxTicks_idx_1) + t2) +
        dxInput) + q_sw_h_tgt) + y_sw_tgt) + L) + CalOffset_idx_0) +
        u_Link_idx_2) + u_Link_idx_3) + q3R) + u_Link_idx_0) - l_st_h * t5 *
                         HalfMaxTicks_idx_0 * sum_term * dq_pitch) - l_st_h *
                        hd2 * u_Link_idx_1 * a_max * dq_pitch) - l_st_h * a_min *
                       varargin_1 * s_st * dq_roll) - l_st_h * s_sw *
                      sum_term_idx_0_0 * sum_term_idx_0 * dq_st_h) - B) - t21) +
                   l_st_h * CurrentYaw * a21 * n * dq_roll) + l_st_h * t99 * t30
        * t36 * dq_st_h;
      x_re = q_roll;
      x_re = cos(x_re);
      CalOffset_idx_1 = q_st_h;
      CalOffset_idx_1 = sin(CalOffset_idx_1);
      uDamping_idx_2 = q_st_lB;
      uDamping_idx_2 = cos(uDamping_idx_2);
      uDamping_idx_3 = q_roll;
      uDamping_idx_3 = sin(uDamping_idx_3);
      t42 = q_st_h;
      t42 = sin(t42);
      t30 = uDamping_idx_2 * uDamping_idx_3 * t42 * dq_roll;
      y_5 = t30 / 2.0;
      uDamping_idx_2 = q_st_lA;
      uDamping_idx_2 = cos(uDamping_idx_2);
      uDamping_idx_3 = q_roll;
      uDamping_idx_3 = sin(uDamping_idx_3);
      t42 = q_st_h;
      t42 = sin(t42);
      t30 = uDamping_idx_2 * uDamping_idx_3 * t42 * dq_st_h;
      y_0 = t30 / 2.0;
      uDamping_idx_2 = q_st_lB;
      uDamping_idx_2 = cos(uDamping_idx_2);
      uDamping_idx_3 = q_roll;
      uDamping_idx_3 = sin(uDamping_idx_3);
      t42 = q_st_h;
      t42 = sin(t42);
      t30 = uDamping_idx_2 * uDamping_idx_3 * t42 * dq_st_h;
      y_1 = t30 / 2.0;
      uDamping_idx_2 = q_roll;
      uDamping_idx_2 = cos(uDamping_idx_2);
      uDamping_idx_3 = q_st_h;
      uDamping_idx_3 = sin(uDamping_idx_3);
      t42 = q_st_lA;
      t42 = sin(t42);
      t30 = uDamping_idx_2 * uDamping_idx_3 * t42 * dq_st_lA;
      y_2 = t30 / 2.0;
      uDamping_idx_2 = q_st_h;
      uDamping_idx_2 = cos(uDamping_idx_2);
      uDamping_idx_3 = q_roll;
      uDamping_idx_3 = sin(uDamping_idx_3);
      t42 = q_st_lA;
      t42 = sin(t42);
      t30 = uDamping_idx_2 * uDamping_idx_3 * t42 * dq_st_lA;
      y_3 = t30 / 2.0;
      uDamping_idx_2 = q_roll;
      uDamping_idx_2 = cos(uDamping_idx_2);
      uDamping_idx_3 = q_st_h;
      uDamping_idx_3 = sin(uDamping_idx_3);
      t42 = q_st_lB;
      t42 = sin(t42);
      t30 = uDamping_idx_2 * uDamping_idx_3 * t42 * dq_st_lB;
      y_4 = t30 / 2.0;
      uDamping_idx_2 = q_st_h;
      uDamping_idx_2 = cos(uDamping_idx_2);
      uDamping_idx_3 = q_roll;
      uDamping_idx_3 = sin(uDamping_idx_3);
      t42 = q_st_lB;
      t42 = sin(t42);
      t30 = uDamping_idx_2 * uDamping_idx_3 * t42 * dq_st_lB;
      alpha = t30 / 2.0;
      uDamping_idx_2 = q_st_h;
      uDamping_idx_2 = cos(uDamping_idx_2);
      uDamping_idx_3 = q_roll;
      uDamping_idx_3 = sin(uDamping_idx_3);
      t42 = q_roll;
      t42 = cos(t42);
      t51 = q_st_h;
      t51 = sin(t51);
      maxval = q_st_h;
      maxval = cos(maxval);
      t11 = q_roll;
      t11 = sin(t11);
      t3 = q_roll;
      t3 = cos(t3);
      t5 = q_st_h;
      t5 = cos(t5);
      HalfMaxTicks_idx_0 = q_st_lA;
      HalfMaxTicks_idx_0 = cos(HalfMaxTicks_idx_0);
      t30 = t3 * t5 * HalfMaxTicks_idx_0 * dq_roll;
      HalfMaxTicks_idx_1 = t30 / 2.0;
      t3 = q_roll;
      t3 = cos(t3);
      t5 = q_st_h;
      t5 = cos(t5);
      HalfMaxTicks_idx_0 = q_st_lB;
      HalfMaxTicks_idx_0 = cos(HalfMaxTicks_idx_0);
      t30 = t3 * t5 * HalfMaxTicks_idx_0 * dq_roll;
      t2 = t30 / 2.0;
      t3 = q_roll;
      t3 = cos(t3);
      t5 = q_st_h;
      t5 = cos(t5);
      HalfMaxTicks_idx_0 = q_st_lA;
      HalfMaxTicks_idx_0 = cos(HalfMaxTicks_idx_0);
      t30 = t3 * t5 * HalfMaxTicks_idx_0 * dq_st_h;
      dxInput = t30 / 2.0;
      t3 = q_roll;
      t3 = cos(t3);
      t5 = q_st_h;
      t5 = cos(t5);
      HalfMaxTicks_idx_0 = q_st_lB;
      HalfMaxTicks_idx_0 = cos(HalfMaxTicks_idx_0);
      t30 = t3 * t5 * HalfMaxTicks_idx_0 * dq_st_h;
      q_sw_h_tgt = t30 / 2.0;
      obj_0->dy = (((((((((((((l_st_h * x_re * CalOffset_idx_1 * dq_roll - y_5)
        - y_0) - y_1) - y_2) - y_3) - y_4) - alpha) + l_st_h * uDamping_idx_2 *
                        uDamping_idx_3 * dq_roll) + l_st_h * t42 * t51 * dq_st_h)
                      + l_st_h * maxval * t11 * dq_st_h) + HalfMaxTicks_idx_1) +
                    t2) + dxInput) + q_sw_h_tgt;
      x_re = q_pitch + q_st_lB;
      x_re = cos(x_re);
      CalOffset_idx_1 = q_pitch + q_st_lA;
      CalOffset_idx_1 = cos(CalOffset_idx_1);
      uDamping_idx_2 = q_st_lA - q_st_lB;
      uDamping_idx_2 = sin(uDamping_idx_2);
      t30 = ((q_st_mA - q_st_lA) * x_re - (q_st_mB - q_st_lB) * CalOffset_idx_1)
        * 5381.6;
      t2 = t30 / uDamping_idx_2;
      x_re = q_pitch + q_sw_lB;
      x_re = cos(x_re);
      CalOffset_idx_1 = q_pitch + q_sw_lA;
      CalOffset_idx_1 = cos(CalOffset_idx_1);
      uDamping_idx_2 = q_sw_lA - q_sw_lB;
      uDamping_idx_2 = sin(uDamping_idx_2);
      t30 = ((q_sw_mA - q_sw_lA) * x_re - (q_sw_mB - q_sw_lB) * CalOffset_idx_1)
        * 5381.6;
      t5 = t30 / uDamping_idx_2;
      CurrentYaw = obj_0->thres_lo;
      a21 = obj_0->thres_hi;

      /*  parsePS3Controller */
      /*  methods */
      /*  classdef */
      /* % LOCAL FUNCTIONS ======================================================== */
      /* SCALEFACTOR Compute scalar (0 to 1) representing forces in leg. */
      /* CLAMP Clamp value between two bounds. */
      /*  */
      /*  Copyright 2015 Mikhail S. Jones */
      /*  Find which limit is min and max */
      if ((CurrentYaw <= a21) || rtIsNaN(a21)) {
        a_min = CurrentYaw;
      } else {
        a_min = a21;
      }

      if ((CurrentYaw >= a21) || rtIsNaN(a21)) {
        a_max = CurrentYaw;
      } else {
        a_max = a21;
      }

      /*  Clamp value between limits */
      if ((t2 <= a_max) || rtIsNaN(a_max)) {
        t99 = t2;
      } else {
        t99 = a_max;
      }

      if ((t99 >= a_min) || rtIsNaN(a_min)) {
        a_min = t99;
      }

      /*  clamp */
      t30 = a_min - CurrentYaw;
      B = a21 - CurrentYaw;
      s_st = t30 / B;
      CurrentYaw = obj_0->thres_lo;
      a21 = obj_0->thres_hi;

      /*  parsePS3Controller */
      /*  methods */
      /*  classdef */
      /* % LOCAL FUNCTIONS ======================================================== */
      /* SCALEFACTOR Compute scalar (0 to 1) representing forces in leg. */
      /* CLAMP Clamp value between two bounds. */
      /*  */
      /*  Copyright 2015 Mikhail S. Jones */
      /*  Find which limit is min and max */
      if ((CurrentYaw <= a21) || rtIsNaN(a21)) {
        a_min = CurrentYaw;
      } else {
        a_min = a21;
      }

      if ((CurrentYaw >= a21) || rtIsNaN(a21)) {
        a_max = CurrentYaw;
      } else {
        a_max = a21;
      }

      /*  Clamp value between limits */
      if ((t5 <= a_max) || rtIsNaN(a_max)) {
        t99 = t5;
      } else {
        t99 = a_max;
      }

      if ((t99 >= a_min) || rtIsNaN(a_min)) {
        a_min = t99;
      }

      /*  clamp */
      t30 = a_min - CurrentYaw;
      B = a21 - CurrentYaw;
      s_sw = t30 / B;
      t30 = s_st * 0.0005;
      B = obj_0->tau + 0.0005;
      alpha = t30 / B;
      t30 = obj_0->tau;
      y_5 = t30 / 10.0;
      t30 = s_st * 0.0005;
      B = y_5 + 0.0005;
      n = t30 / B;
      x_re = obj_0->dx;
      y_5 = fabs(x_re);
      t30 = (obj_0->dx - obj_0->dx_est) * alpha;
      b = (y_5 < 4.0);
      y_5 = t30 * (real_T)b;
      obj_0->dx_est += y_5;
      x_re = obj_0->dy;
      y_5 = fabs(x_re);
      t30 = (obj_0->dy - obj_0->dy_est) * alpha;
      b = (y_5 < 2.0);
      y_5 = t30 * (real_T)b;
      obj_0->dy_est += y_5;
      x_re = obj_0->dq_yaw;
      y_5 = fabs(x_re);
      t30 = (obj_0->dq_yaw - obj_0->dq_yaw_est) * n;
      b = (y_5 < 1.5);
      y_5 = t30 * (real_T)b;
      obj_0->dq_yaw_est += y_5;
      if ((s_st >= s_sw) || rtIsNaN(s_sw)) {
        maxval = s_st;
      } else {
        maxval = s_sw;
      }

      x_re = obj_0->q_yaw;
      x_re = cos(x_re);
      CalOffset_idx_1 = obj_0->q_yaw;
      CalOffset_idx_1 = sin(CalOffset_idx_1);
      obj_0->x_est += (x_re * obj_0->dx_est - CalOffset_idx_1 * obj_0->dy_est) *
        (maxval * 0.0005);
      if ((s_st >= s_sw) || rtIsNaN(s_sw)) {
        maxval = s_st;
      } else {
        maxval = s_sw;
      }

      x_re = obj_0->q_yaw;
      x_re = sin(x_re);
      CalOffset_idx_1 = obj_0->q_yaw;
      CalOffset_idx_1 = cos(CalOffset_idx_1);
      obj_0->y_est += (x_re * obj_0->dx_est + CalOffset_idx_1 * obj_0->dy_est) *
        (maxval * 0.0005);
      x_re = obj_0->dx_est;
      y_5 = fabs(x_re);
      t30 = obj_0->t_gain * y_5;

      /* CLAMP Clamp value between two bounds. */
      /*  */
      /*  Copyright 2015 Mikhail S. Jones */
      /*  Find which limit is min and max */
      a_min = -0.1;

      /*  Clamp value between limits */
      if (t30 <= 0.1) {
        t99 = t30;
      } else {
        t99 = 0.1;
      }

      if (t99 >= -0.1) {
        a_min = t99;
      }

      /*  clamp */
      a21 = obj_0->t0_step - a_min;
      if (u2 == 0.0) {
        a21 = 1.0;
      }

      t30 = q_st_lA + q_st_lB;
      y_5 = t30 / 2.0;
      obj_0->theta = q_pitch + y_5;
      t30 = dq_st_lA + dq_st_lB;
      y_5 = t30 / 2.0;
      CurrentYaw = dq_pitch + y_5;
      t30 = obj_0->dx_est;

      /* CLAMP Clamp value between two bounds. */
      /*  */
      /*  Copyright 2015 Mikhail S. Jones */
      /*  Find which limit is min and max */
      /*  Clamp value between limits */
      if (t30 <= 1.2) {
        t99 = t30;
      } else {
        t99 = 1.2;
      }

      if (t99 >= -0.8) {
        dxInput = t99;
      } else {
        dxInput = -0.8;
      }

      /*  clamp */
      for (rtemp = 0; rtemp < 5; rtemp++) {
        HalfMaxTicks_idx_0 = tmp[rtemp];
        x_1[rtemp] = HalfMaxTicks_idx_0 - dxInput;
        dxSet[rtemp] = HalfMaxTicks_idx_0;
      }

      for (r1 = 0; r1 < 5; r1++) {
        t99 = 1.0 + (real_T)r1;
        x_re = x_1[(int32_T)t99 - 1];
        y_5 = fabs(x_re);
        minAbs[(int32_T)t99 - 1] = y_5;
      }

      Walking_ATRIAS_eml_sort(minAbs, x_1, iidx);
      for (rtemp = 0; rtemp < 5; rtemp++) {
        x_1[rtemp] = iidx[rtemp];
      }

      CalOffset_idx_0 = x_1[0];
      CalOffset_idx_1 = x_1[1];
      r1 = (int32_T)CalOffset_idx_0;
      HalfMaxTicks_idx_1 = u3[r1 - 1];
      a_min = dxSet[(int32_T)CalOffset_idx_1 - 1] - dxInput;
      HalfMaxTicks_idx_1 *= a_min;
      r1 = (int32_T)CalOffset_idx_1;
      HalfMaxTicks_idx_0 = u3[r1 - 1];
      a_min = dxInput - dxSet[(int32_T)CalOffset_idx_0 - 1];
      HalfMaxTicks_idx_0 *= a_min;
      HalfMaxTicks_idx_1 += HalfMaxTicks_idx_0;
      B = dxSet[(int32_T)CalOffset_idx_1 - 1] - dxSet[(int32_T)CalOffset_idx_0 -
        1];
      HalfMaxTicks_idx_1 /= B;
      HalfMaxTicks_idx_0 = obj_0->thetaMin;
      x_re = HalfMaxTicks_idx_1 - HalfMaxTicks_idx_0;
      y_5 = fabs(x_re);
      if (y_5 < 0.3490658503988659) {
        x_re = HalfMaxTicks_idx_1 - HalfMaxTicks_idx_0;
        if (x_re < 0.0) {
          x_re = -1.0;
        } else if (x_re > 0.0) {
          x_re = 1.0;
        } else {
          if (x_re == 0.0) {
            x_re = 0.0;
          }
        }

        HalfMaxTicks_idx_1 = 0.3490658503988659 * x_re + obj_0->thetaMin;
      }

      t30 = obj_0->theta - HalfMaxTicks_idx_0;
      B = HalfMaxTicks_idx_1 - HalfMaxTicks_idx_0;
      y_5 = t30 / B;
      obj_0->sDDA = y_5;
      B = HalfMaxTicks_idx_1 - HalfMaxTicks_idx_0;
      y_5 = CurrentYaw / B;
      obj_0->dsDDA = y_5;
      if (obj_0->isTest11 == 1) {
        B = obj_0->tau + 0.0005;
        alpha = 0.0005 / B;
      }

      AccelValid = (obj_0->dsDDA < 10.0);
      y_5 = AccelValid;
      obj_0->dsDDA_est += (obj_0->dsDDA - obj_0->dsDDA_est) * alpha * y_5;
      y_5 = 1.0 / a21;
      obj_0->tauPhase += ((obj_0->sDDA - obj_0->tauPhase) * 0.0 + y_5) * 0.0005;
      if (obj_0->isTest11 == 1) {
        /* CLAMP Clamp value between two bounds. */
        /*  */
        /*  Copyright 2015 Mikhail S. Jones */
        /*  Find which limit is min and max */
        /*  Clamp value between limits */
        if (sum_term_idx_3 <= 1.0) {
          t99 = sum_term_idx_3;
        } else {
          t99 = 1.0;
        }

        if (t99 >= 0.0) {
          t3 = t99;
        } else {
          t3 = 0.0;
        }

        /*  clamp */
        B = obj_0->t0_step;
        y_5 = 1.0 / B;
        if (y_5 >= 1.0) {
          t11 = y_5;
        } else {
          t11 = 1.0;
        }
      } else {
        t30 = obj_0->tauPhase;

        /* CLAMP Clamp value between two bounds. */
        /*  */
        /*  Copyright 2015 Mikhail S. Jones */
        /*  Find which limit is min and max */
        /*  Clamp value between limits */
        if (t30 <= 1.0) {
          t99 = t30;
        } else {
          t99 = 1.0;
        }

        if (t99 >= 0.0) {
          t3 = t99;
        } else {
          t3 = 0.0;
        }

        /*  clamp */
        y_5 = 1.0 / a21;
        t11 = (obj_0->sDDA - obj_0->tauPhase) * 0.0 + y_5;
      }

      varargin_1 = obj_0->dx_tgt;
      CurrentYaw = obj_0->dx_est - 0.5;
      if ((varargin_1 >= CurrentYaw) || rtIsNaN(CurrentYaw)) {
        maxval = varargin_1;
      } else {
        maxval = CurrentYaw;
      }

      CurrentYaw = obj_0->dx_est + 0.5;
      if ((maxval <= CurrentYaw) || rtIsNaN(CurrentYaw)) {
        t99 = maxval;
      } else {
        t99 = CurrentYaw;
      }

      t21 = ((obj_0->dx_est - t99) * obj_0->dx_err_p_gain + obj_0->dx_gain *
             obj_0->dx_est) + (obj_0->dx_est - obj_0->dx_est_last) *
        obj_0->dx_err_d_gain;

      /*  scaleFactor */
      /* ATANS Arctangent smooth clamp function */
      /*  */
      /*  Rescale Y limit for arctangent function */
      /*  Arctangent scaled to have desired slope at 0 and desired clamp at Inf */
      t30 = t21;
      y_5 = t30 / 0.63661977236758138;
      y_5 = atan(y_5);
      t21 = 0.63661977236758138 * y_5;

      /*  atans */
      x_re = obj_0->dx_est;
      y_5 = fabs(x_re);
      t30 = obj_0->dy_est + obj_0->dy_est_last;
      y_0 = t30 / 2.0;
      t30 = obj_0->dy_est + obj_0->dy_est_last;
      y_1 = t30 / 2.0;
      y_sw_tgt = (((obj_0->y0_offset - obj_0->y0_gain * y_5) * -obj_0->stanceLeg
                   + obj_0->dy_gain * obj_0->dy_est) + (y_0 - obj_0->dy_tgt) *
                  obj_0->dy_err_p_gain) + (y_1 - obj_0->dy_est_avg) *
        obj_0->dy_err_d_gain;
      CurrentYaw = l_sw_h * l_sw_h;
      L = 0.9216 + CurrentYaw;
      L = sqrt(L);
      t30 = y_sw_tgt + y_t;
      y_5 = t30 / L;
      CalOffset_idx_1 = y_5;
      x_re = CalOffset_idx_1;
      y_5 = fabs(x_re);
      if (!(y_5 > 1.0)) {
        CalOffset_idx_1 = asin(CalOffset_idx_1);
      } else {
        HalfMaxTicks_idx_0 = 1.0 + CalOffset_idx_1;
        if (HalfMaxTicks_idx_0 < 0.0) {
          q3R = 0.0;
          a21 = sqrt(fabs(HalfMaxTicks_idx_0));
        } else {
          q3R = sqrt(HalfMaxTicks_idx_0);
          a21 = 0.0;
        }

        HalfMaxTicks_idx_0 = q3R;
        HalfMaxTicks_idx_1 = a21;
        CalOffset_idx_0 = 1.0 - CalOffset_idx_1;
        if (CalOffset_idx_0 < 0.0) {
          q3R = 0.0;
          a21 = sqrt(fabs(CalOffset_idx_0));
        } else {
          q3R = sqrt(CalOffset_idx_0);
          a21 = 0.0;
        }

        CalOffset_idx_0 = q3R;
        CurrentYaw = CalOffset_idx_0 * HalfMaxTicks_idx_0 - a21 *
          HalfMaxTicks_idx_1;
        y_5 = fabs(x_re);
        y_0 = fabs(CurrentYaw);
        q3R = rt_atan2d_snf(y_5, y_0);
        if ((CalOffset_idx_1 < 0.0) != (CurrentYaw < 0.0)) {
          q3R = -q3R;
        }

        CalOffset_idx_1 = q3R;
      }

      y_5 = l_sw_h / L;
      x_re = y_5;
      y_5 = fabs(x_re);
      if (!(y_5 > 1.0)) {
        x_re = asin(x_re);
      } else {
        HalfMaxTicks_idx_0 = 1.0 + x_re;
        if (HalfMaxTicks_idx_0 < 0.0) {
          q3R = 0.0;
          a21 = sqrt(fabs(HalfMaxTicks_idx_0));
        } else {
          q3R = sqrt(HalfMaxTicks_idx_0);
          a21 = 0.0;
        }

        HalfMaxTicks_idx_0 = q3R;
        HalfMaxTicks_idx_1 = a21;
        CalOffset_idx_0 = 1.0 - x_re;
        if (CalOffset_idx_0 < 0.0) {
          q3R = 0.0;
          a21 = sqrt(fabs(CalOffset_idx_0));
        } else {
          q3R = sqrt(CalOffset_idx_0);
          a21 = 0.0;
        }

        CalOffset_idx_0 = q3R;
        CurrentYaw = CalOffset_idx_0 * HalfMaxTicks_idx_0 - a21 *
          HalfMaxTicks_idx_1;
        y_5 = fabs(x_re);
        y_0 = fabs(CurrentYaw);
        q3R = rt_atan2d_snf(y_5, y_0);
        if ((x_re < 0.0) != (CurrentYaw < 0.0)) {
          q3R = -q3R;
        }

        x_re = q3R;
      }

      q_sw_h_tgt = CalOffset_idx_1 - x_re;
      t30 = y_sw_tgt + y_t;
      n = t30 * t30;
      CurrentYaw = L * L;
      y_5 = n / CurrentYaw;
      x_re = 1.0 - y_5;
      x_re = sqrt(x_re);
      B = L * x_re;
      a21 = 0.0 / B;
      if (obj_0->stanceLeg == -1.0) {
        y_5 = q_st_h / 3.1415926535897931;
        CurrentYaw = y_5 * 180.0 + -10.0;
        if ((-10.0 >= CurrentYaw) || rtIsNaN(CurrentYaw)) {
          maxval = -10.0;
        } else {
          maxval = CurrentYaw;
        }

        t30 = maxval * 3.1415926535897931;
        y_5 = t30 / 180.0;

        /* CLAMP Clamp value between two bounds. */
        /*  */
        /*  Copyright 2015 Mikhail S. Jones */
        /*  Find which limit is min and max */
        if (y_5 <= 0.17453292519943295) {
          a_min = y_5;
        } else {
          a_min = 0.17453292519943295;
        }

        if (y_5 >= 0.17453292519943295) {
          a_max = y_5;
        } else {
          a_max = 0.17453292519943295;
        }

        /*  Clamp value between limits */
        if ((q_sw_h_tgt <= a_max) || rtIsNaN(a_max)) {
          t99 = q_sw_h_tgt;
        } else {
          t99 = a_max;
        }

        if ((t99 >= a_min) || rtIsNaN(a_min)) {
          q_sw_h_tgt = t99;
        } else {
          q_sw_h_tgt = a_min;
        }

        /*  clamp */
      } else {
        y_5 = q_st_h / 3.1415926535897931;
        CurrentYaw = y_5 * 180.0 + 10.0;
        if ((10.0 <= CurrentYaw) || rtIsNaN(CurrentYaw)) {
          t99 = 10.0;
        } else {
          t99 = CurrentYaw;
        }

        t30 = t99 * 3.1415926535897931;
        y_5 = t30 / 180.0;

        /* CLAMP Clamp value between two bounds. */
        /*  */
        /*  Copyright 2015 Mikhail S. Jones */
        /*  Find which limit is min and max */
        if (y_5 <= -0.17453292519943295) {
          a_min = y_5;
        } else {
          a_min = -0.17453292519943295;
        }

        if (y_5 >= -0.17453292519943295) {
          a_max = y_5;
        } else {
          a_max = -0.17453292519943295;
        }

        /*  Clamp value between limits */
        if ((q_sw_h_tgt <= a_max) || rtIsNaN(a_max)) {
          t99 = q_sw_h_tgt;
        } else {
          t99 = a_max;
        }

        if ((t99 >= a_min) || rtIsNaN(a_min)) {
          q_sw_h_tgt = t99;
        } else {
          q_sw_h_tgt = a_min;
        }

        /*  clamp */
      }

      if (obj_0->isSim) {
        maxval = 172.0674 * l_st_h;
        t51 = 172.0674 * l_sw_h;
      } else {
        maxval = obj_0->uHipGravity * 26.7 * obj_0->stanceLeg;
        t51 = -obj_0->uHipGravity * 26.7 * obj_0->stanceLeg;
      }

      if ((u2 == 0.0) || (obj_0->isTest5 == 1)) {
        maxval = (0.034906585039886591 * obj_0->stanceLeg - q_st_h) *
          obj_0->kp_hip + (0.0 - dq_st_h) * obj_0->kd_hip;
        t51 = (-0.034906585039886591 * obj_0->stanceLeg - q_sw_h) *
          obj_0->kp_hip + (0.0 - dq_sw_h) * obj_0->kd_hip;
      } else if (obj_0->isTest7 == 1) {
        x_re = 6.2831853071795862 * t3;
        x_re = sin(x_re);
        t30 = (5.0 * x_re + 2.0) * 3.1415926535897931;
        y_5 = t30 / 180.0;
        x_re = 6.2831853071795862 * t3;
        x_re = cos(x_re);
        t30 = 5.0 * x_re * 2.0 * 3.1415926535897931 * t11 * 3.1415926535897931;
        y_0 = t30 / 180.0;
        maxval = ((y_5 * obj_0->stanceLeg - q_st_h) * obj_0->kp_hip + maxval) +
          (y_0 * obj_0->stanceLeg - dq_st_h) * obj_0->kd_hip;
        x_re = 6.2831853071795862 * t3;
        x_re = sin(x_re);
        t30 = -(5.0 * x_re + 2.0) * 3.1415926535897931;
        y_5 = t30 / 180.0;
        x_re = 6.2831853071795862 * t3;
        x_re = cos(x_re);
        t30 = -(5.0 * x_re) * 2.0 * 3.1415926535897931 * t11 *
          3.1415926535897931;
        y_0 = t30 / 180.0;
        t51 = ((y_5 * obj_0->stanceLeg - q_sw_h) * obj_0->kp_hip + t51) + (y_0 *
          obj_0->stanceLeg - dq_sw_h) * obj_0->kd_hip;
      } else {
        if (obj_0->isTest8 != 1) {
          t51 = ((1.0 - s_sw) * t3 * obj_0->kp_hip * (q_sw_h_tgt - q_sw_h) + t51)
            + (1.0 - s_sw) * obj_0->kd_hip * (a21 - dq_sw_h);
          t51 += (obj_0->kp_hip * q_roll + obj_0->kd_hip * dq_roll) * s_sw;
          maxval = ((obj_0->kp_hip * q_roll + obj_0->kd_hip * dq_roll) * s_st +
                    maxval) + (1.0 - s_st) * obj_0->kd_hip * (0.0 - dq_st_h);
        }
      }

      t30 = q_sw_mA - q_st_mB;
      n = t30 / 2.0;
      n = cos(n);

      /* CLAMP Clamp value between two bounds. */
      /*  */
      /*  Copyright 2015 Mikhail S. Jones */
      /*  Find which limit is min and max */
      a_min = -0.1;

      /*  Clamp value between limits */
      if (t21 <= 0.1) {
        t99 = t21;
      } else {
        t99 = 0.1;
      }

      if (t99 >= -0.1) {
        a_min = t99;
      }

      /*  clamp */
      t21 = a_min / n;
      t21 = asin(t21);
      CurrentYaw = x_t / n;
      CurrentYaw = asin(CurrentYaw);
      if (obj_0->isTest11 == 1) {
        t30 = obj_0->dx_tgt;

        /* CLAMP Clamp value between two bounds. */
        /*  */
        /*  Copyright 2015 Mikhail S. Jones */
        /*  Find which limit is min and max */
        /*  Clamp value between limits */
        if (t30 <= 1.6) {
          t99 = t30;
        } else {
          t99 = 1.6;
        }

        if (t99 >= -1.6) {
          dxInput = t99;
        } else {
          dxInput = -1.6;
        }

        /*  clamp */
      } else {
        t30 = obj_0->dx_est;

        /* CLAMP Clamp value between two bounds. */
        /*  */
        /*  Copyright 2015 Mikhail S. Jones */
        /*  Find which limit is min and max */
        /*  Clamp value between limits */
        if (t30 <= 1.6) {
          t99 = t30;
        } else {
          t99 = 1.6;
        }

        if (t99 >= -1.6) {
          dxInput = t99;
        } else {
          dxInput = -1.6;
        }

        /*  clamp */
      }

      if (obj_0->stanceLeg == 1.0) {
        t36 = obj_0->leftHeight;
      } else {
        t36 = obj_0->rightHeight;
      }

      t42 = obj_0->hBelieve;

      /* CLAMP Clamp value between two bounds. */
      /*  */
      /*  Copyright 2015 Mikhail S. Jones */
      /*  Find which limit is min and max */
      /*  Clamp value between limits */
      if (t36 <= 0.1) {
        t99 = t36;
      } else {
        t99 = 0.1;
      }

      if (t99 >= -0.1) {
        t36 = t99;
      } else {
        t36 = -0.1;
      }

      /*  clamp */
      /* CLAMP Clamp value between two bounds. */
      /*  */
      /*  Copyright 2015 Mikhail S. Jones */
      /*  Find which limit is min and max */
      /*  Clamp value between limits */
      if (t42 <= 0.1) {
        t99 = t42;
      } else {
        t99 = 0.1;
      }

      if (t99 >= -0.1) {
        t42 = t99;
      } else {
        t42 = -0.1;
      }

      /*  clamp */
      memcpy(&hAlphaSet[0], &u4[0], 360U * sizeof(real_T));
      hSet[0] = -0.1;
      hSet[1] = 0.0;
      hSet[2] = 0.1;
      for (rtemp = 0; rtemp < 5; rtemp++) {
        HalfMaxTicks_idx_0 = tmp[rtemp];
        x_1[rtemp] = HalfMaxTicks_idx_0 - dxInput;
        dxSet[rtemp] = HalfMaxTicks_idx_0;
      }

      for (r1 = 0; r1 < 5; r1++) {
        t99 = 1.0 + (real_T)r1;
        x_re = x_1[(int32_T)t99 - 1];
        y_5 = fabs(x_re);
        minAbs[(int32_T)t99 - 1] = y_5;
      }

      Walking_ATRIAS_eml_sort(minAbs, x_1, iidx);
      for (rtemp = 0; rtemp < 5; rtemp++) {
        x_1[rtemp] = iidx[rtemp];
      }

      CalOffset_idx_0 = x_1[0];
      CalOffset_idx_1 = x_1[1];
      r1 = (int32_T)CalOffset_idx_0;
      for (rtemp = 0; rtemp < 3; rtemp++) {
        for (i = 0; i < 6; i++) {
          HAlpha_hSet[(i << 2) + 24 * rtemp] = hAlphaSet[((r1 - 1) * 24 + (i <<
            2)) + 120 * rtemp];
          HAlpha_hSet[((i << 2) + 24 * rtemp) + 1] = hAlphaSet[(((r1 - 1) * 24 +
            (i << 2)) + 120 * rtemp) + 1];
          HAlpha_hSet[((i << 2) + 24 * rtemp) + 2] = hAlphaSet[(((r1 - 1) * 24 +
            (i << 2)) + 120 * rtemp) + 2];
          HAlpha_hSet[((i << 2) + 24 * rtemp) + 3] = hAlphaSet[(((r1 - 1) * 24 +
            (i << 2)) + 120 * rtemp) + 3];
        }
      }

      a_min = dxSet[(int32_T)CalOffset_idx_1 - 1] - dxInput;
      for (rtemp = 0; rtemp < 72; rtemp++) {
        HalfMaxTicks_idx_0 = HAlpha_hSet[rtemp];
        HalfMaxTicks_idx_0 *= a_min;
        HAlpha_hSet[rtemp] = HalfMaxTicks_idx_0;
      }

      r1 = (int32_T)CalOffset_idx_1;
      for (rtemp = 0; rtemp < 3; rtemp++) {
        for (i = 0; i < 6; i++) {
          a_0[(i << 2) + 24 * rtemp] = hAlphaSet[((r1 - 1) * 24 + (i << 2)) +
            120 * rtemp];
          a_0[((i << 2) + 24 * rtemp) + 1] = hAlphaSet[(((r1 - 1) * 24 + (i << 2))
            + 120 * rtemp) + 1];
          a_0[((i << 2) + 24 * rtemp) + 2] = hAlphaSet[(((r1 - 1) * 24 + (i << 2))
            + 120 * rtemp) + 2];
          a_0[((i << 2) + 24 * rtemp) + 3] = hAlphaSet[(((r1 - 1) * 24 + (i << 2))
            + 120 * rtemp) + 3];
        }
      }

      a_min = dxInput - dxSet[(int32_T)CalOffset_idx_0 - 1];
      B = dxSet[(int32_T)CalOffset_idx_1 - 1] - dxSet[(int32_T)CalOffset_idx_0 -
        1];
      for (rtemp = 0; rtemp < 72; rtemp++) {
        HalfMaxTicks_idx_1 = a_0[rtemp];
        HalfMaxTicks_idx_0 = HAlpha_hSet[rtemp];
        HalfMaxTicks_idx_1 *= a_min;
        HalfMaxTicks_idx_0 += HalfMaxTicks_idx_1;
        HalfMaxTicks_idx_0 /= B;
        HAlpha_hSet[rtemp] = HalfMaxTicks_idx_0;
        a_0[rtemp] = HalfMaxTicks_idx_1;
      }

      x_2[0] = -0.1 - t36;
      x_2[1] = 0.0 - t36;
      x_2[2] = 0.1 - t36;
      x_re = x_2[0];
      y_5 = fabs(x_re);
      minAbs_0[0] = y_5;
      x_re = x_2[1];
      y_5 = fabs(x_re);
      minAbs_0[1] = y_5;
      x_re = x_2[2];
      y_5 = x_re;
      minAbs_0[2] = y_5;
      Walking_ATRIAS_eml_sort_c(minAbs_0, x_2, iidx_0);
      x_2[0] = iidx_0[0];
      x_2[1] = iidx_0[1];
      CalOffset_idx_0 = x_2[0];
      CalOffset_idx_1 = x_2[1];
      r1 = (int32_T)CalOffset_idx_0;
      for (rtemp = 0; rtemp < 6; rtemp++) {
        HAlpha[rtemp << 2] = HAlpha_hSet[(r1 - 1) * 24 + (rtemp << 2)];
        HAlpha[1 + (rtemp << 2)] = HAlpha_hSet[((r1 - 1) * 24 + (rtemp << 2)) +
          1];
        HAlpha[2 + (rtemp << 2)] = HAlpha_hSet[((r1 - 1) * 24 + (rtemp << 2)) +
          2];
        HAlpha[3 + (rtemp << 2)] = HAlpha_hSet[((r1 - 1) * 24 + (rtemp << 2)) +
          3];
      }

      a_min = hSet[(int32_T)CalOffset_idx_1 - 1] - t36;
      for (rtemp = 0; rtemp < 24; rtemp++) {
        HalfMaxTicks_idx_0 = HAlpha[rtemp];
        HalfMaxTicks_idx_0 *= a_min;
        HAlpha[rtemp] = HalfMaxTicks_idx_0;
      }

      r1 = (int32_T)CalOffset_idx_1;
      for (rtemp = 0; rtemp < 6; rtemp++) {
        a_1[rtemp << 2] = HAlpha_hSet[(r1 - 1) * 24 + (rtemp << 2)];
        a_1[1 + (rtemp << 2)] = HAlpha_hSet[((r1 - 1) * 24 + (rtemp << 2)) + 1];
        a_1[2 + (rtemp << 2)] = HAlpha_hSet[((r1 - 1) * 24 + (rtemp << 2)) + 2];
        a_1[3 + (rtemp << 2)] = HAlpha_hSet[((r1 - 1) * 24 + (rtemp << 2)) + 3];
      }

      a_min = t36 - hSet[(int32_T)CalOffset_idx_0 - 1];
      B = hSet[(int32_T)CalOffset_idx_1 - 1] - hSet[(int32_T)CalOffset_idx_0 - 1];
      for (rtemp = 0; rtemp < 24; rtemp++) {
        HalfMaxTicks_idx_1 = a_1[rtemp];
        HalfMaxTicks_idx_0 = HAlpha[rtemp];
        HalfMaxTicks_idx_1 *= a_min;
        HalfMaxTicks_idx_0 += HalfMaxTicks_idx_1;
        HalfMaxTicks_idx_0 /= B;
        HAlpha[rtemp] = HalfMaxTicks_idx_0;
        a_1[rtemp] = HalfMaxTicks_idx_1;
      }

      hSet[0] = -0.1;
      hSet[1] = 0.0;
      hSet[2] = 0.1;
      for (rtemp = 0; rtemp < 5; rtemp++) {
        HalfMaxTicks_idx_0 = tmp[rtemp];
        x_1[rtemp] = HalfMaxTicks_idx_0 - dxInput;
        dxSet[rtemp] = HalfMaxTicks_idx_0;
      }

      for (r1 = 0; r1 < 5; r1++) {
        t99 = 1.0 + (real_T)r1;
        x_re = x_1[(int32_T)t99 - 1];
        y_5 = fabs(x_re);
        minAbs[(int32_T)t99 - 1] = y_5;
      }

      Walking_ATRIAS_eml_sort(minAbs, x_1, iidx);
      for (rtemp = 0; rtemp < 5; rtemp++) {
        x_1[rtemp] = iidx[rtemp];
      }

      CalOffset_idx_0 = x_1[0];
      CalOffset_idx_1 = x_1[1];
      r1 = (int32_T)CalOffset_idx_0;
      for (rtemp = 0; rtemp < 3; rtemp++) {
        for (i = 0; i < 6; i++) {
          HAlpha_hSet[(i << 2) + 24 * rtemp] = u4[((r1 - 1) * 24 + (i << 2)) +
            120 * rtemp];
          HAlpha_hSet[((i << 2) + 24 * rtemp) + 1] = u4[(((r1 - 1) * 24 + (i <<
            2)) + 120 * rtemp) + 1];
          HAlpha_hSet[((i << 2) + 24 * rtemp) + 2] = u4[(((r1 - 1) * 24 + (i <<
            2)) + 120 * rtemp) + 2];
          HAlpha_hSet[((i << 2) + 24 * rtemp) + 3] = u4[(((r1 - 1) * 24 + (i <<
            2)) + 120 * rtemp) + 3];
        }
      }

      a_min = dxSet[(int32_T)CalOffset_idx_1 - 1] - dxInput;
      for (rtemp = 0; rtemp < 72; rtemp++) {
        HalfMaxTicks_idx_0 = HAlpha_hSet[rtemp];
        HalfMaxTicks_idx_0 *= a_min;
        HAlpha_hSet[rtemp] = HalfMaxTicks_idx_0;
      }

      r1 = (int32_T)CalOffset_idx_1;
      for (rtemp = 0; rtemp < 3; rtemp++) {
        for (i = 0; i < 6; i++) {
          a_0[(i << 2) + 24 * rtemp] = u4[((r1 - 1) * 24 + (i << 2)) + 120 *
            rtemp];
          a_0[((i << 2) + 24 * rtemp) + 1] = u4[(((r1 - 1) * 24 + (i << 2)) +
            120 * rtemp) + 1];
          a_0[((i << 2) + 24 * rtemp) + 2] = u4[(((r1 - 1) * 24 + (i << 2)) +
            120 * rtemp) + 2];
          a_0[((i << 2) + 24 * rtemp) + 3] = u4[(((r1 - 1) * 24 + (i << 2)) +
            120 * rtemp) + 3];
        }
      }

      a_min = dxInput - dxSet[(int32_T)CalOffset_idx_0 - 1];
      B = dxSet[(int32_T)CalOffset_idx_1 - 1] - dxSet[(int32_T)CalOffset_idx_0 -
        1];
      for (rtemp = 0; rtemp < 72; rtemp++) {
        HalfMaxTicks_idx_0 = HAlpha_hSet[rtemp];
        HalfMaxTicks_idx_1 = a_0[rtemp];
        HalfMaxTicks_idx_1 *= a_min;
        HalfMaxTicks_idx_0 += HalfMaxTicks_idx_1;
        HalfMaxTicks_idx_0 /= B;
        HAlpha_hSet[rtemp] = HalfMaxTicks_idx_0;
      }

      x_2[0] = -0.1 - t42;
      x_2[1] = 0.0 - t42;
      x_2[2] = 0.1 - t42;
      x_re = x_2[0];
      y_5 = fabs(x_re);
      minAbs_0[0] = y_5;
      x_re = x_2[1];
      y_5 = fabs(x_re);
      minAbs_0[1] = y_5;
      x_re = x_2[2];
      y_5 = x_re;
      minAbs_0[2] = y_5;
      Walking_ATRIAS_eml_sort_c(minAbs_0, x_2, iidx_0);
      x_2[0] = iidx_0[0];
      x_2[1] = iidx_0[1];
      CalOffset_idx_0 = x_2[0];
      CalOffset_idx_1 = x_2[1];
      r1 = (int32_T)CalOffset_idx_0;
      for (rtemp = 0; rtemp < 6; rtemp++) {
        HAlpha_norm[rtemp << 2] = HAlpha_hSet[(r1 - 1) * 24 + (rtemp << 2)];
        HAlpha_norm[1 + (rtemp << 2)] = HAlpha_hSet[((r1 - 1) * 24 + (rtemp << 2))
          + 1];
        HAlpha_norm[2 + (rtemp << 2)] = HAlpha_hSet[((r1 - 1) * 24 + (rtemp << 2))
          + 2];
        HAlpha_norm[3 + (rtemp << 2)] = HAlpha_hSet[((r1 - 1) * 24 + (rtemp << 2))
          + 3];
      }

      a_min = hSet[(int32_T)CalOffset_idx_1 - 1] - t42;
      for (rtemp = 0; rtemp < 24; rtemp++) {
        HalfMaxTicks_idx_0 = HAlpha_norm[rtemp];
        HalfMaxTicks_idx_0 *= a_min;
        HAlpha_norm[rtemp] = HalfMaxTicks_idx_0;
      }

      r1 = (int32_T)CalOffset_idx_1;
      for (rtemp = 0; rtemp < 6; rtemp++) {
        a_1[rtemp << 2] = HAlpha_hSet[(r1 - 1) * 24 + (rtemp << 2)];
        a_1[1 + (rtemp << 2)] = HAlpha_hSet[((r1 - 1) * 24 + (rtemp << 2)) + 1];
        a_1[2 + (rtemp << 2)] = HAlpha_hSet[((r1 - 1) * 24 + (rtemp << 2)) + 2];
        a_1[3 + (rtemp << 2)] = HAlpha_hSet[((r1 - 1) * 24 + (rtemp << 2)) + 3];
      }

      a_min = t42 - hSet[(int32_T)CalOffset_idx_0 - 1];
      B = hSet[(int32_T)CalOffset_idx_1 - 1] - hSet[(int32_T)CalOffset_idx_0 - 1];
      for (rtemp = 0; rtemp < 24; rtemp++) {
        HalfMaxTicks_idx_1 = a_1[rtemp];
        HalfMaxTicks_idx_0 = HAlpha_norm[rtemp];
        HalfMaxTicks_idx_1 *= a_min;
        HalfMaxTicks_idx_0 += HalfMaxTicks_idx_1;
        HalfMaxTicks_idx_0 /= B;
        HAlpha_norm[rtemp] = HalfMaxTicks_idx_0;
      }

      for (rtemp = 0; rtemp < 3; rtemp++) {
        HAlpha[(rtemp + 3) << 2] = HAlpha_norm[(rtemp + 3) << 2];
        HAlpha[1 + ((rtemp + 3) << 2)] = HAlpha_norm[((rtemp + 3) << 2) + 1];
        HAlpha[2 + ((rtemp + 3) << 2)] = HAlpha_norm[((rtemp + 3) << 2) + 2];
        HAlpha[3 + ((rtemp + 3) << 2)] = HAlpha_norm[((rtemp + 3) << 2) + 3];
      }

      for (rtemp = 0; rtemp < 6; rtemp++) {
        HAlpha_0[rtemp] = HAlpha[(rtemp << 2) + 1] + CurrentYaw;
      }

      for (rtemp = 0; rtemp < 6; rtemp++) {
        HAlpha[1 + (rtemp << 2)] = HAlpha_0[rtemp];
      }

      q_d[0] = obj_0->dhd_last[0];
      q_d[1] = obj_0->dhd_last[1];
      q_d[2] = obj_0->dhd_last[2];
      q_d[3] = obj_0->dhd_last[3];
      HalfMaxTicks_idx_0 = q_d[0];
      HalfMaxTicks_idx_0 /= 5.0;
      q_d[0] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = q_d[1];
      HalfMaxTicks_idx_0 /= 5.0;
      q_d[1] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = q_d[2];
      HalfMaxTicks_idx_0 /= 5.0;
      q_d[2] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = q_d[3];
      HalfMaxTicks_idx_0 /= 5.0;
      q_d[3] = HalfMaxTicks_idx_0;
      B = obj_0->ds_last;
      HalfMaxTicks_idx_0 = q_d[0];
      HalfMaxTicks_idx_0 /= B;
      q_d[0] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = q_d[1];
      HalfMaxTicks_idx_0 /= B;
      q_d[1] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = q_d[2];
      HalfMaxTicks_idx_0 /= B;
      q_d[2] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = q_d[3];
      HalfMaxTicks_idx_0 /= B;
      q_d[3] = HalfMaxTicks_idx_0;
      HAlpha[0] = obj_0->hd_last[0];
      HAlpha[1] = obj_0->hd_last[1];
      HAlpha[2] = obj_0->hd_last[2];
      HAlpha[3] = obj_0->hd_last[3];
      HAlpha[4] = q_d[0] + obj_0->hd_last[0];
      HAlpha[5] = q_d[1] + obj_0->hd_last[1];
      HAlpha[6] = q_d[2] + obj_0->hd_last[2];
      HAlpha[7] = q_d[3] + obj_0->hd_last[3];
      a_max = 0.0;
      if (obj_0->EnableYawControl == 1.0) {
        if (obj_0->stanceLeg == 1.0) {
          t30 = obj_0->dq_yaw_tgt * obj_0->kd_yaw;

          /* CLAMP Clamp value between two bounds. */
          /*  */
          /*  Copyright 2015 Mikhail S. Jones */
          /*  Find which limit is min and max */
          a_min = -0.17453292519943295;

          /*  Clamp value between limits */
          if (t30 <= 0.17453292519943295) {
            t99 = t30;
          } else {
            t99 = 0.17453292519943295;
          }

          if (t99 >= -0.17453292519943295) {
            a_min = t99;
          }

          /*  clamp */
          a_max = (1.0 - s_sw) * -a_min;
        } else {
          t30 = obj_0->dq_yaw_tgt * obj_0->kd_yaw;

          /* CLAMP Clamp value between two bounds. */
          /*  */
          /*  Copyright 2015 Mikhail S. Jones */
          /*  Find which limit is min and max */
          a_min = -0.17453292519943295;

          /*  Clamp value between limits */
          if (t30 <= 0.17453292519943295) {
            t99 = t30;
          } else {
            t99 = 0.17453292519943295;
          }

          if (t99 >= -0.17453292519943295) {
            a_min = t99;
          }

          /*  clamp */
          a_max = (1.0 - s_sw) * a_min;
        }
      }

      memcpy(&a_1[0], &HAlpha[0], 24U * sizeof(real_T));
      q_sw_h_tgt = 0.0;
      q3R = 0.0;
      y_sw_tgt = 0.0;
      for (r1 = 0; r1 < 6; r1++) {
        t99 = r1;
        CurrentYaw = t99;
        if (CurrentYaw > 2.5) {
          CurrentYaw = 5.0 - CurrentYaw;
        }

        y_5 = 1.0;
        a21 = 5.0 - CurrentYaw;
        iyLead = (int32_T)CurrentYaw - 1;
        for (j = 0; j <= iyLead; j++) {
          n = 1.0 + (real_T)j;
          y_5 *= (n + a21) / n;
        }

        y_5 = rt_roundd_snf(y_5);
        y_0 = rt_powd_snf(t3, t99);
        t30 = 1.0 - t3;
        a_min = 5.0 - t99;
        y_1 = rt_powd_snf(t30, a_min);
        i = (int32_T)t99 + 1;
        q_d[1] = a_1[((i - 1) << 2) + 1] * y_5;
        q_d[2] = a_1[((i - 1) << 2) + 2] * y_5;
        q_d[3] = a_1[((i - 1) << 2) + 3] * y_5;
        a_min = y_0 * y_1;
        HalfMaxTicks_idx_0 = q_d[1];
        HalfMaxTicks_idx_0 *= a_min;
        q_d[1] = HalfMaxTicks_idx_0;
        HalfMaxTicks_idx_0 = q_d[2];
        HalfMaxTicks_idx_0 *= a_min;
        q_d[2] = HalfMaxTicks_idx_0;
        HalfMaxTicks_idx_0 = q_d[3];
        HalfMaxTicks_idx_0 *= a_min;
        q_d[3] = HalfMaxTicks_idx_0;
        sum_term = q_sw_h_tgt;
        sum_term += q_d[1];
        q_sw_h_tgt = sum_term;
        sum_term = q3R;
        sum_term += q_d[2];
        q3R = sum_term;
        sum_term = y_sw_tgt;
        sum_term += q_d[3];
        y_sw_tgt = sum_term;
      }

      ix = 1;
      r2 = 1;
      for (i = 0; i < 4; i++) {
        rtemp = ix + 3;
        iyLead = r2 - 1;
        n = HAlpha[ix - 1];
        for (c_0 = 0; c_0 < 5; c_0++) {
          CurrentYaw = HAlpha[rtemp];
          a21 = n;
          n = CurrentYaw;
          CurrentYaw -= a21;
          rtemp += 4;
          y1[iyLead] = CurrentYaw;
          iyLead += 4;
        }

        ix++;
        r2++;
      }

      L = 0.0;
      alpha = 0.0;
      sum_term_idx_3 = 0.0;
      for (r1 = 0; r1 < 5; r1++) {
        t99 = r1;
        CurrentYaw = t99;
        if (CurrentYaw > 2.0) {
          CurrentYaw = 4.0 - CurrentYaw;
        }

        y_5 = 1.0;
        a21 = 4.0 - CurrentYaw;
        iyLead = (int32_T)CurrentYaw - 1;
        for (j = 0; j <= iyLead; j++) {
          n = 1.0 + (real_T)j;
          y_5 *= (n + a21) / n;
        }

        y_5 = rt_roundd_snf(y_5);
        y_0 = rt_powd_snf(t3, t99);
        t30 = 1.0 - t3;
        a_min = 4.0 - t99;
        y_1 = rt_powd_snf(t30, a_min);
        i = (int32_T)t99 + 1;
        q_d[1] = y1[((i - 1) << 2) + 1] * y_5;
        q_d[2] = y1[((i - 1) << 2) + 2] * y_5;
        q_d[3] = y1[((i - 1) << 2) + 3] * y_5;
        a_min = y_0 * y_1;
        HalfMaxTicks_idx_0 = q_d[1];
        HalfMaxTicks_idx_0 *= a_min;
        q_d[1] = HalfMaxTicks_idx_0;
        HalfMaxTicks_idx_0 = q_d[2];
        HalfMaxTicks_idx_0 *= a_min;
        q_d[2] = HalfMaxTicks_idx_0;
        HalfMaxTicks_idx_0 = q_d[3];
        HalfMaxTicks_idx_0 *= a_min;
        q_d[3] = HalfMaxTicks_idx_0;
        sum_term = L;
        sum_term += q_d[1];
        L = sum_term;
        sum_term = alpha;
        sum_term += q_d[2];
        alpha = sum_term;
        sum_term = sum_term_idx_3;
        sum_term += q_d[3];
        sum_term_idx_3 = sum_term;
      }

      sum_term = L;
      sum_term *= 5.0;
      L = sum_term;
      sum_term = alpha;
      sum_term *= 5.0;
      alpha = sum_term;
      sum_term = sum_term_idx_3;
      sum_term *= 5.0;
      sum_term_idx_3 = sum_term;
      sum_term = L;
      sum_term *= t11;
      L = sum_term;
      sum_term = alpha;
      sum_term *= t11;
      alpha = sum_term;
      sum_term = sum_term_idx_3;
      sum_term *= t11;
      sum_term_idx_3 = sum_term;
      if ((s_st > 0.0) && (s_sw > 0.0)) {
        obj_0->contactGround = 1.0;
      }

      if ((obj_0->tauPhase > 1.0) && (obj_0->contactGround > 0.0)) {
        varargin_1 = (obj_0->tauPhase - 1.0) * 1.3962634015954636;
        if (varargin_1 <= 0.55850536063818546) {
          t99 = varargin_1;
        } else {
          t99 = 0.55850536063818546;
        }

        q3R += t99;
        t30 = 1.3962634015954636 * t11;
        b = (obj_0->tauPhase < 1.4);
        y_5 = t30 * (real_T)b;
        alpha += y_5;
      }

      for (rtemp = 0; rtemp < 6; rtemp++) {
        alpha_0[rtemp] = tmp_1[rtemp];
      }

      sum_term = 0.0;
      for (r1 = 0; r1 < 6; r1++) {
        t99 = r1;
        CurrentYaw = t99;
        if (CurrentYaw > 2.5) {
          CurrentYaw = 5.0 - CurrentYaw;
        }

        y_5 = 1.0;
        a21 = 5.0 - CurrentYaw;
        iyLead = (int32_T)CurrentYaw - 1;
        for (j = 0; j <= iyLead; j++) {
          n = 1.0 + (real_T)j;
          y_5 *= (n + a21) / n;
        }

        y_5 = rt_roundd_snf(y_5);
        y_0 = rt_powd_snf(t3, t99);
        t30 = 1.0 - t3;
        a_min = 5.0 - t99;
        y_1 = rt_powd_snf(t30, a_min);
        n = alpha_0[(int32_T)t99] * y_5 * (y_0 * y_1);
        sum_term += n;
      }

      hd2 = (t21 + a_max) * sum_term;
      for (rtemp = 0; rtemp < 5; rtemp++) {
        x_1[rtemp] = tmp_2[rtemp];
      }

      sum_term = 0.0;
      for (r1 = 0; r1 < 5; r1++) {
        t99 = r1;
        CurrentYaw = t99;
        if (CurrentYaw > 2.0) {
          CurrentYaw = 4.0 - CurrentYaw;
        }

        y_5 = 1.0;
        a21 = 4.0 - CurrentYaw;
        iyLead = (int32_T)CurrentYaw - 1;
        for (j = 0; j <= iyLead; j++) {
          n = 1.0 + (real_T)j;
          y_5 *= (n + a21) / n;
        }

        y_5 = rt_roundd_snf(y_5);
        y_0 = rt_powd_snf(t3, t99);
        t30 = 1.0 - t3;
        a_min = 4.0 - t99;
        y_1 = rt_powd_snf(t30, a_min);
        n = x_1[(int32_T)t99] * y_5 * (y_0 * y_1);
        sum_term += n;
      }

      n = sum_term * 5.0 * t11 * t21;
      q_sw_h_tgt += hd2;
      L += n;
      t30 = q_st_lA + q_st_lB;
      y_5 = t30 / 2.0;
      sum_term_idx_0_0 = 6.2831853071795862 - y_5;
      sum_term_idx_0_0 += -q_pitch * s_st;
      sum_term_idx_0 = -dq_pitch * s_st;
      q_sw_h_tgt += -q_pitch * s_sw;
      L += -dq_pitch * s_sw;
      vKneeSpring[0] = (dq_st_lB - dq_st_lA) - (dq_st_mB - dq_st_mA);
      vKneeSpring[1] = (dq_sw_lB - dq_sw_lA) - (dq_sw_mB - dq_sw_mA);
      t30 = obj_0->kd_vs;
      HalfMaxTicks_idx_0 = vKneeSpring[0];
      HalfMaxTicks_idx_0 *= t30;
      vKneeSpring[0] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = vKneeSpring[1];
      HalfMaxTicks_idx_0 *= t30;
      vKneeSpring[1] = HalfMaxTicks_idx_0;
      memcpy(&A[0], &tmp_0[0], sizeof(real_T) << 4U);
      q_d[2] = -vKneeSpring[0];
      q_d[3] = -vKneeSpring[1];
      ipiv[0] = 1;
      ipiv[1] = 2;
      ipiv[2] = 3;
      for (j = 0; j < 3; j++) {
        r2 = j;
        mmj = 3 - j;
        c_0 = r2 * 5;
        jj = 1 + c_0;
        jp1j = jj + 1;
        c_0 = mmj + 1;
        for (rtemp = 0; rtemp < 16; rtemp++) {
          HalfMaxTicks_idx_0 = A[rtemp];
          A_0[rtemp] = HalfMaxTicks_idx_0;
        }

        i = 1;
        ix = jj - 1;
        x_re = A_0[jj - 1];
        y_5 = fabs(x_re);
        n = y_5;
        for (r1 = 2; r1 <= c_0; r1++) {
          ix++;
          x_re = A_0[ix];
          y_5 = fabs(x_re);
          CurrentYaw = y_5;
          if (CurrentYaw > n) {
            i = r1;
            n = CurrentYaw;
          }
        }

        i--;
        r1 = (jj + i) - 1;
        if (A[r1] != 0.0) {
          if (i != 0) {
            c_0 = (j + i) + 1;
            ipiv[j] = (int8_T)c_0;
            r1 = r2 + i;
            n = A[r2];
            A[r2] = A[r1];
            A[r1] = n;
            r2 += 4;
            r1 += 4;
            n = A[r2];
            A[r2] = A[r1];
            A[r1] = n;
            r2 += 4;
            r1 += 4;
            n = A[r2];
            A[r2] = A[r1];
            A[r1] = n;
            r2 += 4;
            r1 += 4;
            n = A[r2];
            A[r2] = A[r1];
            A[r1] = n;
          }

          c_0 = mmj - 1;
          iyLead = jp1j + c_0;
          for (rtemp = jp1j - 1; rtemp + 1 <= iyLead; rtemp++) {
            x_re = A[rtemp];
            y_5 = A[jj - 1];
            CurrentYaw = x_re / y_5;
            A[rtemp] = CurrentYaw;
          }
        }

        c_0 = 3 - j;
        rtemp = jj + 3;
        r1 = jj + 5;
        r1--;
        for (r2 = 1; r2 <= c_0; r2++) {
          n = A[rtemp];
          if (n != 0.0) {
            n = -n;
            ix = jp1j - 1;
            i = r1;
            iyLead = mmj + r1;
            while (i + 1 <= iyLead) {
              A[i] += A[ix] * n;
              ix++;
              i++;
            }
          }

          rtemp += 4;
          r1 += 4;
        }
      }

      q_d[0] = 0.0;
      q_d[1] = 0.0;
      HalfMaxTicks_idx_0 = q_d[2];
      q_d[2] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = q_d[3];
      q_d[3] = HalfMaxTicks_idx_0;
      if (ipiv[0] != 1) {
        r1 = ipiv[0] - 1;
        q_d[0] = q_d[r1];
        q_d[r1] = 0.0;
      }

      if (ipiv[1] != 2) {
        r1 = ipiv[1] - 1;
        q_d[1] = q_d[r1];
        q_d[r1] = 0.0;
      }

      if (ipiv[2] != 3) {
        r1 = ipiv[2] - 1;
        n = q_d[2];
        q_d[2] = q_d[r1];
        q_d[r1] = n;
      }

      for (rtemp = 0; rtemp < 16; rtemp++) {
        HalfMaxTicks_idx_0 = A[rtemp];
        A_0[rtemp] = HalfMaxTicks_idx_0;
      }

      if (q_d[0] != 0.0) {
        for (rtemp = 1; rtemp + 1 < 5; rtemp++) {
          q_d[rtemp] -= q_d[0] * A_0[rtemp];
        }
      }

      if (q_d[1] != 0.0) {
        for (rtemp = 2; rtemp + 1 < 5; rtemp++) {
          q_d[rtemp] -= A_0[rtemp + 4] * q_d[1];
        }
      }

      if (q_d[2] != 0.0) {
        for (rtemp = 3; rtemp + 1 < 5; rtemp++) {
          q_d[rtemp] -= A_0[rtemp + 8] * q_d[2];
        }
      }

      if (q_d[3] != 0.0) {
        x_re = q_d[3];
        y_5 = A[15];
        CurrentYaw = x_re / y_5;
        q_d[3] = CurrentYaw;
        for (rtemp = 0; rtemp + 1 < 4; rtemp++) {
          q_d[rtemp] -= A[rtemp + 12] * q_d[3];
        }
      }

      if (q_d[2] != 0.0) {
        x_re = q_d[2];
        y_5 = A[10];
        CurrentYaw = x_re / y_5;
        q_d[2] = CurrentYaw;
        for (rtemp = 0; rtemp + 1 < 3; rtemp++) {
          q_d[rtemp] -= A[rtemp + 8] * q_d[2];
        }
      }

      if (q_d[1] != 0.0) {
        x_re = q_d[1];
        y_5 = A[5];
        CurrentYaw = x_re / y_5;
        q_d[1] = CurrentYaw;
        for (rtemp = 0; rtemp + 1 < 2; rtemp++) {
          q_d[rtemp] -= A[rtemp + 4] * q_d[1];
        }
      }

      if (q_d[0] != 0.0) {
        x_re = q_d[0];
        y_5 = A[0];
        CurrentYaw = x_re / y_5;
        q_d[0] = CurrentYaw;
      }

      uDamping_idx_3 = q_d[0];
      CalOffset_idx_0 = uDamping_idx_3;
      uDamping_idx_3 = q_d[1];
      CalOffset_idx_1 = uDamping_idx_3;
      uDamping_idx_3 = q_d[2];
      uDamping_idx_2 = uDamping_idx_3;
      uDamping_idx_3 = q_d[3];
      for (rtemp = 0; rtemp < 16; rtemp++) {
        HalfMaxTicks_idx_0 = tmp_0[rtemp];
        A[rtemp] = HalfMaxTicks_idx_0;
      }

      ipiv[0] = 1;
      ipiv[1] = 2;
      ipiv[2] = 3;
      for (j = 0; j < 3; j++) {
        r2 = j;
        mmj = 3 - j;
        c_0 = r2 * 5;
        jj = 1 + c_0;
        jp1j = jj + 1;
        c_0 = mmj + 1;
        for (rtemp = 0; rtemp < 16; rtemp++) {
          HalfMaxTicks_idx_0 = A[rtemp];
          A_0[rtemp] = HalfMaxTicks_idx_0;
        }

        i = 1;
        ix = jj - 1;
        x_re = A_0[jj - 1];
        y_5 = fabs(x_re);
        n = y_5;
        for (r1 = 2; r1 <= c_0; r1++) {
          ix++;
          x_re = A_0[ix];
          y_5 = fabs(x_re);
          CurrentYaw = y_5;
          if (CurrentYaw > n) {
            i = r1;
            n = CurrentYaw;
          }
        }

        i--;
        r1 = (jj + i) - 1;
        if (A[r1] != 0.0) {
          if (i != 0) {
            c_0 = (j + i) + 1;
            ipiv[j] = (int8_T)c_0;
            r1 = r2 + i;
            n = A[r2];
            A[r2] = A[r1];
            A[r1] = n;
            r2 += 4;
            r1 += 4;
            n = A[r2];
            A[r2] = A[r1];
            A[r1] = n;
            r2 += 4;
            r1 += 4;
            n = A[r2];
            A[r2] = A[r1];
            A[r1] = n;
            r2 += 4;
            r1 += 4;
            n = A[r2];
            A[r2] = A[r1];
            A[r1] = n;
          }

          c_0 = mmj - 1;
          iyLead = jp1j + c_0;
          for (rtemp = jp1j - 1; rtemp + 1 <= iyLead; rtemp++) {
            x_re = A[rtemp];
            y_5 = A[jj - 1];
            CurrentYaw = x_re / y_5;
            A[rtemp] = CurrentYaw;
          }
        }

        c_0 = 3 - j;
        rtemp = jj + 3;
        r1 = jj + 5;
        r1--;
        for (r2 = 1; r2 <= c_0; r2++) {
          n = A[rtemp];
          if (n != 0.0) {
            n = -n;
            ix = jp1j - 1;
            i = r1;
            iyLead = mmj + r1;
            while (i + 1 <= iyLead) {
              A[i] += A[ix] * n;
              ix++;
              i++;
            }
          }

          rtemp += 4;
          r1 += 4;
        }
      }

      hd_q[0] = sum_term_idx_0_0;
      hd_q[1] = q_sw_h_tgt;
      hd_q[2] = q3R;
      hd_q[3] = y_sw_tgt;
      if (ipiv[0] != 1) {
        r1 = ipiv[0] - 1;
        n = hd_q[0];
        hd_q[0] = hd_q[r1];
        hd_q[r1] = n;
      }

      if (ipiv[1] != 2) {
        r1 = ipiv[1] - 1;
        n = hd_q[1];
        hd_q[1] = hd_q[r1];
        hd_q[r1] = n;
      }

      if (ipiv[2] != 3) {
        r1 = ipiv[2] - 1;
        n = hd_q[2];
        hd_q[2] = hd_q[r1];
        hd_q[r1] = n;
      }

      for (rtemp = 0; rtemp < 16; rtemp++) {
        HalfMaxTicks_idx_0 = A[rtemp];
        A_0[rtemp] = HalfMaxTicks_idx_0;
      }

      if (hd_q[0] != 0.0) {
        for (rtemp = 1; rtemp + 1 < 5; rtemp++) {
          hd_q[rtemp] -= hd_q[0] * A_0[rtemp];
        }
      }

      if (hd_q[1] != 0.0) {
        for (rtemp = 2; rtemp + 1 < 5; rtemp++) {
          hd_q[rtemp] -= A_0[rtemp + 4] * hd_q[1];
        }
      }

      if (hd_q[2] != 0.0) {
        for (rtemp = 3; rtemp + 1 < 5; rtemp++) {
          hd_q[rtemp] -= A_0[rtemp + 8] * hd_q[2];
        }
      }

      if (hd_q[3] != 0.0) {
        x_re = hd_q[3];
        y_5 = A[15];
        CurrentYaw = x_re / y_5;
        hd_q[3] = CurrentYaw;
        for (rtemp = 0; rtemp + 1 < 4; rtemp++) {
          hd_q[rtemp] -= A[rtemp + 12] * hd_q[3];
        }
      }

      if (hd_q[2] != 0.0) {
        x_re = hd_q[2];
        y_5 = A[10];
        CurrentYaw = x_re / y_5;
        hd_q[2] = CurrentYaw;
        for (rtemp = 0; rtemp + 1 < 3; rtemp++) {
          hd_q[rtemp] -= A[rtemp + 8] * hd_q[2];
        }
      }

      if (hd_q[1] != 0.0) {
        x_re = hd_q[1];
        y_5 = A[5];
        CurrentYaw = x_re / y_5;
        hd_q[1] = CurrentYaw;
        for (rtemp = 0; rtemp + 1 < 2; rtemp++) {
          hd_q[rtemp] -= A[rtemp + 4] * hd_q[1];
        }
      }

      if (hd_q[0] != 0.0) {
        x_re = hd_q[0];
        y_5 = A[0];
        CurrentYaw = x_re / y_5;
        hd_q[0] = CurrentYaw;
      }

      HalfMaxTicks_idx_0 = hd_q[0];
      HalfMaxTicks_idx_0 = 6.2831853071795862 - HalfMaxTicks_idx_0;
      hd_q[0] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = hd_q[1];
      HalfMaxTicks_idx_0 = 6.2831853071795862 - HalfMaxTicks_idx_0;
      hd_q[1] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = hd_q[2];
      HalfMaxTicks_idx_0 = 6.2831853071795862 - HalfMaxTicks_idx_0;
      hd_q[2] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = hd_q[3];
      HalfMaxTicks_idx_0 = 6.2831853071795862 - HalfMaxTicks_idx_0;
      hd_q[3] = HalfMaxTicks_idx_0;
      for (rtemp = 0; rtemp < 16; rtemp++) {
        HalfMaxTicks_idx_0 = tmp_3[rtemp];
        A[rtemp] = HalfMaxTicks_idx_0;
      }

      ipiv[0] = 1;
      ipiv[1] = 2;
      ipiv[2] = 3;
      for (j = 0; j < 3; j++) {
        r2 = j;
        mmj = 3 - j;
        c_0 = r2 * 5;
        jj = 1 + c_0;
        jp1j = jj + 1;
        c_0 = mmj + 1;
        for (rtemp = 0; rtemp < 16; rtemp++) {
          HalfMaxTicks_idx_0 = A[rtemp];
          A_0[rtemp] = HalfMaxTicks_idx_0;
        }

        i = 1;
        ix = jj - 1;
        x_re = A_0[jj - 1];
        y_5 = fabs(x_re);
        n = y_5;
        for (r1 = 2; r1 <= c_0; r1++) {
          ix++;
          x_re = A_0[ix];
          y_5 = fabs(x_re);
          CurrentYaw = y_5;
          if (CurrentYaw > n) {
            i = r1;
            n = CurrentYaw;
          }
        }

        i--;
        r1 = (jj + i) - 1;
        if (A[r1] != 0.0) {
          if (i != 0) {
            c_0 = (j + i) + 1;
            ipiv[j] = (int8_T)c_0;
            r1 = r2 + i;
            n = A[r2];
            A[r2] = A[r1];
            A[r1] = n;
            r2 += 4;
            r1 += 4;
            n = A[r2];
            A[r2] = A[r1];
            A[r1] = n;
            r2 += 4;
            r1 += 4;
            n = A[r2];
            A[r2] = A[r1];
            A[r1] = n;
            r2 += 4;
            r1 += 4;
            n = A[r2];
            A[r2] = A[r1];
            A[r1] = n;
          }

          c_0 = mmj - 1;
          iyLead = jp1j + c_0;
          for (rtemp = jp1j - 1; rtemp + 1 <= iyLead; rtemp++) {
            x_re = A[rtemp];
            y_5 = A[jj - 1];
            CurrentYaw = x_re / y_5;
            A[rtemp] = CurrentYaw;
          }
        }

        c_0 = 3 - j;
        rtemp = jj + 3;
        r1 = jj + 5;
        r1--;
        for (r2 = 1; r2 <= c_0; r2++) {
          n = A[rtemp];
          if (n != 0.0) {
            n = -n;
            ix = jp1j - 1;
            i = r1;
            iyLead = mmj + r1;
            while (i + 1 <= iyLead) {
              A[i] += A[ix] * n;
              ix++;
              i++;
            }
          }

          rtemp += 4;
          r1 += 4;
        }
      }

      q_d[0] = sum_term_idx_0;
      q_d[1] = L;
      q_d[2] = alpha;
      q_d[3] = sum_term_idx_3;
      if (ipiv[0] != 1) {
        r1 = ipiv[0] - 1;
        n = q_d[0];
        q_d[0] = q_d[r1];
        q_d[r1] = n;
      }

      if (ipiv[1] != 2) {
        r1 = ipiv[1] - 1;
        n = q_d[1];
        q_d[1] = q_d[r1];
        q_d[r1] = n;
      }

      if (ipiv[2] != 3) {
        r1 = ipiv[2] - 1;
        n = q_d[2];
        q_d[2] = q_d[r1];
        q_d[r1] = n;
      }

      for (rtemp = 0; rtemp < 16; rtemp++) {
        HalfMaxTicks_idx_0 = A[rtemp];
        A_0[rtemp] = HalfMaxTicks_idx_0;
      }

      if (q_d[0] != 0.0) {
        for (rtemp = 1; rtemp + 1 < 5; rtemp++) {
          q_d[rtemp] -= q_d[0] * A_0[rtemp];
        }
      }

      if (q_d[1] != 0.0) {
        for (rtemp = 2; rtemp + 1 < 5; rtemp++) {
          q_d[rtemp] -= A_0[rtemp + 4] * q_d[1];
        }
      }

      if (q_d[2] != 0.0) {
        for (rtemp = 3; rtemp + 1 < 5; rtemp++) {
          q_d[rtemp] -= A_0[rtemp + 8] * q_d[2];
        }
      }

      if (q_d[3] != 0.0) {
        x_re = q_d[3];
        y_5 = A[15];
        CurrentYaw = x_re / y_5;
        q_d[3] = CurrentYaw;
        for (rtemp = 0; rtemp + 1 < 4; rtemp++) {
          q_d[rtemp] -= A[rtemp + 12] * q_d[3];
        }
      }

      if (q_d[2] != 0.0) {
        x_re = q_d[2];
        y_5 = A[10];
        CurrentYaw = x_re / y_5;
        q_d[2] = CurrentYaw;
        for (rtemp = 0; rtemp + 1 < 3; rtemp++) {
          q_d[rtemp] -= A[rtemp + 8] * q_d[2];
        }
      }

      if (q_d[1] != 0.0) {
        x_re = q_d[1];
        y_5 = A[5];
        CurrentYaw = x_re / y_5;
        q_d[1] = CurrentYaw;
        for (rtemp = 0; rtemp + 1 < 2; rtemp++) {
          q_d[rtemp] -= A[rtemp + 4] * q_d[1];
        }
      }

      if (q_d[0] != 0.0) {
        x_re = q_d[0];
        y_5 = A[0];
        CurrentYaw = x_re / y_5;
        q_d[0] = CurrentYaw;
      }

      NormalizedCountPrev[0] = q_roll;
      NormalizedCountPrev[1] = obj_0->q_yaw;
      NormalizedCountPrev[2] = q_pitch;
      NormalizedCountPrev[3] = hd_q[0];
      NormalizedCountPrev[4] = hd_q[1];
      NormalizedCountPrev[5] = hd_q[2];
      NormalizedCountPrev[6] = hd_q[3];
      NormalizedCountPrev[7] = 0.0;
      NormalizedCountPrev[8] = 0.0;
      NormalizedCount[0] = q_roll;
      NormalizedCount[1] = obj_0->q_yaw;
      NormalizedCount[2] = q_pitch;
      NormalizedCount[3] = q_st_mA;
      NormalizedCount[4] = q_st_mB;
      NormalizedCount[5] = q_sw_mA;
      NormalizedCount[6] = q_sw_mB;
      NormalizedCount[7] = 0.0;
      NormalizedCount[8] = 0.0;
      x_re = obj_0->dx_tgt;
      y_5 = fabs(x_re);
      x_re = obj_0->dy_tgt;
      y_0 = fabs(x_re);
      dq_d[0] = dq_roll;
      dq_d[1] = obj_0->dq_yaw;
      dq_d[2] = dq_pitch;
      dq_d[3] = q_d[0];
      dq_d[4] = q_d[1];
      dq_d[5] = q_d[2];
      dq_d[6] = q_d[3];
      dq_d[7] = y_5 * t3;
      dq_d[8] = y_0 * t3;
      x_re = obj_0->dx_est;
      y_5 = fabs(x_re);
      t30 = obj_0->dy_est + obj_0->dy_est_last;
      y_0 = t30 / 2.0;
      y_0 = fabs(y_0);
      dq_0[0] = dq_roll;
      dq_0[1] = obj_0->dq_yaw;
      dq_0[2] = dq_pitch;
      dq_0[3] = dq_st_mA;
      dq_0[4] = dq_st_mB;
      dq_0[5] = dq_sw_mA;
      dq_0[6] = dq_sw_mB;
      dq_0[7] = y_5 * t3;
      dq_0[8] = y_0 * t3;
      for (rtemp = 0; rtemp < 36; rtemp++) {
        a[rtemp] = tmp_4[rtemp];
      }

      for (rtemp = 0; rtemp < 9; rtemp++) {
        HalfMaxTicks_idx_1 = NormalizedCountPrev[rtemp];
        HalfMaxTicks_idx_1 -= NormalizedCount[rtemp];
        NormalizedCountPrev[rtemp] = HalfMaxTicks_idx_1;
      }

      for (rtemp = 0; rtemp < 4; rtemp++) {
        q_d[rtemp] = 0.0;
        for (i = 0; i < 9; i++) {
          HalfMaxTicks_idx_0 = q_d[rtemp];
          HalfMaxTicks_idx_0 += (real_T)a[(i << 2) + rtemp] *
            NormalizedCountPrev[i];
          q_d[rtemp] = HalfMaxTicks_idx_0;
        }
      }

      for (rtemp = 0; rtemp < 36; rtemp++) {
        a[rtemp] = tmp_4[rtemp];
      }

      for (rtemp = 0; rtemp < 9; rtemp++) {
        HalfMaxTicks_idx_0 = dq_d[rtemp];
        HalfMaxTicks_idx_0 -= dq_0[rtemp];
        dq_d[rtemp] = HalfMaxTicks_idx_0;
      }

      for (rtemp = 0; rtemp < 4; rtemp++) {
        delta_dq[rtemp] = 0.0;
        for (i = 0; i < 9; i++) {
          HalfMaxTicks_idx_0 = delta_dq[rtemp];
          HalfMaxTicks_idx_0 += (real_T)a[(i << 2) + rtemp] * dq_d[i];
          delta_dq[rtemp] = HalfMaxTicks_idx_0;
        }
      }

      n = (1.0 - s_st) * obj_0->kp_sw_leg + s_st * obj_0->kp_st_leg;
      CurrentYaw = (1.0 - s_st) * obj_0->kd_sw_leg + s_st * obj_0->kd_st_leg;
      a21 = (1.0 - s_sw) * obj_0->kp_sw_leg + s_sw * obj_0->kp_st_leg;
      a_max = (1.0 - s_sw) * obj_0->kd_sw_leg + s_sw * obj_0->kd_st_leg;
      u_Link_idx_0 = (n * q_d[0] + CurrentYaw * delta_dq[0]) + CalOffset_idx_0;
      u_Link_idx_1 = (n * q_d[1] + CurrentYaw * delta_dq[1]) + CalOffset_idx_1;
      u_Link_idx_2 = (a21 * q_d[2] + a_max * delta_dq[2]) + uDamping_idx_2;
      u_Link_idx_3 = (a21 * q_d[3] + a_max * delta_dq[3]) + uDamping_idx_3;
      CurrentYaw = u_Link_idx_0 - u_Link_idx_1;
      t30 = u_Link_idx_0 + u_Link_idx_1;
      n = t30 / 2.0;
      a_max = -obj_0->u_lim;
      t99 = obj_0->u_lim;
      a_min = -obj_0->u_lim;
      t21 = obj_0->u_lim;

      /* -------------------------------------------------------------------------- */
      /*  Inputs: */
      /*  1) u_LS: desired LS torque */
      /*  2) u_LA: desired LA torque */
      /*  3) w: weight in the cost function. Note that w should be strictly positive. */
      /*  The cost function is defined as */
      /*  J = (Delta J_LS)^2 + w * (Delta J_LA)^2 */
      /*  4) u1_min: lower bound on u1 */
      /*  5) u1_max: upper bound on u1 */
      /*  6) u2_min: lower bound on u2 */
      /*  7) u2_max: upper bound on u2 */
      /* -------------------------------------------------------------------------- */
      /*  Outputs: */
      /*  1) u_opt: optimal solution of the QP */
      /*  2) L_opt: Lagrange multipliers at the optimal solution */
      /*  3) case_m: case number. */
      /* -------------------------------------------------------------------------- */
      /*  Consider different cases */
      /* %%%%%  03-Jun-2013 08:50:09 */
      /* %%% */
      /* ------------------------------------------------------ */
      /*  u_opt */
      t30 = -((2.0 * CurrentYaw + n * 100.0) * 96.0);
      y_5 = t30 / 800.0;
      t30 = (2.0 * CurrentYaw - n * 100.0) * 104.0;
      y_0 = t30 / 800.0;
      HalfMaxTicks_idx_0 = y_5 - y_0;
      t30 = (2.0 * CurrentYaw + n * 100.0) * 104.0;
      y_5 = t30 / 800.0;
      t30 = (2.0 * CurrentYaw - n * 100.0) * 96.0;
      y_0 = t30 / 800.0;
      HalfMaxTicks_idx_1 = y_5 + y_0;

      /* ------------------------------------------------------ */
      /*  L_opt */
      /* %%%%%  03-Jun-2013 08:50:11 */
      /* %%% */
      /* ------------------------------------------------------ */
      /*  u_opt */
      t30 = ((4.0 * a_max + 4.0 * CurrentYaw) - a_max * 100.0) + 2.0 * n * 100.0;
      y_5 = t30 / 104.0;
      CalOffset_idx_0 = y_5;

      /* ------------------------------------------------------ */
      /*  L_opt */
      t30 = (8.0 * a_max * 100.0 - 8.0 * n * 100.0) + 4.0 * CurrentYaw * 100.0;
      y_5 = t30 / 104.0;
      L_opt_2[0] = y_5;
      L_opt_2[1] = 0.0;
      L_opt_2[2] = 0.0;
      L_opt_2[3] = 0.0;

      /* %%%%%  03-Jun-2013 08:50:11 */
      /* %%% */
      /* ------------------------------------------------------ */
      /*  u_opt */
      t30 = ((4.0 * t99 + 4.0 * CurrentYaw) - t99 * 100.0) + 2.0 * n * 100.0;
      y_5 = t30 / 104.0;
      CalOffset_idx_1 = y_5;

      /* ------------------------------------------------------ */
      /*  L_opt */
      L_opt_3[0] = 0.0;
      t30 = -((8.0 * t99 * 100.0 - 8.0 * n * 100.0) + 4.0 * CurrentYaw * 100.0);
      y_5 = t30 / 104.0;
      L_opt_3[1] = y_5;
      L_opt_3[2] = 0.0;
      L_opt_3[3] = 0.0;

      /* %%%%%  03-Jun-2013 08:50:11 */
      /* %%% */
      /* ------------------------------------------------------ */
      /*  u_opt */
      t30 = ((4.0 * a_min - 4.0 * CurrentYaw) - a_min * 100.0) + 2.0 * n * 100.0;
      y_5 = t30 / 104.0;
      uDamping_idx_2 = y_5;

      /* ------------------------------------------------------ */
      /*  L_opt */
      L_opt_4[0] = 0.0;
      L_opt_4[1] = 0.0;
      t30 = -((8.0 * n * 100.0 - 8.0 * a_min * 100.0) + 4.0 * CurrentYaw * 100.0);
      y_5 = t30 / 104.0;
      L_opt_4[2] = y_5;
      L_opt_4[3] = 0.0;

      /* %%%%%  03-Jun-2013 08:50:12 */
      /* %%% */
      /* ------------------------------------------------------ */
      /*  u_opt */
      t30 = ((4.0 * t21 - 4.0 * CurrentYaw) - t21 * 100.0) + 2.0 * n * 100.0;
      y_5 = t30 / 104.0;
      uDamping_idx_3 = y_5;

      /* ------------------------------------------------------ */
      /*  L_opt */
      L_opt_5[0] = 0.0;
      L_opt_5[1] = 0.0;
      L_opt_5[2] = 0.0;
      t30 = (8.0 * n * 100.0 - 8.0 * t21 * 100.0) + 4.0 * CurrentYaw * 100.0;
      y_5 = t30 / 104.0;
      L_opt_5[3] = y_5;

      /* %%%%%  03-Jun-2013 08:50:12 */
      /* %%% */
      /* ------------------------------------------------------ */
      /*  u_opt */
      /* ------------------------------------------------------ */
      /*  L_opt */
      y_5 = a_max / 2.0;
      y_0 = a_min / 2.0;
      L_opt_6[0] = ((2.0 * a_max - 2.0 * a_min) + 2.0 * CurrentYaw) + ((y_5 +
        y_0) - n) * 100.0;
      L_opt_6[1] = 0.0;
      y_5 = a_max / 2.0;
      y_0 = a_min / 2.0;
      L_opt_6[2] = ((2.0 * a_min - 2.0 * a_max) - 2.0 * CurrentYaw) + ((y_5 +
        y_0) - n) * 100.0;
      L_opt_6[3] = 0.0;

      /* %%%%%  03-Jun-2013 08:50:13 */
      /* %%% */
      /* ------------------------------------------------------ */
      /*  u_opt */
      /* ------------------------------------------------------ */
      /*  L_opt */
      y_5 = a_max / 2.0;
      y_0 = t21 / 2.0;
      L_opt_7[0] = ((2.0 * a_max - 2.0 * t21) + 2.0 * CurrentYaw) + ((y_5 + y_0)
        - n) * 100.0;
      L_opt_7[1] = 0.0;
      L_opt_7[2] = 0.0;
      t30 = a_max * 100.0;
      y_5 = t30 / 2.0;
      t30 = t21 * 100.0;
      y_0 = t30 / 2.0;
      L_opt_7[3] = ((((2.0 * a_max - 2.0 * t21) + 2.0 * CurrentYaw) - y_5) - y_0)
        + n * 100.0;

      /* %%%%%  03-Jun-2013 08:50:13 */
      /* %%% */
      /* ------------------------------------------------------ */
      /*  u_opt */
      /* ------------------------------------------------------ */
      /*  L_opt */
      L_opt_8[0] = 0.0;
      t30 = a_min * 100.0;
      y_5 = t30 / 2.0;
      t30 = t99 * 100.0;
      y_0 = t30 / 2.0;
      L_opt_8[1] = ((((2.0 * a_min - 2.0 * t99) - 2.0 * CurrentYaw) - y_5) - y_0)
        + n * 100.0;
      y_5 = a_min / 2.0;
      y_0 = t99 / 2.0;
      L_opt_8[2] = ((2.0 * a_min - 2.0 * t99) - 2.0 * CurrentYaw) + ((y_5 + y_0)
        - n) * 100.0;
      L_opt_8[3] = 0.0;

      /* %%%%%  03-Jun-2013 08:50:13 */
      /* %%% */
      /* ------------------------------------------------------ */
      /*  u_opt */
      /* ------------------------------------------------------ */
      /*  L_opt */
      L_opt_9[0] = 0.0;
      t30 = t99 * 100.0;
      y_5 = t30 / 2.0;
      t30 = t21 * 100.0;
      y_0 = t30 / 2.0;
      L_opt_9[1] = ((((2.0 * t21 - 2.0 * t99) - 2.0 * CurrentYaw) - y_5) - y_0)
        + n * 100.0;
      L_opt_9[2] = 0.0;
      t30 = t99 * 100.0;
      y_5 = t30 / 2.0;
      t30 = t21 * 100.0;
      y_0 = t30 / 2.0;
      L_opt_9[3] = ((((2.0 * t99 - 2.0 * t21) + 2.0 * CurrentYaw) - y_5) - y_0)
        + n * 100.0;

      /*  Lower and upper bounds for [u1; u2] */
      vKneeSpring[0] = a_max;
      vKneeSpring[1] = a_min;
      uLegSpring[0] = t99;
      uLegSpring[1] = t21;

      /*  Set the initial value */
      AbsEncoder[0] = 0.0;
      AbsEncoder[1] = 0.0;

      /*  Case 1 */
      AbsUnrolled[0] = HalfMaxTicks_idx_0 - uLegSpring[0];
      AbsUnrolled[1] = HalfMaxTicks_idx_1 - uLegSpring[1];
      r1 = 1;
      n = AbsUnrolled[0];
      b = rtIsNaN(n);
      if (b) {
        ix = 2;
        exitg40 = false;
        while ((exitg40 == false) && (ix < 3)) {
          r1 = 2;
          x_re = AbsUnrolled[1];
          b = rtIsNaN(x_re);
          if (!b) {
            n = AbsUnrolled[1];
            exitg40 = true;
          } else {
            ix = 3;
          }
        }
      }

      if (r1 < 2) {
        for (ix = 1; ix + 1 < 3; ix++) {
          t30 = AbsUnrolled[ix];
          p = (t30 > n);
          if (p) {
            n = AbsUnrolled[ix];
          }
        }
      }

      if (n <= 0.0) {
        AbsUnrolled[0] = HalfMaxTicks_idx_0 - vKneeSpring[0];
        AbsUnrolled[1] = HalfMaxTicks_idx_1 - vKneeSpring[1];
        r1 = 1;
        n = AbsUnrolled[0];
        b = rtIsNaN(n);
        if (b) {
          ix = 2;
          exitg39 = false;
          while ((exitg39 == false) && (ix < 3)) {
            r1 = 2;
            x_re = AbsUnrolled[1];
            b = rtIsNaN(x_re);
            if (!b) {
              n = AbsUnrolled[1];
              exitg39 = true;
            } else {
              ix = 3;
            }
          }
        }

        if (r1 < 2) {
          for (ix = 1; ix + 1 < 3; ix++) {
            t30 = AbsUnrolled[ix];
            p = (t30 < n);
            if (p) {
              n = AbsUnrolled[ix];
            }
          }
        }

        if (n >= 0.0) {
          AbsEncoder[0] = HalfMaxTicks_idx_0;
          AbsEncoder[1] = HalfMaxTicks_idx_1;
        }
      }

      /*  Case 2 */
      AbsUnrolled[0] = a_max - uLegSpring[0];
      AbsUnrolled[1] = CalOffset_idx_0 - uLegSpring[1];
      r1 = 1;
      n = AbsUnrolled[0];
      b = rtIsNaN(n);
      if (b) {
        ix = 2;
        exitg38 = false;
        while ((exitg38 == false) && (ix < 3)) {
          r1 = 2;
          x_re = AbsUnrolled[1];
          b = rtIsNaN(x_re);
          if (!b) {
            n = AbsUnrolled[1];
            exitg38 = true;
          } else {
            ix = 3;
          }
        }
      }

      if (r1 < 2) {
        for (ix = 1; ix + 1 < 3; ix++) {
          t30 = AbsUnrolled[ix];
          p = (t30 > n);
          if (p) {
            n = AbsUnrolled[ix];
          }
        }
      }

      if (n <= 0.0) {
        AbsUnrolled[0] = a_max - vKneeSpring[0];
        AbsUnrolled[1] = CalOffset_idx_0 - vKneeSpring[1];
        r1 = 1;
        n = AbsUnrolled[0];
        b = rtIsNaN(n);
        if (b) {
          ix = 2;
          exitg37 = false;
          while ((exitg37 == false) && (ix < 3)) {
            r1 = 2;
            x_re = AbsUnrolled[1];
            b = rtIsNaN(x_re);
            if (!b) {
              n = AbsUnrolled[1];
              exitg37 = true;
            } else {
              ix = 3;
            }
          }
        }

        if (r1 < 2) {
          for (ix = 1; ix + 1 < 3; ix++) {
            t30 = AbsUnrolled[ix];
            p = (t30 < n);
            if (p) {
              n = AbsUnrolled[ix];
            }
          }
        }

        if (n >= 0.0) {
          r1 = 1;
          n = L_opt_2[0];
          b = rtIsNaN(n);
          if (b) {
            r1 = 2;
            n = 0.0;
          }

          for (ix = r1; ix + 1 < 5; ix++) {
            t30 = L_opt_2[ix];
            p = (t30 < n);
            if (p) {
              n = L_opt_2[ix];
            }
          }

          if (n >= 0.0) {
            AbsEncoder[0] = a_max;
            AbsEncoder[1] = CalOffset_idx_0;
          }
        }
      }

      /*  Case 3 */
      AbsUnrolled[0] = t99 - uLegSpring[0];
      AbsUnrolled[1] = CalOffset_idx_1 - uLegSpring[1];
      r1 = 1;
      n = AbsUnrolled[0];
      b = rtIsNaN(n);
      if (b) {
        ix = 2;
        exitg36 = false;
        while ((exitg36 == false) && (ix < 3)) {
          r1 = 2;
          x_re = AbsUnrolled[1];
          b = rtIsNaN(x_re);
          if (!b) {
            n = AbsUnrolled[1];
            exitg36 = true;
          } else {
            ix = 3;
          }
        }
      }

      if (r1 < 2) {
        for (ix = 1; ix + 1 < 3; ix++) {
          t30 = AbsUnrolled[ix];
          p = (t30 > n);
          if (p) {
            n = AbsUnrolled[ix];
          }
        }
      }

      if (n <= 0.0) {
        AbsUnrolled[0] = t99 - vKneeSpring[0];
        AbsUnrolled[1] = CalOffset_idx_1 - vKneeSpring[1];
        r1 = 1;
        n = AbsUnrolled[0];
        b = rtIsNaN(n);
        if (b) {
          ix = 2;
          exitg35 = false;
          while ((exitg35 == false) && (ix < 3)) {
            r1 = 2;
            x_re = AbsUnrolled[1];
            b = rtIsNaN(x_re);
            if (!b) {
              n = AbsUnrolled[1];
              exitg35 = true;
            } else {
              ix = 3;
            }
          }
        }

        if (r1 < 2) {
          for (ix = 1; ix + 1 < 3; ix++) {
            t30 = AbsUnrolled[ix];
            p = (t30 < n);
            if (p) {
              n = AbsUnrolled[ix];
            }
          }
        }

        if (n >= 0.0) {
          n = 0.0;
          for (ix = 1; ix + 1 < 5; ix++) {
            t30 = L_opt_3[ix];
            p = (t30 < n);
            if (p) {
              n = L_opt_3[ix];
            }
          }

          if (n >= 0.0) {
            AbsEncoder[0] = t99;
            AbsEncoder[1] = CalOffset_idx_1;
          }
        }
      }

      /*  Case 4 */
      AbsUnrolled[0] = uDamping_idx_2 - uLegSpring[0];
      AbsUnrolled[1] = a_min - uLegSpring[1];
      r1 = 1;
      n = AbsUnrolled[0];
      b = rtIsNaN(n);
      if (b) {
        ix = 2;
        exitg34 = false;
        while ((exitg34 == false) && (ix < 3)) {
          r1 = 2;
          x_re = AbsUnrolled[1];
          b = rtIsNaN(x_re);
          if (!b) {
            n = AbsUnrolled[1];
            exitg34 = true;
          } else {
            ix = 3;
          }
        }
      }

      if (r1 < 2) {
        for (ix = 1; ix + 1 < 3; ix++) {
          t30 = AbsUnrolled[ix];
          p = (t30 > n);
          if (p) {
            n = AbsUnrolled[ix];
          }
        }
      }

      if (n <= 0.0) {
        AbsUnrolled[0] = uDamping_idx_2 - vKneeSpring[0];
        AbsUnrolled[1] = a_min - vKneeSpring[1];
        r1 = 1;
        n = AbsUnrolled[0];
        b = rtIsNaN(n);
        if (b) {
          ix = 2;
          exitg33 = false;
          while ((exitg33 == false) && (ix < 3)) {
            r1 = 2;
            x_re = AbsUnrolled[1];
            b = rtIsNaN(x_re);
            if (!b) {
              n = AbsUnrolled[1];
              exitg33 = true;
            } else {
              ix = 3;
            }
          }
        }

        if (r1 < 2) {
          for (ix = 1; ix + 1 < 3; ix++) {
            t30 = AbsUnrolled[ix];
            p = (t30 < n);
            if (p) {
              n = AbsUnrolled[ix];
            }
          }
        }

        if (n >= 0.0) {
          n = 0.0;
          for (ix = 1; ix + 1 < 5; ix++) {
            t30 = L_opt_4[ix];
            p = (t30 < n);
            if (p) {
              n = L_opt_4[ix];
            }
          }

          if (n >= 0.0) {
            AbsEncoder[0] = uDamping_idx_2;
            AbsEncoder[1] = a_min;
          }
        }
      }

      /*  Case 5 */
      AbsUnrolled[0] = uDamping_idx_3 - uLegSpring[0];
      AbsUnrolled[1] = t21 - uLegSpring[1];
      r1 = 1;
      n = AbsUnrolled[0];
      b = rtIsNaN(n);
      if (b) {
        ix = 2;
        exitg32 = false;
        while ((exitg32 == false) && (ix < 3)) {
          r1 = 2;
          x_re = AbsUnrolled[1];
          b = rtIsNaN(x_re);
          if (!b) {
            n = AbsUnrolled[1];
            exitg32 = true;
          } else {
            ix = 3;
          }
        }
      }

      if (r1 < 2) {
        for (ix = 1; ix + 1 < 3; ix++) {
          t30 = AbsUnrolled[ix];
          p = (t30 > n);
          if (p) {
            n = AbsUnrolled[ix];
          }
        }
      }

      if (n <= 0.0) {
        AbsUnrolled[0] = uDamping_idx_3 - vKneeSpring[0];
        AbsUnrolled[1] = t21 - vKneeSpring[1];
        r1 = 1;
        n = AbsUnrolled[0];
        b = rtIsNaN(n);
        if (b) {
          ix = 2;
          exitg31 = false;
          while ((exitg31 == false) && (ix < 3)) {
            r1 = 2;
            x_re = AbsUnrolled[1];
            b = rtIsNaN(x_re);
            if (!b) {
              n = AbsUnrolled[1];
              exitg31 = true;
            } else {
              ix = 3;
            }
          }
        }

        if (r1 < 2) {
          for (ix = 1; ix + 1 < 3; ix++) {
            t30 = AbsUnrolled[ix];
            p = (t30 < n);
            if (p) {
              n = AbsUnrolled[ix];
            }
          }
        }

        if (n >= 0.0) {
          n = 0.0;
          for (ix = 1; ix + 1 < 5; ix++) {
            t30 = L_opt_5[ix];
            p = (t30 < n);
            if (p) {
              n = L_opt_5[ix];
            }
          }

          if (n >= 0.0) {
            AbsEncoder[0] = uDamping_idx_3;
            AbsEncoder[1] = t21;
          }
        }
      }

      /*  Case 6 */
      AbsUnrolled[0] = a_max - uLegSpring[0];
      AbsUnrolled[1] = a_min - uLegSpring[1];
      r1 = 1;
      n = AbsUnrolled[0];
      b = rtIsNaN(n);
      if (b) {
        ix = 2;
        exitg30 = false;
        while ((exitg30 == false) && (ix < 3)) {
          r1 = 2;
          x_re = AbsUnrolled[1];
          b = rtIsNaN(x_re);
          if (!b) {
            n = AbsUnrolled[1];
            exitg30 = true;
          } else {
            ix = 3;
          }
        }
      }

      if (r1 < 2) {
        for (ix = 1; ix + 1 < 3; ix++) {
          t30 = AbsUnrolled[ix];
          p = (t30 > n);
          if (p) {
            n = AbsUnrolled[ix];
          }
        }
      }

      if (n <= 0.0) {
        AbsUnrolled[0] = a_max - vKneeSpring[0];
        AbsUnrolled[1] = a_min - vKneeSpring[1];
        r1 = 1;
        n = AbsUnrolled[0];
        b = rtIsNaN(n);
        if (b) {
          ix = 2;
          exitg29 = false;
          while ((exitg29 == false) && (ix < 3)) {
            r1 = 2;
            x_re = AbsUnrolled[1];
            b = rtIsNaN(x_re);
            if (!b) {
              n = AbsUnrolled[1];
              exitg29 = true;
            } else {
              ix = 3;
            }
          }
        }

        if (r1 < 2) {
          for (ix = 1; ix + 1 < 3; ix++) {
            t30 = AbsUnrolled[ix];
            p = (t30 < n);
            if (p) {
              n = AbsUnrolled[ix];
            }
          }
        }

        if (n >= 0.0) {
          r1 = 1;
          n = L_opt_6[0];
          b = rtIsNaN(n);
          if (b) {
            ix = 2;
            exitg28 = false;
            while ((exitg28 == false) && (ix < 5)) {
              r1 = ix;
              x_re = L_opt_6[ix - 1];
              b = rtIsNaN(x_re);
              if (!b) {
                n = L_opt_6[ix - 1];
                exitg28 = true;
              } else {
                ix++;
              }
            }
          }

          if (r1 < 4) {
            for (ix = r1; ix + 1 < 5; ix++) {
              t30 = L_opt_6[ix];
              p = (t30 < n);
              if (p) {
                n = L_opt_6[ix];
              }
            }
          }

          if (n >= 0.0) {
            AbsEncoder[0] = a_max;
            AbsEncoder[1] = a_min;
          }
        }
      }

      /*  Case 7 */
      AbsUnrolled[0] = a_max - uLegSpring[0];
      AbsUnrolled[1] = t21 - uLegSpring[1];
      r1 = 1;
      n = AbsUnrolled[0];
      b = rtIsNaN(n);
      if (b) {
        ix = 2;
        exitg27 = false;
        while ((exitg27 == false) && (ix < 3)) {
          r1 = 2;
          x_re = AbsUnrolled[1];
          b = rtIsNaN(x_re);
          if (!b) {
            n = AbsUnrolled[1];
            exitg27 = true;
          } else {
            ix = 3;
          }
        }
      }

      if (r1 < 2) {
        for (ix = 1; ix + 1 < 3; ix++) {
          t30 = AbsUnrolled[ix];
          p = (t30 > n);
          if (p) {
            n = AbsUnrolled[ix];
          }
        }
      }

      if (n <= 0.0) {
        AbsUnrolled[0] = a_max - vKneeSpring[0];
        AbsUnrolled[1] = t21 - vKneeSpring[1];
        r1 = 1;
        n = AbsUnrolled[0];
        b = rtIsNaN(n);
        if (b) {
          ix = 2;
          exitg26 = false;
          while ((exitg26 == false) && (ix < 3)) {
            r1 = 2;
            x_re = AbsUnrolled[1];
            b = rtIsNaN(x_re);
            if (!b) {
              n = AbsUnrolled[1];
              exitg26 = true;
            } else {
              ix = 3;
            }
          }
        }

        if (r1 < 2) {
          for (ix = 1; ix + 1 < 3; ix++) {
            t30 = AbsUnrolled[ix];
            p = (t30 < n);
            if (p) {
              n = AbsUnrolled[ix];
            }
          }
        }

        if (n >= 0.0) {
          r1 = 1;
          n = L_opt_7[0];
          b = rtIsNaN(n);
          if (b) {
            ix = 2;
            exitg25 = false;
            while ((exitg25 == false) && (ix < 5)) {
              r1 = ix;
              x_re = L_opt_7[ix - 1];
              b = rtIsNaN(x_re);
              if (!b) {
                n = L_opt_7[ix - 1];
                exitg25 = true;
              } else {
                ix++;
              }
            }
          }

          if (r1 < 4) {
            for (ix = r1; ix + 1 < 5; ix++) {
              t30 = L_opt_7[ix];
              p = (t30 < n);
              if (p) {
                n = L_opt_7[ix];
              }
            }
          }

          if (n >= 0.0) {
            AbsEncoder[0] = a_max;
            AbsEncoder[1] = t21;
          }
        }
      }

      /*  Case 8 */
      AbsUnrolled[0] = t99 - uLegSpring[0];
      AbsUnrolled[1] = a_min - uLegSpring[1];
      r1 = 1;
      n = AbsUnrolled[0];
      b = rtIsNaN(n);
      if (b) {
        ix = 2;
        exitg24 = false;
        while ((exitg24 == false) && (ix < 3)) {
          r1 = 2;
          x_re = AbsUnrolled[1];
          b = rtIsNaN(x_re);
          if (!b) {
            n = AbsUnrolled[1];
            exitg24 = true;
          } else {
            ix = 3;
          }
        }
      }

      if (r1 < 2) {
        for (ix = 1; ix + 1 < 3; ix++) {
          t30 = AbsUnrolled[ix];
          p = (t30 > n);
          if (p) {
            n = AbsUnrolled[ix];
          }
        }
      }

      if (n <= 0.0) {
        AbsUnrolled[0] = t99 - vKneeSpring[0];
        AbsUnrolled[1] = a_min - vKneeSpring[1];
        r1 = 1;
        n = AbsUnrolled[0];
        b = rtIsNaN(n);
        if (b) {
          ix = 2;
          exitg23 = false;
          while ((exitg23 == false) && (ix < 3)) {
            r1 = 2;
            x_re = AbsUnrolled[1];
            b = rtIsNaN(x_re);
            if (!b) {
              n = AbsUnrolled[1];
              exitg23 = true;
            } else {
              ix = 3;
            }
          }
        }

        if (r1 < 2) {
          for (ix = 1; ix + 1 < 3; ix++) {
            t30 = AbsUnrolled[ix];
            p = (t30 < n);
            if (p) {
              n = AbsUnrolled[ix];
            }
          }
        }

        if (n >= 0.0) {
          n = 0.0;
          for (ix = 1; ix + 1 < 5; ix++) {
            t30 = L_opt_8[ix];
            p = (t30 < n);
            if (p) {
              n = L_opt_8[ix];
            }
          }

          if (n >= 0.0) {
            AbsEncoder[0] = t99;
            AbsEncoder[1] = a_min;
          }
        }
      }

      /*  Case 9 */
      HalfMaxTicks_idx_0 = uLegSpring[0];
      HalfMaxTicks_idx_0 = t99 - HalfMaxTicks_idx_0;
      uLegSpring[0] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = uLegSpring[1];
      HalfMaxTicks_idx_0 = t21 - HalfMaxTicks_idx_0;
      uLegSpring[1] = HalfMaxTicks_idx_0;
      r1 = 1;
      n = uLegSpring[0];
      b = rtIsNaN(n);
      if (b) {
        ix = 2;
        exitg22 = false;
        while ((exitg22 == false) && (ix < 3)) {
          r1 = 2;
          x_re = uLegSpring[1];
          b = rtIsNaN(x_re);
          if (!b) {
            n = uLegSpring[1];
            exitg22 = true;
          } else {
            ix = 3;
          }
        }
      }

      if (r1 < 2) {
        for (ix = 1; ix + 1 < 3; ix++) {
          t30 = uLegSpring[ix];
          p = (t30 > n);
          if (p) {
            n = uLegSpring[ix];
          }
        }
      }

      if (n <= 0.0) {
        HalfMaxTicks_idx_0 = vKneeSpring[0];
        HalfMaxTicks_idx_0 = t99 - HalfMaxTicks_idx_0;
        vKneeSpring[0] = HalfMaxTicks_idx_0;
        HalfMaxTicks_idx_0 = vKneeSpring[1];
        HalfMaxTicks_idx_0 = t21 - HalfMaxTicks_idx_0;
        vKneeSpring[1] = HalfMaxTicks_idx_0;
        r1 = 1;
        n = vKneeSpring[0];
        b = rtIsNaN(n);
        if (b) {
          ix = 2;
          exitg21 = false;
          while ((exitg21 == false) && (ix < 3)) {
            r1 = 2;
            x_re = vKneeSpring[1];
            b = rtIsNaN(x_re);
            if (!b) {
              n = vKneeSpring[1];
              exitg21 = true;
            } else {
              ix = 3;
            }
          }
        }

        if (r1 < 2) {
          for (ix = 1; ix + 1 < 3; ix++) {
            t30 = vKneeSpring[ix];
            p = (t30 < n);
            if (p) {
              n = vKneeSpring[ix];
            }
          }
        }

        if (n >= 0.0) {
          n = 0.0;
          for (ix = 1; ix + 1 < 5; ix++) {
            t30 = L_opt_9[ix];
            p = (t30 < n);
            if (p) {
              n = L_opt_9[ix];
            }
          }

          if (n >= 0.0) {
            AbsEncoder[0] = t99;
            AbsEncoder[1] = t21;
          }
        }
      }

      u_Link_idx_0 = AbsEncoder[1];
      u_Link_idx_1 = AbsEncoder[0];

      /*  parsePS3Controller */
      /*  methods */
      /*  classdef */
      /* % LOCAL FUNCTIONS ======================================================== */
      /* SCALEFACTOR Compute scalar (0 to 1) representing forces in leg. */
      /* CLAMP Clamp value between two bounds. */
      /*  */
      /*  Copyright 2015 Mikhail S. Jones */
      /*  Find which limit is min and max */
      a_min = 0.3;

      /*  Clamp value between limits */
      if (t3 <= 0.7) {
        t99 = t3;
      } else {
        t99 = 0.7;
      }

      if (t99 >= 0.3) {
        a_min = t99;
      }

      /*  clamp */
      t30 = a_min - 0.3;
      CurrentYaw = t30 / 0.39999999999999997;
      a_min = CurrentYaw * 2.0 - 1.0;
      a21 = rt_powd_snf(10.0, a_min);
      t30 = u_Link_idx_2 + u_Link_idx_3;
      y_5 = t30 / 2.0;
      n = u_Link_idx_2 - u_Link_idx_3;
      a_max = -obj_0->u_lim;
      t99 = obj_0->u_lim;
      a_min = -obj_0->u_lim;
      t21 = obj_0->u_lim;

      /* -------------------------------------------------------------------------- */
      /*  Inputs: */
      /*  1) u_LS: desired LS torque */
      /*  2) u_LA: desired LA torque */
      /*  3) w: weight in the cost function. Note that w should be strictly positive. */
      /*  The cost function is defined as */
      /*  J = (Delta J_LS)^2 + w * (Delta J_LA)^2 */
      /*  4) u1_min: lower bound on u1 */
      /*  5) u1_max: upper bound on u1 */
      /*  6) u2_min: lower bound on u2 */
      /*  7) u2_max: upper bound on u2 */
      /* -------------------------------------------------------------------------- */
      /*  Outputs: */
      /*  1) u_opt: optimal solution of the QP */
      /*  2) L_opt: Lagrange multipliers at the optimal solution */
      /*  3) case_m: case number. */
      /* -------------------------------------------------------------------------- */
      /*  Consider different cases */
      /* %%%%%  03-Jun-2013 08:50:09 */
      /* %%% */
      /* ------------------------------------------------------ */
      /*  u_opt */
      t30 = -((2.0 * n + y_5 * a21) * (a21 - 4.0));
      B = 8.0 * a21;
      y_0 = t30 / B;
      t30 = (2.0 * n - y_5 * a21) * (a21 + 4.0);
      B = 8.0 * a21;
      y_1 = t30 / B;
      HalfMaxTicks_idx_0 = y_0 - y_1;
      t30 = (2.0 * n + y_5 * a21) * (a21 + 4.0);
      B = 8.0 * a21;
      y_0 = t30 / B;
      t30 = (2.0 * n - y_5 * a21) * (a21 - 4.0);
      B = 8.0 * a21;
      y_1 = t30 / B;
      HalfMaxTicks_idx_1 = y_0 + y_1;

      /* ------------------------------------------------------ */
      /*  L_opt */
      /* %%%%%  03-Jun-2013 08:50:11 */
      /* %%% */
      /* ------------------------------------------------------ */
      /*  u_opt */
      t30 = ((4.0 * a_max + 4.0 * n) - a_max * a21) + 2.0 * y_5 * a21;
      B = a21 + 4.0;
      y_0 = t30 / B;
      CalOffset_idx_0 = y_0;

      /* ------------------------------------------------------ */
      /*  L_opt */
      t30 = (8.0 * a_max * a21 - 8.0 * y_5 * a21) + 4.0 * n * a21;
      B = a21 + 4.0;
      y_0 = t30 / B;
      L_opt_2_0[0] = y_0;
      L_opt_2_0[1] = 0.0;
      L_opt_2_0[2] = 0.0;
      L_opt_2_0[3] = 0.0;

      /* %%%%%  03-Jun-2013 08:50:11 */
      /* %%% */
      /* ------------------------------------------------------ */
      /*  u_opt */
      t30 = ((4.0 * t99 + 4.0 * n) - t99 * a21) + 2.0 * y_5 * a21;
      B = a21 + 4.0;
      y_0 = t30 / B;
      CalOffset_idx_1 = y_0;

      /* ------------------------------------------------------ */
      /*  L_opt */
      L_opt_3_0[0] = 0.0;
      t30 = -((8.0 * t99 * a21 - 8.0 * y_5 * a21) + 4.0 * n * a21);
      B = a21 + 4.0;
      y_0 = t30 / B;
      L_opt_3_0[1] = y_0;
      L_opt_3_0[2] = 0.0;
      L_opt_3_0[3] = 0.0;

      /* %%%%%  03-Jun-2013 08:50:11 */
      /* %%% */
      /* ------------------------------------------------------ */
      /*  u_opt */
      t30 = ((4.0 * a_min - 4.0 * n) - a_min * a21) + 2.0 * y_5 * a21;
      B = a21 + 4.0;
      y_0 = t30 / B;
      uDamping_idx_2 = y_0;

      /* ------------------------------------------------------ */
      /*  L_opt */
      L_opt_4_0[0] = 0.0;
      L_opt_4_0[1] = 0.0;
      t30 = -((8.0 * y_5 * a21 - 8.0 * a_min * a21) + 4.0 * n * a21);
      B = a21 + 4.0;
      y_0 = t30 / B;
      L_opt_4_0[2] = y_0;
      L_opt_4_0[3] = 0.0;

      /* %%%%%  03-Jun-2013 08:50:12 */
      /* %%% */
      /* ------------------------------------------------------ */
      /*  u_opt */
      t30 = ((4.0 * t21 - 4.0 * n) - t21 * a21) + 2.0 * y_5 * a21;
      B = a21 + 4.0;
      y_0 = t30 / B;
      uDamping_idx_3 = y_0;

      /* ------------------------------------------------------ */
      /*  L_opt */
      L_opt_5_0[0] = 0.0;
      L_opt_5_0[1] = 0.0;
      L_opt_5_0[2] = 0.0;
      t30 = (8.0 * y_5 * a21 - 8.0 * t21 * a21) + 4.0 * n * a21;
      B = a21 + 4.0;
      y_0 = t30 / B;
      L_opt_5_0[3] = y_0;

      /* %%%%%  03-Jun-2013 08:50:12 */
      /* %%% */
      /* ------------------------------------------------------ */
      /*  u_opt */
      /* ------------------------------------------------------ */
      /*  L_opt */
      y_0 = a_max / 2.0;
      y_1 = a_min / 2.0;
      L_opt_6_0[0] = ((2.0 * a_max - 2.0 * a_min) + 2.0 * n) + ((y_0 + y_1) -
        y_5) * a21;
      L_opt_6_0[1] = 0.0;
      y_0 = a_max / 2.0;
      y_1 = a_min / 2.0;
      L_opt_6_0[2] = ((2.0 * a_min - 2.0 * a_max) - 2.0 * n) + ((y_0 + y_1) -
        y_5) * a21;
      L_opt_6_0[3] = 0.0;

      /* %%%%%  03-Jun-2013 08:50:13 */
      /* %%% */
      /* ------------------------------------------------------ */
      /*  u_opt */
      /* ------------------------------------------------------ */
      /*  L_opt */
      y_0 = a_max / 2.0;
      y_1 = t21 / 2.0;
      L_opt_7_0[0] = ((2.0 * a_max - 2.0 * t21) + 2.0 * n) + ((y_0 + y_1) - y_5)
        * a21;
      L_opt_7_0[1] = 0.0;
      L_opt_7_0[2] = 0.0;
      t30 = a_max * a21;
      y_0 = t30 / 2.0;
      t30 = t21 * a21;
      y_1 = t30 / 2.0;
      L_opt_7_0[3] = ((((2.0 * a_max - 2.0 * t21) + 2.0 * n) - y_0) - y_1) + y_5
        * a21;

      /* %%%%%  03-Jun-2013 08:50:13 */
      /* %%% */
      /* ------------------------------------------------------ */
      /*  u_opt */
      /* ------------------------------------------------------ */
      /*  L_opt */
      L_opt_8_0[0] = 0.0;
      t30 = a_min * a21;
      y_0 = t30 / 2.0;
      t30 = t99 * a21;
      y_1 = t30 / 2.0;
      L_opt_8_0[1] = ((((2.0 * a_min - 2.0 * t99) - 2.0 * n) - y_0) - y_1) + y_5
        * a21;
      y_0 = a_min / 2.0;
      y_1 = t99 / 2.0;
      L_opt_8_0[2] = ((2.0 * a_min - 2.0 * t99) - 2.0 * n) + ((y_0 + y_1) - y_5)
        * a21;
      L_opt_8_0[3] = 0.0;

      /* %%%%%  03-Jun-2013 08:50:13 */
      /* %%% */
      /* ------------------------------------------------------ */
      /*  u_opt */
      /* ------------------------------------------------------ */
      /*  L_opt */
      L_opt_9_0[0] = 0.0;
      t30 = t99 * a21;
      y_0 = t30 / 2.0;
      t30 = t21 * a21;
      y_1 = t30 / 2.0;
      L_opt_9_0[1] = ((((2.0 * t21 - 2.0 * t99) - 2.0 * n) - y_0) - y_1) + y_5 *
        a21;
      L_opt_9_0[2] = 0.0;
      t30 = t99 * a21;
      y_0 = t30 / 2.0;
      t30 = t21 * a21;
      y_1 = t30 / 2.0;
      L_opt_9_0[3] = ((((2.0 * t99 - 2.0 * t21) + 2.0 * n) - y_0) - y_1) + y_5 *
        a21;

      /*  Lower and upper bounds for [u1; u2] */
      vKneeSpring[0] = a_max;
      vKneeSpring[1] = a_min;
      uLegSpring[0] = t99;
      uLegSpring[1] = t21;

      /*  Set the initial value */
      AbsEncoder[0] = 0.0;
      AbsEncoder[1] = 0.0;

      /*  Case 1 */
      AbsUnrolled[0] = HalfMaxTicks_idx_0 - uLegSpring[0];
      AbsUnrolled[1] = HalfMaxTicks_idx_1 - uLegSpring[1];
      r1 = 1;
      n = AbsUnrolled[0];
      b = rtIsNaN(n);
      if (b) {
        ix = 2;
        exitg20 = false;
        while ((exitg20 == false) && (ix < 3)) {
          r1 = 2;
          x_re = AbsUnrolled[1];
          b = rtIsNaN(x_re);
          if (!b) {
            n = AbsUnrolled[1];
            exitg20 = true;
          } else {
            ix = 3;
          }
        }
      }

      if (r1 < 2) {
        for (ix = 1; ix + 1 < 3; ix++) {
          t30 = AbsUnrolled[ix];
          p = (t30 > n);
          if (p) {
            n = AbsUnrolled[ix];
          }
        }
      }

      if (n <= 0.0) {
        AbsUnrolled[0] = HalfMaxTicks_idx_0 - vKneeSpring[0];
        AbsUnrolled[1] = HalfMaxTicks_idx_1 - vKneeSpring[1];
        r1 = 1;
        n = AbsUnrolled[0];
        b = rtIsNaN(n);
        if (b) {
          ix = 2;
          exitg19 = false;
          while ((exitg19 == false) && (ix < 3)) {
            r1 = 2;
            x_re = AbsUnrolled[1];
            b = rtIsNaN(x_re);
            if (!b) {
              n = AbsUnrolled[1];
              exitg19 = true;
            } else {
              ix = 3;
            }
          }
        }

        if (r1 < 2) {
          for (ix = 1; ix + 1 < 3; ix++) {
            t30 = AbsUnrolled[ix];
            p = (t30 < n);
            if (p) {
              n = AbsUnrolled[ix];
            }
          }
        }

        if (n >= 0.0) {
          AbsEncoder[0] = HalfMaxTicks_idx_0;
          AbsEncoder[1] = HalfMaxTicks_idx_1;
        }
      }

      /*  Case 2 */
      AbsUnrolled[0] = a_max - uLegSpring[0];
      AbsUnrolled[1] = CalOffset_idx_0 - uLegSpring[1];
      r1 = 1;
      n = AbsUnrolled[0];
      b = rtIsNaN(n);
      if (b) {
        ix = 2;
        exitg18 = false;
        while ((exitg18 == false) && (ix < 3)) {
          r1 = 2;
          x_re = AbsUnrolled[1];
          b = rtIsNaN(x_re);
          if (!b) {
            n = AbsUnrolled[1];
            exitg18 = true;
          } else {
            ix = 3;
          }
        }
      }

      if (r1 < 2) {
        for (ix = 1; ix + 1 < 3; ix++) {
          t30 = AbsUnrolled[ix];
          p = (t30 > n);
          if (p) {
            n = AbsUnrolled[ix];
          }
        }
      }

      if (n <= 0.0) {
        AbsUnrolled[0] = a_max - vKneeSpring[0];
        AbsUnrolled[1] = CalOffset_idx_0 - vKneeSpring[1];
        r1 = 1;
        n = AbsUnrolled[0];
        b = rtIsNaN(n);
        if (b) {
          ix = 2;
          exitg17 = false;
          while ((exitg17 == false) && (ix < 3)) {
            r1 = 2;
            x_re = AbsUnrolled[1];
            b = rtIsNaN(x_re);
            if (!b) {
              n = AbsUnrolled[1];
              exitg17 = true;
            } else {
              ix = 3;
            }
          }
        }

        if (r1 < 2) {
          for (ix = 1; ix + 1 < 3; ix++) {
            t30 = AbsUnrolled[ix];
            p = (t30 < n);
            if (p) {
              n = AbsUnrolled[ix];
            }
          }
        }

        if (n >= 0.0) {
          r1 = 1;
          n = L_opt_2_0[0];
          b = rtIsNaN(n);
          if (b) {
            r1 = 2;
            n = 0.0;
          }

          for (ix = r1; ix + 1 < 5; ix++) {
            t30 = L_opt_2_0[ix];
            p = (t30 < n);
            if (p) {
              n = L_opt_2_0[ix];
            }
          }

          if (n >= 0.0) {
            AbsEncoder[0] = a_max;
            AbsEncoder[1] = CalOffset_idx_0;
          }
        }
      }

      /*  Case 3 */
      AbsUnrolled[0] = t99 - uLegSpring[0];
      AbsUnrolled[1] = CalOffset_idx_1 - uLegSpring[1];
      r1 = 1;
      n = AbsUnrolled[0];
      b = rtIsNaN(n);
      if (b) {
        ix = 2;
        exitg16 = false;
        while ((exitg16 == false) && (ix < 3)) {
          r1 = 2;
          x_re = AbsUnrolled[1];
          b = rtIsNaN(x_re);
          if (!b) {
            n = AbsUnrolled[1];
            exitg16 = true;
          } else {
            ix = 3;
          }
        }
      }

      if (r1 < 2) {
        for (ix = 1; ix + 1 < 3; ix++) {
          t30 = AbsUnrolled[ix];
          p = (t30 > n);
          if (p) {
            n = AbsUnrolled[ix];
          }
        }
      }

      if (n <= 0.0) {
        AbsUnrolled[0] = t99 - vKneeSpring[0];
        AbsUnrolled[1] = CalOffset_idx_1 - vKneeSpring[1];
        r1 = 1;
        n = AbsUnrolled[0];
        b = rtIsNaN(n);
        if (b) {
          ix = 2;
          exitg15 = false;
          while ((exitg15 == false) && (ix < 3)) {
            r1 = 2;
            x_re = AbsUnrolled[1];
            b = rtIsNaN(x_re);
            if (!b) {
              n = AbsUnrolled[1];
              exitg15 = true;
            } else {
              ix = 3;
            }
          }
        }

        if (r1 < 2) {
          for (ix = 1; ix + 1 < 3; ix++) {
            t30 = AbsUnrolled[ix];
            p = (t30 < n);
            if (p) {
              n = AbsUnrolled[ix];
            }
          }
        }

        if (n >= 0.0) {
          n = 0.0;
          for (ix = 1; ix + 1 < 5; ix++) {
            t30 = L_opt_3_0[ix];
            p = (t30 < n);
            if (p) {
              n = L_opt_3_0[ix];
            }
          }

          if (n >= 0.0) {
            AbsEncoder[0] = t99;
            AbsEncoder[1] = CalOffset_idx_1;
          }
        }
      }

      /*  Case 4 */
      AbsUnrolled[0] = uDamping_idx_2 - uLegSpring[0];
      AbsUnrolled[1] = a_min - uLegSpring[1];
      r1 = 1;
      n = AbsUnrolled[0];
      b = rtIsNaN(n);
      if (b) {
        ix = 2;
        exitg14 = false;
        while ((exitg14 == false) && (ix < 3)) {
          r1 = 2;
          x_re = AbsUnrolled[1];
          b = rtIsNaN(x_re);
          if (!b) {
            n = AbsUnrolled[1];
            exitg14 = true;
          } else {
            ix = 3;
          }
        }
      }

      if (r1 < 2) {
        for (ix = 1; ix + 1 < 3; ix++) {
          t30 = AbsUnrolled[ix];
          p = (t30 > n);
          if (p) {
            n = AbsUnrolled[ix];
          }
        }
      }

      if (n <= 0.0) {
        AbsUnrolled[0] = uDamping_idx_2 - vKneeSpring[0];
        AbsUnrolled[1] = a_min - vKneeSpring[1];
        r1 = 1;
        n = AbsUnrolled[0];
        b = rtIsNaN(n);
        if (b) {
          ix = 2;
          exitg13 = false;
          while ((exitg13 == false) && (ix < 3)) {
            r1 = 2;
            x_re = AbsUnrolled[1];
            b = rtIsNaN(x_re);
            if (!b) {
              n = AbsUnrolled[1];
              exitg13 = true;
            } else {
              ix = 3;
            }
          }
        }

        if (r1 < 2) {
          for (ix = 1; ix + 1 < 3; ix++) {
            t30 = AbsUnrolled[ix];
            p = (t30 < n);
            if (p) {
              n = AbsUnrolled[ix];
            }
          }
        }

        if (n >= 0.0) {
          n = 0.0;
          for (ix = 1; ix + 1 < 5; ix++) {
            t30 = L_opt_4_0[ix];
            p = (t30 < n);
            if (p) {
              n = L_opt_4_0[ix];
            }
          }

          if (n >= 0.0) {
            AbsEncoder[0] = uDamping_idx_2;
            AbsEncoder[1] = a_min;
          }
        }
      }

      /*  Case 5 */
      AbsUnrolled[0] = uDamping_idx_3 - uLegSpring[0];
      AbsUnrolled[1] = t21 - uLegSpring[1];
      r1 = 1;
      n = AbsUnrolled[0];
      b = rtIsNaN(n);
      if (b) {
        ix = 2;
        exitg12 = false;
        while ((exitg12 == false) && (ix < 3)) {
          r1 = 2;
          x_re = AbsUnrolled[1];
          b = rtIsNaN(x_re);
          if (!b) {
            n = AbsUnrolled[1];
            exitg12 = true;
          } else {
            ix = 3;
          }
        }
      }

      if (r1 < 2) {
        for (ix = 1; ix + 1 < 3; ix++) {
          t30 = AbsUnrolled[ix];
          p = (t30 > n);
          if (p) {
            n = AbsUnrolled[ix];
          }
        }
      }

      if (n <= 0.0) {
        AbsUnrolled[0] = uDamping_idx_3 - vKneeSpring[0];
        AbsUnrolled[1] = t21 - vKneeSpring[1];
        r1 = 1;
        n = AbsUnrolled[0];
        b = rtIsNaN(n);
        if (b) {
          ix = 2;
          exitg11 = false;
          while ((exitg11 == false) && (ix < 3)) {
            r1 = 2;
            x_re = AbsUnrolled[1];
            b = rtIsNaN(x_re);
            if (!b) {
              n = AbsUnrolled[1];
              exitg11 = true;
            } else {
              ix = 3;
            }
          }
        }

        if (r1 < 2) {
          for (ix = 1; ix + 1 < 3; ix++) {
            t30 = AbsUnrolled[ix];
            p = (t30 < n);
            if (p) {
              n = AbsUnrolled[ix];
            }
          }
        }

        if (n >= 0.0) {
          n = 0.0;
          for (ix = 1; ix + 1 < 5; ix++) {
            t30 = L_opt_5_0[ix];
            p = (t30 < n);
            if (p) {
              n = L_opt_5_0[ix];
            }
          }

          if (n >= 0.0) {
            AbsEncoder[0] = uDamping_idx_3;
            AbsEncoder[1] = t21;
          }
        }
      }

      /*  Case 6 */
      AbsUnrolled[0] = a_max - uLegSpring[0];
      AbsUnrolled[1] = a_min - uLegSpring[1];
      r1 = 1;
      n = AbsUnrolled[0];
      b = rtIsNaN(n);
      if (b) {
        ix = 2;
        exitg10 = false;
        while ((exitg10 == false) && (ix < 3)) {
          r1 = 2;
          x_re = AbsUnrolled[1];
          b = rtIsNaN(x_re);
          if (!b) {
            n = AbsUnrolled[1];
            exitg10 = true;
          } else {
            ix = 3;
          }
        }
      }

      if (r1 < 2) {
        for (ix = 1; ix + 1 < 3; ix++) {
          t30 = AbsUnrolled[ix];
          p = (t30 > n);
          if (p) {
            n = AbsUnrolled[ix];
          }
        }
      }

      if (n <= 0.0) {
        AbsUnrolled[0] = a_max - vKneeSpring[0];
        AbsUnrolled[1] = a_min - vKneeSpring[1];
        r1 = 1;
        n = AbsUnrolled[0];
        b = rtIsNaN(n);
        if (b) {
          ix = 2;
          exitg9 = false;
          while ((exitg9 == false) && (ix < 3)) {
            r1 = 2;
            x_re = AbsUnrolled[1];
            b = rtIsNaN(x_re);
            if (!b) {
              n = AbsUnrolled[1];
              exitg9 = true;
            } else {
              ix = 3;
            }
          }
        }

        if (r1 < 2) {
          for (ix = 1; ix + 1 < 3; ix++) {
            t30 = AbsUnrolled[ix];
            p = (t30 < n);
            if (p) {
              n = AbsUnrolled[ix];
            }
          }
        }

        if (n >= 0.0) {
          r1 = 1;
          n = L_opt_6_0[0];
          b = rtIsNaN(n);
          if (b) {
            ix = 2;
            exitg8 = false;
            while ((exitg8 == false) && (ix < 5)) {
              r1 = ix;
              x_re = L_opt_6_0[ix - 1];
              b = rtIsNaN(x_re);
              if (!b) {
                n = L_opt_6_0[ix - 1];
                exitg8 = true;
              } else {
                ix++;
              }
            }
          }

          if (r1 < 4) {
            for (ix = r1; ix + 1 < 5; ix++) {
              t30 = L_opt_6_0[ix];
              p = (t30 < n);
              if (p) {
                n = L_opt_6_0[ix];
              }
            }
          }

          if (n >= 0.0) {
            AbsEncoder[0] = a_max;
            AbsEncoder[1] = a_min;
          }
        }
      }

      /*  Case 7 */
      AbsUnrolled[0] = a_max - uLegSpring[0];
      AbsUnrolled[1] = t21 - uLegSpring[1];
      r1 = 1;
      n = AbsUnrolled[0];
      b = rtIsNaN(n);
      if (b) {
        ix = 2;
        exitg7 = false;
        while ((exitg7 == false) && (ix < 3)) {
          r1 = 2;
          x_re = AbsUnrolled[1];
          b = rtIsNaN(x_re);
          if (!b) {
            n = AbsUnrolled[1];
            exitg7 = true;
          } else {
            ix = 3;
          }
        }
      }

      if (r1 < 2) {
        for (ix = 1; ix + 1 < 3; ix++) {
          t30 = AbsUnrolled[ix];
          p = (t30 > n);
          if (p) {
            n = AbsUnrolled[ix];
          }
        }
      }

      if (n <= 0.0) {
        AbsUnrolled[0] = a_max - vKneeSpring[0];
        AbsUnrolled[1] = t21 - vKneeSpring[1];
        r1 = 1;
        n = AbsUnrolled[0];
        b = rtIsNaN(n);
        if (b) {
          ix = 2;
          exitg6 = false;
          while ((exitg6 == false) && (ix < 3)) {
            r1 = 2;
            x_re = AbsUnrolled[1];
            b = rtIsNaN(x_re);
            if (!b) {
              n = AbsUnrolled[1];
              exitg6 = true;
            } else {
              ix = 3;
            }
          }
        }

        if (r1 < 2) {
          for (ix = 1; ix + 1 < 3; ix++) {
            t30 = AbsUnrolled[ix];
            p = (t30 < n);
            if (p) {
              n = AbsUnrolled[ix];
            }
          }
        }

        if (n >= 0.0) {
          r1 = 1;
          n = L_opt_7_0[0];
          b = rtIsNaN(n);
          if (b) {
            ix = 2;
            exitg5 = false;
            while ((exitg5 == false) && (ix < 5)) {
              r1 = ix;
              x_re = L_opt_7_0[ix - 1];
              b = rtIsNaN(x_re);
              if (!b) {
                n = L_opt_7_0[ix - 1];
                exitg5 = true;
              } else {
                ix++;
              }
            }
          }

          if (r1 < 4) {
            for (ix = r1; ix + 1 < 5; ix++) {
              t30 = L_opt_7_0[ix];
              p = (t30 < n);
              if (p) {
                n = L_opt_7_0[ix];
              }
            }
          }

          if (n >= 0.0) {
            AbsEncoder[0] = a_max;
            AbsEncoder[1] = t21;
          }
        }
      }

      /*  Case 8 */
      AbsUnrolled[0] = t99 - uLegSpring[0];
      AbsUnrolled[1] = a_min - uLegSpring[1];
      r1 = 1;
      n = AbsUnrolled[0];
      b = rtIsNaN(n);
      if (b) {
        ix = 2;
        exitg4 = false;
        while ((exitg4 == false) && (ix < 3)) {
          r1 = 2;
          x_re = AbsUnrolled[1];
          b = rtIsNaN(x_re);
          if (!b) {
            n = AbsUnrolled[1];
            exitg4 = true;
          } else {
            ix = 3;
          }
        }
      }

      if (r1 < 2) {
        for (ix = 1; ix + 1 < 3; ix++) {
          t30 = AbsUnrolled[ix];
          p = (t30 > n);
          if (p) {
            n = AbsUnrolled[ix];
          }
        }
      }

      if (n <= 0.0) {
        AbsUnrolled[0] = t99 - vKneeSpring[0];
        AbsUnrolled[1] = a_min - vKneeSpring[1];
        r1 = 1;
        n = AbsUnrolled[0];
        b = rtIsNaN(n);
        if (b) {
          ix = 2;
          exitg3 = false;
          while ((exitg3 == false) && (ix < 3)) {
            r1 = 2;
            x_re = AbsUnrolled[1];
            b = rtIsNaN(x_re);
            if (!b) {
              n = AbsUnrolled[1];
              exitg3 = true;
            } else {
              ix = 3;
            }
          }
        }

        if (r1 < 2) {
          for (ix = 1; ix + 1 < 3; ix++) {
            t30 = AbsUnrolled[ix];
            p = (t30 < n);
            if (p) {
              n = AbsUnrolled[ix];
            }
          }
        }

        if (n >= 0.0) {
          n = 0.0;
          for (ix = 1; ix + 1 < 5; ix++) {
            t30 = L_opt_8_0[ix];
            p = (t30 < n);
            if (p) {
              n = L_opt_8_0[ix];
            }
          }

          if (n >= 0.0) {
            AbsEncoder[0] = t99;
            AbsEncoder[1] = a_min;
          }
        }
      }

      /*  Case 9 */
      HalfMaxTicks_idx_0 = uLegSpring[0];
      HalfMaxTicks_idx_0 = t99 - HalfMaxTicks_idx_0;
      uLegSpring[0] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = uLegSpring[1];
      HalfMaxTicks_idx_0 = t21 - HalfMaxTicks_idx_0;
      uLegSpring[1] = HalfMaxTicks_idx_0;
      r1 = 1;
      n = uLegSpring[0];
      b = rtIsNaN(n);
      if (b) {
        ix = 2;
        exitg2 = false;
        while ((exitg2 == false) && (ix < 3)) {
          r1 = 2;
          x_re = uLegSpring[1];
          b = rtIsNaN(x_re);
          if (!b) {
            n = uLegSpring[1];
            exitg2 = true;
          } else {
            ix = 3;
          }
        }
      }

      if (r1 < 2) {
        for (ix = 1; ix + 1 < 3; ix++) {
          t30 = uLegSpring[ix];
          p = (t30 > n);
          if (p) {
            n = uLegSpring[ix];
          }
        }
      }

      if (n <= 0.0) {
        HalfMaxTicks_idx_0 = vKneeSpring[0];
        HalfMaxTicks_idx_0 = t99 - HalfMaxTicks_idx_0;
        vKneeSpring[0] = HalfMaxTicks_idx_0;
        HalfMaxTicks_idx_0 = vKneeSpring[1];
        HalfMaxTicks_idx_0 = t21 - HalfMaxTicks_idx_0;
        vKneeSpring[1] = HalfMaxTicks_idx_0;
        r1 = 1;
        n = vKneeSpring[0];
        b = rtIsNaN(n);
        if (b) {
          ix = 2;
          exitg1 = false;
          while ((exitg1 == false) && (ix < 3)) {
            r1 = 2;
            x_re = vKneeSpring[1];
            b = rtIsNaN(x_re);
            if (!b) {
              n = vKneeSpring[1];
              exitg1 = true;
            } else {
              ix = 3;
            }
          }
        }

        if (r1 < 2) {
          for (ix = 1; ix + 1 < 3; ix++) {
            t30 = vKneeSpring[ix];
            p = (t30 < n);
            if (p) {
              n = vKneeSpring[ix];
            }
          }
        }

        if (n >= 0.0) {
          n = 0.0;
          for (ix = 1; ix + 1 < 5; ix++) {
            t30 = L_opt_9_0[ix];
            p = (t30 < n);
            if (p) {
              n = L_opt_9_0[ix];
            }
          }

          if (n >= 0.0) {
            AbsEncoder[0] = t99;
            AbsEncoder[1] = t21;
          }
        }
      }

      u_Link_idx_2 = AbsEncoder[1];
      u_Link_idx_3 = AbsEncoder[0];
      obj_0->output[0] = t36;
      obj_0->output[1] = t42;
      b = (obj_0->stanceLeg == 1.0);
      obj_4[0] = obj_0->s_r_B * u_Link_idx_3;
      obj_4[1] = obj_0->s_r_A * u_Link_idx_2;
      obj_4[2] = t51;
      obj_4[3] = obj_0->s_l_B * u_Link_idx_1;
      obj_4[4] = obj_0->s_l_A * u_Link_idx_0;
      obj_4[5] = maxval;
      obj_5[0] = obj_0->s_l_B * u_Link_idx_1;
      obj_5[1] = obj_0->s_l_A * u_Link_idx_0;
      obj_5[2] = maxval;
      obj_5[3] = obj_0->s_r_B * u_Link_idx_3;
      obj_5[4] = obj_0->s_r_A * u_Link_idx_2;
      obj_5[5] = t51;
      for (rtemp = 0; rtemp < 6; rtemp++) {
        if (b) {
          alpha_0[rtemp] = obj_4[rtemp];
        } else {
          alpha_0[rtemp] = obj_5[rtemp];
        }
      }

      t30 = hd_q[3];
      y_5 = t30 / 10.0;
      y_0 = q_sw_mB / 10.0;
      RefAngle[0] = hd_q[0] - q_st_mA;
      RefAngle[1] = hd_q[1] - q_st_mB;
      RefAngle[2] = hd_q[2] - q_sw_mA;
      RefAngle[3] = hd_q[3] - q_sw_mB;
      RefAngle[4] = y_5;
      RefAngle[5] = y_0;
      x_re = 6.2831853071795862 * t3;
      x_re = sin(x_re);
      t30 = (5.0 * x_re + 2.0) * 3.1415926535897931;
      y_5 = t30 / 180.0;
      x_re = 6.2831853071795862 * t3;
      x_re = sin(x_re);
      t30 = -(5.0 * x_re + 2.0) * 3.1415926535897931;
      y_0 = t30 / 180.0;
      y_1 = t2 / 100.0;
      y_2 = t5 / 100.0;
      y_3 = s_st / 180.0;
      y_4 = s_sw / 180.0;
      x[0] = y_5 * obj_0->stanceLeg - q_st_h;
      x[1] = y_0 * obj_0->stanceLeg - q_sw_h;
      x[2] = y_1;
      x[3] = y_2;
      x[4] = y_3 * 3.1415926535897931;
      x[5] = y_4 * 3.1415926535897931;
      if (((((t3 >= 0.5) && (s_sw >= 1.0)) || (obj_0->tauPhase >= 3.0)) &&
           (obj_0->isTest11 == 0)) || ((t3 >= 1.0) && (obj_0->isTest11 == 1))) {
        t30 = obj_0->dy_est + obj_0->dy_est_last;
        y_5 = t30 / 2.0;
        obj_0->dy_est_avg = y_5;
        obj_0->dx_est_last = obj_0->dx_est;
        obj_0->dy_est_last = obj_0->dy_est;
        obj_0->hd_last[0] = q_pitch * s_st + q_sw_h_tgt;
        obj_0->hd_last[1] = q_pitch * s_sw + sum_term_idx_0_0;
        obj_0->hd_last[2] = y_sw_tgt;
        obj_0->hd_last[3] = q3R;
        obj_0->dhd_last[0] = dq_pitch * s_st + L;
        obj_0->dhd_last[1] = dq_pitch * s_sw + sum_term_idx_0;
        obj_0->dhd_last[2] = sum_term_idx_3;
        obj_0->dhd_last[3] = alpha;
        obj_0->ds_last = t11;
        t30 = q_sw_lA + q_sw_lB;
        y_5 = t30 / 2.0;
        obj_0->thetaMin = q_pitch + y_5;
        if (obj_0->stanceLeg == 1.0) {
          obj_0->rightHeight = footHeight;
          obj_0->rightBelieve = 0.2 * obj_0->rightBelieve + 0.8 *
            obj_0->rightHeight;
          obj_0->hBelieve = obj_0->leftBelieve;
        } else {
          obj_0->leftHeight = footHeight;
          obj_0->leftBelieve = 0.2 * obj_0->leftBelieve + 0.8 *
            obj_0->leftHeight;
          obj_0->hBelieve = obj_0->rightBelieve;
        }

        obj_0->stanceLeg = -obj_0->stanceLeg;
        obj_0->t = 0.0;
        obj_0->tauPhase = 0.0;
      }
    } else {
      /*  Reset run time */
      obj->runTime = 0.0;

      /*  Run controller specific initialization */
      obj_0 = obj;
      obj_0->gaitMode = Circle;
      obj_0->t = 0.0;
      obj_0->x_est = 0.0;
      obj_0->y_est = 0.0;
      obj_0->dx_est = 0.0;
      obj_0->dy_est = 0.0;
      obj_0->dy_est_avg = 0.0;
      obj_0->dx_tgt = 0.0;
      obj_0->dy_tgt = 0.0;
      obj_0->dx_est_last = 0.0;
      obj_0->dy_est_last = 0.0;
      obj_0->dx = 0.0;
      obj_0->dy = 0.0;
      if (obj_0->isSim == 1) {
        obj_0->x_offset = -0.025;
        obj_0->y_offset = -0.0;
      } else {
        obj_0->x_offset = -0.0;
        obj_0->y_offset = 0.04;
      }

      obj_0->q_yaw_tgt = 0.0;
      obj_0->dq_yaw_tgt = 0.0;
      obj_0->theta = 0.0;
      obj_0->sDDA = 0.0;
      obj_0->dsDDA = 0.0;
      obj_0->dsDDA_est = 0.0;
      obj_0->ds_last = 0.1;
      obj_0->tauPhase = 0.0;
      obj_0->hd_last[0] = 3.1774;
      obj_0->hd_last[1] = 3.1774;
      obj_0->hd_last[2] = 0.7148;
      obj_0->hd_last[3] = 0.7149;
      obj_0->dhd_last[0] = 0.0;
      obj_0->dhd_last[1] = 0.0;
      obj_0->dhd_last[2] = 0.0;
      obj_0->dhd_last[3] = 0.0;
      obj_0->dq_yaw_est = 0.0;
      obj_0->thetaMin = 0.0;
      obj_0->leftHeight = 0.0;
      obj_0->rightHeight = 0.0;
      obj_0->rightBelieve = 0.0;
      obj_0->leftBelieve = 0.0;
      obj_0->hBelieve = 0.0;
      obj_0->PressTime = 0.0;
      obj_0->yawReset = 0.0;
      obj_0->contactGround = 0.0;

      /*  				% Damping gains */
      /*  				kd_leg = 150; */
      /*  				kd_hip = 40; */
      /*  				 */
      /*  				% Leg actuator torques computed to behave like virtual dampers */
      /*  				u([1 2 4 5]) = (0 - dq([2 4 6 8]))*kd_leg; */
      /*  				u([3 6]) = (0 - dq([9 10]))*kd_hip; */
      /*  				y_out = zeros(6,1); */
      /*  				dy_out = zeros(6,1); */
      /*  Damping gains */
      /*  Leg actuator torques computed to behave like virtual dampers */
      delta_dq[0] = 3.4906585039886591 - u0[1];
      delta_dq[1] = 2.7925268031909272 - u0[3];
      delta_dq[2] = 3.4906585039886591 - u0[5];
      delta_dq[3] = 2.7925268031909272 - u0[7];
      HalfMaxTicks_idx_0 = delta_dq[0];
      HalfMaxTicks_idx_0 *= 200.0;
      delta_dq[0] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = delta_dq[1];
      HalfMaxTicks_idx_0 *= 200.0;
      delta_dq[1] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = delta_dq[2];
      HalfMaxTicks_idx_0 *= 200.0;
      delta_dq[2] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = delta_dq[3];
      HalfMaxTicks_idx_0 *= 200.0;
      delta_dq[3] = HalfMaxTicks_idx_0;
      q_d[0] = 0.0 - u1[1];
      q_d[1] = 0.0 - u1[3];
      q_d[2] = 0.0 - u1[5];
      q_d[3] = 0.0 - u1[7];
      HalfMaxTicks_idx_0 = q_d[0];
      HalfMaxTicks_idx_0 *= 150.0;
      q_d[0] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = q_d[1];
      HalfMaxTicks_idx_0 *= 150.0;
      q_d[1] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = q_d[2];
      HalfMaxTicks_idx_0 *= 150.0;
      q_d[2] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = q_d[3];
      HalfMaxTicks_idx_0 *= 150.0;
      q_d[3] = HalfMaxTicks_idx_0;
      alpha_0[0] = delta_dq[0] + q_d[0];
      alpha_0[1] = delta_dq[1] + q_d[1];
      alpha_0[3] = delta_dq[2] + q_d[2];
      alpha_0[4] = delta_dq[3] + q_d[3];
      vKneeSpring[0] = 0.0 - u0[8];
      vKneeSpring[1] = 0.0 - u0[9];
      HalfMaxTicks_idx_0 = vKneeSpring[0];
      HalfMaxTicks_idx_0 *= 300.0;
      vKneeSpring[0] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = vKneeSpring[1];
      HalfMaxTicks_idx_0 *= 300.0;
      vKneeSpring[1] = HalfMaxTicks_idx_0;
      uLegSpring[0] = 0.0 - u1[8];
      uLegSpring[1] = 0.0 - u1[9];
      HalfMaxTicks_idx_0 = uLegSpring[0];
      HalfMaxTicks_idx_0 *= 40.0;
      uLegSpring[0] = HalfMaxTicks_idx_0;
      HalfMaxTicks_idx_0 = uLegSpring[1];
      HalfMaxTicks_idx_0 *= 40.0;
      uLegSpring[1] = HalfMaxTicks_idx_0;
      alpha_0[2] = vKneeSpring[0] + uLegSpring[0];
      alpha_0[5] = vKneeSpring[1] + uLegSpring[1];
      for (i = 0; i < 6; i++) {
        RefAngle[i] = 0.0;
        x[i] = 0.0;
      }
    }

    /*  if */
    /*  Limit torque commands */
    HalfMaxTicks_idx_1 = -obj->u_lim;
    CalOffset_idx_0 = obj->u_lim;

    /*  stepImpl */
    /*  methods */
    /*  classdef */
    /* % LOCAL FUNCTIONS ======================================================== */
    /* CLAMP Clamp value between two bounds. */
    /*  Find which limit is min and max */
    if ((HalfMaxTicks_idx_1 <= CalOffset_idx_0) || rtIsNaN(CalOffset_idx_0)) {
      a_min = HalfMaxTicks_idx_1;
    } else {
      a_min = CalOffset_idx_0;
    }

    if ((HalfMaxTicks_idx_1 >= CalOffset_idx_0) || rtIsNaN(CalOffset_idx_0)) {
      a_max = HalfMaxTicks_idx_1;
    } else {
      a_max = CalOffset_idx_0;
    }

    /*  Clamp value between limits */
    for (r1 = 0; r1 < 6; r1++) {
      n = alpha_0[r1];
      if (!((n <= a_max) || rtIsNaN(a_max))) {
        n = a_max;
      }

      HAlpha_0[r1] = n;
    }

    for (r1 = 0; r1 < 6; r1++) {
      n = HAlpha_0[r1];
      if (!((n >= a_min) || rtIsNaN(a_min))) {
        n = a_min;
      }

      alpha_0[r1] = n;
    }

    /*  Simulation overrides */
    for (rtemp = 0; rtemp < 6; rtemp++) {
      alpha = alpha_0[rtemp];
      alpha = -alpha;
      alpha_0[rtemp] = alpha;
    }

    alpha_0[2] = -alpha_0[2];

    /*  User output */
    t30 = obj->q_yaw * 180.0;
    y_5 = t30 / 3.1415926535897931;
    varargout_3[0] = obj->dx_est;
    varargout_3[1] = obj->rightHeight;
    varargout_3[2] = obj->leftHeight;
    varargout_3[3] = obj->x_offset;
    varargout_3[4] = obj->y_offset;
    varargout_3[5] = obj->dx_est;
    varargout_3[6] = obj->dy_est;
    varargout_3[7] = obj->dx_tgt;
    varargout_3[8] = obj->output[0];
    varargout_3[9] = obj->output[1];
    varargout_3[10] = obj->tauPhase;
    varargout_3[11] = obj->dx;
    varargout_3[12] = obj->dy;
    varargout_3[13] = y_5;
    varargout_3[14] = obj->dq_yaw;
    varargout_3[15] = obj->dq_yaw_est;

    /* End of Start for MATLABSystem: '<S2>/Controller3' */

    /* MATLABSystem: '<S2>/Controller3' */
    Walking_ATRIAS_B.Controller3_o1 = isTest5;
    for (rtemp = 0; rtemp < 6; rtemp++) {
      HAlpha_0[rtemp] = RefAngle[rtemp];
      obj_4[rtemp] = x[rtemp];
      Walking_ATRIAS_B.Controller3_o2[rtemp] = alpha_0[rtemp];
    }

    memcpy(&Walking_ATRIAS_B.Controller3_o3[0], &varargout_3[0], sizeof(real_T) <<
           4U);
    for (rtemp = 0; rtemp < 6; rtemp++) {
      /* MATLABSystem: '<S2>/Controller3' */
      Walking_ATRIAS_B.Controller3_o4[rtemp] = HAlpha_0[rtemp];
      Walking_ATRIAS_B.Controller3_o5[rtemp] = obj_4[rtemp];

      /* Reshape: '<S2>/Reshape' */
      Walking_ATRIAS_B.Reshape[rtemp] = Walking_ATRIAS_B.Controller3_o2[rtemp];

      /* Gain: '<S2>/Gain2' */
      Walking_ATRIAS_B.Gain2[rtemp] = Walking_ATRIAS_ConstP.Gain2_Gain[rtemp] *
        Walking_ATRIAS_B.Reshape[rtemp];

      /* RelationalOperator: '<S30>/LowerRelop1' */
      Walking_ATRIAS_B.LowerRelop1[rtemp] = (Walking_ATRIAS_B.Gain2[rtemp] >
        Walking_ATRIAS_B.Gain1[rtemp]);

      /* Gain: '<S20>/Gain' */
      Walking_ATRIAS_B.Gain_e[rtemp] = (-1.0) * Walking_ATRIAS_B.Gain1[rtemp];

      /* RelationalOperator: '<S30>/UpperRelop' */
      Walking_ATRIAS_B.UpperRelop[rtemp] = (Walking_ATRIAS_B.Gain2[rtemp] <
        Walking_ATRIAS_B.Gain_e[rtemp]);

      /* Switch: '<S30>/Switch' */
      if (Walking_ATRIAS_B.UpperRelop[rtemp]) {
        Walking_ATRIAS_B.Switch[rtemp] = Walking_ATRIAS_B.Gain_e[rtemp];
      } else {
        Walking_ATRIAS_B.Switch[rtemp] = Walking_ATRIAS_B.Gain2[rtemp];
      }

      /* End of Switch: '<S30>/Switch' */

      /* Switch: '<S30>/Switch2' */
      if (Walking_ATRIAS_B.LowerRelop1[rtemp]) {
        Walking_ATRIAS_B.Switch2[rtemp] = Walking_ATRIAS_B.Gain1[rtemp];
      } else {
        Walking_ATRIAS_B.Switch2[rtemp] = Walking_ATRIAS_B.Switch[rtemp];
      }

      /* End of Switch: '<S30>/Switch2' */

      /* DataTypeConversion: '<S20>/Data Type Conversion1' */
      Walking_ATRIAS_B.torque_sat[rtemp] = Walking_ATRIAS_B.Switch2[rtemp];

      /* Gain: '<S8>/TorqueToCurrent' */
      Walking_ATRIAS_B.current_unsat[rtemp] =
        Walking_ATRIAS_ConstP.TorqueToCurrent_Gain[rtemp] *
        Walking_ATRIAS_B.torque_sat[rtemp];

      /* RelationalOperator: '<S35>/LowerRelop1' incorporates:
       *  Constant: '<S8>/CurrentSaturation'
       */
      Walking_ATRIAS_B.LowerRelop1_k[rtemp] =
        (Walking_ATRIAS_B.current_unsat[rtemp] > 50.0);

      /* RelationalOperator: '<S35>/UpperRelop' */
      Walking_ATRIAS_B.UpperRelop_j[rtemp] =
        (Walking_ATRIAS_B.current_unsat[rtemp] < Walking_ATRIAS_ConstB.Gain);

      /* Switch: '<S35>/Switch' */
      if (Walking_ATRIAS_B.UpperRelop_j[rtemp]) {
        Walking_ATRIAS_B.Switch_b[rtemp] = Walking_ATRIAS_ConstB.Gain;
      } else {
        Walking_ATRIAS_B.Switch_b[rtemp] = Walking_ATRIAS_B.current_unsat[rtemp];
      }

      /* End of Switch: '<S35>/Switch' */

      /* Switch: '<S35>/Switch2' incorporates:
       *  Constant: '<S8>/CurrentSaturation'
       */
      if (Walking_ATRIAS_B.LowerRelop1_k[rtemp]) {
        Walking_ATRIAS_B.Switch2_d[rtemp] = 50.0;
      } else {
        Walking_ATRIAS_B.Switch2_d[rtemp] = Walking_ATRIAS_B.Switch_b[rtemp];
      }

      /* End of Switch: '<S35>/Switch2' */
    }

    /* DataTypeConversion: '<S2>/Data Type Conversion' */
    Walking_ATRIAS_B.DataTypeConversion = Walking_ATRIAS_B.Controller3_o1;

    /* DataTypeConversion: '<Root>/Data Type Conversion' */
    Walking_ATRIAS_B.DataTypeConversion_h = (Walking_ATRIAS_B.DataTypeConversion
      != 0.0);
    for (i = 0; i < 13; i++) {
      /* UnitDelay: '<S8>/Unit Delay2' */
      Walking_ATRIAS_B.UnitDelay2_o[i] = Walking_ATRIAS_DW.UnitDelay2_DSTATE_h[i];

      /* UnitDelay: '<S8>/Unit Delay1' */
      Walking_ATRIAS_B.UnitDelay1_h[i] = Walking_ATRIAS_DW.UnitDelay1_DSTATE_j[i];
    }

    /* UnitDelay: '<S8>/Unit Delay' */
    Walking_ATRIAS_B.UnitDelay_a = Walking_ATRIAS_DW.UnitDelay_DSTATE_k;

    /* MATLAB Function: '<S8>/SAFETY' incorporates:
     *  Constant: '<S8>/MedullaCommand'
     */
    /* MATLAB Function 'Subsystem1/SAFETY': '<S34>:1' */
    a21 = Walking_ATRIAS_P.MedullaCommand;
    isTest5 = Walking_ATRIAS_B.DataTypeConversion_h;
    CurrentYaw = Walking_ATRIAS_B.UnitDelay_a;

    /*  Checks DAQ inputs and outputs to ensure that the commands sent to the */
    /*  robot and the state reported by the robot are okay. Any invalid */
    /*  commands to the robot are discarded, and default (zero) commands are */
    /*  send instead. The cause of the failure can be traced by logging the */
    /*  SafetyStateOut output. */
    /*  */
    /*  SafetyState is a double with integer value in the range 0 to */
    /*  2^52-1. The 52 bits of the significand represent different safety */
    /*  checks. Corresponding bits are set when a safety violation is */
    /*  detected. If SafetyState is nonzero for more than SSMAX time steps, */
    /*  the requested commands (MotorCurrentCommand, MedullaCommand, */
    /*  IMUCommand) are replaced with the safe commands specified below. This */
    /*  should cause the torque to be zero and the Medullas to enter the HALT */
    /*  or ERROR state. */
    /*      if (nargin < 6) */
    /*          SelectBasicLimits = 1; */
    /*      end */
    /*  SAFE OUTPUTS */
    /*  THESE OUTPUTS ARE USED IN A HARD SHUTDOWN, AND CAUSE ALL COMMANDED */
    /*  CURRENTS TO BE ZEROED AND THE MEDULLAS TO ENTER THE HALT STATE. */
    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.MotorCurrentCommandSafe[i] = 0.0;
    }

    a_max = 4.0;

    /*  4=HALT */
    /*  HARD SAFETY PARAMETERS */
    /*  THE FOLLOWING PARAMETERS SPECIFY LIMITS WHICH, WHEN EXCEEDED, CAUSE */
    /*  THE SAFETY TO LOCK DOWN THE ROBOT BY SENDING THE DEFAULT SAFE OUTPUTS */
    /*  ABOVE. */
    /* MAX_MOTOR_TEMP         = 80; % C */
    /*  Amps  */
    /* VALID_IMU_COMMANDS     = [0 1 2]; % Meaningless for now */
    /*  END (HARD SAFETY PARAMETERS) */
    /*  SOFT SAFETY PARAMETERS */
    /*  THE FOLLOWING PARAMETERS SPECIFY LIMITS WHICH DO NOT CAUSE THE SAFETY */
    /*  TO LOCK DOWN THE WHOLE ROBOT. INSTEAD, APPROPRIATE CURRENTS ARE */
    /*  LIMITED TO PREVENT DRIVING THE MOTORS IN A MANNER THAT MIGHT CAUSE */
    /*  DAMAGE */
    /* MAX_HIP_ANGLE_SOFT           = 7; % degrees; mechanical limit is reported to be 20 degrees */
    /* MIN_HIP_ANGLE_SOFT           = -15; % degrees; mechanical limit is reported to be -10 degrees  */
    /* SOFT_LIMIT_WIDTH_HIP         = 4;  % degrees */
    /* SOFT_LIMIT_UMAX_HIP          = 15; % Amps */
    /*  END (SOFT SAFETY PARAMETERS) */
    /*  SAFETY STATE DEFINITION */
    /* SS_DYNAMIC_STATE_LIMIT     = 2.^(0:39).'; % bits 1:40 */
    /*  bits 1:40 */
    /*  bit 41 */
    /*  bit 42 */
    /* SSMASK_INVALID_IMU_COMMAND     = 2^42; % bit 43 */
    /* SSMASK_OVERTEMP                = 2^43; % bit 44 */
    /*  CHECK ROBOT CONFIGURATION AND VELOCITY (HARD SAFETY) */
    Walking_MARLOBasicSafetyLimits3(Walking_ATRIAS_B.UnitDelay2_o,
      Walking_ATRIAS_B.UnitDelay1_h, tmp_5);
    for (rtemp = 0; rtemp < 34; rtemp++) {
      x_0[rtemp] = SS_DYNAMIC_STATE_LIMIT[rtemp] * (real_T)tmp_5[rtemp];
    }

    t99 = x_0[0];
    for (r1 = 0; r1 < 33; r1++) {
      t99 += x_0[r1 + 1];
    }

    /*  VALIDATE MOTOR COMMAND */
    /*                     % Check for NaN and +Inf and -Inf */
    AccelValid = false;
    for (rtemp = 0; rtemp < 6; rtemp++) {
      RefAngle_0[rtemp] = !((!rtIsInf(Walking_ATRIAS_B.Switch2_d[rtemp])) &&
                            (!rtIsNaN(Walking_ATRIAS_B.Switch2_d[rtemp])));
    }

    if (Walking_ATRIAS_any(RefAngle_0)) {
      AccelValid = true;
    } else {
      for (r2 = 0; r2 < 6; r2++) {
        HalfMaxTicks_idx_0 = fabs(Walking_ATRIAS_B.Switch2_d[r2]);
        RefAngle_0[r2] = (HalfMaxTicks_idx_0 > 120.0);
      }

      if (Walking_ATRIAS_any(RefAngle_0)) {
        AccelValid = true;
      }
    }

    if (AccelValid) {
      /*  Check for extremely large commands */
      t99 += 1.099511627776E+12;
    }

    /*  VALIDATE MEDULLA COMMAND */
    p_0 = false;
    r1 = 0;
    r2 = 1;
    i = 8;
    GyroValid = false;
    while ((!GyroValid) && (i >= r2)) {
      rtemp = ((r2 >> 1) + (i >> 1)) - 1;
      if (((r2 & 1) == 1) && ((i & 1) == 1)) {
        rtemp++;
      }

      n = fabs((real_T)rtemp / 2.0);
      if (n <= 2.2250738585072014E-308) {
        n = 4.94065645841247E-324;
      } else {
        frexp(n, &exponent);
        n = ldexp(1.0, exponent - 53);
      }

      p = (fabs((real_T)rtemp - a21) < n);
      if (p) {
        r1 = rtemp + 1;
        GyroValid = true;
      } else {
        AccelValid = (a21 < rtemp);
        if (AccelValid) {
          i = rtemp;
        } else {
          r2 = rtemp + 2;
        }
      }
    }

    if (r1 > 0) {
      AccelValid = false;
      while ((!AccelValid) && (r1 - 1 > 0)) {
        n = (real_T)(r1 - 2) / 2.0;
        if (n <= 2.2250738585072014E-308) {
          n = 4.94065645841247E-324;
        } else {
          frexp(n, &b_exponent);
          n = ldexp(1.0, b_exponent - 53);
        }

        GyroValid = (fabs((real_T)(r1 - 2) - a21) < n);
        if (GyroValid) {
          r1--;
        } else {
          AccelValid = true;
        }
      }
    }

    if (r1 > 0) {
      p_0 = true;
    }

    b = (!p_0 == 0);
    if (!b) {
      t99 += 2.199023255552E+12;
    }

    /*  VALIDATE IMU COMMAND */
    /* if any(~ismember(IMUCommand, VALID_IMU_COMMANDS)) */
    /*     SafetyState = SafetyState + SS_INVALID_IMU_COMMAND; */
    /* end     */
    /*  CHECK THERMISTORS     */
    /*  TODO */
    /*  CHECK ROBOT CONFIGURATION (SOFT SAFETY) */
    /*  THE FOLLOWING LIMITS, WHEN EXCEEDED, DO *NOT* CAUSE THE SAFETY TO */
    /*  LOCK DOWN THE WHOLE ROBOT. INSTEAD, APPROPRIATE CURENTS ARE LIMITED */
    /*  TO PREVENT DRIVING THE MOTORS IN A MANNER THAT MIGHT CAUSE DAMAGE */
    /*     %{ */
    /*     % BGB 2014-05-21 */
    /*     q3R = q(10); */
    /*     q3L = q(13); */
    /*      */
    /*     MotorCurrentCommand(3) = continuouslySaturate(MotorCurrentCommand(3), q3R, [MIN_HIP_ANGLE_SOFT MAX_HIP_ANGLE_SOFT]*pi/180, SOFT_LIMIT_WIDTH_HIP*pi/180, SOFT_LIMIT_UMAX_HIP); */
    /*     MotorCurrentCommand(6) = continuouslySaturate(MotorCurrentCommand(6), q3L, [MIN_HIP_ANGLE_SOFT MAX_HIP_ANGLE_SOFT]*pi/180, SOFT_LIMIT_WIDTH_HIP*pi/180, SOFT_LIMIT_UMAX_HIP); */
    /*     % END BGB 2014-05-21 */
    /*     %} */
    /*  IF EVERYTHING LOOKS OKAY (SAFETYSTATE==0), THEN PASS THE COMMANDS TO THE DAQ */
    if (t99 == 0.0) {
      n = CurrentYaw - 1.0;
      if ((0.0 >= n) || rtIsNaN(n)) {
        n = 0.0;
      }
    } else {
      n = CurrentYaw + 1.0;
      if (!(n <= 10.0)) {
        n = 10.0;
      }
    }

    if ((n < 4.0) && (isTest5 == 0)) {
      for (i = 0; i < 6; i++) {
        Walking_ATRIAS_B.MotorCurrentCommandSafe[i] =
          Walking_ATRIAS_B.Switch2_d[i];
      }

      a_max = a21;
    }

    /* '<S34>:1:3' */
    Walking_ATRIAS_B.MedullaCommandSafe = a_max;
    Walking_ATRIAS_B.SafetyState = t99;
    Walking_ATRIAS_B.SafetyCountOut = n;

    /* End of MATLAB Function: '<S8>/SAFETY' */

    /* Outport: '<Root>/MedullaCommandSafe' */
    Walking_ATRIAS_Y.MedullaCommandSafe = Walking_ATRIAS_B.MedullaCommandSafe;

    /* Outport: '<Root>/SafetyState' */
    Walking_ATRIAS_Y.SafetyState = Walking_ATRIAS_B.SafetyState;
    for (i = 0; i < 6; i++) {
      /* Outport: '<Root>/MotorCurrentSafe' */
      Walking_ATRIAS_Y.MotorCurrentSafe[i] =
        Walking_ATRIAS_B.MotorCurrentCommandSafe[i];

      /* Outport: '<Root>/u' */
      Walking_ATRIAS_Y.u[i] = Walking_ATRIAS_B.torque_sat[i];

      /* Reshape: '<S2>/Reshape3' */
      Walking_ATRIAS_B.Reshape3_i[i] = Walking_ATRIAS_B.Controller3_o4[i];

      /* Outport: '<Root>/y' */
      Walking_ATRIAS_Y.y[i] = Walking_ATRIAS_B.Reshape3_i[i];

      /* Reshape: '<S2>/Reshape4' */
      Walking_ATRIAS_B.Reshape4[i] = Walking_ATRIAS_B.Controller3_o5[i];

      /* Outport: '<Root>/dy' */
      Walking_ATRIAS_Y.dy[i] = Walking_ATRIAS_B.Reshape4[i];
    }

    for (i = 0; i < 16; i++) {
      /* Reshape: '<S2>/Reshape1' */
      Walking_ATRIAS_B.Reshape1[i] = Walking_ATRIAS_B.Controller3_o3[i];

      /* Outport: '<Root>/ControlOutput' */
      Walking_ATRIAS_Y.ControlOutput[i] = Walking_ATRIAS_B.Reshape1[i];
    }

    /* ok to acquire for <S3>/S-Function */
    Walking_ATRIAS_DW.SFunction_IWORK.AcquireOK = 1;

    /* ok to acquire for <S4>/S-Function */
    Walking_ATRIAS_DW.SFunction_IWORK_m.AcquireOK = 1;

    /* ok to acquire for <S5>/S-Function */
    Walking_ATRIAS_DW.SFunction_IWORK_m1.AcquireOK = 1;

    /* ok to acquire for <S6>/S-Function */
    Walking_ATRIAS_DW.SFunction_IWORK_l.AcquireOK = 1;

    /* ok to acquire for <S7>/S-Function */
    Walking_ATRIAS_DW.SFunction_IWORK_k.AcquireOK = 1;

    /* Gain: '<Root>/rad2deg' */
    for (i = 0; i < 13; i++) {
      Walking_ATRIAS_B.rad2deg[i] = 57.295779513082323 * Walking_ATRIAS_B.q[i];
    }

    /* End of Gain: '<Root>/rad2deg' */

    /* Sum: '<Root>/Add' */
    Walking_ATRIAS_B.Add_j[0] = Walking_ATRIAS_B.rad2deg[3] -
      Walking_ATRIAS_B.rad2deg[7];
    Walking_ATRIAS_B.Add_j[1] = Walking_ATRIAS_B.rad2deg[4] -
      Walking_ATRIAS_B.rad2deg[8];
    Walking_ATRIAS_B.Add_j[2] = Walking_ATRIAS_B.rad2deg[5] -
      Walking_ATRIAS_B.rad2deg[10];
    Walking_ATRIAS_B.Add_j[3] = Walking_ATRIAS_B.rad2deg[6] -
      Walking_ATRIAS_B.rad2deg[11];

    /* DigitalClock: '<Root>/Digital Clock' */
    Walking_ATRIAS_B.DigitalClock = Walking_ATRIAS_M->Timing.t[0];

    /* Gain: '<Root>/Gain1' */
    Walking_ATRIAS_B.Gain1_o[0] = 10.0 * Walking_ATRIAS_B.Add_j[0];
    Walking_ATRIAS_B.Gain1_o[1] = 10.0 * Walking_ATRIAS_B.Add_j[1];
    Walking_ATRIAS_B.Gain1_o[2] = 10.0 * Walking_ATRIAS_B.Add_j[2];
    Walking_ATRIAS_B.Gain1_o[3] = 10.0 * Walking_ATRIAS_B.Add_j[3];

    /* ok to acquire for <S21>/S-Function */
    Walking_ATRIAS_DW.SFunction_IWORK_o.AcquireOK = 1;

    /* ok to acquire for <S22>/S-Function */
    Walking_ATRIAS_DW.SFunction_IWORK_b.AcquireOK = 1;

    /* ok to acquire for <S23>/S-Function */
    Walking_ATRIAS_DW.SFunction_IWORK_j.AcquireOK = 1;

    /* ok to acquire for <S24>/S-Function */
    Walking_ATRIAS_DW.SFunction_IWORK_n.AcquireOK = 1;

    /* ok to acquire for <S25>/S-Function */
    Walking_ATRIAS_DW.SFunction_IWORK_h.AcquireOK = 1;

    /* ok to acquire for <S26>/S-Function */
    Walking_ATRIAS_DW.SFunction_IWORK_c.AcquireOK = 1;
    for (i = 0; i < 6; i++) {
      /* Gain: '<S2>/Gain' */
      Walking_ATRIAS_B.Gain_d[i] = 57.295779513082323 *
        Walking_ATRIAS_B.Reshape3_i[i];

      /* Gain: '<S2>/Gain1' */
      Walking_ATRIAS_B.Gain1_i[i] = 57.295779513082323 *
        Walking_ATRIAS_B.Reshape4[i];
    }

    /* Switch: '<S27>/Switch' incorporates:
     *  Constant: '<S27>/Constant3'
     *  Constant: '<S27>/Constant4'
     *  Constant: '<S2>/Constant2'
     */
    if (Walking_ATRIAS_P.isTrackHold > 0.0) {
      Walking_ATRIAS_B.Switch_f = 0.0;
    } else {
      Walking_ATRIAS_B.Switch_f = 1.0;
    }

    /* End of Switch: '<S27>/Switch' */
    /* ok to acquire for <S36>/S-Function */
    Walking_ATRIAS_DW.SFunction_IWORK_i.AcquireOK = 1;

    /* DigitalClock: '<S33>/Digital Clock' */
    Walking_ATRIAS_B.DigitalClock_e = Walking_ATRIAS_M->Timing.t[0];

    /* RelationalOperator: '<S39>/Compare' incorporates:
     *  Constant: '<S39>/Constant'
     */
    Walking_ATRIAS_B.Compare_k = (Walking_ATRIAS_B.DigitalClock_e <= 12.0);
    for (i = 0; i < 6; i++) {
      /* DataTypeConversion: '<S45>/Data Type Conversion97' */
      Walking_ATRIAS_B.DataTypeConversion97[i] = Walking_ATRIAS_B.EtherCATInit[i];

      /* Saturate: '<S38>/Current Saturation' */
      HalfMaxTicks_idx_0 = Walking_ATRIAS_B.MotorCurrentCommandSafe[i];
      HalfMaxTicks_idx_1 = (-50.0);
      u2 = 50.0;
      if (HalfMaxTicks_idx_0 > u2) {
        HalfMaxTicks_idx_0 = u2;
      } else {
        if (HalfMaxTicks_idx_0 < HalfMaxTicks_idx_1) {
          HalfMaxTicks_idx_0 = HalfMaxTicks_idx_1;
        }
      }

      Walking_ATRIAS_B.CurrentSaturation[i] = HalfMaxTicks_idx_0;

      /* End of Saturate: '<S38>/Current Saturation' */
    }

    /* RelationalOperator: '<S40>/Compare' incorporates:
     *  Constant: '<S40>/Constant'
     */
    Walking_ATRIAS_B.Compare_m = (Walking_ATRIAS_B.DataTypeConversion97[1] !=
      8.0);

    /* Logic: '<S33>/Logical Operator' */
    Walking_ATRIAS_B.LogicalOperator = (Walking_ATRIAS_B.Compare_k ||
      Walking_ATRIAS_B.Compare_m);

    /* Logic: '<S33>/Logical Operator2' */
    Walking_ATRIAS_B.LogicalOperator2 = (Walking_ATRIAS_B.LogicalOperator &&
      Walking_ATRIAS_B.UnitDelay_l);

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[24];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[25];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion69' */
    Walking_ATRIAS_B.DataTypeConversion69[0] = Walking_ATRIAS_B.EtherCATRxVar6_b;
    Walking_ATRIAS_B.DataTypeConversion69[1] = Walking_ATRIAS_B.EtherCATRxVar7;

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[26];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[27];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion93' */
    Walking_ATRIAS_B.DataTypeConversion93[0] = Walking_ATRIAS_B.EtherCATRxVar6_j;
    Walking_ATRIAS_B.DataTypeConversion93[1] = Walking_ATRIAS_B.EtherCATRxVar7_p;

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[28];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion111' */
    Walking_ATRIAS_B.DataTypeConversion111 = Walking_ATRIAS_B.EtherCATRxVar;

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[29];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[30];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion21' */
    Walking_ATRIAS_B.DataTypeConversion21[0] = Walking_ATRIAS_B.EtherCATRxVar6_h;
    Walking_ATRIAS_B.DataTypeConversion21[1] = Walking_ATRIAS_B.EtherCATRxVar7_g;

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[31];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[32];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion45' */
    Walking_ATRIAS_B.DataTypeConversion45[0] =
      Walking_ATRIAS_B.EtherCATRxVar6_bg;
    Walking_ATRIAS_B.DataTypeConversion45[1] = Walking_ATRIAS_B.EtherCATRxVar7_h;

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[33];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion126' */
    Walking_ATRIAS_B.DataTypeConversion126 = Walking_ATRIAS_B.EtherCATRxVar_h;

    /* SignalConversion: '<S54>/TmpSignal ConversionAt SFunction Inport1' incorporates:
     *  MATLAB Function: '<S45>/ConvertAmpCurrent'
     */
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_c[0] =
      Walking_ATRIAS_B.DataTypeConversion69[0];
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_c[1] =
      Walking_ATRIAS_B.DataTypeConversion69[1];
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_c[2] =
      Walking_ATRIAS_B.DataTypeConversion93[0];
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_c[3] =
      Walking_ATRIAS_B.DataTypeConversion93[1];
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_c[4] =
      Walking_ATRIAS_B.DataTypeConversion111;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_c[5] =
      Walking_ATRIAS_B.DataTypeConversion21[0];
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_c[6] =
      Walking_ATRIAS_B.DataTypeConversion21[1];
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_c[7] =
      Walking_ATRIAS_B.DataTypeConversion45[0];
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_c[8] =
      Walking_ATRIAS_B.DataTypeConversion45[1];
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_c[9] =
      Walking_ATRIAS_B.DataTypeConversion126;

    /* MATLAB Function: '<S45>/ConvertAmpCurrent' */
    /* MATLAB Function 'Subsystem1/Subsystem/EtherCATRobotMicrostrain/ConvertAmpCurrent': '<S54>:1' */
    /* '<S54>:1:4' */
    for (i = 0; i < 10; i++) {
      Walking_ATRIAS_B.measuredCurrent[i] =
        Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_c[i] * 60.0 / 8192.0;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[34];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion62' */
    Walking_ATRIAS_B.DataTypeConversion62 = Walking_ATRIAS_B.EtherCATRxVar10;

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[35];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion86' */
    Walking_ATRIAS_B.DataTypeConversion86 = Walking_ATRIAS_B.EtherCATRxVar10_i;

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[36];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion103' */
    Walking_ATRIAS_B.DataTypeConversion103 = Walking_ATRIAS_B.EtherCATRxVar6_p;

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[37];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion14' */
    Walking_ATRIAS_B.DataTypeConversion14 = Walking_ATRIAS_B.EtherCATRxVar10_h;

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[38];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion38' */
    Walking_ATRIAS_B.DataTypeConversion38 = Walking_ATRIAS_B.EtherCATRxVar10_l;

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[39];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion118' */
    Walking_ATRIAS_B.DataTypeConversion118 = Walking_ATRIAS_B.EtherCATRxVar6_n;

    /* SignalConversion: '<S55>/TmpSignal ConversionAt SFunction Inport1' incorporates:
     *  MATLAB Function: '<S45>/ConvertLogicVoltage'
     */
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_o[0] =
      Walking_ATRIAS_B.DataTypeConversion62;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_o[1] =
      Walking_ATRIAS_B.DataTypeConversion86;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_o[2] =
      Walking_ATRIAS_B.DataTypeConversion103;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_o[3] =
      Walking_ATRIAS_B.DataTypeConversion14;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_o[4] =
      Walking_ATRIAS_B.DataTypeConversion38;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_o[5] =
      Walking_ATRIAS_B.DataTypeConversion118;

    /* MATLAB Function 'Subsystem1/Subsystem/EtherCATRobotMicrostrain/ConvertLogicVoltage': '<S55>:1' */
    /* '<S55>:1:5' */
    /* '<S55>:1:7' */

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[40];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion61' */
    Walking_ATRIAS_B.DataTypeConversion61 = Walking_ATRIAS_B.EtherCATRxVar11_b;

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[41];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion85' */
    Walking_ATRIAS_B.DataTypeConversion85 = Walking_ATRIAS_B.EtherCATRxVar11_e;

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[42];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion101' */
    Walking_ATRIAS_B.DataTypeConversion101 = Walking_ATRIAS_B.EtherCATRxVar1_n;

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[43];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion13' */
    Walking_ATRIAS_B.DataTypeConversion13 = Walking_ATRIAS_B.EtherCATRxVar11_k;

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[44];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion37' */
    Walking_ATRIAS_B.DataTypeConversion37 = Walking_ATRIAS_B.EtherCATRxVar11_l;

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[45];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion116' */
    Walking_ATRIAS_B.DataTypeConversion116 = Walking_ATRIAS_B.EtherCATRxVar1_b;

    /* SignalConversion: '<S56>/TmpSignal ConversionAt SFunction Inport1' incorporates:
     *  MATLAB Function: '<S45>/ConvertMotorVoltage'
     */
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_l[0] =
      Walking_ATRIAS_B.DataTypeConversion61;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_l[1] =
      Walking_ATRIAS_B.DataTypeConversion85;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_l[2] =
      Walking_ATRIAS_B.DataTypeConversion101;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_l[3] =
      Walking_ATRIAS_B.DataTypeConversion13;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_l[4] =
      Walking_ATRIAS_B.DataTypeConversion37;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_l[5] =
      Walking_ATRIAS_B.DataTypeConversion116;

    /* MATLAB Function 'Subsystem1/Subsystem/EtherCATRobotMicrostrain/ConvertMotorVoltage': '<S56>:1' */
    /* '<S56>:1:4' */
    /* '<S56>:1:8' */

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[46];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[47];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[48];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[49];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[50];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[51];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion63' */
    Walking_ATRIAS_B.DataTypeConversion63[0] =
      Walking_ATRIAS_B.EtherCATRxVar12_f;
    Walking_ATRIAS_B.DataTypeConversion63[1] = Walking_ATRIAS_B.EtherCATRxVar13;
    Walking_ATRIAS_B.DataTypeConversion63[2] = Walking_ATRIAS_B.EtherCATRxVar14;
    Walking_ATRIAS_B.DataTypeConversion63[3] = Walking_ATRIAS_B.EtherCATRxVar15;
    Walking_ATRIAS_B.DataTypeConversion63[4] = Walking_ATRIAS_B.EtherCATRxVar16;
    Walking_ATRIAS_B.DataTypeConversion63[5] = Walking_ATRIAS_B.EtherCATRxVar17;

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[52];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[53];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[54];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[55];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[56];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[57];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion87' */
    Walking_ATRIAS_B.DataTypeConversion87[0] =
      Walking_ATRIAS_B.EtherCATRxVar12_o;
    Walking_ATRIAS_B.DataTypeConversion87[1] =
      Walking_ATRIAS_B.EtherCATRxVar13_b;
    Walking_ATRIAS_B.DataTypeConversion87[2] =
      Walking_ATRIAS_B.EtherCATRxVar14_j;
    Walking_ATRIAS_B.DataTypeConversion87[3] =
      Walking_ATRIAS_B.EtherCATRxVar15_m;
    Walking_ATRIAS_B.DataTypeConversion87[4] =
      Walking_ATRIAS_B.EtherCATRxVar16_h;
    Walking_ATRIAS_B.DataTypeConversion87[5] =
      Walking_ATRIAS_B.EtherCATRxVar17_b;

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[58];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[59];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[60];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion102' */
    Walking_ATRIAS_B.DataTypeConversion102[0] =
      Walking_ATRIAS_B.EtherCATRxVar12_l;
    Walking_ATRIAS_B.DataTypeConversion102[1] =
      Walking_ATRIAS_B.EtherCATRxVar13_f;
    Walking_ATRIAS_B.DataTypeConversion102[2] =
      Walking_ATRIAS_B.EtherCATRxVar14_f;

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[61];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[62];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[63];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[64];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[65];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[66];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion15' */
    Walking_ATRIAS_B.DataTypeConversion15[0] =
      Walking_ATRIAS_B.EtherCATRxVar12_og;
    Walking_ATRIAS_B.DataTypeConversion15[1] =
      Walking_ATRIAS_B.EtherCATRxVar13_h;
    Walking_ATRIAS_B.DataTypeConversion15[2] =
      Walking_ATRIAS_B.EtherCATRxVar14_l;
    Walking_ATRIAS_B.DataTypeConversion15[3] =
      Walking_ATRIAS_B.EtherCATRxVar15_k;
    Walking_ATRIAS_B.DataTypeConversion15[4] =
      Walking_ATRIAS_B.EtherCATRxVar16_b;
    Walking_ATRIAS_B.DataTypeConversion15[5] =
      Walking_ATRIAS_B.EtherCATRxVar17_g;

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[67];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[68];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[69];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[70];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[71];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[72];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion39' */
    Walking_ATRIAS_B.DataTypeConversion39[0] =
      Walking_ATRIAS_B.EtherCATRxVar12_m;
    Walking_ATRIAS_B.DataTypeConversion39[1] =
      Walking_ATRIAS_B.EtherCATRxVar13_n;
    Walking_ATRIAS_B.DataTypeConversion39[2] =
      Walking_ATRIAS_B.EtherCATRxVar14_b;
    Walking_ATRIAS_B.DataTypeConversion39[3] =
      Walking_ATRIAS_B.EtherCATRxVar15_mh;
    Walking_ATRIAS_B.DataTypeConversion39[4] =
      Walking_ATRIAS_B.EtherCATRxVar16_hz;
    Walking_ATRIAS_B.DataTypeConversion39[5] =
      Walking_ATRIAS_B.EtherCATRxVar17_bq;

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[73];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[74];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[75];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion117' */
    Walking_ATRIAS_B.DataTypeConversion117[0] =
      Walking_ATRIAS_B.EtherCATRxVar12_k;
    Walking_ATRIAS_B.DataTypeConversion117[1] =
      Walking_ATRIAS_B.EtherCATRxVar13_g;
    Walking_ATRIAS_B.DataTypeConversion117[2] =
      Walking_ATRIAS_B.EtherCATRxVar14_d;
    for (i = 0; i < 6; i++) {
      /* MATLAB Function: '<S45>/ConvertLogicVoltage' */
      Walking_ATRIAS_B.logicVoltage[i] =
        (Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_o[i] - 172.0) *
        0.00065934065934065934 * 6.0;

      /* MATLAB Function: '<S45>/ConvertMotorVoltage' */
      Walking_ATRIAS_B.motorVoltage[i] =
        (Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_l[i] - 1300.0) * 60.2 /
        2300.0;

      /* SignalConversion: '<S57>/TmpSignal ConversionAt SFunction Inport1' incorporates:
       *  MATLAB Function: '<S45>/ConvertThermistors'
       */
      Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_a[i] =
        Walking_ATRIAS_B.DataTypeConversion63[i];
    }

    for (i = 0; i < 6; i++) {
      /* SignalConversion: '<S57>/TmpSignal ConversionAt SFunction Inport1' incorporates:
       *  MATLAB Function: '<S45>/ConvertThermistors'
       */
      Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_a[i + 6] =
        Walking_ATRIAS_B.DataTypeConversion87[i];
    }

    /* SignalConversion: '<S57>/TmpSignal ConversionAt SFunction Inport1' incorporates:
     *  MATLAB Function: '<S45>/ConvertThermistors'
     */
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_a[12] =
      Walking_ATRIAS_B.DataTypeConversion102[0];
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_a[13] =
      Walking_ATRIAS_B.DataTypeConversion102[1];
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_a[14] =
      Walking_ATRIAS_B.DataTypeConversion102[2];
    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_a[i + 15] =
        Walking_ATRIAS_B.DataTypeConversion15[i];
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_a[i + 21] =
        Walking_ATRIAS_B.DataTypeConversion39[i];
    }

    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_a[27] =
      Walking_ATRIAS_B.DataTypeConversion117[0];
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_a[28] =
      Walking_ATRIAS_B.DataTypeConversion117[1];
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_a[29] =
      Walking_ATRIAS_B.DataTypeConversion117[2];

    /* MATLAB Function: '<S45>/ConvertThermistors' */
    /* MATLAB Function 'Subsystem1/Subsystem/EtherCATRobotMicrostrain/ConvertThermistors': '<S57>:1' */
    /* '<S57>:1:7' */
    for (i = 0; i < 30; i++) {
      Walking_ATRIAS_B.Temperatures[i] = 0.0;
    }

    /* S-Function (sdspcount2): '<S45>/Counter' */
    /*  20141104 */
    /*      Temperatures = (1.0./( (1.0/298.15) + (1.0/3988.0)*log(4700.0./((3.26./processedADCValue) - 1.0)/10000))) - 273.15; %2015-12-17 DDA uncommend code */
    Walking_ATRIAS_B.Counter_o2 = 0.0;
    Walking_ATRIAS_B.Counter_o1 = Walking_ATRIAS_DW.Counter_Count;
    if (Walking_ATRIAS_DW.Counter_Count == ((uint16_T)32U)) {
      Walking_ATRIAS_B.Counter_o2 = 1.0;
    }

    if (Walking_ATRIAS_DW.Counter_Count < ((uint16_T)65535U)) {
      Walking_ATRIAS_DW.Counter_Count++;
    } else {
      Walking_ATRIAS_DW.Counter_Count = 0U;
    }

    /* End of S-Function (sdspcount2): '<S45>/Counter' */

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[76];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion10' */
    Walking_ATRIAS_B.DataTypeConversion10 = Walking_ATRIAS_B.EtherCATRxVar5;

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[77];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion105' */
    Walking_ATRIAS_B.DataTypeConversion105 = Walking_ATRIAS_B.EtherCATRxVar19;

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[78];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion106' */
    Walking_ATRIAS_B.DataTypeConversion106 = Walking_ATRIAS_B.EtherCATRxVar16_e;

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[79];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion107' */
    Walking_ATRIAS_B.DataTypeConversion107 = Walking_ATRIAS_B.EtherCATRxVar15_d;

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[80];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion108' */
    Walking_ATRIAS_B.DataTypeConversion108 = Walking_ATRIAS_B.EtherCATRxVar5_h;

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[81];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion109' */
    Walking_ATRIAS_B.DataTypeConversion109 = Walking_ATRIAS_B.EtherCATRxVar3;

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[82];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion11' */
    Walking_ATRIAS_B.DataTypeConversion11 = Walking_ATRIAS_B.EtherCATRxVar9_p;

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[83];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion110' */
    Walking_ATRIAS_B.DataTypeConversion110 = Walking_ATRIAS_B.EtherCATRxVar17_f;

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[84];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion112' */
    Walking_ATRIAS_B.DataTypeConversion112 = Walking_ATRIAS_B.EtherCATRxVar18_a;

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[85];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion12' */
    Walking_ATRIAS_B.DataTypeConversion12 = Walking_ATRIAS_B.EtherCATRxVar1_c;

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[86];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion120' */
    Walking_ATRIAS_B.DataTypeConversion120 = Walking_ATRIAS_B.EtherCATRxVar19_p;

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[87];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion121' */
    Walking_ATRIAS_B.DataTypeConversion121 = Walking_ATRIAS_B.EtherCATRxVar16_l;

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[88];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion122' */
    Walking_ATRIAS_B.DataTypeConversion122 = Walking_ATRIAS_B.EtherCATRxVar15_j;

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[89];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion123' */
    Walking_ATRIAS_B.DataTypeConversion123 = Walking_ATRIAS_B.EtherCATRxVar5_f;

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[90];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion124' */
    Walking_ATRIAS_B.DataTypeConversion124 = Walking_ATRIAS_B.EtherCATRxVar3_f;

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[91];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion125' */
    Walking_ATRIAS_B.DataTypeConversion125 = Walking_ATRIAS_B.EtherCATRxVar17_i;

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[92];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion157' */
    Walking_ATRIAS_B.DataTypeConversion157 = Walking_ATRIAS_B.EtherCATRxVar18_n;

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[93];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion16' */
    Walking_ATRIAS_B.DataTypeConversion16 = Walking_ATRIAS_B.EtherCATRxVar16_e3;

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[94];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion18' */
    Walking_ATRIAS_B.DataTypeConversion18 = Walking_ATRIAS_B.EtherCATRxVar17_n;

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[95];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion19' */
    Walking_ATRIAS_B.DataTypeConversion19 = Walking_ATRIAS_B.EtherCATRxVar15_e;

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[96];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion2' */
    Walking_ATRIAS_B.DataTypeConversion2 = Walking_ATRIAS_B.EtherCATRxVar23;

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[97];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[98];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion23' */
    Walking_ATRIAS_B.DataTypeConversion23[0] = Walking_ATRIAS_B.EtherCATRxVar2_g;
    Walking_ATRIAS_B.DataTypeConversion23[1] = Walking_ATRIAS_B.EtherCATRxVar3_e;

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[99];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion27' */
    Walking_ATRIAS_B.DataTypeConversion27 = Walking_ATRIAS_B.EtherCATRxVar23_d;

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[100];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion28' */
    Walking_ATRIAS_B.DataTypeConversion28 = Walking_ATRIAS_B.EtherCATRxVar21;

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[101];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion29' */
    Walking_ATRIAS_B.DataTypeConversion29 = Walking_ATRIAS_B.EtherCATRxVar20;

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[102];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion30' */
    Walking_ATRIAS_B.DataTypeConversion30 = Walking_ATRIAS_B.EtherCATRxVar22;

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[103];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion31' */
    Walking_ATRIAS_B.DataTypeConversion31 = Walking_ATRIAS_B.EtherCATRxVar18_d;

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[104];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion32' */
    Walking_ATRIAS_B.DataTypeConversion32 = Walking_ATRIAS_B.EtherCATRxVar19_p0;

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[105];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion34' */
    Walking_ATRIAS_B.DataTypeConversion34 = Walking_ATRIAS_B.EtherCATRxVar5_g;

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[106];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion35' */
    Walking_ATRIAS_B.DataTypeConversion35 = Walking_ATRIAS_B.EtherCATRxVar9_n;

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[107];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion36' */
    Walking_ATRIAS_B.DataTypeConversion36 = Walking_ATRIAS_B.EtherCATRxVar1_g;

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[108];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion4' */
    Walking_ATRIAS_B.DataTypeConversion4 = Walking_ATRIAS_B.EtherCATRxVar21_f;

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[109];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[110];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion47' */
    Walking_ATRIAS_B.DataTypeConversion47[0] =
      Walking_ATRIAS_B.EtherCATRxVar2_iw;
    Walking_ATRIAS_B.DataTypeConversion47[1] = Walking_ATRIAS_B.EtherCATRxVar3_k;

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[111];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion5' */
    Walking_ATRIAS_B.DataTypeConversion5 = Walking_ATRIAS_B.EtherCATRxVar20_n;

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[112];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion51' */
    Walking_ATRIAS_B.DataTypeConversion51 = Walking_ATRIAS_B.EtherCATRxVar23_n;

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[113];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion52' */
    Walking_ATRIAS_B.DataTypeConversion52 = Walking_ATRIAS_B.EtherCATRxVar21_p;

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[114];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion53' */
    Walking_ATRIAS_B.DataTypeConversion53 = Walking_ATRIAS_B.EtherCATRxVar20_h;

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[115];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion54' */
    Walking_ATRIAS_B.DataTypeConversion54 = Walking_ATRIAS_B.EtherCATRxVar22_l;

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[116];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion55' */
    Walking_ATRIAS_B.DataTypeConversion55 = Walking_ATRIAS_B.EtherCATRxVar18_e;

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[117];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion56' */
    Walking_ATRIAS_B.DataTypeConversion56 = Walking_ATRIAS_B.EtherCATRxVar19_m;

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[118];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion58' */
    Walking_ATRIAS_B.DataTypeConversion58 = Walking_ATRIAS_B.EtherCATRxVar5_e;

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[119];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion59' */
    Walking_ATRIAS_B.DataTypeConversion59 = Walking_ATRIAS_B.EtherCATRxVar9_nz;

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[120];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion6' */
    Walking_ATRIAS_B.DataTypeConversion6 = Walking_ATRIAS_B.EtherCATRxVar22_i;

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[121];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion60' */
    Walking_ATRIAS_B.DataTypeConversion60 = Walking_ATRIAS_B.EtherCATRxVar1_m;

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[122];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion7' */
    Walking_ATRIAS_B.DataTypeConversion7_l = Walking_ATRIAS_B.EtherCATRxVar18_b;

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[123];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[124];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion71' */
    Walking_ATRIAS_B.DataTypeConversion71[0] = Walking_ATRIAS_B.EtherCATRxVar2_f;
    Walking_ATRIAS_B.DataTypeConversion71[1] = Walking_ATRIAS_B.EtherCATRxVar3_b;

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[125];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion75' */
    Walking_ATRIAS_B.DataTypeConversion75 = Walking_ATRIAS_B.EtherCATRxVar23_b;

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[126];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion76' */
    Walking_ATRIAS_B.DataTypeConversion76 = Walking_ATRIAS_B.EtherCATRxVar21_l;

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[127];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion77' */
    Walking_ATRIAS_B.DataTypeConversion77 = Walking_ATRIAS_B.EtherCATRxVar20_e;

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[128];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion78' */
    Walking_ATRIAS_B.DataTypeConversion78 = Walking_ATRIAS_B.EtherCATRxVar22_a;

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[129];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion79' */
    Walking_ATRIAS_B.DataTypeConversion79 = Walking_ATRIAS_B.EtherCATRxVar18_o;

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[130];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion8' */
    Walking_ATRIAS_B.DataTypeConversion8 = Walking_ATRIAS_B.EtherCATRxVar19_ma;

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[131];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion80' */
    Walking_ATRIAS_B.DataTypeConversion80 = Walking_ATRIAS_B.EtherCATRxVar19_c;

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[132];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion82' */
    Walking_ATRIAS_B.DataTypeConversion82 = Walking_ATRIAS_B.EtherCATRxVar5_gi;

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[133];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion83' */
    Walking_ATRIAS_B.DataTypeConversion83 = Walking_ATRIAS_B.EtherCATRxVar9_e;

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[134];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion84' */
    Walking_ATRIAS_B.DataTypeConversion84 = Walking_ATRIAS_B.EtherCATRxVar1_o;

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[135];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[136];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S45>/Data Type Conversion95' */
    Walking_ATRIAS_B.DataTypeConversion95[0] = Walking_ATRIAS_B.EtherCATRxVar2_d;
    Walking_ATRIAS_B.DataTypeConversion95[1] = Walking_ATRIAS_B.EtherCATRxVar3_c;

    /* SignalConversion: '<S58>/TmpSignal ConversionAt SFunction Inport1' incorporates:
     *  MATLAB Function: '<S45>/EncodeSwitches'
     */
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_e[0] =
      Walking_ATRIAS_B.DataTypeConversion52;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_e[1] =
      Walking_ATRIAS_B.DataTypeConversion76;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_e[2] =
      Walking_ATRIAS_B.DataTypeConversion157;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_e[3] =
      Walking_ATRIAS_B.DataTypeConversion4;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_e[4] =
      Walking_ATRIAS_B.DataTypeConversion28;
    Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_e[5] =
      Walking_ATRIAS_B.DataTypeConversion112;

    /* MATLAB Function 'Subsystem1/Subsystem/EtherCATRobotMicrostrain/EncodeSwitches': '<S58>:1' */
    /* '<S58>:1:2' */
    /* '<S58>:1:3' */
    /*  From OSU code: */
    /*  (See atrias/software/atrias_medulla_drivers/src/LegMedulla.cpp and */
    /*  http://code.google.com/p/atrias/wiki/LimitSwitches; note error in Leg */
    /*  A bits 4 and 5.) */
    /*  */
    /*  Hip */
    /*  0 	Inside limit (relaxed position) */
    /*  1 	Outside limit (fully extended) */
    /*  */
    /*  Leg A */
    /*  0 	Negative motor limit */
    /*  1 	Positive motor limit */
    /*  2 	Negative spring deflection limit */
    /*  3 	Positive spring deflection limit */
    /*  4 	Leg extension limit */
    /*  5 	Leg retraction limit */
    /*  */
    /*  Leg B */
    /*  0 	Negative motor limit */
    /*  1 	Positive motor limit */
    /*  2 	Negative spring deflection limit */
    /*  3 	Positive spring deflection limit */
    /*  4 	Motor retraction limit */
    /*  LimitSwitches is an integer which encodes the state of all of the limit switches */
    /*  The bit encoding is as follows: */
    /*    Right Shin (A) */
    /*      LSB 0:	Negative motor limit */
    /*          1: 	Positive motor limit */
    /*          2: 	Negative spring deflection limit */
    /*          3: 	Positive spring deflection limit */
    /*          4: 	Leg retraction limit */
    /*          5: 	Leg extension limit */
    /*    Right Thigh (B) */
    /*    	  6: 	Negative motor limit */
    /*    	  7:	Positive motor limit */
    /*    	  8:	Negative spring deflection limit */
    /*    	  9:	Positive spring deflection limit */
    /*    	 10:	Motor retraction limit */
    /*    Right Hip */
    /*    	 11:	Inside limit (relaxed position) */
    /*    	 12:    Outside limit (fully extended) */
    /*    Left Shin (A) */
    /*         16:	Negative motor limit */
    /*         17: 	Positive motor limit */
    /*         18: 	Negative spring deflection limit */
    /*         19: 	Positive spring deflection limit */
    /*         20: 	Leg retraction limit */
    /*         21: 	Leg extension limit */
    /*    Left Thigh (B) */
    /*    	 22: 	Negative motor limit */
    /*    	 23:	Positive motor limit */
    /*    	 24:	Negative spring deflection limit */
    /*    	 25:	Positive spring deflection limit */
    /*    	 26:	Motor retraction limit */
    /*    Left Hip */
    /*    	 27:	Inside limit (relaxed position) */
    /*    	 28:	Outside limit (fully extended) */
    /*  Right Shin (A) */
    /*  Right Thigh (B) */
    /*  Right Hip */
    /*  Left Shin (A) */
    /*  Left Thigh (B) */
    /*  Left Hip */
    for (i = 0; i < 6; i++) {
      /* MATLAB Function: '<S45>/EncodeSwitches' */
      HalfMaxTicks_idx_0 = rt_roundd_snf
        (Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_e[i]);
      if (HalfMaxTicks_idx_0 < 4.294967296E+9) {
        if (HalfMaxTicks_idx_0 >= 0.0) {
          tmp_9 = (uint32_T)HalfMaxTicks_idx_0;
        } else {
          tmp_9 = 0U;
        }
      } else {
        tmp_9 = MAX_uint32_T;
      }

      LimitSwitchesVec[i] = tmp_9;

      /* MATLAB Function: '<S38>/convert_mtr_current_to_pwm' */
      Walking_ATRIAS_B.y[i] = 0.0;
    }

    /* MATLAB Function: '<S45>/EncodeSwitches' */
    Walking_ATRIAS_B.LimitSwitchesEncoded = LimitSwitchesVec[1] << 6U |
      LimitSwitchesVec[0] | LimitSwitchesVec[2] << 11U | LimitSwitchesVec[3] <<
      16U | LimitSwitchesVec[4] << 22U | LimitSwitchesVec[5] << 27U;

    /* DataTypeConversion: '<S59>/Data Type Conversion3' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.MedullaCommandSafe;
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 256.0);
    }

    Walking_ATRIAS_B.DataTypeConversion3_o = (uint8_T)(HalfMaxTicks_idx_0 < 0.0 ?
      (int32_T)(uint8_T)-(int8_T)(uint8_T)-HalfMaxTicks_idx_0 : (int32_T)
      (uint8_T)HalfMaxTicks_idx_0);

    /* End of DataTypeConversion: '<S59>/Data Type Conversion3' */

    /* Level2 S-Function Block: '<S59>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[137];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S59>/Data Type Conversion4' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.Counter_o1;
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 65536.0);
    }

    Walking_ATRIAS_B.DataTypeConversion4_d = (uint16_T)(HalfMaxTicks_idx_0 < 0.0
      ? (int32_T)(uint16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_0 : (int32_T)
      (uint16_T)HalfMaxTicks_idx_0);

    /* End of DataTypeConversion: '<S59>/Data Type Conversion4' */

    /* Level2 S-Function Block: '<S59>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[138];
      sfcnOutputs(rts, 0);
    }

    /* MATLAB Function: '<S38>/ZeroingLegs' */
    /* MATLAB Function 'Subsystem1/Subsystem/ZeroingLegs': '<S46>:1' */
    /*  leg_motor_1R_torque_cmd = u(1); */
    /*  leg_motor_2R_torque_cmd = u(2); */
    /*  hip_motor_3R_torque_cmd = u(3); */
    /*  leg_motor_1L_torque_cmd = u(4); */
    /*  leg_motor_2L_torque_cmd = u(5); */
    /*  hip_motor_3L_torque_cmd = u(6); */
    /* '<S46>:1:10' */
    Walking_ATRIAS_B.u_zeroed[0] = 0.0;
    Walking_ATRIAS_B.u_zeroed[1] = 0.0;
    Walking_ATRIAS_B.u_zeroed[2] = Walking_ATRIAS_B.CurrentSaturation[2];
    Walking_ATRIAS_B.u_zeroed[3] = 0.0;
    Walking_ATRIAS_B.u_zeroed[4] = 0.0;
    Walking_ATRIAS_B.u_zeroed[5] = Walking_ATRIAS_B.CurrentSaturation[5];

    /* MATLAB Function: '<S38>/convert_mtr_current_to_pwm' incorporates:
     *  Constant: '<S38>/MotorParameters'
     */
    /* MATLAB Function 'Subsystem1/Subsystem/convert_mtr_current_to_pwm': '<S48>:1' */
    /* This function takes motor torque command inputs and outputs */
    /* pwm commands (for the Medulla) in UMich convention */
    /* '<S48>:1:6' */
    if (!Walking_ATRIAS_B.LogicalOperator1) {
      /* The inputs, which are commanded motor torques  */
      /* '<S48>:1:13' */
      /* '<S48>:1:14' */
      /* '<S48>:1:15' */
      /* '<S48>:1:16' */
      /* '<S48>:1:17' */
      /* '<S48>:1:18' */
      /* Parameters determined experimentally at U Mich */
      /* '<S48>:1:21' */
      /* The direction for the left hip motor. (UMich convention) */
      /* '<S48>:1:22' */
      /* The direction for the right hip motor. (UMich convention) */
      /*  The parameters, from http://code.google.com/p/atrias/source/browse/robot_definitions/ */
      /* From robot_invariant_defs.h */
      /* '<S48>:1:26' */
      /* The maximum commanded amplifier value. This is the maximum value sent to the Medullas for the amplifier command. */
      /* From biped2_variant_defs.h */
      /* '<S48>:1:28' */
      /* Maximum motor torque for scaling */
      /* '<S48>:1:29' */
      /* Maximum hip motor torque for scaling */
      /* From leg3_definitions.h (corresponds to our left leg) */
      /* (Note that A=shin and B=thigh for OSU convention) */
      /* '<S48>:1:32' */
      /* '<S48>:1:33' */
      /* From leg4_definitions.h (corresponds to our right leg) */
      /* (Note that A=shin and B=thigh for OSU convention) */
      /* '<S48>:1:36' */
      /* '<S48>:1:37' */
      /* '<S48>:1:39' */
      n = Walking_ATRIAS_P.Calibration.Motors[2] /
        Walking_ATRIAS_P.Calibration.Motors[3];

      /* '<S48>:1:40' */
      CurrentYaw = Walking_ATRIAS_P.Calibration.Motors[2] /
        Walking_ATRIAS_P.Calibration.Motors[4];

      /* Convert leg_motor_1L_torque_cmd */
      /* '<S48>:1:44' */
      /* '<S48>:1:69' */
      Walking_ATRIAS_B.y[0] = Walking_ATRIAS_P.Calibration.Motors[5] * n *
        Walking_ATRIAS_B.u_zeroed[3];

      /* Convert leg_motor_2L_torque_cmd */
      /* '<S48>:1:48' */
      /* '<S48>:1:69' */
      Walking_ATRIAS_B.y[1] = Walking_ATRIAS_P.Calibration.Motors[6] * n *
        Walking_ATRIAS_B.u_zeroed[4];

      /* Convert leg_motor_1R_torque_cmd */
      /* '<S48>:1:52' */
      /* '<S48>:1:69' */
      Walking_ATRIAS_B.y[2] = Walking_ATRIAS_P.Calibration.Motors[7] * n *
        Walking_ATRIAS_B.u_zeroed[0];

      /* Convert leg_motor_2R_torque_cmd */
      /* '<S48>:1:56' */
      /* '<S48>:1:69' */
      Walking_ATRIAS_B.y[3] = Walking_ATRIAS_P.Calibration.Motors[8] * n *
        Walking_ATRIAS_B.u_zeroed[1];

      /* Convert hip_motor_3R_torque_cmd */
      /* Verified experimentally */
      /* '<S48>:1:60' */
      /* '<S48>:1:69' */
      Walking_ATRIAS_B.y[4] = Walking_ATRIAS_P.Calibration.Motors[1] *
        CurrentYaw * Walking_ATRIAS_B.u_zeroed[2];

      /* Convert hip_motor_3L_torque_cmd */
      /* Verified experimentally */
      /* '<S48>:1:64' */
      /* '<S48>:1:69' */
      Walking_ATRIAS_B.y[5] = Walking_ATRIAS_P.Calibration.Motors[0] *
        CurrentYaw * Walking_ATRIAS_B.u_zeroed[5];
    } else {
      /* '<S48>:1:8' */
    }

    /* DataTypeConversion: '<S59>/Data Type Conversion5' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.y[5];
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 4.294967296E+9);
    }

    Walking_ATRIAS_B.DataTypeConversion5_a = HalfMaxTicks_idx_0 < 0.0 ?
      -(int32_T)(uint32_T)-HalfMaxTicks_idx_0 : (int32_T)(uint32_T)
      HalfMaxTicks_idx_0;

    /* End of DataTypeConversion: '<S59>/Data Type Conversion5' */

    /* Level2 S-Function Block: '<S59>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[139];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S60>/Data Type Conversion3' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.MedullaCommandSafe;
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 256.0);
    }

    Walking_ATRIAS_B.DataTypeConversion3_m = (uint8_T)(HalfMaxTicks_idx_0 < 0.0 ?
      (int32_T)(uint8_T)-(int8_T)(uint8_T)-HalfMaxTicks_idx_0 : (int32_T)
      (uint8_T)HalfMaxTicks_idx_0);

    /* End of DataTypeConversion: '<S60>/Data Type Conversion3' */

    /* Level2 S-Function Block: '<S60>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[140];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S60>/Data Type Conversion4' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.Counter_o1;
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 65536.0);
    }

    Walking_ATRIAS_B.DataTypeConversion4_l = (uint16_T)(HalfMaxTicks_idx_0 < 0.0
      ? (int32_T)(uint16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_0 : (int32_T)
      (uint16_T)HalfMaxTicks_idx_0);

    /* End of DataTypeConversion: '<S60>/Data Type Conversion4' */

    /* Level2 S-Function Block: '<S60>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[141];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S60>/Data Type Conversion5' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.y[4];
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 4.294967296E+9);
    }

    Walking_ATRIAS_B.DataTypeConversion5_d = HalfMaxTicks_idx_0 < 0.0 ?
      -(int32_T)(uint32_T)-HalfMaxTicks_idx_0 : (int32_T)(uint32_T)
      HalfMaxTicks_idx_0;

    /* End of DataTypeConversion: '<S60>/Data Type Conversion5' */

    /* Level2 S-Function Block: '<S60>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[142];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[143];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[144];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S61>/Data Type Conversion3' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.MedullaCommandSafe;
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 256.0);
    }

    Walking_ATRIAS_B.DataTypeConversion3_m4 = (uint8_T)(HalfMaxTicks_idx_0 < 0.0
      ? (int32_T)(uint8_T)-(int8_T)(uint8_T)-HalfMaxTicks_idx_0 : (int32_T)
      (uint8_T)HalfMaxTicks_idx_0);

    /* End of DataTypeConversion: '<S61>/Data Type Conversion3' */

    /* Level2 S-Function Block: '<S61>/EtherCAT Tx Var ' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[145];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S61>/Data Type Conversion4' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.Counter_o1;
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 65536.0);
    }

    Walking_ATRIAS_B.DataTypeConversion4_li = (uint16_T)(HalfMaxTicks_idx_0 <
      0.0 ? (int32_T)(uint16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_0 :
      (int32_T)(uint16_T)HalfMaxTicks_idx_0);

    /* End of DataTypeConversion: '<S61>/Data Type Conversion4' */

    /* Level2 S-Function Block: '<S61>/EtherCAT Tx Var 1' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[146];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S71>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[147];
      sfcnOutputs(rts, 0);
    }

    /* S-Function (sfix_bitop): '<S74>/Bitwise Operator' */
    Walking_ATRIAS_B.BitwiseOperator = (uint16_T)
      (Walking_ATRIAS_B.EtherCATPDOReceive5 & ((uint16_T)79U));

    /* RelationalOperator: '<S83>/Compare' incorporates:
     *  Constant: '<S83>/Constant'
     */
    Walking_ATRIAS_B.Compare_o = (Walking_ATRIAS_B.BitwiseOperator == ((uint16_T)
      64U));

    /* S-Function (sfix_bitop): '<S75>/Bitwise Operator' */
    Walking_ATRIAS_B.BitwiseOperator_c = (uint16_T)
      (Walking_ATRIAS_B.EtherCATPDOReceive5 & ((uint16_T)111U));

    /* RelationalOperator: '<S84>/Compare' incorporates:
     *  Constant: '<S84>/Constant'
     */
    Walking_ATRIAS_B.Compare_l = (Walking_ATRIAS_B.BitwiseOperator_c ==
      ((uint16_T)39U));

    /* S-Function (sfix_bitop): '<S76>/Bitwise Operator' */
    Walking_ATRIAS_B.BitwiseOperator_j = (uint16_T)
      (Walking_ATRIAS_B.EtherCATPDOReceive5 & ((uint16_T)111U));

    /* RelationalOperator: '<S85>/Compare' incorporates:
     *  Constant: '<S85>/Constant'
     */
    Walking_ATRIAS_B.Compare_ly = (Walking_ATRIAS_B.BitwiseOperator_j ==
      ((uint16_T)33U));

    /* S-Function (sfix_bitop): '<S77>/Bitwise Operator' */
    Walking_ATRIAS_B.BitwiseOperator_m = (uint16_T)
      (Walking_ATRIAS_B.EtherCATPDOReceive5 & ((uint16_T)8U));

    /* RelationalOperator: '<S86>/Compare' incorporates:
     *  Constant: '<S86>/Constant'
     */
    Walking_ATRIAS_B.Compare_d = (Walking_ATRIAS_B.BitwiseOperator_m ==
      ((uint16_T)8U));

    /* Chart: '<S62>/Chart' */
    /* Gateway: Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_1L/Chart */
    Walking_ATRIAS_DW.sfEvent_l = -1;

    /* During: Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_1L/Chart */
    if (Walking_ATRIAS_DW.is_active_c43_Walking_ATRIAS == 0U) {
      /* Entry: Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_1L/Chart */
      Walking_ATRIAS_DW.is_active_c43_Walking_ATRIAS = 1U;

      /* Entry Internal: Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_1L/Chart */
      /* Transition: '<S70>:78' */
      Walking_ATRIAS_DW.is_c43_Walking_ATRIAS = Walking_ATRIAS_IN_Start1_o;

      /* Entry 'Start1': '<S70>:79' */
      Walking_ATRIAS_B.ControlWordIndex_m = 0.0;
      Walking_ATRIAS_B.EnableTargetTorque_h = 0.0;
      Walking_ATRIAS_B.FaultDetected_g = 0.0;
    } else {
      switch (Walking_ATRIAS_DW.is_c43_Walking_ATRIAS) {
       case Walking_ATRIA_IN_FaultRunning_m:
        /* During 'FaultRunning': '<S70>:81' */
        if (Walking_ATRIAS_B.MedullaCommandSafe == 6.0) {
          /* Transition: '<S70>:96' */
          Walking_ATRIAS_DW.is_c43_Walking_ATRIAS = Walking_ATRIAS_IN_Start1_o;

          /* Entry 'Start1': '<S70>:79' */
          Walking_ATRIAS_B.ControlWordIndex_m = 0.0;
          Walking_ATRIAS_B.EnableTargetTorque_h = 0.0;
          Walking_ATRIAS_B.FaultDetected_g = 0.0;
        }
        break;

       case Walking_ATR_IN_Initialization_d:
        /* During 'Initialization': '<S70>:87' */
        AccelValid = ((Walking_ATRIAS_B.MedullaCommandSafe == 4.0) ||
                      (Walking_ATRIAS_B.MedullaCommandSafe == 5.0));
        if (AccelValid) {
          /* Transition: '<S70>:71' */
          /* Exit Internal 'Initialization': '<S70>:87' */
          Walking_ATRIAS_DW.is_Initialization_a =
            Walking_AT_IN_NO_ACTIVE_CHILD_b;
          Walking_ATRIAS_DW.is_c43_Walking_ATRIAS =
            Walking_ATRIA_IN_FaultRunning_m;

          /* Entry 'FaultRunning': '<S70>:81' */
          Walking_ATRIAS_B.ControlWordIndex_m = 1.0;
          Walking_ATRIAS_B.EnableTargetTorque_h = 0.0;
          Walking_ATRIAS_B.FaultDetected_g = 1.0;
        } else {
          switch (Walking_ATRIAS_DW.is_Initialization_a) {
           case Walking_ATRIAS_IN_Fault_l:
            /* During 'Fault': '<S70>:72' */
            if (Walking_ATRIAS_DW.Timeout_b >= 20.0) {
              /* Transition: '<S70>:83' */
              Walking_ATRIAS_DW.is_Initialization_a = Walking_ATRIAS_IN_Fault_l;

              /* Entry 'Fault': '<S70>:72' */
              Walking_ATRIAS_B.ControlWordIndex_m = 3.0;
              Walking_ATRIAS_B.EnableTargetTorque_h = 0.0;
              Walking_ATRIAS_DW.Timeout_b = 0.0;
              Walking_ATRIAS_B.FaultDetected_g = 0.0;
            } else if (Walking_ATRIAS_B.Compare_o == 1) {
              /* Transition: '<S70>:92' */
              Walking_ATRIAS_DW.is_Initialization_a =
                Walking_A_IN_SwitchOnDisabled_j;

              /* Entry 'SwitchOnDisabled': '<S70>:73' */
              Walking_ATRIAS_B.ControlWordIndex_m = 1.0;
              Walking_ATRIAS_DW.Timeout_b = 0.0;
              Walking_ATRIAS_B.EnableTargetTorque_h = 0.0;
              Walking_ATRIAS_B.FaultDetected_g = 0.0;
            } else {
              Walking_ATRIAS_DW.Timeout_b++;
              Walking_ATRIAS_B.ControlWordIndex_m = 0.0;
            }
            break;

           case Walking_AT_IN_ReadyToSwitchOn_p:
            /* During 'ReadyToSwitchOn': '<S70>:91' */
            if (Walking_ATRIAS_B.Compare_d == 1) {
              /* Transition: '<S70>:90' */
              Walking_ATRIAS_DW.is_Initialization_a = Walking_ATRIAS_IN_Fault_l;

              /* Entry 'Fault': '<S70>:72' */
              Walking_ATRIAS_B.ControlWordIndex_m = 3.0;
              Walking_ATRIAS_B.EnableTargetTorque_h = 0.0;
              Walking_ATRIAS_DW.Timeout_b = 0.0;
              Walking_ATRIAS_B.FaultDetected_g = 0.0;
            } else if (Walking_ATRIAS_B.Compare_o == 1) {
              /* Transition: '<S70>:94' */
              Walking_ATRIAS_DW.is_Initialization_a =
                Walking_A_IN_SwitchOnDisabled_j;

              /* Entry 'SwitchOnDisabled': '<S70>:73' */
              Walking_ATRIAS_B.ControlWordIndex_m = 1.0;
              Walking_ATRIAS_DW.Timeout_b = 0.0;
              Walking_ATRIAS_B.EnableTargetTorque_h = 0.0;
              Walking_ATRIAS_B.FaultDetected_g = 0.0;
            } else {
              AccelValid = ((Walking_ATRIAS_B.Compare_l == 1) &&
                            (Walking_ATRIAS_B.Compare_d == 0));
              if (AccelValid) {
                /* Transition: '<S70>:74' */
                Walking_ATRIAS_DW.is_Initialization_a =
                  Walking_AT_IN_NO_ACTIVE_CHILD_b;
                Walking_ATRIAS_DW.is_c43_Walking_ATRIAS =
                  Walking_ATRIAS_IN_Running_j;

                /* Entry 'Running': '<S70>:76' */
                Walking_ATRIAS_B.FaultDetected_g = 0.0;
                Walking_ATRIAS_B.ControlWordIndex_m = 2.0;
                Walking_ATRIAS_B.EnableTargetTorque_h = 1.0;
              } else {
                Walking_ATRIAS_DW.Timeout_b++;
              }
            }
            break;

           default:
            /* During 'SwitchOnDisabled': '<S70>:73' */
            if (Walking_ATRIAS_B.Compare_ly == 1) {
              /* Transition: '<S70>:75' */
              Walking_ATRIAS_DW.is_Initialization_a =
                Walking_AT_IN_ReadyToSwitchOn_p;

              /* Entry 'ReadyToSwitchOn': '<S70>:91' */
              Walking_ATRIAS_B.ControlWordIndex_m = 2.0;
              Walking_ATRIAS_DW.Timeout_b = 0.0;
              Walking_ATRIAS_B.EnableTargetTorque_h = 0.0;
              Walking_ATRIAS_B.FaultDetected_g = 0.0;
            } else if (Walking_ATRIAS_B.Compare_d == 1) {
              /* Transition: '<S70>:86' */
              Walking_ATRIAS_DW.is_Initialization_a = Walking_ATRIAS_IN_Fault_l;

              /* Entry 'Fault': '<S70>:72' */
              Walking_ATRIAS_B.ControlWordIndex_m = 3.0;
              Walking_ATRIAS_B.EnableTargetTorque_h = 0.0;
              Walking_ATRIAS_DW.Timeout_b = 0.0;
              Walking_ATRIAS_B.FaultDetected_g = 0.0;
            } else {
              Walking_ATRIAS_DW.Timeout_b++;
            }
            break;
          }
        }
        break;

       case Walking_ATRIAS_IN_Running_j:
        /* During 'Running': '<S70>:76' */
        if (Walking_ATRIAS_B.Compare_d == 1) {
          /* Transition: '<S70>:77' */
          Walking_ATRIAS_DW.is_c43_Walking_ATRIAS =
            Walking_ATRIA_IN_FaultRunning_m;

          /* Entry 'FaultRunning': '<S70>:81' */
          Walking_ATRIAS_B.ControlWordIndex_m = 1.0;
          Walking_ATRIAS_B.EnableTargetTorque_h = 0.0;
          Walking_ATRIAS_B.FaultDetected_g = 1.0;
        } else {
          AccelValid = ((Walking_ATRIAS_B.MedullaCommandSafe == 4.0) ||
                        (Walking_ATRIAS_B.MedullaCommandSafe == 5.0));
          if (AccelValid) {
            /* Transition: '<S70>:89' */
            Walking_ATRIAS_DW.is_c43_Walking_ATRIAS =
              Walking_ATRIA_IN_FaultRunning_m;

            /* Entry 'FaultRunning': '<S70>:81' */
            Walking_ATRIAS_B.ControlWordIndex_m = 1.0;
            Walking_ATRIAS_B.EnableTargetTorque_h = 0.0;
            Walking_ATRIAS_B.FaultDetected_g = 1.0;
          }
        }
        break;

       default:
        /* During 'Start1': '<S70>:79' */
        if (Walking_ATRIAS_B.MedullaCommandSafe == 2.0) {
          /* Transition: '<S70>:85' */
          Walking_ATRIAS_DW.is_c43_Walking_ATRIAS =
            Walking_ATR_IN_Initialization_d;

          /* Entry Internal 'Initialization': '<S70>:87' */
          /* Transition: '<S70>:88' */
          Walking_ATRIAS_DW.is_Initialization_a =
            Walking_A_IN_SwitchOnDisabled_j;

          /* Entry 'SwitchOnDisabled': '<S70>:73' */
          Walking_ATRIAS_B.ControlWordIndex_m = 1.0;
          Walking_ATRIAS_DW.Timeout_b = 0.0;
          Walking_ATRIAS_B.EnableTargetTorque_h = 0.0;
          Walking_ATRIAS_B.FaultDetected_g = 0.0;
        }
        break;
      }
    }

    /* End of Chart: '<S62>/Chart' */

    /* Level2 S-Function Block: '<S71>/EtherCAT PDO Receive' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[148];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S62>/Data Type Conversion2' */
    Walking_ATRIAS_B.VectorConcatenate_g[0] =
      Walking_ATRIAS_B.EtherCATPDOReceive;

    /* SignalConversion: '<S78>/ConcatBufferAtVector ConcatenateIn2' incorporates:
     *  Constant: '<S62>/MaxRatedCurrent'
     */
    Walking_ATRIAS_B.VectorConcatenate_g[1] = 48.47;

    /* Fcn: '<S78>/Fcn' */
    Walking_ATRIAS_B.Fcn = Walking_ATRIAS_B.VectorConcatenate_g[0] *
      Walking_ATRIAS_B.VectorConcatenate_g[1] / 1000.0;

    /* DataTypeConversion: '<S62>/Data Type Conversion20' */
    Walking_ATRIAS_B.DataTypeConversion20_f = Walking_ATRIAS_B.Fcn;

    /* Level2 S-Function Block: '<S71>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[149];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S62>/Data Type Conversion42' */
    Walking_ATRIAS_B.DataTypeConversion42 = Walking_ATRIAS_B.EtherCATPDOReceive1;

    /* Level2 S-Function Block: '<S71>/EtherCAT PDO Receive2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[150];
      sfcnOutputs(rts, 0);
    }

    /* Switch: '<S62>/Switch' incorporates:
     *  Constant: '<S62>/Constant1'
     */
    if (Walking_ATRIAS_B.EnableTargetTorque_h > 0.0) {
      /* SignalConversion: '<S72>/ConcatBufferAtVector ConcatenateIn2' incorporates:
       *  Constant: '<S62>/MaxRatedCurrent'
       */
      Walking_ATRIAS_B.VectorConcatenate_f0[1] = 48.47;

      /* SignalConversion: '<S72>/ConcatBufferAtVector ConcatenateIn1' */
      Walking_ATRIAS_B.VectorConcatenate_f0[0] =
        Walking_ATRIAS_B.CurrentSaturation[3];

      /* Fcn: '<S72>/Fcn' */
      Walking_ATRIAS_B.Fcn_c = Walking_ATRIAS_B.VectorConcatenate_f0[0] * 1000.0
        / Walking_ATRIAS_B.VectorConcatenate_f0[1];

      /* DataTypeConversion: '<S72>/Data Type Conversion6' */
      HalfMaxTicks_idx_0 = floor(Walking_ATRIAS_B.Fcn_c);
      if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
        HalfMaxTicks_idx_0 = 0.0;
      } else {
        HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 65536.0);
      }

      Walking_ATRIAS_B.DataTypeConversion6_f = (int16_T)(HalfMaxTicks_idx_0 <
        0.0 ? (int32_T)(int16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_0 :
        (int32_T)(int16_T)(uint16_T)HalfMaxTicks_idx_0);

      /* End of DataTypeConversion: '<S72>/Data Type Conversion6' */
      Walking_ATRIAS_B.Switch_fb = Walking_ATRIAS_B.DataTypeConversion6_f;
    } else {
      Walking_ATRIAS_B.Switch_fb = 0;
    }

    /* End of Switch: '<S62>/Switch' */

    /* Level2 S-Function Block: '<S71>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[151];
      sfcnOutputs(rts, 0);
    }

    /* SwitchCase: '<S73>/Switch Case' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.ControlWordIndex_m;
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 4.294967296E+9);
    }

    switch (HalfMaxTicks_idx_0 < 0.0 ? -(int32_T)(uint32_T)-HalfMaxTicks_idx_0 :
            (int32_T)(uint32_T)HalfMaxTicks_idx_0) {
     case 1:
      /* Outputs for IfAction SubSystem: '<S73>/ShutdownControlWord' incorporates:
       *  ActionPort: '<S82>/Action Port'
       */
      Walking_ATR_ShutdownControlWord(&Walking_ATRIAS_B.Merge);

      /* End of Outputs for SubSystem: '<S73>/ShutdownControlWord' */
      break;

     case 2:
      /* Outputs for IfAction SubSystem: '<S73>/EnableControlWord' incorporates:
       *  ActionPort: '<S79>/Action Port'
       */
      Walking_ATRIA_EnableControlWord(&Walking_ATRIAS_B.Merge);

      /* End of Outputs for SubSystem: '<S73>/EnableControlWord' */
      break;

     case 3:
      /* Outputs for IfAction SubSystem: '<S73>/FaultReset' incorporates:
       *  ActionPort: '<S80>/Action Port'
       */
      Walking_ATRIAS_FaultReset(&Walking_ATRIAS_B.Merge);

      /* End of Outputs for SubSystem: '<S73>/FaultReset' */
      break;

     default:
      /* Outputs for IfAction SubSystem: '<S73>/NothingControlWord' incorporates:
       *  ActionPort: '<S81>/Action Port'
       */
      Walking_ATRI_NothingControlWord(&Walking_ATRIAS_B.Merge);

      /* End of Outputs for SubSystem: '<S73>/NothingControlWord' */
      break;
    }

    /* End of SwitchCase: '<S73>/Switch Case' */

    /* Level2 S-Function Block: '<S71>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[152];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S71>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[153];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S88>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[154];
      sfcnOutputs(rts, 0);
    }

    /* S-Function (sfix_bitop): '<S91>/Bitwise Operator' */
    Walking_ATRIAS_B.BitwiseOperator_h = (uint16_T)
      (Walking_ATRIAS_B.EtherCATPDOReceive5_d & ((uint16_T)79U));

    /* RelationalOperator: '<S100>/Compare' incorporates:
     *  Constant: '<S100>/Constant'
     */
    Walking_ATRIAS_B.Compare_d0 = (Walking_ATRIAS_B.BitwiseOperator_h ==
      ((uint16_T)64U));

    /* S-Function (sfix_bitop): '<S92>/Bitwise Operator' */
    Walking_ATRIAS_B.BitwiseOperator_d = (uint16_T)
      (Walking_ATRIAS_B.EtherCATPDOReceive5_d & ((uint16_T)111U));

    /* RelationalOperator: '<S101>/Compare' incorporates:
     *  Constant: '<S101>/Constant'
     */
    Walking_ATRIAS_B.Compare_p = (Walking_ATRIAS_B.BitwiseOperator_d ==
      ((uint16_T)39U));

    /* S-Function (sfix_bitop): '<S93>/Bitwise Operator' */
    Walking_ATRIAS_B.BitwiseOperator_k = (uint16_T)
      (Walking_ATRIAS_B.EtherCATPDOReceive5_d & ((uint16_T)111U));

    /* RelationalOperator: '<S102>/Compare' incorporates:
     *  Constant: '<S102>/Constant'
     */
    Walking_ATRIAS_B.Compare_om = (Walking_ATRIAS_B.BitwiseOperator_k ==
      ((uint16_T)33U));

    /* S-Function (sfix_bitop): '<S94>/Bitwise Operator' */
    Walking_ATRIAS_B.BitwiseOperator_he = (uint16_T)
      (Walking_ATRIAS_B.EtherCATPDOReceive5_d & ((uint16_T)8U));

    /* RelationalOperator: '<S103>/Compare' incorporates:
     *  Constant: '<S103>/Constant'
     */
    Walking_ATRIAS_B.Compare_n = (Walking_ATRIAS_B.BitwiseOperator_he ==
      ((uint16_T)8U));

    /* Chart: '<S63>/Chart' */
    Walking_ATRIAS_Chart(Walking_ATRIAS_B.Compare_d0, Walking_ATRIAS_B.Compare_p,
                         Walking_ATRIAS_B.Compare_om, Walking_ATRIAS_B.Compare_n,
                         Walking_ATRIAS_B.MedullaCommandSafe,
                         &Walking_ATRIAS_B.sf_Chart_m,
                         &Walking_ATRIAS_DW.sf_Chart_m);

    /* Level2 S-Function Block: '<S88>/EtherCAT PDO Receive' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[155];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S63>/Data Type Conversion3' */
    Walking_ATRIAS_B.VectorConcatenate_f[0] =
      Walking_ATRIAS_B.EtherCATPDOReceive_d;

    /* SignalConversion: '<S95>/ConcatBufferAtVector ConcatenateIn2' incorporates:
     *  Constant: '<S63>/MaxRatedCurrent'
     */
    Walking_ATRIAS_B.VectorConcatenate_f[1] = 48.47;

    /* Fcn: '<S95>/Fcn' */
    Walking_ATRIAS_B.Fcn_m = Walking_ATRIAS_B.VectorConcatenate_f[0] *
      Walking_ATRIAS_B.VectorConcatenate_f[1] / 1000.0;

    /* DataTypeConversion: '<S63>/Data Type Conversion20' */
    Walking_ATRIAS_B.DataTypeConversion20_o = Walking_ATRIAS_B.Fcn_m;

    /* Level2 S-Function Block: '<S88>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[156];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S63>/Data Type Conversion42' */
    Walking_ATRIAS_B.DataTypeConversion42_e =
      Walking_ATRIAS_B.EtherCATPDOReceive1_d;

    /* Level2 S-Function Block: '<S88>/EtherCAT PDO Receive2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[157];
      sfcnOutputs(rts, 0);
    }

    /* Switch: '<S63>/Switch' incorporates:
     *  Constant: '<S63>/Constant1'
     */
    if (Walking_ATRIAS_B.sf_Chart_m.EnableTargetTorque > 0.0) {
      /* SignalConversion: '<S89>/ConcatBufferAtVector ConcatenateIn2' incorporates:
       *  Constant: '<S63>/MaxRatedCurrent'
       */
      Walking_ATRIAS_B.VectorConcatenate_c[1] = 48.47;

      /* SignalConversion: '<S89>/ConcatBufferAtVector ConcatenateIn1' */
      Walking_ATRIAS_B.VectorConcatenate_c[0] =
        Walking_ATRIAS_B.CurrentSaturation[0];

      /* Fcn: '<S89>/Fcn' */
      Walking_ATRIAS_B.Fcn_h = Walking_ATRIAS_B.VectorConcatenate_c[0] * 1000.0 /
        Walking_ATRIAS_B.VectorConcatenate_c[1];

      /* DataTypeConversion: '<S89>/Data Type Conversion6' */
      HalfMaxTicks_idx_0 = floor(Walking_ATRIAS_B.Fcn_h);
      if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
        HalfMaxTicks_idx_0 = 0.0;
      } else {
        HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 65536.0);
      }

      Walking_ATRIAS_B.DataTypeConversion6_eq = (int16_T)(HalfMaxTicks_idx_0 <
        0.0 ? (int32_T)(int16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_0 :
        (int32_T)(int16_T)(uint16_T)HalfMaxTicks_idx_0);

      /* End of DataTypeConversion: '<S89>/Data Type Conversion6' */
      Walking_ATRIAS_B.Switch_fg = Walking_ATRIAS_B.DataTypeConversion6_eq;
    } else {
      Walking_ATRIAS_B.Switch_fg = 0;
    }

    /* End of Switch: '<S63>/Switch' */

    /* Level2 S-Function Block: '<S88>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[158];
      sfcnOutputs(rts, 0);
    }

    /* SwitchCase: '<S90>/Switch Case' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.sf_Chart_m.ControlWordIndex;
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 4.294967296E+9);
    }

    switch (HalfMaxTicks_idx_0 < 0.0 ? -(int32_T)(uint32_T)-HalfMaxTicks_idx_0 :
            (int32_T)(uint32_T)HalfMaxTicks_idx_0) {
     case 1:
      /* Outputs for IfAction SubSystem: '<S90>/ShutdownControlWord' incorporates:
       *  ActionPort: '<S99>/Action Port'
       */
      Walking_ATR_ShutdownControlWord(&Walking_ATRIAS_B.Merge_b);

      /* End of Outputs for SubSystem: '<S90>/ShutdownControlWord' */
      break;

     case 2:
      /* Outputs for IfAction SubSystem: '<S90>/EnableControlWord' incorporates:
       *  ActionPort: '<S96>/Action Port'
       */
      Walking_ATRIA_EnableControlWord(&Walking_ATRIAS_B.Merge_b);

      /* End of Outputs for SubSystem: '<S90>/EnableControlWord' */
      break;

     case 3:
      /* Outputs for IfAction SubSystem: '<S90>/FaultReset' incorporates:
       *  ActionPort: '<S97>/Action Port'
       */
      Walking_ATRIAS_FaultReset(&Walking_ATRIAS_B.Merge_b);

      /* End of Outputs for SubSystem: '<S90>/FaultReset' */
      break;

     default:
      /* Outputs for IfAction SubSystem: '<S90>/NothingControlWord' incorporates:
       *  ActionPort: '<S98>/Action Port'
       */
      Walking_ATRI_NothingControlWord(&Walking_ATRIAS_B.Merge_b);

      /* End of Outputs for SubSystem: '<S90>/NothingControlWord' */
      break;
    }

    /* End of SwitchCase: '<S90>/Switch Case' */

    /* Level2 S-Function Block: '<S88>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[159];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S88>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[160];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S105>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[161];
      sfcnOutputs(rts, 0);
    }

    /* S-Function (sfix_bitop): '<S108>/Bitwise Operator' */
    Walking_ATRIAS_B.BitwiseOperator_hh = (uint16_T)
      (Walking_ATRIAS_B.EtherCATPDOReceive5_dm & ((uint16_T)79U));

    /* RelationalOperator: '<S117>/Compare' incorporates:
     *  Constant: '<S117>/Constant'
     */
    Walking_ATRIAS_B.Compare_e = (Walking_ATRIAS_B.BitwiseOperator_hh ==
      ((uint16_T)64U));

    /* S-Function (sfix_bitop): '<S109>/Bitwise Operator' */
    Walking_ATRIAS_B.BitwiseOperator_f = (uint16_T)
      (Walking_ATRIAS_B.EtherCATPDOReceive5_dm & ((uint16_T)111U));

    /* RelationalOperator: '<S118>/Compare' incorporates:
     *  Constant: '<S118>/Constant'
     */
    Walking_ATRIAS_B.Compare_lx = (Walking_ATRIAS_B.BitwiseOperator_f ==
      ((uint16_T)39U));

    /* S-Function (sfix_bitop): '<S110>/Bitwise Operator' */
    Walking_ATRIAS_B.BitwiseOperator_cf = (uint16_T)
      (Walking_ATRIAS_B.EtherCATPDOReceive5_dm & ((uint16_T)111U));

    /* RelationalOperator: '<S119>/Compare' incorporates:
     *  Constant: '<S119>/Constant'
     */
    Walking_ATRIAS_B.Compare_k0 = (Walking_ATRIAS_B.BitwiseOperator_cf ==
      ((uint16_T)33U));

    /* S-Function (sfix_bitop): '<S111>/Bitwise Operator' */
    Walking_ATRIAS_B.BitwiseOperator_e = (uint16_T)
      (Walking_ATRIAS_B.EtherCATPDOReceive5_dm & ((uint16_T)8U));

    /* RelationalOperator: '<S120>/Compare' incorporates:
     *  Constant: '<S120>/Constant'
     */
    Walking_ATRIAS_B.Compare_la = (Walking_ATRIAS_B.BitwiseOperator_e ==
      ((uint16_T)8U));

    /* Chart: '<S64>/Chart' */
    /* Gateway: Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_2L/Chart */
    Walking_ATRIAS_DW.sfEvent = -1;

    /* During: Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_2L/Chart */
    if (Walking_ATRIAS_DW.is_active_c45_Walking_ATRIAS == 0U) {
      /* Entry: Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_2L/Chart */
      Walking_ATRIAS_DW.is_active_c45_Walking_ATRIAS = 1U;

      /* Entry Internal: Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_2L/Chart */
      /* Transition: '<S104>:161' */
      Walking_ATRIAS_DW.is_c45_Walking_ATRIAS = Walking_ATRIAS_IN_Start1_o;

      /* Entry 'Start1': '<S104>:157' */
      Walking_ATRIAS_B.ControlWordIndex = 0.0;
      Walking_ATRIAS_B.EnableTargetTorque = 0.0;
      Walking_ATRIAS_B.FaultDetected = 0.0;
    } else {
      switch (Walking_ATRIAS_DW.is_c45_Walking_ATRIAS) {
       case Walking_ATRIA_IN_FaultRunning_m:
        /* During 'FaultRunning': '<S104>:147' */
        if (Walking_ATRIAS_B.MedullaCommandSafe == 6.0) {
          /* Transition: '<S104>:166' */
          Walking_ATRIAS_DW.is_c45_Walking_ATRIAS = Walking_ATRIAS_IN_Start1_o;

          /* Entry 'Start1': '<S104>:157' */
          Walking_ATRIAS_B.ControlWordIndex = 0.0;
          Walking_ATRIAS_B.EnableTargetTorque = 0.0;
          Walking_ATRIAS_B.FaultDetected = 0.0;
        }
        break;

       case Walking_ATR_IN_Initialization_d:
        /* During 'Initialization': '<S104>:144' */
        AccelValid = ((Walking_ATRIAS_B.MedullaCommandSafe == 4.0) ||
                      (Walking_ATRIAS_B.MedullaCommandSafe == 5.0));
        if (AccelValid) {
          /* Transition: '<S104>:160' */
          /* Exit Internal 'Initialization': '<S104>:144' */
          Walking_ATRIAS_DW.is_Initialization = Walking_AT_IN_NO_ACTIVE_CHILD_b;
          Walking_ATRIAS_DW.is_c45_Walking_ATRIAS =
            Walking_ATRIA_IN_FaultRunning_m;

          /* Entry 'FaultRunning': '<S104>:147' */
          Walking_ATRIAS_B.ControlWordIndex = 1.0;
          Walking_ATRIAS_B.EnableTargetTorque = 0.0;
          Walking_ATRIAS_B.FaultDetected = 1.0;
        } else {
          switch (Walking_ATRIAS_DW.is_Initialization) {
           case Walking_ATRIAS_IN_Fault_l:
            /* During 'Fault': '<S104>:163' */
            if (Walking_ATRIAS_DW.Timeout >= 20.0) {
              /* Transition: '<S104>:164' */
              Walking_ATRIAS_DW.is_Initialization = Walking_ATRIAS_IN_Fault_l;

              /* Entry 'Fault': '<S104>:163' */
              Walking_ATRIAS_B.ControlWordIndex = 3.0;
              Walking_ATRIAS_B.EnableTargetTorque = 0.0;
              Walking_ATRIAS_DW.Timeout = 0.0;
              Walking_ATRIAS_B.FaultDetected = 0.0;
            } else if (Walking_ATRIAS_B.Compare_e == 1) {
              /* Transition: '<S104>:150' */
              Walking_ATRIAS_DW.is_Initialization =
                Walking_A_IN_SwitchOnDisabled_j;

              /* Entry 'SwitchOnDisabled': '<S104>:159' */
              Walking_ATRIAS_B.ControlWordIndex = 1.0;
              Walking_ATRIAS_DW.Timeout = 0.0;
              Walking_ATRIAS_B.EnableTargetTorque = 0.0;
              Walking_ATRIAS_B.FaultDetected = 0.0;
            } else {
              Walking_ATRIAS_DW.Timeout++;
              Walking_ATRIAS_B.ControlWordIndex = 0.0;
            }
            break;

           case Walking_AT_IN_ReadyToSwitchOn_p:
            /* During 'ReadyToSwitchOn': '<S104>:162' */
            if (Walking_ATRIAS_B.Compare_la == 1) {
              /* Transition: '<S104>:143' */
              Walking_ATRIAS_DW.is_Initialization = Walking_ATRIAS_IN_Fault_l;

              /* Entry 'Fault': '<S104>:163' */
              Walking_ATRIAS_B.ControlWordIndex = 3.0;
              Walking_ATRIAS_B.EnableTargetTorque = 0.0;
              Walking_ATRIAS_DW.Timeout = 0.0;
              Walking_ATRIAS_B.FaultDetected = 0.0;
            } else if (Walking_ATRIAS_B.Compare_e == 1) {
              /* Transition: '<S104>:152' */
              Walking_ATRIAS_DW.is_Initialization =
                Walking_A_IN_SwitchOnDisabled_j;

              /* Entry 'SwitchOnDisabled': '<S104>:159' */
              Walking_ATRIAS_B.ControlWordIndex = 1.0;
              Walking_ATRIAS_DW.Timeout = 0.0;
              Walking_ATRIAS_B.EnableTargetTorque = 0.0;
              Walking_ATRIAS_B.FaultDetected = 0.0;
            } else {
              AccelValid = ((Walking_ATRIAS_B.Compare_lx == 1) &&
                            (Walking_ATRIAS_B.Compare_la == 0));
              if (AccelValid) {
                /* Transition: '<S104>:158' */
                Walking_ATRIAS_DW.is_Initialization =
                  Walking_AT_IN_NO_ACTIVE_CHILD_b;
                Walking_ATRIAS_DW.is_c45_Walking_ATRIAS =
                  Walking_ATRIAS_IN_Running_j;

                /* Entry 'Running': '<S104>:154' */
                Walking_ATRIAS_B.FaultDetected = 0.0;
                Walking_ATRIAS_B.ControlWordIndex = 2.0;
                Walking_ATRIAS_B.EnableTargetTorque = 1.0;
              } else {
                Walking_ATRIAS_DW.Timeout++;
              }
            }
            break;

           default:
            /* During 'SwitchOnDisabled': '<S104>:159' */
            if (Walking_ATRIAS_B.Compare_k0 == 1) {
              /* Transition: '<S104>:146' */
              Walking_ATRIAS_DW.is_Initialization =
                Walking_AT_IN_ReadyToSwitchOn_p;

              /* Entry 'ReadyToSwitchOn': '<S104>:162' */
              Walking_ATRIAS_B.ControlWordIndex = 2.0;
              Walking_ATRIAS_DW.Timeout = 0.0;
              Walking_ATRIAS_B.EnableTargetTorque = 0.0;
              Walking_ATRIAS_B.FaultDetected = 0.0;
            } else if (Walking_ATRIAS_B.Compare_la == 1) {
              /* Transition: '<S104>:148' */
              Walking_ATRIAS_DW.is_Initialization = Walking_ATRIAS_IN_Fault_l;

              /* Entry 'Fault': '<S104>:163' */
              Walking_ATRIAS_B.ControlWordIndex = 3.0;
              Walking_ATRIAS_B.EnableTargetTorque = 0.0;
              Walking_ATRIAS_DW.Timeout = 0.0;
              Walking_ATRIAS_B.FaultDetected = 0.0;
            } else {
              Walking_ATRIAS_DW.Timeout++;
            }
            break;
          }
        }
        break;

       case Walking_ATRIAS_IN_Running_j:
        /* During 'Running': '<S104>:154' */
        if (Walking_ATRIAS_B.Compare_la == 1) {
          /* Transition: '<S104>:145' */
          Walking_ATRIAS_DW.is_c45_Walking_ATRIAS =
            Walking_ATRIA_IN_FaultRunning_m;

          /* Entry 'FaultRunning': '<S104>:147' */
          Walking_ATRIAS_B.ControlWordIndex = 1.0;
          Walking_ATRIAS_B.EnableTargetTorque = 0.0;
          Walking_ATRIAS_B.FaultDetected = 1.0;
        } else {
          AccelValid = ((Walking_ATRIAS_B.MedullaCommandSafe == 4.0) ||
                        (Walking_ATRIAS_B.MedullaCommandSafe == 5.0));
          if (AccelValid) {
            /* Transition: '<S104>:165' */
            Walking_ATRIAS_DW.is_c45_Walking_ATRIAS =
              Walking_ATRIA_IN_FaultRunning_m;

            /* Entry 'FaultRunning': '<S104>:147' */
            Walking_ATRIAS_B.ControlWordIndex = 1.0;
            Walking_ATRIAS_B.EnableTargetTorque = 0.0;
            Walking_ATRIAS_B.FaultDetected = 1.0;
          }
        }
        break;

       default:
        /* During 'Start1': '<S104>:157' */
        if (Walking_ATRIAS_B.MedullaCommandSafe == 2.0) {
          /* Transition: '<S104>:151' */
          Walking_ATRIAS_DW.is_c45_Walking_ATRIAS =
            Walking_ATR_IN_Initialization_d;

          /* Entry Internal 'Initialization': '<S104>:144' */
          /* Transition: '<S104>:156' */
          Walking_ATRIAS_DW.is_Initialization = Walking_A_IN_SwitchOnDisabled_j;

          /* Entry 'SwitchOnDisabled': '<S104>:159' */
          Walking_ATRIAS_B.ControlWordIndex = 1.0;
          Walking_ATRIAS_DW.Timeout = 0.0;
          Walking_ATRIAS_B.EnableTargetTorque = 0.0;
          Walking_ATRIAS_B.FaultDetected = 0.0;
        }
        break;
      }
    }

    /* End of Chart: '<S64>/Chart' */

    /* Level2 S-Function Block: '<S105>/EtherCAT PDO Receive' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[162];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S64>/Data Type Conversion2' */
    Walking_ATRIAS_B.VectorConcatenate_d[0] =
      Walking_ATRIAS_B.EtherCATPDOReceive_p;

    /* SignalConversion: '<S112>/ConcatBufferAtVector ConcatenateIn2' incorporates:
     *  Constant: '<S64>/MaxRatedCurrent'
     */
    Walking_ATRIAS_B.VectorConcatenate_d[1] = 48.47;

    /* Fcn: '<S112>/Fcn' */
    Walking_ATRIAS_B.Fcn_k = Walking_ATRIAS_B.VectorConcatenate_d[0] *
      Walking_ATRIAS_B.VectorConcatenate_d[1] / 1000.0;

    /* DataTypeConversion: '<S64>/Data Type Conversion20' */
    Walking_ATRIAS_B.DataTypeConversion20_n = Walking_ATRIAS_B.Fcn_k;

    /* Level2 S-Function Block: '<S105>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[163];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S64>/Data Type Conversion42' */
    Walking_ATRIAS_B.DataTypeConversion42_h =
      Walking_ATRIAS_B.EtherCATPDOReceive1_n;

    /* Level2 S-Function Block: '<S105>/EtherCAT PDO Receive2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[164];
      sfcnOutputs(rts, 0);
    }

    /* Switch: '<S64>/Switch' incorporates:
     *  Constant: '<S64>/Constant1'
     */
    if (Walking_ATRIAS_B.EnableTargetTorque > 0.0) {
      /* SignalConversion: '<S106>/ConcatBufferAtVector ConcatenateIn2' incorporates:
       *  Constant: '<S64>/MaxRatedCurrent'
       */
      Walking_ATRIAS_B.VectorConcatenate_n[1] = 48.47;

      /* SignalConversion: '<S106>/ConcatBufferAtVector ConcatenateIn1' */
      Walking_ATRIAS_B.VectorConcatenate_n[0] =
        Walking_ATRIAS_B.CurrentSaturation[4];

      /* Fcn: '<S106>/Fcn' */
      Walking_ATRIAS_B.Fcn_f = Walking_ATRIAS_B.VectorConcatenate_n[0] * 1000.0 /
        Walking_ATRIAS_B.VectorConcatenate_n[1];

      /* DataTypeConversion: '<S106>/Data Type Conversion6' */
      HalfMaxTicks_idx_0 = floor(Walking_ATRIAS_B.Fcn_f);
      if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
        HalfMaxTicks_idx_0 = 0.0;
      } else {
        HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 65536.0);
      }

      Walking_ATRIAS_B.DataTypeConversion6_e = (int16_T)(HalfMaxTicks_idx_0 <
        0.0 ? (int32_T)(int16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_0 :
        (int32_T)(int16_T)(uint16_T)HalfMaxTicks_idx_0);

      /* End of DataTypeConversion: '<S106>/Data Type Conversion6' */
      Walking_ATRIAS_B.Switch_d = Walking_ATRIAS_B.DataTypeConversion6_e;
    } else {
      Walking_ATRIAS_B.Switch_d = 0;
    }

    /* End of Switch: '<S64>/Switch' */

    /* Level2 S-Function Block: '<S105>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[165];
      sfcnOutputs(rts, 0);
    }

    /* SwitchCase: '<S107>/Switch Case' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.ControlWordIndex;
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 4.294967296E+9);
    }

    switch (HalfMaxTicks_idx_0 < 0.0 ? -(int32_T)(uint32_T)-HalfMaxTicks_idx_0 :
            (int32_T)(uint32_T)HalfMaxTicks_idx_0) {
     case 1:
      /* Outputs for IfAction SubSystem: '<S107>/ShutdownControlWord' incorporates:
       *  ActionPort: '<S116>/Action Port'
       */
      Walking_ATR_ShutdownControlWord(&Walking_ATRIAS_B.Merge_e);

      /* End of Outputs for SubSystem: '<S107>/ShutdownControlWord' */
      break;

     case 2:
      /* Outputs for IfAction SubSystem: '<S107>/EnableControlWord' incorporates:
       *  ActionPort: '<S113>/Action Port'
       */
      Walking_ATRIA_EnableControlWord(&Walking_ATRIAS_B.Merge_e);

      /* End of Outputs for SubSystem: '<S107>/EnableControlWord' */
      break;

     case 3:
      /* Outputs for IfAction SubSystem: '<S107>/FaultReset' incorporates:
       *  ActionPort: '<S114>/Action Port'
       */
      Walking_ATRIAS_FaultReset(&Walking_ATRIAS_B.Merge_e);

      /* End of Outputs for SubSystem: '<S107>/FaultReset' */
      break;

     default:
      /* Outputs for IfAction SubSystem: '<S107>/NothingControlWord' incorporates:
       *  ActionPort: '<S115>/Action Port'
       */
      Walking_ATRI_NothingControlWord(&Walking_ATRIAS_B.Merge_e);

      /* End of Outputs for SubSystem: '<S107>/NothingControlWord' */
      break;
    }

    /* End of SwitchCase: '<S107>/Switch Case' */

    /* Level2 S-Function Block: '<S105>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[166];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S105>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[167];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S122>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[168];
      sfcnOutputs(rts, 0);
    }

    /* S-Function (sfix_bitop): '<S125>/Bitwise Operator' */
    Walking_ATRIAS_B.BitwiseOperator_d5 = (uint16_T)
      (Walking_ATRIAS_B.EtherCATPDOReceive5_m & ((uint16_T)79U));

    /* RelationalOperator: '<S134>/Compare' incorporates:
     *  Constant: '<S134>/Constant'
     */
    Walking_ATRIAS_B.Compare_i = (Walking_ATRIAS_B.BitwiseOperator_d5 ==
      ((uint16_T)64U));

    /* S-Function (sfix_bitop): '<S126>/Bitwise Operator' */
    Walking_ATRIAS_B.BitwiseOperator_g = (uint16_T)
      (Walking_ATRIAS_B.EtherCATPDOReceive5_m & ((uint16_T)111U));

    /* RelationalOperator: '<S135>/Compare' incorporates:
     *  Constant: '<S135>/Constant'
     */
    Walking_ATRIAS_B.Compare_ls = (Walking_ATRIAS_B.BitwiseOperator_g ==
      ((uint16_T)39U));

    /* S-Function (sfix_bitop): '<S127>/Bitwise Operator' */
    Walking_ATRIAS_B.BitwiseOperator_o = (uint16_T)
      (Walking_ATRIAS_B.EtherCATPDOReceive5_m & ((uint16_T)111U));

    /* RelationalOperator: '<S136>/Compare' incorporates:
     *  Constant: '<S136>/Constant'
     */
    Walking_ATRIAS_B.Compare_da = (Walking_ATRIAS_B.BitwiseOperator_o ==
      ((uint16_T)33U));

    /* S-Function (sfix_bitop): '<S128>/Bitwise Operator' */
    Walking_ATRIAS_B.BitwiseOperator_hb = (uint16_T)
      (Walking_ATRIAS_B.EtherCATPDOReceive5_m & ((uint16_T)8U));

    /* RelationalOperator: '<S137>/Compare' incorporates:
     *  Constant: '<S137>/Constant'
     */
    Walking_ATRIAS_B.Compare_dh = (Walking_ATRIAS_B.BitwiseOperator_hb ==
      ((uint16_T)8U));

    /* Chart: '<S65>/Chart' */
    Walking_ATRIAS_Chart(Walking_ATRIAS_B.Compare_i, Walking_ATRIAS_B.Compare_ls,
                         Walking_ATRIAS_B.Compare_da,
                         Walking_ATRIAS_B.Compare_dh,
                         Walking_ATRIAS_B.MedullaCommandSafe,
                         &Walking_ATRIAS_B.sf_Chart_mz,
                         &Walking_ATRIAS_DW.sf_Chart_mz);

    /* Level2 S-Function Block: '<S122>/EtherCAT PDO Receive' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[169];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S65>/Data Type Conversion2' */
    Walking_ATRIAS_B.VectorConcatenate_p[0] =
      Walking_ATRIAS_B.EtherCATPDOReceive_o;

    /* SignalConversion: '<S129>/ConcatBufferAtVector ConcatenateIn2' incorporates:
     *  Constant: '<S65>/MaxRatedCurrent'
     */
    Walking_ATRIAS_B.VectorConcatenate_p[1] = 48.47;

    /* Fcn: '<S129>/Fcn' */
    Walking_ATRIAS_B.Fcn_mq = Walking_ATRIAS_B.VectorConcatenate_p[0] *
      Walking_ATRIAS_B.VectorConcatenate_p[1] / 1000.0;

    /* DataTypeConversion: '<S65>/Data Type Conversion20' */
    Walking_ATRIAS_B.DataTypeConversion20_h = Walking_ATRIAS_B.Fcn_mq;

    /* Level2 S-Function Block: '<S122>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[170];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S65>/Data Type Conversion42' */
    Walking_ATRIAS_B.DataTypeConversion42_i =
      Walking_ATRIAS_B.EtherCATPDOReceive1_f;

    /* Level2 S-Function Block: '<S122>/EtherCAT PDO Receive3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[171];
      sfcnOutputs(rts, 0);
    }

    /* Switch: '<S65>/Switch' incorporates:
     *  Constant: '<S65>/Constant1'
     */
    if (Walking_ATRIAS_B.sf_Chart_mz.EnableTargetTorque > 0.0) {
      /* SignalConversion: '<S123>/ConcatBufferAtVector ConcatenateIn2' incorporates:
       *  Constant: '<S65>/MaxRatedCurrent'
       */
      Walking_ATRIAS_B.VectorConcatenate_dr[1] = 48.47;

      /* SignalConversion: '<S123>/ConcatBufferAtVector ConcatenateIn1' */
      Walking_ATRIAS_B.VectorConcatenate_dr[0] =
        Walking_ATRIAS_B.CurrentSaturation[1];

      /* Fcn: '<S123>/Fcn' */
      Walking_ATRIAS_B.Fcn_i = Walking_ATRIAS_B.VectorConcatenate_dr[0] * 1000.0
        / Walking_ATRIAS_B.VectorConcatenate_dr[1];

      /* DataTypeConversion: '<S123>/Data Type Conversion6' */
      HalfMaxTicks_idx_0 = floor(Walking_ATRIAS_B.Fcn_i);
      if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
        HalfMaxTicks_idx_0 = 0.0;
      } else {
        HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 65536.0);
      }

      Walking_ATRIAS_B.DataTypeConversion6_h = (int16_T)(HalfMaxTicks_idx_0 <
        0.0 ? (int32_T)(int16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_0 :
        (int32_T)(int16_T)(uint16_T)HalfMaxTicks_idx_0);

      /* End of DataTypeConversion: '<S123>/Data Type Conversion6' */
      Walking_ATRIAS_B.Switch_i = Walking_ATRIAS_B.DataTypeConversion6_h;
    } else {
      Walking_ATRIAS_B.Switch_i = 0;
    }

    /* End of Switch: '<S65>/Switch' */

    /* Level2 S-Function Block: '<S122>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[172];
      sfcnOutputs(rts, 0);
    }

    /* SwitchCase: '<S124>/Switch Case' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.sf_Chart_mz.ControlWordIndex;
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 4.294967296E+9);
    }

    switch (HalfMaxTicks_idx_0 < 0.0 ? -(int32_T)(uint32_T)-HalfMaxTicks_idx_0 :
            (int32_T)(uint32_T)HalfMaxTicks_idx_0) {
     case 1:
      /* Outputs for IfAction SubSystem: '<S124>/ShutdownControlWord' incorporates:
       *  ActionPort: '<S133>/Action Port'
       */
      Walking_ATR_ShutdownControlWord(&Walking_ATRIAS_B.Merge_k);

      /* End of Outputs for SubSystem: '<S124>/ShutdownControlWord' */
      break;

     case 2:
      /* Outputs for IfAction SubSystem: '<S124>/EnableControlWord' incorporates:
       *  ActionPort: '<S130>/Action Port'
       */
      Walking_ATRIA_EnableControlWord(&Walking_ATRIAS_B.Merge_k);

      /* End of Outputs for SubSystem: '<S124>/EnableControlWord' */
      break;

     case 3:
      /* Outputs for IfAction SubSystem: '<S124>/FaultReset' incorporates:
       *  ActionPort: '<S131>/Action Port'
       */
      Walking_ATRIAS_FaultReset(&Walking_ATRIAS_B.Merge_k);

      /* End of Outputs for SubSystem: '<S124>/FaultReset' */
      break;

     default:
      /* Outputs for IfAction SubSystem: '<S124>/NothingControlWord' incorporates:
       *  ActionPort: '<S132>/Action Port'
       */
      Walking_ATRI_NothingControlWord(&Walking_ATRIAS_B.Merge_k);

      /* End of Outputs for SubSystem: '<S124>/NothingControlWord' */
      break;
    }

    /* End of SwitchCase: '<S124>/Switch Case' */

    /* Level2 S-Function Block: '<S122>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[173];
      sfcnOutputs(rts, 0);
    }

    /* Level2 S-Function Block: '<S122>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[174];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S66>/Data Type Conversion3' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.MedullaCommandSafe;
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 256.0);
    }

    Walking_ATRIAS_B.DataTypeConversion3_h = (uint8_T)(HalfMaxTicks_idx_0 < 0.0 ?
      (int32_T)(uint8_T)-(int8_T)(uint8_T)-HalfMaxTicks_idx_0 : (int32_T)
      (uint8_T)HalfMaxTicks_idx_0);

    /* End of DataTypeConversion: '<S66>/Data Type Conversion3' */

    /* Level2 S-Function Block: '<S66>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[175];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S66>/Data Type Conversion4' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.Counter_o1;
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 65536.0);
    }

    Walking_ATRIAS_B.DataTypeConversion4_g = (uint16_T)(HalfMaxTicks_idx_0 < 0.0
      ? (int32_T)(uint16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_0 : (int32_T)
      (uint16_T)HalfMaxTicks_idx_0);

    /* End of DataTypeConversion: '<S66>/Data Type Conversion4' */

    /* Level2 S-Function Block: '<S66>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[176];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S66>/Data Type Conversion5' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.y[0];
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 4.294967296E+9);
    }

    Walking_ATRIAS_B.DataTypeConversion5_i = HalfMaxTicks_idx_0 < 0.0 ?
      -(int32_T)(uint32_T)-HalfMaxTicks_idx_0 : (int32_T)(uint32_T)
      HalfMaxTicks_idx_0;

    /* End of DataTypeConversion: '<S66>/Data Type Conversion5' */

    /* Level2 S-Function Block: '<S66>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[177];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S67>/Data Type Conversion3' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.MedullaCommandSafe;
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 256.0);
    }

    Walking_ATRIAS_B.DataTypeConversion3_m4p = (uint8_T)(HalfMaxTicks_idx_0 <
      0.0 ? (int32_T)(uint8_T)-(int8_T)(uint8_T)-HalfMaxTicks_idx_0 : (int32_T)
      (uint8_T)HalfMaxTicks_idx_0);

    /* End of DataTypeConversion: '<S67>/Data Type Conversion3' */

    /* Level2 S-Function Block: '<S67>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[178];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S67>/Data Type Conversion4' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.Counter_o1;
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 65536.0);
    }

    Walking_ATRIAS_B.DataTypeConversion4_a = (uint16_T)(HalfMaxTicks_idx_0 < 0.0
      ? (int32_T)(uint16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_0 : (int32_T)
      (uint16_T)HalfMaxTicks_idx_0);

    /* End of DataTypeConversion: '<S67>/Data Type Conversion4' */

    /* Level2 S-Function Block: '<S67>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[179];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S67>/Data Type Conversion5' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.y[2];
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 4.294967296E+9);
    }

    Walking_ATRIAS_B.DataTypeConversion5_p = HalfMaxTicks_idx_0 < 0.0 ?
      -(int32_T)(uint32_T)-HalfMaxTicks_idx_0 : (int32_T)(uint32_T)
      HalfMaxTicks_idx_0;

    /* End of DataTypeConversion: '<S67>/Data Type Conversion5' */

    /* Level2 S-Function Block: '<S67>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[180];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S68>/Data Type Conversion3' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.MedullaCommandSafe;
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 256.0);
    }

    Walking_ATRIAS_B.DataTypeConversion3_f = (uint8_T)(HalfMaxTicks_idx_0 < 0.0 ?
      (int32_T)(uint8_T)-(int8_T)(uint8_T)-HalfMaxTicks_idx_0 : (int32_T)
      (uint8_T)HalfMaxTicks_idx_0);

    /* End of DataTypeConversion: '<S68>/Data Type Conversion3' */

    /* Level2 S-Function Block: '<S68>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[181];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S68>/Data Type Conversion4' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.Counter_o1;
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 65536.0);
    }

    Walking_ATRIAS_B.DataTypeConversion4_di = (uint16_T)(HalfMaxTicks_idx_0 <
      0.0 ? (int32_T)(uint16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_0 :
      (int32_T)(uint16_T)HalfMaxTicks_idx_0);

    /* End of DataTypeConversion: '<S68>/Data Type Conversion4' */

    /* Level2 S-Function Block: '<S68>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[182];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S68>/Data Type Conversion5' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.y[1];
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 4.294967296E+9);
    }

    Walking_ATRIAS_B.DataTypeConversion5_h = HalfMaxTicks_idx_0 < 0.0 ?
      -(int32_T)(uint32_T)-HalfMaxTicks_idx_0 : (int32_T)(uint32_T)
      HalfMaxTicks_idx_0;

    /* End of DataTypeConversion: '<S68>/Data Type Conversion5' */

    /* Level2 S-Function Block: '<S68>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[183];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S69>/Data Type Conversion3' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.MedullaCommandSafe;
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 256.0);
    }

    Walking_ATRIAS_B.DataTypeConversion3_l = (uint8_T)(HalfMaxTicks_idx_0 < 0.0 ?
      (int32_T)(uint8_T)-(int8_T)(uint8_T)-HalfMaxTicks_idx_0 : (int32_T)
      (uint8_T)HalfMaxTicks_idx_0);

    /* End of DataTypeConversion: '<S69>/Data Type Conversion3' */

    /* Level2 S-Function Block: '<S69>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[184];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S69>/Data Type Conversion4' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.Counter_o1;
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 65536.0);
    }

    Walking_ATRIAS_B.DataTypeConversion4_f = (uint16_T)(HalfMaxTicks_idx_0 < 0.0
      ? (int32_T)(uint16_T)-(int16_T)(uint16_T)-HalfMaxTicks_idx_0 : (int32_T)
      (uint16_T)HalfMaxTicks_idx_0);

    /* End of DataTypeConversion: '<S69>/Data Type Conversion4' */

    /* Level2 S-Function Block: '<S69>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[185];
      sfcnOutputs(rts, 0);
    }

    /* DataTypeConversion: '<S69>/Data Type Conversion5' */
    HalfMaxTicks_idx_0 = Walking_ATRIAS_B.y[3];
    if (HalfMaxTicks_idx_0 < 0.0) {
      HalfMaxTicks_idx_0 = ceil(HalfMaxTicks_idx_0);
    } else {
      HalfMaxTicks_idx_0 = floor(HalfMaxTicks_idx_0);
    }

    if (rtIsNaN(HalfMaxTicks_idx_0) || rtIsInf(HalfMaxTicks_idx_0)) {
      HalfMaxTicks_idx_0 = 0.0;
    } else {
      HalfMaxTicks_idx_0 = fmod(HalfMaxTicks_idx_0, 4.294967296E+9);
    }

    Walking_ATRIAS_B.DataTypeConversion5_b = HalfMaxTicks_idx_0 < 0.0 ?
      -(int32_T)(uint32_T)-HalfMaxTicks_idx_0 : (int32_T)(uint32_T)
      HalfMaxTicks_idx_0;

    /* End of DataTypeConversion: '<S69>/Data Type Conversion5' */

    /* Level2 S-Function Block: '<S69>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[186];
      sfcnOutputs(rts, 0);
    }

    /* user code (Output function Trailer) */
    {
      int32_T data[6]= { 0 };

      /*------------ S-Function Block: <S45>/EtherCAT Init  Write Process Data ,Run Admin Tasks and then Write Acyclic Data------------*/
      //xpcEtherCATSetOPState(3);
      xpcEtherCATWriteProcessData(3,NULL);
      xpcEtherCATExecAdminJobs(3);
      xpcEtherCATWriteAcyclicData(3);
      mwErrorGet((int_T)3,
                 &data[0], &data[1], &data[2], &data[3],&data[4],&data[5]);
      memcpy(&Walking_ATRIAS_B.EtherCATInit[0], data,6*sizeof(int32_T));
      mwErrorClear( (int_T)3 );

      // Clear all momentary triggered values
    }
  }
}

/* Model update function */
void Walking_ATRIAS_update(void)
{
  /* local scratch DWork variables */
  int32_T ForEach_itr;
  real_T rtb_ImpSel_InsertedFor_q_at_out;
  int32_T i;

  /* Update for UnitDelay: '<S38>/Unit Delay1' */
  Walking_ATRIAS_DW.UnitDelay1_DSTATE[0] = Walking_ATRIAS_B.DataTypeConversion57;
  Walking_ATRIAS_DW.UnitDelay1_DSTATE[1] = Walking_ATRIAS_B.DataTypeConversion81;
  Walking_ATRIAS_DW.UnitDelay1_DSTATE[2] = Walking_ATRIAS_B.DataTypeConversion9;
  Walking_ATRIAS_DW.UnitDelay1_DSTATE[3] = Walking_ATRIAS_B.DataTypeConversion33;
  Walking_ATRIAS_DW.UnitDelay1_DSTATE[4] =
    Walking_ATRIAS_B.DataTypeConversion104;
  Walking_ATRIAS_DW.UnitDelay1_DSTATE[5] =
    Walking_ATRIAS_B.DataTypeConversion119;
  Walking_ATRIAS_DW.UnitDelay1_DSTATE[6] =
    Walking_ATRIAS_ConstB.DataTypeConversion141[0];
  Walking_ATRIAS_DW.UnitDelay1_DSTATE[7] =
    Walking_ATRIAS_ConstB.DataTypeConversion141[1];
  Walking_ATRIAS_DW.UnitDelay1_DSTATE[8] =
    Walking_ATRIAS_ConstB.DataTypeConversion141[2];

  /* Update for UnitDelay: '<S33>/Unit Delay' */
  Walking_ATRIAS_DW.UnitDelay_DSTATE_b = Walking_ATRIAS_B.LogicalOperator2;

  /* Update for UnitDelay: '<S38>/Unit Delay' */
  memcpy(&Walking_ATRIAS_DW.UnitDelay_DSTATE[0], &Walking_ATRIAS_B.Rollover[0],
         9U * sizeof(real_T));

  /* Update for UnitDelay: '<S38>/Unit Delay2' */
  for (i = 0; i < 6; i++) {
    Walking_ATRIAS_DW.UnitDelay2_DSTATE[i] = Walking_ATRIAS_B.IncCalTick[i];
  }

  /* End of Update for UnitDelay: '<S38>/Unit Delay2' */

  /* Update for Iterator SubSystem: '<S38>/EncoderFilters1' */
  for (ForEach_itr = 0; ForEach_itr < 19; ForEach_itr++) {
    /* Update for ForEachSliceSelector: '<S43>/ImpSel_InsertedFor_q_at_outport_0' */
    rtb_ImpSel_InsertedFor_q_at_out =
      Walking_ATRIAS_B.VectorConcatenate[ForEach_itr];

    /* Update for UnitDelay: '<S53>/UD' */
    Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].UD_DSTATE =
      rtb_ImpSel_InsertedFor_q_at_out;

    /* Update for DiscreteTransferFcn: '<S52>/two_pole_filter' */
    Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].two_pole_filter_states[1] =
      Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].two_pole_filter_states[0];
    Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].two_pole_filter_states[0] =
      Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].two_pole_filter_tmp;

    /* Update for UnitDelay: '<S50>/Unit Delay2' */
    Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].UnitDelay2_DSTATE =
      Walking_ATRIAS_B.CoreSubsys[ForEach_itr].two_pole_filter;

    /* Update for UnitDelay: '<S50>/Unit Delay1' */
    Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].UnitDelay1_DSTATE =
      Walking_ATRIAS_B.CoreSubsys[ForEach_itr].dq_good;
  }

  /* End of Update for SubSystem: '<S38>/EncoderFilters1' */

  /* Update for UnitDelay: '<S38>/Unit Delay7' */
  Walking_ATRIAS_DW.UnitDelay7_DSTATE[0] = Walking_ATRIAS_B.wk[0];
  Walking_ATRIAS_DW.UnitDelay7_DSTATE[1] = Walking_ATRIAS_B.wk[1];
  Walking_ATRIAS_DW.UnitDelay7_DSTATE[2] = Walking_ATRIAS_B.wk[2];

  /* Update for UnitDelay: '<S38>/Unit Delay5' */
  Walking_ATRIAS_DW.UnitDelay5_DSTATE[0] = Walking_ATRIAS_B.Ak[0];
  Walking_ATRIAS_DW.UnitDelay5_DSTATE[1] = Walking_ATRIAS_B.Ak[1];
  Walking_ATRIAS_DW.UnitDelay5_DSTATE[2] = Walking_ATRIAS_B.Ak[2];

  /* Update for UnitDelay: '<S38>/Unit Delay8' */
  Walking_ATRIAS_DW.UnitDelay8_DSTATE = Walking_ATRIAS_B.Seqk;
  for (i = 0; i < 9; i++) {
    /* Update for UnitDelay: '<S38>/Unit Delay6' */
    Walking_ATRIAS_DW.UnitDelay6_DSTATE[i] = Walking_ATRIAS_B.Rk[i];

    /* Update for UnitDelay: '<S38>/Unit Delay10' */
    Walking_ATRIAS_DW.UnitDelay10_DSTATE[i] = Walking_ATRIAS_B.R0[i];
  }

  /* Update for UnitDelay: '<S38>/Unit Delay9' */
  Walking_ATRIAS_DW.UnitDelay9_DSTATE[0] = Walking_ATRIAS_B.YawRollover[0];
  Walking_ATRIAS_DW.UnitDelay9_DSTATE[1] = Walking_ATRIAS_B.YawRollover[1];

  /* Update for UnitDelay: '<S27>/Unit Delay' */
  Walking_ATRIAS_DW.UnitDelay_DSTATE_l = Walking_ATRIAS_B.Divide;

  /* Update for DiscreteIntegrator: '<S27>/Discrete-Time Integrator1' */
  Walking_ATRIAS_DW.DiscreteTimeIntegrator1_DSTATE += 0.001 *
    Walking_ATRIAS_B.Switch_f;
  if (Walking_ATRIAS_B.Compare) {
    Walking_ATRIAS_DW.DiscreteTimeIntegrator1_PrevRes = 1;
  } else {
    Walking_ATRIAS_DW.DiscreteTimeIntegrator1_PrevRes = 0;
  }

  for (i = 0; i < 13; i++) {
    /* Update for UnitDelay: '<S8>/Unit Delay2' */
    Walking_ATRIAS_DW.UnitDelay2_DSTATE_h[i] = Walking_ATRIAS_B.q_clean[i];

    /* Update for UnitDelay: '<S8>/Unit Delay1' */
    Walking_ATRIAS_DW.UnitDelay1_DSTATE_j[i] = Walking_ATRIAS_B.dq_clean[i];
  }

  /* End of Update for DiscreteIntegrator: '<S27>/Discrete-Time Integrator1' */

  /* Update for UnitDelay: '<S8>/Unit Delay' */
  Walking_ATRIAS_DW.UnitDelay_DSTATE_k = Walking_ATRIAS_B.SafetyCountOut;

  /* Update absolute time for base rate */
  /* The "clockTick0" counts the number of times the code of this task has
   * been executed. The absolute time is the multiplication of "clockTick0"
   * and "Timing.stepSize0". Size of "clockTick0" ensures timer will not
   * overflow during the application lifespan selected.
   * Timer of this task consists of two 32 bit unsigned integers.
   * The two integers represent the low bits Timing.clockTick0 and the high bits
   * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment.
   */
  if (!(++Walking_ATRIAS_M->Timing.clockTick0)) {
    ++Walking_ATRIAS_M->Timing.clockTickH0;
  }

  Walking_ATRIAS_M->Timing.t[0] = Walking_ATRIAS_M->Timing.clockTick0 *
    Walking_ATRIAS_M->Timing.stepSize0 + Walking_ATRIAS_M->Timing.clockTickH0 *
    Walking_ATRIAS_M->Timing.stepSize0 * 4294967296.0;
}

/* Model initialize function */
void Walking_ATRIAS_initialize(void)
{
  {
    /* local scratch DWork variables */
    int32_T ForEach_itr;
    real_T t0_step;
    real_T t_gain;
    real_T kp_st_leg;
    real_T kd_st_leg;
    real_T kp_sw_leg;
    real_T kd_sw_leg;
    real_T kp_hip;
    real_T kd_hip;
    real_T kp_vs;
    real_T kd_vs;
    real_T kp_yaw;
    real_T kd_yaw;
    real_T s_l_A;
    real_T s_l_B;
    real_T s_r_A;
    real_T s_r_B;
    real_T thres_lo;
    real_T thres_hi;
    real_T tau;
    real_T dx_gain;
    real_T dx_err_p_gain;
    real_T dx_err_d_gain;
    real_T dy_gain;
    real_T dy_err_p_gain;
    real_T dy_err_d_gain;
    real_T y0_offset;
    real_T y0_gain;
    boolean_T isTest5;
    boolean_T isTest7;
    boolean_T isTest8;
    boolean_T isTest11;
    boolean_T isTest12;
    real_T EnableYawControl;
    real_T uHipGravity;
    boolean_T isSim;
    real_T u_lim;
    Controller3DHZD_obj_2_Walking_T *obj;
    boolean_T flag;
    Controller3DHZD_obj_2_Walking_T *obj_0;
    PS3Controller_2_Walking_ATRIA_T *obj_1;
    PS3Button_Walking_ATRIAS_T *obj_2;

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[0];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[1];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[2];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[3];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[4];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[5];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[6];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[7];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[8];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[9];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[10];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[11];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[12];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[13];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[14];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[15];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Start for Iterator SubSystem: '<S38>/EncoderFilters1' */
    for (ForEach_itr = 0; ForEach_itr < 19; ForEach_itr++) {
      Walking_ATRIAS_B.CoreSubsys[ForEach_itr].Uk1 = 0.0;
      Walking_ATRIAS_B.CoreSubsys[ForEach_itr].Diff = 0.0;
      Walking_ATRIAS_B.CoreSubsys[ForEach_itr].Gain1 = 0.0;
      Walking_ATRIAS_B.CoreSubsys[ForEach_itr].two_pole_filter = 0.0;
      Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].two_pole_filter_states[0] = 0.0;
      Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].two_pole_filter_states[1] = 0.0;
      Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].two_pole_filter_tmp = 0.0;
      Walking_ATRIAS_B.CoreSubsys[ForEach_itr].UnitDelay2 = 0.0;
      Walking_ATRIAS_B.CoreSubsys[ForEach_itr].UnitDelay1 = 0.0;

      /* Start for MATLAB Function: '<S50>/Logic Filter' */
      Walking_ATRIAS_B.CoreSubsys[ForEach_itr].dq_out = 0.0;
      Walking_ATRIAS_B.CoreSubsys[ForEach_itr].dq_good = 0.0;

      /* InitializeConditions for UnitDelay: '<S53>/UD' */
      Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].UD_DSTATE = 0.0;

      /* InitializeConditions for DiscreteTransferFcn: '<S52>/two_pole_filter' */
      Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].two_pole_filter_states[0] = 0.0;
      Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].two_pole_filter_states[1] = 0.0;

      /* InitializeConditions for UnitDelay: '<S50>/Unit Delay2' */
      Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].UnitDelay2_DSTATE = 0.0;

      /* InitializeConditions for UnitDelay: '<S50>/Unit Delay1' */
      Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].UnitDelay1_DSTATE = 0.0;
    }

    /* End of Start for SubSystem: '<S38>/EncoderFilters1' */
    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[16];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[17];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[18];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[19];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[20];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[21];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[22];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[23];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Start for MATLABSystem: '<S2>/Controller3' */
    t0_step = Walking_ATRIAS_P.t0_step;
    t_gain = Walking_ATRIAS_P.step_gain;
    kp_st_leg = Walking_ATRIAS_P.kp_st_leg;
    kd_st_leg = Walking_ATRIAS_P.kd_st_leg;
    kp_sw_leg = Walking_ATRIAS_P.kp_sw_leg;
    kd_sw_leg = Walking_ATRIAS_P.kd_sw_leg;
    kp_hip = Walking_ATRIAS_P.kp_hip;
    kd_hip = Walking_ATRIAS_P.kd_hip;
    kp_vs = Walking_ATRIAS_P.kp_vs;
    kd_vs = Walking_ATRIAS_P.kd_vs;
    kp_yaw = Walking_ATRIAS_P.kp_yaw;
    kd_yaw = Walking_ATRIAS_P.kd_yaw;
    s_l_A = 1.0;
    s_l_B = 1.0;
    s_r_A = 1.0;
    s_r_B = 1.0;
    thres_lo = Walking_ATRIAS_P.lbForce;
    thres_hi = Walking_ATRIAS_P.ubForce;
    tau = Walking_ATRIAS_P.velFilConst;
    dx_gain = Walking_ATRIAS_P.dx_gain;
    dx_err_p_gain = Walking_ATRIAS_P.dx_err_p_gain;
    dx_err_d_gain = Walking_ATRIAS_P.dx_err_d_gain;
    dy_gain = Walking_ATRIAS_P.dy_gain;
    dy_err_p_gain = Walking_ATRIAS_P.dy_err_p_gain;
    dy_err_d_gain = Walking_ATRIAS_P.dy_err_d_gain;
    y0_offset = Walking_ATRIAS_P.hip_offset;
    y0_gain = Walking_ATRIAS_P.hip_gain;
    isTest5 = Walking_ATRIAS_P.isSetHipConst;
    isTest7 = Walking_ATRIAS_P.isTestHipTrack;
    isTest8 = Walking_ATRIAS_P.isTestGravity;
    isTest11 = Walking_ATRIAS_P.isVirtualConstraint;
    isTest12 = Walking_ATRIAS_P.isVCtracking;
    EnableYawControl = 1.0;
    uHipGravity = Walking_ATRIAS_P.uHipGravity;
    isSim = Walking_ATRIAS_P.isSim;
    u_lim = 250.0;
    obj = &Walking_ATRIAS_DW.obj;
    obj->stanceLeg = -1.0;
    obj->z_offset = 0.2087;
    obj->q_yaw = 0.0;
    obj->dq_yaw = 0.0;
    obj->output[0] = 0.0;
    obj->output[1] = 0.0;
    obj->runTime = 0.0;
    obj->isRun = true;
    obj->isInitialized = false;
    obj->isReleased = false;
    Walking_ATRIAS_DW.objisempty = true;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.t0_step = t0_step;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.t_gain = t_gain;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.kp_st_leg = kp_st_leg;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.kd_st_leg = kd_st_leg;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.kp_sw_leg = kp_sw_leg;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.kd_sw_leg = kd_sw_leg;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.kp_hip = kp_hip;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.kd_hip = kd_hip;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.kp_vs = kp_vs;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.kd_vs = kd_vs;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.kp_yaw = kp_yaw;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.kd_yaw = kd_yaw;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.s_l_A = s_l_A;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.s_l_B = s_l_B;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.s_r_A = s_r_A;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.s_r_B = s_r_B;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.thres_lo = thres_lo;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.thres_hi = thres_hi;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.tau = tau;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.dx_gain = dx_gain;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.dx_err_p_gain = dx_err_p_gain;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.dx_err_d_gain = dx_err_d_gain;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.dy_gain = dy_gain;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.dy_err_p_gain = dy_err_p_gain;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.dy_err_d_gain = dy_err_d_gain;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.y0_offset = y0_offset;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.y0_gain = y0_gain;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.isTest5 = isTest5;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.isTest7 = isTest7;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.isTest8 = isTest8;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.isTest11 = isTest11;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.isTest12 = isTest12;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.EnableYawControl = EnableYawControl;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.uHipGravity = uHipGravity;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.isSim = isSim;
    obj = &Walking_ATRIAS_DW.obj;
    obj_0 = obj;
    if (obj_0->isInitialized && (!obj_0->isReleased)) {
      flag = true;
    } else {
      flag = false;
    }

    if (flag) {
      obj->TunablePropsChanged = true;
    }

    Walking_ATRIAS_DW.obj.u_lim = u_lim;
    obj = &Walking_ATRIAS_DW.obj;
    obj->isInitialized = true;
    obj_0 = obj;
    obj_1 = &obj_0->ps3;
    obj_2 = &obj_1->select;
    obj_2->value = false;
    obj_2->clickDuration = 0.0;
    obj_2->clickCount = 0.0;
    obj_2->time = 0.0;
    obj_2->timePressed = 0.0;
    obj_2->sampleInterval = 0.001;
    obj_2->clickInterval = 0.5;

    /*  update */
    /*  methods */
    /*  classdef */
    obj_2 = &obj_1->l3;
    obj_2->value = false;
    obj_2->clickDuration = 0.0;
    obj_2->clickCount = 0.0;
    obj_2->time = 0.0;
    obj_2->timePressed = 0.0;
    obj_2->sampleInterval = 0.001;
    obj_2->clickInterval = 0.5;

    /*  update */
    /*  methods */
    /*  classdef */
    obj_2 = &obj_1->r3;
    obj_2->value = false;
    obj_2->clickDuration = 0.0;
    obj_2->clickCount = 0.0;
    obj_2->time = 0.0;
    obj_2->timePressed = 0.0;
    obj_2->sampleInterval = 0.001;
    obj_2->clickInterval = 0.5;

    /*  update */
    /*  methods */
    /*  classdef */
    obj_2 = &obj_1->start;
    obj_2->value = false;
    obj_2->clickDuration = 0.0;
    obj_2->clickCount = 0.0;
    obj_2->time = 0.0;
    obj_2->timePressed = 0.0;
    obj_2->sampleInterval = 0.001;
    obj_2->clickInterval = 0.5;

    /*  update */
    /*  methods */
    /*  classdef */
    obj_2 = &obj_1->up;
    obj_2->value = false;
    obj_2->clickDuration = 0.0;
    obj_2->clickCount = 0.0;
    obj_2->time = 0.0;
    obj_2->timePressed = 0.0;
    obj_2->sampleInterval = 0.001;
    obj_2->clickInterval = 0.5;

    /*  update */
    /*  methods */
    /*  classdef */
    obj_2 = &obj_1->right;
    obj_2->value = false;
    obj_2->clickDuration = 0.0;
    obj_2->clickCount = 0.0;
    obj_2->time = 0.0;
    obj_2->timePressed = 0.0;
    obj_2->sampleInterval = 0.001;
    obj_2->clickInterval = 0.5;

    /*  update */
    /*  methods */
    /*  classdef */
    obj_2 = &obj_1->down;
    obj_2->value = false;
    obj_2->clickDuration = 0.0;
    obj_2->clickCount = 0.0;
    obj_2->time = 0.0;
    obj_2->timePressed = 0.0;
    obj_2->sampleInterval = 0.001;
    obj_2->clickInterval = 0.5;

    /*  update */
    /*  methods */
    /*  classdef */
    obj_2 = &obj_1->left;
    obj_2->value = false;
    obj_2->clickDuration = 0.0;
    obj_2->clickCount = 0.0;
    obj_2->time = 0.0;
    obj_2->timePressed = 0.0;
    obj_2->sampleInterval = 0.001;
    obj_2->clickInterval = 0.5;

    /*  update */
    /*  methods */
    /*  classdef */
    obj_2 = &obj_1->l2;
    obj_2->value = false;
    obj_2->clickDuration = 0.0;
    obj_2->clickCount = 0.0;
    obj_2->time = 0.0;
    obj_2->timePressed = 0.0;
    obj_2->sampleInterval = 0.001;
    obj_2->clickInterval = 0.5;

    /*  update */
    /*  methods */
    /*  classdef */
    obj_2 = &obj_1->r2;
    obj_2->value = false;
    obj_2->clickDuration = 0.0;
    obj_2->clickCount = 0.0;
    obj_2->time = 0.0;
    obj_2->timePressed = 0.0;
    obj_2->sampleInterval = 0.001;
    obj_2->clickInterval = 0.5;

    /*  update */
    /*  methods */
    /*  classdef */
    obj_2 = &obj_1->l1;
    obj_2->value = false;
    obj_2->clickDuration = 0.0;
    obj_2->clickCount = 0.0;
    obj_2->time = 0.0;
    obj_2->timePressed = 0.0;
    obj_2->sampleInterval = 0.001;
    obj_2->clickInterval = 0.5;

    /*  update */
    /*  methods */
    /*  classdef */
    obj_2 = &obj_1->r1;
    obj_2->value = false;
    obj_2->clickDuration = 0.0;
    obj_2->clickCount = 0.0;
    obj_2->time = 0.0;
    obj_2->timePressed = 0.0;
    obj_2->sampleInterval = 0.001;
    obj_2->clickInterval = 0.5;

    /*  update */
    /*  methods */
    /*  classdef */
    obj_2 = &obj_1->triangle;
    obj_2->value = false;
    obj_2->clickDuration = 0.0;
    obj_2->clickCount = 0.0;
    obj_2->time = 0.0;
    obj_2->timePressed = 0.0;
    obj_2->sampleInterval = 0.001;
    obj_2->clickInterval = 0.5;

    /*  update */
    /*  methods */
    /*  classdef */
    obj_2 = &obj_1->circle;
    obj_2->value = false;
    obj_2->clickDuration = 0.0;
    obj_2->clickCount = 0.0;
    obj_2->time = 0.0;
    obj_2->timePressed = 0.0;
    obj_2->sampleInterval = 0.001;
    obj_2->clickInterval = 0.5;

    /*  update */
    /*  methods */
    /*  classdef */
    obj_2 = &obj_1->cross;
    obj_2->value = false;
    obj_2->clickDuration = 0.0;
    obj_2->clickCount = 0.0;
    obj_2->time = 0.0;
    obj_2->timePressed = 0.0;
    obj_2->sampleInterval = 0.001;
    obj_2->clickInterval = 0.5;

    /*  update */
    /*  methods */
    /*  classdef */
    obj_2 = &obj_1->square;
    obj_2->value = false;
    obj_2->clickDuration = 0.0;
    obj_2->clickCount = 0.0;
    obj_2->time = 0.0;
    obj_2->timePressed = 0.0;
    obj_2->sampleInterval = 0.001;
    obj_2->clickInterval = 0.5;

    /*  update */
    /*  methods */
    /*  classdef */
    obj_2 = &obj_1->ps;
    obj_2->value = false;
    obj_2->clickDuration = 0.0;
    obj_2->clickCount = 0.0;
    obj_2->time = 0.0;
    obj_2->timePressed = 0.0;
    obj_2->sampleInterval = 0.001;
    obj_2->clickInterval = 0.5;

    /*  update */
    /*  methods */
    /*  classdef */
    /*  update */
    /*  methods */
    /*  classdef */
    obj_0->gaitMode = Circle;
    obj_0->t = 0.0;
    obj_0->x_est = 0.0;
    obj_0->y_est = 0.0;
    obj_0->dx_est = 0.0;
    obj_0->dy_est = 0.0;
    obj_0->dy_est_avg = 0.0;
    obj_0->dx_tgt = 0.0;
    obj_0->dy_tgt = 0.0;
    obj_0->dx_est_last = 0.0;
    obj_0->dy_est_last = 0.0;
    obj_0->dx = 0.0;
    obj_0->dy = 0.0;
    if (obj_0->isSim == 1) {
      obj_0->x_offset = -0.025;
      obj_0->y_offset = -0.0;
    } else {
      obj_0->x_offset = -0.0;
      obj_0->y_offset = 0.04;
    }

    obj_0->q_yaw_tgt = 0.0;
    obj_0->dq_yaw_tgt = 0.0;
    obj_0->theta = 0.0;
    obj_0->sDDA = 0.0;
    obj_0->dsDDA = 0.0;
    obj_0->dsDDA_est = 0.0;
    obj_0->ds_last = 0.1;
    obj_0->tauPhase = 0.0;
    obj_0->hd_last[0] = 3.1774;
    obj_0->hd_last[1] = 3.1774;
    obj_0->hd_last[2] = 0.7148;
    obj_0->hd_last[3] = 0.7149;
    obj_0->dhd_last[0] = 0.0;
    obj_0->dhd_last[1] = 0.0;
    obj_0->dhd_last[2] = 0.0;
    obj_0->dhd_last[3] = 0.0;
    obj_0->dq_yaw_est = 0.0;
    obj_0->thetaMin = 0.0;
    obj_0->leftHeight = 0.0;
    obj_0->rightHeight = 0.0;
    obj_0->rightBelieve = 0.0;
    obj_0->leftBelieve = 0.0;
    obj_0->hBelieve = 0.0;
    obj_0->PressTime = 0.0;
    obj_0->yawReset = 0.0;
    obj_0->contactGround = 0.0;
    obj->TunablePropsChanged = false;

    /* End of Start for MATLABSystem: '<S2>/Controller3' */

    /* S-Function Block: <S3>/S-Function (scblock) */
    {
      int i;
      if ((i = rl32eScopeExists(1)) == 0) {
        if ((i = rl32eDefScope(1,1)) != 0) {
          printf("Error creating scope 1\n");
        } else {
          rl32eAddSignal(1, rl32eGetSignalNo("rad2deg/s1"));
          rl32eAddSignal(1, rl32eGetSignalNo("rad2deg/s2"));
          rl32eAddSignal(1, rl32eGetSignalNo("rad2deg/s3"));
          rl32eSetScope(1, 4, 2500);
          rl32eSetScope(1, 5, 0);
          rl32eSetScope(1, 6, 1);
          rl32eSetScope(1, 0, 0);
          rl32eSetScope(1, 3, rl32eGetSignalNo("rad2deg/s1"));
          rl32eSetScope(1, 1, 0.0);
          rl32eSetScope(1, 2, 0);
          rl32eSetScope(1, 9, 0);
          xpceScopeAcqOK(1, &Walking_ATRIAS_DW.SFunction_IWORK.AcquireOK);
        }
      }

      if (i) {
        rl32eRestartAcquisition(1);
      }
    }

    /* S-Function Block: <S4>/S-Function (scblock) */
    {
      int i;
      if ((i = rl32eScopeExists(2)) == 0) {
        if ((i = rl32eDefScope(2,1)) != 0) {
          printf("Error creating scope 2\n");
        } else {
          rl32eAddSignal(2, rl32eGetSignalNo("rad2deg/s4"));
          rl32eAddSignal(2, rl32eGetSignalNo("rad2deg/s5"));
          rl32eAddSignal(2, rl32eGetSignalNo("rad2deg/s6"));
          rl32eAddSignal(2, rl32eGetSignalNo("rad2deg/s7"));
          rl32eSetScope(2, 4, 2500);
          rl32eSetScope(2, 5, 0);
          rl32eSetScope(2, 6, 1);
          rl32eSetScope(2, 0, 0);
          rl32eSetScope(2, 3, rl32eGetSignalNo("rad2deg/s4"));
          rl32eSetScope(2, 1, 0.0);
          rl32eSetScope(2, 2, 0);
          rl32eSetScope(2, 9, 0);
          xpceScopeAcqOK(2, &Walking_ATRIAS_DW.SFunction_IWORK_m.AcquireOK);
        }
      }

      if (i) {
        rl32eRestartAcquisition(2);
      }
    }

    /* S-Function Block: <S5>/S-Function (scblock) */
    {
      int i;
      if ((i = rl32eScopeExists(3)) == 0) {
        if ((i = rl32eDefScope(3,1)) != 0) {
          printf("Error creating scope 3\n");
        } else {
          rl32eAddSignal(3, rl32eGetSignalNo("rad2deg/s8"));
          rl32eAddSignal(3, rl32eGetSignalNo("rad2deg/s9"));
          rl32eAddSignal(3, rl32eGetSignalNo("rad2deg/s11"));
          rl32eAddSignal(3, rl32eGetSignalNo("rad2deg/s12"));
          rl32eSetScope(3, 4, 2500);
          rl32eSetScope(3, 5, 0);
          rl32eSetScope(3, 6, 1);
          rl32eSetScope(3, 0, 0);
          rl32eSetScope(3, 3, rl32eGetSignalNo("rad2deg/s8"));
          rl32eSetScope(3, 1, 0.0);
          rl32eSetScope(3, 2, 0);
          rl32eSetScope(3, 9, 0);
          xpceScopeAcqOK(3, &Walking_ATRIAS_DW.SFunction_IWORK_m1.AcquireOK);
        }
      }

      if (i) {
        rl32eRestartAcquisition(3);
      }
    }

    /* S-Function Block: <S6>/S-Function (scblock) */
    {
      int i;
      if ((i = rl32eScopeExists(5)) == 0) {
        if ((i = rl32eDefScope(5,1)) != 0) {
          printf("Error creating scope 5\n");
        } else {
          rl32eAddSignal(5, rl32eGetSignalNo("rad2deg/s10"));
          rl32eAddSignal(5, rl32eGetSignalNo("rad2deg/s13"));
          rl32eSetScope(5, 4, 2500);
          rl32eSetScope(5, 5, 0);
          rl32eSetScope(5, 6, 1);
          rl32eSetScope(5, 0, 0);
          rl32eSetScope(5, 3, rl32eGetSignalNo("rad2deg/s10"));
          rl32eSetScope(5, 1, 0.0);
          rl32eSetScope(5, 2, 0);
          rl32eSetScope(5, 9, 0);
          xpceScopeAcqOK(5, &Walking_ATRIAS_DW.SFunction_IWORK_l.AcquireOK);
        }
      }

      if (i) {
        rl32eRestartAcquisition(5);
      }
    }

    /* S-Function Block: <S7>/S-Function (scblock) */
    {
      int i;
      if ((i = rl32eScopeExists(6)) == 0) {
        if ((i = rl32eDefScope(6,1)) != 0) {
          printf("Error creating scope 6\n");
        } else {
          rl32eAddSignal(6, rl32eGetSignalNo("Gain1/s1"));
          rl32eAddSignal(6, rl32eGetSignalNo("Gain1/s2"));
          rl32eAddSignal(6, rl32eGetSignalNo("Gain1/s3"));
          rl32eAddSignal(6, rl32eGetSignalNo("Gain1/s4"));
          rl32eSetScope(6, 4, 2500);
          rl32eSetScope(6, 5, 0);
          rl32eSetScope(6, 6, 1);
          rl32eSetScope(6, 0, 0);
          rl32eSetScope(6, 3, rl32eGetSignalNo("Gain1/s1"));
          rl32eSetScope(6, 1, 0.0);
          rl32eSetScope(6, 2, 0);
          rl32eSetScope(6, 9, 0);
          xpceScopeAcqOK(6, &Walking_ATRIAS_DW.SFunction_IWORK_k.AcquireOK);
        }
      }

      if (i) {
        rl32eRestartAcquisition(6);
      }
    }

    /* S-Function Block: <S21>/S-Function (scblock) */
    {
      int i;
      if ((i = rl32eScopeExists(7)) == 0) {
        if ((i = rl32eDefScope(7,1)) != 0) {
          printf("Error creating scope 7\n");
        } else {
          rl32eAddSignal(7, rl32eGetSignalNo("RoughTerrain1/Gain/s5"));
          rl32eAddSignal(7, rl32eGetSignalNo("RoughTerrain1/Gain/s6"));
          rl32eSetScope(7, 4, 2000);
          rl32eSetScope(7, 5, 0);
          rl32eSetScope(7, 6, 5);
          rl32eSetScope(7, 0, 0);
          rl32eSetScope(7, 3, rl32eGetSignalNo("RoughTerrain1/Gain/s5"));
          rl32eSetScope(7, 1, 0.0);
          rl32eSetScope(7, 2, 0);
          rl32eSetScope(7, 9, 0);
          xpceScopeAcqOK(7, &Walking_ATRIAS_DW.SFunction_IWORK_o.AcquireOK);
        }
      }

      if (i) {
        rl32eRestartAcquisition(7);
      }
    }

    /* S-Function Block: <S22>/S-Function (scblock) */
    {
      int i;
      if ((i = rl32eScopeExists(8)) == 0) {
        if ((i = rl32eDefScope(8,1)) != 0) {
          printf("Error creating scope 8\n");
        } else {
          rl32eAddSignal(8, rl32eGetSignalNo("RoughTerrain1/Gain1/s1"));
          rl32eAddSignal(8, rl32eGetSignalNo("RoughTerrain1/Gain1/s2"));
          rl32eAddSignal(8, rl32eGetSignalNo("RoughTerrain1/Gain1/s3"));
          rl32eAddSignal(8, rl32eGetSignalNo("RoughTerrain1/Gain1/s4"));
          rl32eSetScope(8, 4, 2000);
          rl32eSetScope(8, 5, 0);
          rl32eSetScope(8, 6, 5);
          rl32eSetScope(8, 0, 0);
          rl32eSetScope(8, 3, rl32eGetSignalNo("RoughTerrain1/Gain1/s1"));
          rl32eSetScope(8, 1, 0.0);
          rl32eSetScope(8, 2, 0);
          rl32eSetScope(8, 9, 0);
          xpceScopeAcqOK(8, &Walking_ATRIAS_DW.SFunction_IWORK_b.AcquireOK);
        }
      }

      if (i) {
        rl32eRestartAcquisition(8);
      }
    }

    /* S-Function Block: <S23>/S-Function (scblock) */
    {
      int i;
      if ((i = rl32eScopeExists(9)) == 0) {
        if ((i = rl32eDefScope(9,1)) != 0) {
          printf("Error creating scope 9\n");
        } else {
          rl32eAddSignal(9, rl32eGetSignalNo("RoughTerrain1/Gain1/s5"));
          rl32eAddSignal(9, rl32eGetSignalNo("RoughTerrain1/Gain1/s6"));
          rl32eSetScope(9, 4, 2000);
          rl32eSetScope(9, 5, 0);
          rl32eSetScope(9, 6, 5);
          rl32eSetScope(9, 0, 0);
          rl32eSetScope(9, 3, rl32eGetSignalNo("RoughTerrain1/Gain1/s5"));
          rl32eSetScope(9, 1, 0.0);
          rl32eSetScope(9, 2, 0);
          rl32eSetScope(9, 9, 0);
          xpceScopeAcqOK(9, &Walking_ATRIAS_DW.SFunction_IWORK_j.AcquireOK);
        }
      }

      if (i) {
        rl32eRestartAcquisition(9);
      }
    }

    /* S-Function Block: <S24>/S-Function (scblock) */
    {
      int i;
      if ((i = rl32eScopeExists(4)) == 0) {
        if ((i = rl32eDefScope(4,1)) != 0) {
          printf("Error creating scope 4\n");
        } else {
          rl32eAddSignal(4, rl32eGetSignalNo(
            "RoughTerrain1/Saturation/Data Type Conversion1/s1"));
          rl32eAddSignal(4, rl32eGetSignalNo(
            "RoughTerrain1/Saturation/Data Type Conversion1/s2"));
          rl32eAddSignal(4, rl32eGetSignalNo(
            "RoughTerrain1/Saturation/Data Type Conversion1/s4"));
          rl32eAddSignal(4, rl32eGetSignalNo(
            "RoughTerrain1/Saturation/Data Type Conversion1/s5"));
          rl32eSetScope(4, 4, 2000);
          rl32eSetScope(4, 5, 0);
          rl32eSetScope(4, 6, 5);
          rl32eSetScope(4, 0, 0);
          rl32eSetScope(4, 3, rl32eGetSignalNo(
            "RoughTerrain1/Saturation/Data Type Conversion1/s1"));
          rl32eSetScope(4, 1, 0.0);
          rl32eSetScope(4, 2, 0);
          rl32eSetScope(4, 9, 0);
          xpceScopeAcqOK(4, &Walking_ATRIAS_DW.SFunction_IWORK_n.AcquireOK);
        }
      }

      if (i) {
        rl32eRestartAcquisition(4);
      }
    }

    /* S-Function Block: <S25>/S-Function (scblock) */
    {
      int i;
      if ((i = rl32eScopeExists(10)) == 0) {
        if ((i = rl32eDefScope(10,1)) != 0) {
          printf("Error creating scope 10\n");
        } else {
          rl32eAddSignal(10, rl32eGetSignalNo("RoughTerrain1/Gain/s1"));
          rl32eAddSignal(10, rl32eGetSignalNo("RoughTerrain1/Gain/s2"));
          rl32eAddSignal(10, rl32eGetSignalNo("RoughTerrain1/Gain/s3"));
          rl32eAddSignal(10, rl32eGetSignalNo("RoughTerrain1/Gain/s4"));
          rl32eSetScope(10, 4, 2000);
          rl32eSetScope(10, 5, 0);
          rl32eSetScope(10, 6, 5);
          rl32eSetScope(10, 0, 0);
          rl32eSetScope(10, 3, rl32eGetSignalNo("RoughTerrain1/Gain/s1"));
          rl32eSetScope(10, 1, 0.0);
          rl32eSetScope(10, 2, 0);
          rl32eSetScope(10, 9, 0);
          xpceScopeAcqOK(10, &Walking_ATRIAS_DW.SFunction_IWORK_h.AcquireOK);
        }
      }

      if (i) {
        rl32eRestartAcquisition(10);
      }
    }

    /* S-Function Block: <S26>/S-Function (scblock) */
    {
      int i;
      if ((i = rl32eScopeExists(12)) == 0) {
        if ((i = rl32eDefScope(12,1)) != 0) {
          printf("Error creating scope 12\n");
        } else {
          rl32eAddSignal(12, rl32eGetSignalNo(
            "RoughTerrain1/Saturation/Data Type Conversion1/s3"));
          rl32eAddSignal(12, rl32eGetSignalNo(
            "RoughTerrain1/Saturation/Data Type Conversion1/s6"));
          rl32eSetScope(12, 4, 2000);
          rl32eSetScope(12, 5, 0);
          rl32eSetScope(12, 6, 5);
          rl32eSetScope(12, 0, 0);
          rl32eSetScope(12, 3, rl32eGetSignalNo(
            "RoughTerrain1/Saturation/Data Type Conversion1/s3"));
          rl32eSetScope(12, 1, 0.0);
          rl32eSetScope(12, 2, 0);
          rl32eSetScope(12, 9, 0);
          xpceScopeAcqOK(12, &Walking_ATRIAS_DW.SFunction_IWORK_c.AcquireOK);
        }
      }

      if (i) {
        rl32eRestartAcquisition(12);
      }
    }

    /* S-Function Block: <S36>/S-Function (scblock) */
    {
      int i;
      if ((i = rl32eScopeExists(11)) == 0) {
        if ((i = rl32eDefScope(11,1)) != 0) {
          printf("Error creating scope 11\n");
        } else {
          rl32eAddSignal(11, rl32eGetSignalNo("Subsystem1/SAFETY/p3"));
          rl32eSetScope(11, 4, 2500);
          rl32eSetScope(11, 5, 0);
          rl32eSetScope(11, 6, 1);
          rl32eSetScope(11, 0, 0);
          rl32eSetScope(11, 3, rl32eGetSignalNo("Subsystem1/SAFETY/p3"));
          rl32eSetScope(11, 1, 0.0);
          rl32eSetScope(11, 2, 0);
          rl32eSetScope(11, 9, 0);
          xpceScopeAcqOK(11, &Walking_ATRIAS_DW.SFunction_IWORK_i.AcquireOK);
        }
      }

      if (i) {
        rl32eRestartAcquisition(11);
      }
    }

    /* Start for S-Function (xpcethercatinit): '<S45>/EtherCAT Init ' */
    {
      int_T status = 1;
      char_T *errMsg;
      xpcPCIDevice pciInfo;
      char_T l_errMsg[128];
      int_T j;
      uint8_T *DeviceType;

      /* From LinkOsLayer.h   Intel PRO-100 specific definitions */
      struct EtherCATDevices {
        uint16_T VendorID;
        uint16_T DeviceID;
        uint8_T *DeviceType;
      } EtherCATDeviceTable[] = {
        /* I8254x types */
        { 0x8086, 0xABB1, "I8254x" },  //

        { 0x8086, 0xABB2, "I8254x" },  //

        { 0x8086, 0x1013, "I8254x" },  //  PCI_DEVICE_I82541EI_COPPER

        { 0x8086, 0x1078, "I8254x" },  //  PCI_DEVICE_I82541ER

        { 0x8086, 0x1076, "I8254x" },  //  PCI_DEVICE_I82541GI_COPPER

        { 0x8086, 0x107C, "I8254x" },  //  PCI_DEVICE_I82541PI_DESKTOP

        { 0x8086, 0x1019, "I8254x" },  //  PCI_DEVICE_I82547GI_COPPER

        { 0x8086, 0x1026, "I8254x" },  //  PCI_DEVICE_I82545GM_COPPER

        { 0x8086, 0x10BD, "I8254x" },  //  PCI_DEVICE_I82566L

        { 0x8086, 0x10EA, "I8254x" },  //  PCI_DEVICE_I82577LM

        { 0x8086, 0x10EB, "I8254x" },  //  PCI_DEVICE_I82577LC

        { 0x8086, 0x10A7, "I8254x" },  //  PCI_DEVICE_I82575_ZOAR

        { 0x8086, 0x1075, "I8254x" },  //  PCI_DEVICE_I82547EI

        { 0x8086, 0x108C, "I8254x" },  //  PCI_DEVICE_I82573

        { 0x8086, 0x109A, "I8254x" },  //  PCI_DEVICE_I82573L

        { 0x8086, 0x10B9, "I8254x" },  //  PCI_DEVICE_I82572GI

        { 0x8086, 0x10A4, "I8254x" },  //  PCI_DEVICE_I82571GB_QUAD

        { 0x8086, 0x10D3, "I8254x" },  //  PCI_DEVICE_I82574L

        { 0x8086, 0x1010, "I8254x" },  //  PCI_DEVICE_I82546EB_COPPER_DUAL

        { 0x8086, 0x1079, "I8254x" },  //  PCI_DEVICE_I82546GB_COPPER_DUAL

        { 0x8086, 0x100E, "I8254x" },  //  PCI_DEVICE_I82540EM_DESKTOP

        { 0x8086, 0x105E, "I8254x" },  //  PCI_DEVICE_N1E5132_SERVER

        { 0x8086, 0x10BC, "I8254x" },  //  PCI_DEVICE_I82571GB_QUAD_2

        { 0x8086, 0x10C9, "I8254x" },  //  PCI_DEVICE_I82576

        { 0x8086, 0x10CE, "I8254x" },  //  PCI_DEVICE_I82567V

        { 0x8086, 0x150E, "I8254x" },  //  PCI_DEVICE_I82580_QUAD

        { 0x8086, 0x10F5, "I8254x" },  //  PCI_DEVICE_I82567LM

        { 0x8086, 0x10DE, "I8254x" },  //  PCI_DEVICE_I82567LM3

        { 0x8086, 0x1527, "I8254x" },  //  PCI_DEVICE_I82580_QUAD_FIBRE

        { 0x8086, 0x1501, "I8254x" },  //  PCI_DEVICE_I82567V3

        { 0x8086, 0x108B, "I8254x" },  //  PCI_DEVICE_I82573E

        { 0x8086, 0x107D, "I8254x" },  //  PCI_DEVICE_I82572EI

        { 0x8086, 0x150C, "I8254x" },  //  PCI_DEVICE_I82583V

        { 0x8086, 0x1502, "I8254x" },  //  PCI_DEVICE_I82579LM

        { 0x8086, 0x1503, "I8254x" },  //  PCI_DEVICE_I82579V

        { 0x8086, 0x1526, "I8254x" },  //  PCI_DEVICE_I82576_ET2

        { 0x8086, 0x1521, "I8254x" },  //  PCI_DEVICE_I350

        { 0x8086, 0x1533, "I8254x" },  //  PCI_DEVICE_I210

        { 0x8086, 0x104A, "I8254x" },  //  PCI_DEVICE_I82566DM

        /* I8255x types */
        { 0x8086, 0x103a, "I8255x" },  //  PCI device ID, Intel 82801DB(M) (ICH4) LAN Controller

        { 0x8086, 0x1229, "I8255x" },  //  82557 device ID

        { 0x8086, 0x1209, "I8255x" },  //  82557 ER device ID

        { 0x8086, 0x1050, "I8255x" },  //  PRO/100 VE device ID

        { 0x8086, 0x1039, "I8255x" },  //  82562 VE/VM device ID

        { 0x8086, 0x2449, "I8255x" },  //  82559 ER device ID

        { 0x8086, 0x27DC, "I8255x" },  //  PRO/100 VE device ID

        { 0x8086, 0x1059, "I8255x" },  //  Mobile version of 1229

        { 0x8086, 0x1092, "I8255x" }   //  PRO/100 VE3 device ID
      };

      if (!xpcIsModelInit()) {
        status = xpcGetPciConfigAtSlot( 2, 0, &pciInfo);
        if (status ) {
          sprintf(l_errMsg, "You must specify a bus/slot, not auto search.\n");
          rtmSetErrorStatus(Walking_ATRIAS_M, l_errMsg);
          return;
        }

        status = -1;                   // Preset to a failed search.
        DeviceType = "";
        for (j = 0 ; j < sizeof(EtherCATDeviceTable)/sizeof(struct
              EtherCATDevices) ; j++ ) {
          // Search through the device table for the matching vendor/device ID.
          if (( pciInfo.DeviceId == EtherCATDeviceTable[j].DeviceID )
              && ( pciInfo.VendorId == EtherCATDeviceTable[j].VendorID ) ) {
            status = 0;
            DeviceType = EtherCATDeviceTable[j].DeviceType;
            break;
          }
        }

        if (status ) {
          printf("No valid Ethernet board found at bus %d slot %d\n", 2, 0);
          sprintf(l_errMsg, "No valid Ethernet board found.\n");
          rtmSetErrorStatus(Walking_ATRIAS_M, l_errMsg);
        } else {
          char *logfile = "c:\\dbglog.txt";
          status = xpcEtherCATinitialize(3, DeviceType, 2, 0, 0, 1,
            xmlCharArr_3, sizeof(xmlCharArr_3),0, 1, logfile, 0.001);
          if (status != XPC_ECAT_OK) {
            errMsg = xpcPrintEtherCATError(3, 0);
            rtmSetErrorStatus(Walking_ATRIAS_M, errMsg);
            return;
          }

          //printf("init status = %08x\n", status );
        }
      }
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[24];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[25];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[26];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[27];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[28];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[29];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[30];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[31];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[32];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var ' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[33];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[34];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[35];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[36];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[37];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[38];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[39];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[40];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[41];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[42];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[43];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[44];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[45];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[46];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[47];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[48];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[49];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[50];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[51];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[52];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[53];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[54];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[55];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[56];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[57];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[58];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[59];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[60];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[61];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[62];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[63];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[64];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[65];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[66];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[67];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[68];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[69];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[70];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[71];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[72];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[73];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[74];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[75];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[76];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[77];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[78];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[79];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[80];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[81];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[82];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[83];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[84];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[85];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[86];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[87];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[88];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[89];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[90];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[91];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[92];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[93];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[94];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[95];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[96];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[97];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[98];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[99];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[100];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[101];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[102];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[103];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[104];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[105];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[106];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[107];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[108];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[109];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[110];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[111];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[112];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[113];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[114];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[115];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[116];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[117];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[118];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[119];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[120];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[121];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[122];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[123];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[124];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[125];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[126];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[127];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[128];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[129];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[130];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[131];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[132];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[133];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[134];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[135];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[136];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S59>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[137];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S59>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[138];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S59>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[139];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S60>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[140];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S60>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[141];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S60>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[142];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[143];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[144];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S61>/EtherCAT Tx Var ' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[145];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S61>/EtherCAT Tx Var 1' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[146];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S71>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[147];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S71>/EtherCAT PDO Receive' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[148];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S71>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[149];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S71>/EtherCAT PDO Receive2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[150];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S71>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[151];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S71>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[152];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S71>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[153];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S88>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[154];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S88>/EtherCAT PDO Receive' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[155];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S88>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[156];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S88>/EtherCAT PDO Receive2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[157];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S88>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[158];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S88>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[159];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S88>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[160];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S105>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[161];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S105>/EtherCAT PDO Receive' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[162];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S105>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[163];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S105>/EtherCAT PDO Receive2' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[164];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S105>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[165];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S105>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[166];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S105>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[167];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S122>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[168];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S122>/EtherCAT PDO Receive' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[169];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S122>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[170];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S122>/EtherCAT PDO Receive3' (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[171];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S122>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[172];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S122>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[173];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S122>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[174];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[175];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[176];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S66>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[177];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[178];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[179];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S67>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[180];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[181];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[182];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S68>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[183];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[184];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[185];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }

    /* Level2 S-Function Block: '<S69>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[186];
      sfcnStart(rts);
      if (ssGetErrorStatus(rts) != (NULL))
        return;
    }
  }

  {
    /* local scratch DWork variables */
    int32_T ForEach_itr;
    int32_T i;

    /* InitializeConditions for UnitDelay: '<S33>/Unit Delay' */
    Walking_ATRIAS_DW.UnitDelay_DSTATE_b = true;
    for (i = 0; i < 9; i++) {
      /* InitializeConditions for UnitDelay: '<S38>/Unit Delay1' */
      Walking_ATRIAS_DW.UnitDelay1_DSTATE[i] = 0.0;

      /* InitializeConditions for UnitDelay: '<S38>/Unit Delay' */
      Walking_ATRIAS_DW.UnitDelay_DSTATE[i] = Walking_ATRIAS_ConstP.pooled18[i];
    }

    /* InitializeConditions for UnitDelay: '<S38>/Unit Delay2' */
    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_DW.UnitDelay2_DSTATE[i] =
        Walking_ATRIAS_ConstP.UnitDelay2_InitialCon[i];
    }

    /* End of InitializeConditions for UnitDelay: '<S38>/Unit Delay2' */

    /* InitializeConditions for Iterator SubSystem: '<S38>/EncoderFilters1' */
    for (ForEach_itr = 0; ForEach_itr < 19; ForEach_itr++) {
      /* InitializeConditions for UnitDelay: '<S53>/UD' */
      Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].UD_DSTATE = 0.0;

      /* InitializeConditions for DiscreteTransferFcn: '<S52>/two_pole_filter' */
      Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].two_pole_filter_states[0] = 0.0;
      Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].two_pole_filter_states[1] = 0.0;

      /* InitializeConditions for UnitDelay: '<S50>/Unit Delay2' */
      Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].UnitDelay2_DSTATE = 0.0;

      /* InitializeConditions for UnitDelay: '<S50>/Unit Delay1' */
      Walking_ATRIAS_DW.CoreSubsys[ForEach_itr].UnitDelay1_DSTATE = 0.0;
    }

    /* End of InitializeConditions for SubSystem: '<S38>/EncoderFilters1' */

    /* InitializeConditions for UnitDelay: '<S38>/Unit Delay7' */
    Walking_ATRIAS_DW.UnitDelay7_DSTATE[0] = 0.0;
    Walking_ATRIAS_DW.UnitDelay7_DSTATE[1] = 0.0;
    Walking_ATRIAS_DW.UnitDelay7_DSTATE[2] = 0.0;

    /* InitializeConditions for UnitDelay: '<S38>/Unit Delay5' */
    Walking_ATRIAS_DW.UnitDelay5_DSTATE[0] = 0.0;
    Walking_ATRIAS_DW.UnitDelay5_DSTATE[1] = 0.0;
    Walking_ATRIAS_DW.UnitDelay5_DSTATE[2] = 0.0;

    /* InitializeConditions for UnitDelay: '<S38>/Unit Delay8' */
    Walking_ATRIAS_DW.UnitDelay8_DSTATE = 0.0;
    for (i = 0; i < 9; i++) {
      /* InitializeConditions for UnitDelay: '<S38>/Unit Delay6' */
      Walking_ATRIAS_DW.UnitDelay6_DSTATE[i] = Walking_ATRIAS_ConstP.pooled18[i];

      /* InitializeConditions for UnitDelay: '<S38>/Unit Delay10' */
      Walking_ATRIAS_DW.UnitDelay10_DSTATE[i] = Walking_ATRIAS_ConstP.pooled18[i];
    }

    /* InitializeConditions for UnitDelay: '<S38>/Unit Delay9' */
    Walking_ATRIAS_DW.UnitDelay9_DSTATE[0] = 0.0;
    Walking_ATRIAS_DW.UnitDelay9_DSTATE[1] = 0.0;

    /* InitializeConditions for UnitDelay: '<S27>/Unit Delay' */
    Walking_ATRIAS_DW.UnitDelay_DSTATE_l = 0.0;

    /* InitializeConditions for DiscreteIntegrator: '<S27>/Discrete-Time Integrator1' */
    Walking_ATRIAS_DW.DiscreteTimeIntegrator1_DSTATE = 0.0;
    Walking_ATRIAS_DW.DiscreteTimeIntegrator1_PrevRes = 2;
    for (i = 0; i < 13; i++) {
      /* InitializeConditions for UnitDelay: '<S8>/Unit Delay2' */
      Walking_ATRIAS_DW.UnitDelay2_DSTATE_h[i] = 0.0;

      /* InitializeConditions for UnitDelay: '<S8>/Unit Delay1' */
      Walking_ATRIAS_DW.UnitDelay1_DSTATE_j[i] = 0.0;
    }

    /* InitializeConditions for UnitDelay: '<S8>/Unit Delay' */
    Walking_ATRIAS_DW.UnitDelay_DSTATE_k = 0.0;

    /* InitializeConditions for S-Function (sdspcount2): '<S45>/Counter' */
    Walking_ATRIAS_DW.Counter_Count = ((uint16_T)0U);

    /* InitializeConditions for Chart: '<S62>/Chart' */
    Walking_ATRIAS_DW.sfEvent_l = -1;
    Walking_ATRIAS_DW.is_Initialization_a = Walking_AT_IN_NO_ACTIVE_CHILD_b;
    Walking_ATRIAS_DW.is_active_c43_Walking_ATRIAS = 0U;
    Walking_ATRIAS_DW.is_c43_Walking_ATRIAS = Walking_AT_IN_NO_ACTIVE_CHILD_b;

    /* InitializeConditions for Chart: '<S63>/Chart' */
    Walking_ATRIAS_Chart_Init(&Walking_ATRIAS_DW.sf_Chart_m);

    /* InitializeConditions for Chart: '<S64>/Chart' */
    Walking_ATRIAS_DW.sfEvent = -1;
    Walking_ATRIAS_DW.is_Initialization = Walking_AT_IN_NO_ACTIVE_CHILD_b;
    Walking_ATRIAS_DW.is_active_c45_Walking_ATRIAS = 0U;
    Walking_ATRIAS_DW.is_c45_Walking_ATRIAS = Walking_AT_IN_NO_ACTIVE_CHILD_b;

    /* InitializeConditions for Chart: '<S65>/Chart' */
    Walking_ATRIAS_Chart_Init(&Walking_ATRIAS_DW.sf_Chart_mz);
  }
}

/* Model terminate function */
void Walking_ATRIAS_terminate(void)
{
  boolean_T flag;
  Controller3DHZD_obj_2_Walking_T *obj;

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[0];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[1];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[2];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[3];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[4];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[5];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[6];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 8' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[7];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[8];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[9];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var ' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[10];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var ' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[11];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var ' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[12];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var ' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[13];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[14];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[15];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[16];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[17];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[18];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[19];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[20];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[21];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[22];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[23];
    sfcnTerminate(rts);
  }

  /* Start for MATLABSystem: '<S2>/Controller3' incorporates:
   *  Terminate for MATLABSystem: '<S2>/Controller3'
   */
  obj = &Walking_ATRIAS_DW.obj;
  flag = obj->isInitialized;
  if (flag) {
    obj = &Walking_ATRIAS_DW.obj;
    if (obj->isInitialized) {
      obj->isReleased = true;
    }
  }

  /* End of Start for MATLABSystem: '<S2>/Controller3' */
  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[24];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[25];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[26];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[27];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var ' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[28];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[29];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[30];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[31];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 7' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[32];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var ' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[33];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[34];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[35];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[36];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[37];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 10' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[38];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 6' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[39];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[40];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[41];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[42];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[43];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 11' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[44];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[45];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[46];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[47];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[48];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[49];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[50];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[51];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[52];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[53];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[54];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[55];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[56];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[57];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[58];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[59];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[60];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[61];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[62];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[63];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[64];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[65];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[66];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[67];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[68];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[69];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[70];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[71];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[72];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 12' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[73];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 13' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[74];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 14' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[75];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[76];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[77];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[78];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[79];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[80];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[81];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[82];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[83];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[84];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[85];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[86];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[87];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[88];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[89];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[90];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S59>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[91];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S60>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[92];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 16' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[93];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 17' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[94];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 15' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[95];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[96];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[97];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[98];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[99];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[100];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[101];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[102];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[103];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[104];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[105];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[106];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[107];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[108];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[109];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[110];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[111];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[112];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[113];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[114];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[115];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[116];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[117];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[118];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[119];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[120];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[121];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[122];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[123];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[124];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 23' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[125];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 21' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[126];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 20' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[127];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 22' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[128];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 18' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[129];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[130];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 19' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[131];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 5' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[132];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 9' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[133];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 1' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[134];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 2' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[135];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[136];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S59>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[137];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S59>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[138];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S59>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[139];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S60>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[140];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S60>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[141];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S60>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[142];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 3' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[143];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S61>/EtherCAT Rx Var 4' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[144];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S61>/EtherCAT Tx Var ' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[145];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S61>/EtherCAT Tx Var 1' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[146];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S71>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[147];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S71>/EtherCAT PDO Receive' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[148];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S71>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[149];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S71>/EtherCAT PDO Receive2' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[150];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S71>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[151];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S71>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[152];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S71>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[153];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S88>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[154];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S88>/EtherCAT PDO Receive' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[155];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S88>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[156];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S88>/EtherCAT PDO Receive2' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[157];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S88>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[158];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S88>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[159];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S88>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[160];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S105>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[161];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S105>/EtherCAT PDO Receive' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[162];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S105>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[163];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S105>/EtherCAT PDO Receive2' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[164];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S105>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[165];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S105>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[166];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S105>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[167];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S122>/EtherCAT PDO Receive5' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[168];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S122>/EtherCAT PDO Receive' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[169];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S122>/EtherCAT PDO Receive1' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[170];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S122>/EtherCAT PDO Receive3' (xpcethercatpdorx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[171];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S122>/EtherCAT PDO Transmit' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[172];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S122>/EtherCAT PDO Transmit1' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[173];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S122>/EtherCAT PDO Transmit2' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[174];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[175];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[176];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S66>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[177];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[178];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[179];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S67>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[180];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[181];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[182];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S68>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[183];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Tx Var 3' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[184];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Tx Var 4' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[185];
    sfcnTerminate(rts);
  }

  /* Level2 S-Function Block: '<S69>/EtherCAT Tx Var 5' (xpcethercatpdotx) */
  {
    SimStruct *rts = Walking_ATRIAS_M->childSfunctions[186];
    sfcnTerminate(rts);
  }

  /* user code (Terminate function Trailer) */

  /*------------ S-Function Block: <S45>/EtherCAT Init  Process Shutdown Network ------------*/
  {
    int_T status;
    if (!xpcIsModelInit()) {
      status = xpcEtherCATstop(3, 1000 /* 1 second timeout */
        );
    }
  }
}

/*========================================================================*
 * Start of Classic call interface                                        *
 *========================================================================*/
void MdlOutputs(int_T tid)
{
  Walking_ATRIAS_output();
  UNUSED_PARAMETER(tid);
}

void MdlUpdate(int_T tid)
{
  Walking_ATRIAS_update();
  UNUSED_PARAMETER(tid);
}

void MdlInitializeSizes(void)
{
}

void MdlInitializeSampleTimes(void)
{
}

void MdlInitialize(void)
{
}

void MdlStart(void)
{
  Walking_ATRIAS_initialize();
}

void MdlTerminate(void)
{
  Walking_ATRIAS_terminate();
}

/* Registration function */
RT_MODEL_Walking_ATRIAS_T *Walking_ATRIAS(void)
{
  /* Registration code */

  /* initialize non-finites */
  rt_InitInfAndNaN(sizeof(real_T));

  /* initialize real-time model */
  (void) memset((void *)Walking_ATRIAS_M, 0,
                sizeof(RT_MODEL_Walking_ATRIAS_T));
  rtsiSetSolverName(&Walking_ATRIAS_M->solverInfo,"FixedStepDiscrete");
  Walking_ATRIAS_M->solverInfoPtr = (&Walking_ATRIAS_M->solverInfo);

  /* Initialize timing info */
  {
    int_T *mdlTsMap = Walking_ATRIAS_M->Timing.sampleTimeTaskIDArray;
    mdlTsMap[0] = 0;
    Walking_ATRIAS_M->Timing.sampleTimeTaskIDPtr = (&mdlTsMap[0]);
    Walking_ATRIAS_M->Timing.sampleTimes =
      (&Walking_ATRIAS_M->Timing.sampleTimesArray[0]);
    Walking_ATRIAS_M->Timing.offsetTimes =
      (&Walking_ATRIAS_M->Timing.offsetTimesArray[0]);

    /* task periods */
    Walking_ATRIAS_M->Timing.sampleTimes[0] = (0.001);

    /* task offsets */
    Walking_ATRIAS_M->Timing.offsetTimes[0] = (0.0);
  }

  rtmSetTPtr(Walking_ATRIAS_M, &Walking_ATRIAS_M->Timing.tArray[0]);

  {
    int_T *mdlSampleHits = Walking_ATRIAS_M->Timing.sampleHitArray;
    mdlSampleHits[0] = 1;
    Walking_ATRIAS_M->Timing.sampleHits = (&mdlSampleHits[0]);
  }

  rtmSetTFinal(Walking_ATRIAS_M, -1);
  Walking_ATRIAS_M->Timing.stepSize0 = 0.001;

  /* Setup for data logging */
  {
    static RTWLogInfo rt_DataLoggingInfo;
    Walking_ATRIAS_M->rtwLogInfo = &rt_DataLoggingInfo;
  }

  /* Setup for data logging */
  {
    rtliSetLogXSignalInfo(Walking_ATRIAS_M->rtwLogInfo, (NULL));
    rtliSetLogXSignalPtrs(Walking_ATRIAS_M->rtwLogInfo, (NULL));
    rtliSetLogT(Walking_ATRIAS_M->rtwLogInfo, "tout");
    rtliSetLogX(Walking_ATRIAS_M->rtwLogInfo, "");
    rtliSetLogXFinal(Walking_ATRIAS_M->rtwLogInfo, "");
    rtliSetLogVarNameModifier(Walking_ATRIAS_M->rtwLogInfo, "rt_");
    rtliSetLogFormat(Walking_ATRIAS_M->rtwLogInfo, 0);
    rtliSetLogMaxRows(Walking_ATRIAS_M->rtwLogInfo, 0);
    rtliSetLogDecimation(Walking_ATRIAS_M->rtwLogInfo, 1);

    /*
     * Set pointers to the data and signal info for each output
     */
    {
      static void * rt_LoggedOutputSignalPtrs[] = {
        &Walking_ATRIAS_Y.q[0],
        &Walking_ATRIAS_Y.dq[0],
        &Walking_ATRIAS_Y.EncoderAnglesClean[0],
        &Walking_ATRIAS_Y.EncoderDerivsClean[0],
        &Walking_ATRIAS_Y.MicrostrainEulerAnglesClean[0],
        &Walking_ATRIAS_Y.MicrostrainEulerDerivsClean[0],
        &Walking_ATRIAS_Y.AbsTick[0],
        &Walking_ATRIAS_Y.IncTick[0],
        &Walking_ATRIAS_Y.ValidStates[0],
        &Walking_ATRIAS_Y.RotationMatrix[0],
        &Walking_ATRIAS_Y.MotorCurrentSafe[0],
        &Walking_ATRIAS_Y.MedullaCommandSafe,
        &Walking_ATRIAS_Y.SafetyState,
        &Walking_ATRIAS_Y.u[0],
        &Walking_ATRIAS_Y.y[0],
        &Walking_ATRIAS_Y.dy[0],
        &Walking_ATRIAS_Y.ControlOutput[0]
      };

      rtliSetLogYSignalPtrs(Walking_ATRIAS_M->rtwLogInfo, ((LogSignalPtrsType)
        rt_LoggedOutputSignalPtrs));
    }

    {
      static int_T rt_LoggedOutputWidths[] = {
        13,
        13,
        19,
        19,
        3,
        3,
        10,
        9,
        3,
        9,
        6,
        1,
        1,
        6,
        6,
        6,
        16
      };

      static int_T rt_LoggedOutputNumDimensions[] = {
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1
      };

      static int_T rt_LoggedOutputDimensions[] = {
        13,
        13,
        19,
        19,
        3,
        3,
        10,
        9,
        3,
        9,
        6,
        1,
        1,
        6,
        6,
        6,
        16
      };

      static boolean_T rt_LoggedOutputIsVarDims[] = {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      };

      static void* rt_LoggedCurrentSignalDimensions[] = {
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL),
        (NULL)
      };

      static int_T rt_LoggedCurrentSignalDimensionsSize[] = {
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4
      };

      static BuiltInDTypeId rt_LoggedOutputDataTypeIds[] = {
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE,
        SS_DOUBLE
      };

      static int_T rt_LoggedOutputComplexSignals[] = {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      };

      static const char_T *rt_LoggedOutputLabels[] = {
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "u",
        "y",
        "dy",
        "" };

      static const char_T *rt_LoggedOutputBlockNames[] = {
        "Walking_ATRIAS/q",
        "Walking_ATRIAS/dq",
        "Walking_ATRIAS/EncoderAnglesClean",
        "Walking_ATRIAS/EncoderDerivsClean",
        "Walking_ATRIAS/MicrostrainEulerAnglesClean",
        "Walking_ATRIAS/MicrostrainEulerDerivsClean",
        "Walking_ATRIAS/AbsTick",
        "Walking_ATRIAS/IncTick",
        "Walking_ATRIAS/ValidStates",
        "Walking_ATRIAS/RotationMatrix",
        "Walking_ATRIAS/MotorCurrentSafe",
        "Walking_ATRIAS/MedullaCommandSafe",
        "Walking_ATRIAS/SafetyState",
        "Walking_ATRIAS/u",
        "Walking_ATRIAS/y",
        "Walking_ATRIAS/dy",
        "Walking_ATRIAS/ControlOutput" };

      static RTWLogDataTypeConvert rt_RTWLogDataTypeConvert[] = {
        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 },

        { 0, SS_DOUBLE, SS_DOUBLE, 0, 0, 0, 1.0, 0, 0.0 }
      };

      static RTWLogSignalInfo rt_LoggedOutputSignalInfo[] = {
        {
          17,
          rt_LoggedOutputWidths,
          rt_LoggedOutputNumDimensions,
          rt_LoggedOutputDimensions,
          rt_LoggedOutputIsVarDims,
          rt_LoggedCurrentSignalDimensions,
          rt_LoggedCurrentSignalDimensionsSize,
          rt_LoggedOutputDataTypeIds,
          rt_LoggedOutputComplexSignals,
          (NULL),

          { rt_LoggedOutputLabels },
          (NULL),
          (NULL),
          (NULL),

          { rt_LoggedOutputBlockNames },

          { (NULL) },
          (NULL),
          rt_RTWLogDataTypeConvert
        }
      };

      rtliSetLogYSignalInfo(Walking_ATRIAS_M->rtwLogInfo,
                            rt_LoggedOutputSignalInfo);

      /* set currSigDims field */
      rt_LoggedCurrentSignalDimensions[0] = &rt_LoggedOutputWidths[0];
      rt_LoggedCurrentSignalDimensions[1] = &rt_LoggedOutputWidths[1];
      rt_LoggedCurrentSignalDimensions[2] = &rt_LoggedOutputWidths[2];
      rt_LoggedCurrentSignalDimensions[3] = &rt_LoggedOutputWidths[3];
      rt_LoggedCurrentSignalDimensions[4] = &rt_LoggedOutputWidths[4];
      rt_LoggedCurrentSignalDimensions[5] = &rt_LoggedOutputWidths[5];
      rt_LoggedCurrentSignalDimensions[6] = &rt_LoggedOutputWidths[6];
      rt_LoggedCurrentSignalDimensions[7] = &rt_LoggedOutputWidths[7];
      rt_LoggedCurrentSignalDimensions[8] = &rt_LoggedOutputWidths[8];
      rt_LoggedCurrentSignalDimensions[9] = &rt_LoggedOutputWidths[9];
      rt_LoggedCurrentSignalDimensions[10] = &rt_LoggedOutputWidths[10];
      rt_LoggedCurrentSignalDimensions[11] = &rt_LoggedOutputWidths[11];
      rt_LoggedCurrentSignalDimensions[12] = &rt_LoggedOutputWidths[12];
      rt_LoggedCurrentSignalDimensions[13] = &rt_LoggedOutputWidths[13];
      rt_LoggedCurrentSignalDimensions[14] = &rt_LoggedOutputWidths[14];
      rt_LoggedCurrentSignalDimensions[15] = &rt_LoggedOutputWidths[15];
      rt_LoggedCurrentSignalDimensions[16] = &rt_LoggedOutputWidths[16];
    }

    rtliSetLogY(Walking_ATRIAS_M->rtwLogInfo, "yout");
  }

  /* External mode info */
  Walking_ATRIAS_M->Sizes.checksums[0] = (2385601952U);
  Walking_ATRIAS_M->Sizes.checksums[1] = (804019991U);
  Walking_ATRIAS_M->Sizes.checksums[2] = (783034396U);
  Walking_ATRIAS_M->Sizes.checksums[3] = (4003235734U);

  {
    static const sysRanDType rtAlwaysEnabled = SUBSYS_RAN_BC_ENABLE;
    static RTWExtModeInfo rt_ExtModeInfo;
    static const sysRanDType *systemRan[42];
    Walking_ATRIAS_M->extModeInfo = (&rt_ExtModeInfo);
    rteiSetSubSystemActiveVectorAddresses(&rt_ExtModeInfo, systemRan);
    systemRan[0] = &rtAlwaysEnabled;
    systemRan[1] = &rtAlwaysEnabled;
    systemRan[2] = &rtAlwaysEnabled;
    systemRan[3] = &rtAlwaysEnabled;
    systemRan[4] = &rtAlwaysEnabled;
    systemRan[5] = &rtAlwaysEnabled;
    systemRan[6] = &rtAlwaysEnabled;
    systemRan[7] = &rtAlwaysEnabled;
    systemRan[8] = &rtAlwaysEnabled;
    systemRan[9] = &rtAlwaysEnabled;
    systemRan[10] = &rtAlwaysEnabled;
    systemRan[11] = &rtAlwaysEnabled;
    systemRan[12] = &rtAlwaysEnabled;
    systemRan[13] = &rtAlwaysEnabled;
    systemRan[14] = &rtAlwaysEnabled;
    systemRan[15] = &rtAlwaysEnabled;
    systemRan[16] = &rtAlwaysEnabled;
    systemRan[17] = (sysRanDType *)
      &Walking_ATRIAS_DW.EnableControlWord.EnableControlWord_SubsysRanBC;
    systemRan[18] = (sysRanDType *)
      &Walking_ATRIAS_DW.FaultReset.FaultReset_SubsysRanBC;
    systemRan[19] = (sysRanDType *)
      &Walking_ATRIAS_DW.NothingControlWord.NothingControlWord_SubsysRanBC;
    systemRan[20] = (sysRanDType *)
      &Walking_ATRIAS_DW.ShutdownControlWord.ShutdownControlWord_SubsysRanBC;
    systemRan[21] = &rtAlwaysEnabled;
    systemRan[22] = &rtAlwaysEnabled;
    systemRan[23] = (sysRanDType *)
      &Walking_ATRIAS_DW.EnableControlWord_h.EnableControlWord_SubsysRanBC;
    systemRan[24] = (sysRanDType *)
      &Walking_ATRIAS_DW.FaultReset_a.FaultReset_SubsysRanBC;
    systemRan[25] = (sysRanDType *)
      &Walking_ATRIAS_DW.NothingControlWord_n.NothingControlWord_SubsysRanBC;
    systemRan[26] = (sysRanDType *)
      &Walking_ATRIAS_DW.ShutdownControlWord_p.ShutdownControlWord_SubsysRanBC;
    systemRan[27] = &rtAlwaysEnabled;
    systemRan[28] = &rtAlwaysEnabled;
    systemRan[29] = (sysRanDType *)
      &Walking_ATRIAS_DW.EnableControlWord_k.EnableControlWord_SubsysRanBC;
    systemRan[30] = (sysRanDType *)
      &Walking_ATRIAS_DW.FaultReset_k.FaultReset_SubsysRanBC;
    systemRan[31] = (sysRanDType *)
      &Walking_ATRIAS_DW.NothingControlWord_j.NothingControlWord_SubsysRanBC;
    systemRan[32] = (sysRanDType *)
      &Walking_ATRIAS_DW.ShutdownControlWord_b.ShutdownControlWord_SubsysRanBC;
    systemRan[33] = &rtAlwaysEnabled;
    systemRan[34] = &rtAlwaysEnabled;
    systemRan[35] = (sysRanDType *)
      &Walking_ATRIAS_DW.EnableControlWord_n.EnableControlWord_SubsysRanBC;
    systemRan[36] = (sysRanDType *)
      &Walking_ATRIAS_DW.FaultReset_l.FaultReset_SubsysRanBC;
    systemRan[37] = (sysRanDType *)
      &Walking_ATRIAS_DW.NothingControlWord_jg.NothingControlWord_SubsysRanBC;
    systemRan[38] = (sysRanDType *)
      &Walking_ATRIAS_DW.ShutdownControlWord_l.ShutdownControlWord_SubsysRanBC;
    systemRan[39] = &rtAlwaysEnabled;
    systemRan[40] = &rtAlwaysEnabled;
    systemRan[41] = &rtAlwaysEnabled;
    rteiSetModelMappingInfoPtr(Walking_ATRIAS_M->extModeInfo,
      &Walking_ATRIAS_M->SpecialInfo.mappingInfo);
    rteiSetChecksumsPtr(Walking_ATRIAS_M->extModeInfo,
                        Walking_ATRIAS_M->Sizes.checksums);
    rteiSetTPtr(Walking_ATRIAS_M->extModeInfo, rtmGetTPtr(Walking_ATRIAS_M));
  }

  Walking_ATRIAS_M->solverInfoPtr = (&Walking_ATRIAS_M->solverInfo);
  Walking_ATRIAS_M->Timing.stepSize = (0.001);
  rtsiSetFixedStepSize(&Walking_ATRIAS_M->solverInfo, 0.001);
  rtsiSetSolverMode(&Walking_ATRIAS_M->solverInfo, SOLVER_MODE_SINGLETASKING);

  /* block I/O */
  Walking_ATRIAS_M->ModelData.blockIO = ((void *) &Walking_ATRIAS_B);
  (void) memset(((void *) &Walking_ATRIAS_B), 0,
                sizeof(B_Walking_ATRIAS_T));

  {
    int_T i;
    for (i = 0; i < 9; i++) {
      Walking_ATRIAS_B.UnitDelay1[i] = 0.0;
    }

    for (i = 0; i < 9; i++) {
      Walking_ATRIAS_B.UnitDelay[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.UnitDelay2[i] = 0.0;
    }

    for (i = 0; i < 19; i++) {
      Walking_ATRIAS_B.VectorConcatenate[i] = 0.0;
    }

    for (i = 0; i < 9; i++) {
      Walking_ATRIAS_B.UnitDelay6[i] = 0.0;
    }

    for (i = 0; i < 9; i++) {
      Walking_ATRIAS_B.UnitDelay10[i] = 0.0;
    }

    for (i = 0; i < 9; i++) {
      Walking_ATRIAS_B.Reshape3[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.Gain1[i] = 0.0;
    }

    for (i = 0; i < 13; i++) {
      Walking_ATRIAS_B.Gain[i] = 0.0;
    }

    for (i = 0; i < 13; i++) {
      Walking_ATRIAS_B.Add[i] = 0.0;
    }

    for (i = 0; i < 13; i++) {
      Walking_ATRIAS_B.Gain_a[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.Constant3[i] = 0.0;
    }

    for (i = 0; i < 11; i++) {
      Walking_ATRIAS_B.Constant4[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.Reshape[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.Gain2[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.Gain_e[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.Switch[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.Switch2[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.torque_sat[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.current_unsat[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.Switch_b[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.Switch2_d[i] = 0.0;
    }

    for (i = 0; i < 13; i++) {
      Walking_ATRIAS_B.UnitDelay2_o[i] = 0.0;
    }

    for (i = 0; i < 13; i++) {
      Walking_ATRIAS_B.UnitDelay1_h[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.Reshape3_i[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.Reshape4[i] = 0.0;
    }

    for (i = 0; i < 16; i++) {
      Walking_ATRIAS_B.Reshape1[i] = 0.0;
    }

    for (i = 0; i < 13; i++) {
      Walking_ATRIAS_B.rad2deg[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.Gain_d[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.Gain1_i[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.DataTypeConversion97[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.CurrentSaturation[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.DataTypeConversion63[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.DataTypeConversion87[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.DataTypeConversion15[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.DataTypeConversion39[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.y[i] = 0.0;
    }

    for (i = 0; i < 10; i++) {
      Walking_ATRIAS_B.TmpSignalConversionAtSFunctionI[i] = 0.0;
    }

    for (i = 0; i < 9; i++) {
      Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_d[i] = 0.0;
    }

    for (i = 0; i < 9; i++) {
      Walking_ATRIAS_B.Rollover[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.IncCalTick[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.u_zeroed[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_e[i] = 0.0;
    }

    for (i = 0; i < 30; i++) {
      Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_a[i] = 0.0;
    }

    for (i = 0; i < 30; i++) {
      Walking_ATRIAS_B.Temperatures[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_l[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.motorVoltage[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_o[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.logicVoltage[i] = 0.0;
    }

    for (i = 0; i < 10; i++) {
      Walking_ATRIAS_B.TmpSignalConversionAtSFunctio_c[i] = 0.0;
    }

    for (i = 0; i < 10; i++) {
      Walking_ATRIAS_B.measuredCurrent[i] = 0.0;
    }

    for (i = 0; i < 9; i++) {
      Walking_ATRIAS_B.Rk[i] = 0.0;
    }

    for (i = 0; i < 19; i++) {
      Walking_ATRIAS_B.ImpAsg_InsertedFor_q_clean_at_i[i] = 0.0;
    }

    for (i = 0; i < 19; i++) {
      Walking_ATRIAS_B.ImpAsg_InsertedFor_dq_clean_at_[i] = 0.0;
    }

    for (i = 0; i < 9; i++) {
      Walking_ATRIAS_B.Rk_g[i] = 0.0;
    }

    for (i = 0; i < 9; i++) {
      Walking_ATRIAS_B.R0[i] = 0.0;
    }

    for (i = 0; i < 13; i++) {
      Walking_ATRIAS_B.q_clean[i] = 0.0;
    }

    for (i = 0; i < 13; i++) {
      Walking_ATRIAS_B.dq_clean[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.MotorCurrentCommandSafe[i] = 0.0;
    }

    for (i = 0; i < 13; i++) {
      Walking_ATRIAS_B.q[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.Controller3_o2[i] = 0.0;
    }

    for (i = 0; i < 16; i++) {
      Walking_ATRIAS_B.Controller3_o3[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.Controller3_o4[i] = 0.0;
    }

    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_B.Controller3_o5[i] = 0.0;
    }

    Walking_ATRIAS_B.DataTypeConversion49 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion73 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion3 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion25 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion50 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion74 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion1 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion26 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion98 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion114 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion57 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion81 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion9 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion33 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion104 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion119 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion20[0] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion20[1] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion20[2] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion22[0] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion22[1] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion22[2] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion17 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion24 = 0.0;
    Walking_ATRIAS_B.UnitDelay7[0] = 0.0;
    Walking_ATRIAS_B.UnitDelay7[1] = 0.0;
    Walking_ATRIAS_B.UnitDelay7[2] = 0.0;
    Walking_ATRIAS_B.UnitDelay5[0] = 0.0;
    Walking_ATRIAS_B.UnitDelay5[1] = 0.0;
    Walking_ATRIAS_B.UnitDelay5[2] = 0.0;
    Walking_ATRIAS_B.UnitDelay8 = 0.0;
    Walking_ATRIAS_B.UnitDelay9[0] = 0.0;
    Walking_ATRIAS_B.UnitDelay9[1] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion7[0] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion7[1] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion7[2] = 0.0;
    Walking_ATRIAS_B.UnitDelay_m = 0.0;
    Walking_ATRIAS_B.DiscreteTimeIntegrator1 = 0.0;
    Walking_ATRIAS_B.Divide = 0.0;
    Walking_ATRIAS_B.DataTypeConversion = 0.0;
    Walking_ATRIAS_B.UnitDelay_a = 0.0;
    Walking_ATRIAS_B.Add_j[0] = 0.0;
    Walking_ATRIAS_B.Add_j[1] = 0.0;
    Walking_ATRIAS_B.Add_j[2] = 0.0;
    Walking_ATRIAS_B.Add_j[3] = 0.0;
    Walking_ATRIAS_B.DigitalClock = 0.0;
    Walking_ATRIAS_B.Gain1_o[0] = 0.0;
    Walking_ATRIAS_B.Gain1_o[1] = 0.0;
    Walking_ATRIAS_B.Gain1_o[2] = 0.0;
    Walking_ATRIAS_B.Gain1_o[3] = 0.0;
    Walking_ATRIAS_B.Switch_f = 0.0;
    Walking_ATRIAS_B.DigitalClock_e = 0.0;
    Walking_ATRIAS_B.DataTypeConversion69[0] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion69[1] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion93[0] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion93[1] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion111 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion21[0] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion21[1] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion45[0] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion45[1] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion126 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion62 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion86 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion103 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion14 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion38 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion118 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion61 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion85 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion101 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion13 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion37 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion116 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion102[0] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion102[1] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion102[2] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion117[0] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion117[1] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion117[2] = 0.0;
    Walking_ATRIAS_B.Counter_o1 = 0.0;
    Walking_ATRIAS_B.Counter_o2 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion10 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion105 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion106 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion107 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion108 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion109 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion11 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion110 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion112 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion12 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion120 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion121 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion122 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion123 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion124 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion125 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion157 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion16 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion18 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion19 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion2 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion23[0] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion23[1] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion27 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion28 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion29 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion30 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion31 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion32 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion34 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion35 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion36 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion4 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion47[0] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion47[1] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion5 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion51 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion52 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion53 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion54 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion55 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion56 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion58 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion59 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion6 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion60 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion7_l = 0.0;
    Walking_ATRIAS_B.DataTypeConversion71[0] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion71[1] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion75 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion76 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion77 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion78 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion79 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion8 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion80 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion82 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion83 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion84 = 0.0;
    Walking_ATRIAS_B.DataTypeConversion95[0] = 0.0;
    Walking_ATRIAS_B.DataTypeConversion95[1] = 0.0;
    Walking_ATRIAS_B.VectorConcatenate_g[0] = 0.0;
    Walking_ATRIAS_B.VectorConcatenate_g[1] = 0.0;
    Walking_ATRIAS_B.Fcn = 0.0;
    Walking_ATRIAS_B.DataTypeConversion20_f = 0.0;
    Walking_ATRIAS_B.DataTypeConversion42 = 0.0;
    Walking_ATRIAS_B.VectorConcatenate_f[0] = 0.0;
    Walking_ATRIAS_B.VectorConcatenate_f[1] = 0.0;
    Walking_ATRIAS_B.Fcn_m = 0.0;
    Walking_ATRIAS_B.DataTypeConversion20_o = 0.0;
    Walking_ATRIAS_B.DataTypeConversion42_e = 0.0;
    Walking_ATRIAS_B.VectorConcatenate_d[0] = 0.0;
    Walking_ATRIAS_B.VectorConcatenate_d[1] = 0.0;
    Walking_ATRIAS_B.Fcn_k = 0.0;
    Walking_ATRIAS_B.DataTypeConversion20_n = 0.0;
    Walking_ATRIAS_B.DataTypeConversion42_h = 0.0;
    Walking_ATRIAS_B.VectorConcatenate_p[0] = 0.0;
    Walking_ATRIAS_B.VectorConcatenate_p[1] = 0.0;
    Walking_ATRIAS_B.Fcn_mq = 0.0;
    Walking_ATRIAS_B.DataTypeConversion20_h = 0.0;
    Walking_ATRIAS_B.DataTypeConversion42_i = 0.0;
    Walking_ATRIAS_B.VectorConcatenate_dr[0] = 0.0;
    Walking_ATRIAS_B.VectorConcatenate_dr[1] = 0.0;
    Walking_ATRIAS_B.Fcn_i = 0.0;
    Walking_ATRIAS_B.ControlWordIndex = 0.0;
    Walking_ATRIAS_B.EnableTargetTorque = 0.0;
    Walking_ATRIAS_B.FaultDetected = 0.0;
    Walking_ATRIAS_B.VectorConcatenate_n[0] = 0.0;
    Walking_ATRIAS_B.VectorConcatenate_n[1] = 0.0;
    Walking_ATRIAS_B.Fcn_f = 0.0;
    Walking_ATRIAS_B.VectorConcatenate_c[0] = 0.0;
    Walking_ATRIAS_B.VectorConcatenate_c[1] = 0.0;
    Walking_ATRIAS_B.Fcn_h = 0.0;
    Walking_ATRIAS_B.ControlWordIndex_m = 0.0;
    Walking_ATRIAS_B.EnableTargetTorque_h = 0.0;
    Walking_ATRIAS_B.FaultDetected_g = 0.0;
    Walking_ATRIAS_B.VectorConcatenate_f0[0] = 0.0;
    Walking_ATRIAS_B.VectorConcatenate_f0[1] = 0.0;
    Walking_ATRIAS_B.Fcn_c = 0.0;
    Walking_ATRIAS_B.LimitSwitchesEncoded = 0.0;
    Walking_ATRIAS_B.wk[0] = 0.0;
    Walking_ATRIAS_B.wk[1] = 0.0;
    Walking_ATRIAS_B.wk[2] = 0.0;
    Walking_ATRIAS_B.Ak[0] = 0.0;
    Walking_ATRIAS_B.Ak[1] = 0.0;
    Walking_ATRIAS_B.Ak[2] = 0.0;
    Walking_ATRIAS_B.Seqk = 0.0;
    Walking_ATRIAS_B.ZYX[0] = 0.0;
    Walking_ATRIAS_B.ZYX[1] = 0.0;
    Walking_ATRIAS_B.ZYX[2] = 0.0;
    Walking_ATRIAS_B.dZYX[0] = 0.0;
    Walking_ATRIAS_B.dZYX[1] = 0.0;
    Walking_ATRIAS_B.dZYX[2] = 0.0;
    Walking_ATRIAS_B.YawRollover[0] = 0.0;
    Walking_ATRIAS_B.YawRollover[1] = 0.0;
    Walking_ATRIAS_B.MedullaCommandSafe = 0.0;
    Walking_ATRIAS_B.SafetyState = 0.0;
    Walking_ATRIAS_B.SafetyCountOut = 0.0;
    Walking_ATRIAS_B.EtherCATRxVar6 = 0.0F;
    Walking_ATRIAS_B.EtherCATRxVar1 = 0.0F;
    Walking_ATRIAS_B.EtherCATRxVar2 = 0.0F;
    Walking_ATRIAS_B.EtherCATRxVar9 = 0.0F;
    Walking_ATRIAS_B.EtherCATRxVar11 = 0.0F;
    Walking_ATRIAS_B.EtherCATRxVar12 = 0.0F;
    Walking_ATRIAS_B.sf_Chart_mz.ControlWordIndex = 0.0;
    Walking_ATRIAS_B.sf_Chart_mz.EnableTargetTorque = 0.0;
    Walking_ATRIAS_B.sf_Chart_mz.FaultDetected = 0.0;
    Walking_ATRIAS_B.sf_Chart_m.ControlWordIndex = 0.0;
    Walking_ATRIAS_B.sf_Chart_m.EnableTargetTorque = 0.0;
    Walking_ATRIAS_B.sf_Chart_m.FaultDetected = 0.0;
  }

  /* parameters */
  Walking_ATRIAS_M->ModelData.defaultParam = ((real_T *)&Walking_ATRIAS_P);

  /* states (dwork) */
  Walking_ATRIAS_M->ModelData.dwork = ((void *) &Walking_ATRIAS_DW);
  (void) memset((void *)&Walking_ATRIAS_DW, 0,
                sizeof(DW_Walking_ATRIAS_T));

  {
    int_T i;
    for (i = 0; i < 9; i++) {
      Walking_ATRIAS_DW.UnitDelay1_DSTATE[i] = 0.0;
    }
  }

  {
    int_T i;
    for (i = 0; i < 9; i++) {
      Walking_ATRIAS_DW.UnitDelay_DSTATE[i] = 0.0;
    }
  }

  {
    int_T i;
    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_DW.UnitDelay2_DSTATE[i] = 0.0;
    }
  }

  {
    int_T i;
    for (i = 0; i < 9; i++) {
      Walking_ATRIAS_DW.UnitDelay6_DSTATE[i] = 0.0;
    }
  }

  Walking_ATRIAS_DW.UnitDelay7_DSTATE[0] = 0.0;
  Walking_ATRIAS_DW.UnitDelay7_DSTATE[1] = 0.0;
  Walking_ATRIAS_DW.UnitDelay7_DSTATE[2] = 0.0;
  Walking_ATRIAS_DW.UnitDelay5_DSTATE[0] = 0.0;
  Walking_ATRIAS_DW.UnitDelay5_DSTATE[1] = 0.0;
  Walking_ATRIAS_DW.UnitDelay5_DSTATE[2] = 0.0;
  Walking_ATRIAS_DW.UnitDelay8_DSTATE = 0.0;

  {
    int_T i;
    for (i = 0; i < 9; i++) {
      Walking_ATRIAS_DW.UnitDelay10_DSTATE[i] = 0.0;
    }
  }

  Walking_ATRIAS_DW.UnitDelay9_DSTATE[0] = 0.0;
  Walking_ATRIAS_DW.UnitDelay9_DSTATE[1] = 0.0;
  Walking_ATRIAS_DW.UnitDelay_DSTATE_l = 0.0;
  Walking_ATRIAS_DW.DiscreteTimeIntegrator1_DSTATE = 0.0;

  {
    int_T i;
    for (i = 0; i < 13; i++) {
      Walking_ATRIAS_DW.UnitDelay2_DSTATE_h[i] = 0.0;
    }
  }

  {
    int_T i;
    for (i = 0; i < 13; i++) {
      Walking_ATRIAS_DW.UnitDelay1_DSTATE_j[i] = 0.0;
    }
  }

  Walking_ATRIAS_DW.UnitDelay_DSTATE_k = 0.0;
  Walking_ATRIAS_DW.Timeout = 0.0;
  Walking_ATRIAS_DW.Timeout_b = 0.0;
  Walking_ATRIAS_DW.sf_Chart_mz.Timeout = 0.0;
  Walking_ATRIAS_DW.sf_Chart_m.Timeout = 0.0;

  /* external outputs */
  Walking_ATRIAS_M->ModelData.outputs = (&Walking_ATRIAS_Y);

  {
    int_T i;
    for (i = 0; i < 13; i++) {
      Walking_ATRIAS_Y.q[i] = 0.0;
    }
  }

  {
    int_T i;
    for (i = 0; i < 13; i++) {
      Walking_ATRIAS_Y.dq[i] = 0.0;
    }
  }

  {
    int_T i;
    for (i = 0; i < 19; i++) {
      Walking_ATRIAS_Y.EncoderAnglesClean[i] = 0.0;
    }
  }

  {
    int_T i;
    for (i = 0; i < 19; i++) {
      Walking_ATRIAS_Y.EncoderDerivsClean[i] = 0.0;
    }
  }

  Walking_ATRIAS_Y.MicrostrainEulerAnglesClean[0] = 0.0;
  Walking_ATRIAS_Y.MicrostrainEulerAnglesClean[1] = 0.0;
  Walking_ATRIAS_Y.MicrostrainEulerAnglesClean[2] = 0.0;
  Walking_ATRIAS_Y.MicrostrainEulerDerivsClean[0] = 0.0;
  Walking_ATRIAS_Y.MicrostrainEulerDerivsClean[1] = 0.0;
  Walking_ATRIAS_Y.MicrostrainEulerDerivsClean[2] = 0.0;

  {
    int_T i;
    for (i = 0; i < 10; i++) {
      Walking_ATRIAS_Y.AbsTick[i] = 0.0;
    }
  }

  {
    int_T i;
    for (i = 0; i < 9; i++) {
      Walking_ATRIAS_Y.IncTick[i] = 0.0;
    }
  }

  Walking_ATRIAS_Y.ValidStates[0] = 0.0;
  Walking_ATRIAS_Y.ValidStates[1] = 0.0;
  Walking_ATRIAS_Y.ValidStates[2] = 0.0;

  {
    int_T i;
    for (i = 0; i < 9; i++) {
      Walking_ATRIAS_Y.RotationMatrix[i] = 0.0;
    }
  }

  {
    int_T i;
    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_Y.MotorCurrentSafe[i] = 0.0;
    }
  }

  Walking_ATRIAS_Y.MedullaCommandSafe = 0.0;
  Walking_ATRIAS_Y.SafetyState = 0.0;

  {
    int_T i;
    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_Y.u[i] = 0.0;
    }
  }

  {
    int_T i;
    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_Y.y[i] = 0.0;
    }
  }

  {
    int_T i;
    for (i = 0; i < 6; i++) {
      Walking_ATRIAS_Y.dy[i] = 0.0;
    }
  }

  {
    int_T i;
    for (i = 0; i < 16; i++) {
      Walking_ATRIAS_Y.ControlOutput[i] = 0.0;
    }
  }

  /* data type transition information */
  {
    static DataTypeTransInfo dtInfo;
    (void) memset((char_T *) &dtInfo, 0,
                  sizeof(dtInfo));
    Walking_ATRIAS_M->SpecialInfo.mappingInfo = (&dtInfo);
    Walking_ATRIAS_M->SpecialInfo.xpcData = ((void*) &dtInfo);
    dtInfo.numDataTypes = 17;
    dtInfo.dataTypeSizes = &rtDataTypeSizes[0];
    dtInfo.dataTypeNames = &rtDataTypeNames[0];

    /* Block I/O transition table */
    dtInfo.B = &rtBTransTable;

    /* Parameters transition table */
    dtInfo.P = &rtPTransTable;
  }

  /* Initialize DataMapInfo substructure containing ModelMap for C API */
  Walking_ATRIAS_InitializeDataMapInfo(Walking_ATRIAS_M);

  /* child S-Function registration */
  {
    RTWSfcnInfo *sfcnInfo = &Walking_ATRIAS_M->NonInlinedSFcns.sfcnInfo;
    Walking_ATRIAS_M->sfcnInfo = (sfcnInfo);
    rtssSetErrorStatusPtr(sfcnInfo, (&rtmGetErrorStatus(Walking_ATRIAS_M)));
    rtssSetNumRootSampTimesPtr(sfcnInfo, &Walking_ATRIAS_M->Sizes.numSampTimes);
    Walking_ATRIAS_M->NonInlinedSFcns.taskTimePtrs[0] = &(rtmGetTPtr
      (Walking_ATRIAS_M)[0]);
    rtssSetTPtrPtr(sfcnInfo,Walking_ATRIAS_M->NonInlinedSFcns.taskTimePtrs);
    rtssSetTStartPtr(sfcnInfo, &rtmGetTStart(Walking_ATRIAS_M));
    rtssSetTFinalPtr(sfcnInfo, &rtmGetTFinal(Walking_ATRIAS_M));
    rtssSetTimeOfLastOutputPtr(sfcnInfo, &rtmGetTimeOfLastOutput
      (Walking_ATRIAS_M));
    rtssSetStepSizePtr(sfcnInfo, &Walking_ATRIAS_M->Timing.stepSize);
    rtssSetStopRequestedPtr(sfcnInfo, &rtmGetStopRequested(Walking_ATRIAS_M));
    rtssSetDerivCacheNeedsResetPtr(sfcnInfo,
      &Walking_ATRIAS_M->ModelData.derivCacheNeedsReset);
    rtssSetZCCacheNeedsResetPtr(sfcnInfo,
      &Walking_ATRIAS_M->ModelData.zCCacheNeedsReset);
    rtssSetBlkStateChangePtr(sfcnInfo,
      &Walking_ATRIAS_M->ModelData.blkStateChange);
    rtssSetSampleHitsPtr(sfcnInfo, &Walking_ATRIAS_M->Timing.sampleHits);
    rtssSetPerTaskSampleHitsPtr(sfcnInfo,
      &Walking_ATRIAS_M->Timing.perTaskSampleHits);
    rtssSetSimModePtr(sfcnInfo, &Walking_ATRIAS_M->simMode);
    rtssSetSolverInfoPtr(sfcnInfo, &Walking_ATRIAS_M->solverInfoPtr);
  }

  Walking_ATRIAS_M->Sizes.numSFcns = (187);

  /* register each child */
  {
    (void) memset((void *)&Walking_ATRIAS_M->NonInlinedSFcns.childSFunctions[0],
                  0,
                  187*sizeof(SimStruct));
    Walking_ATRIAS_M->childSfunctions =
      (&Walking_ATRIAS_M->NonInlinedSFcns.childSFunctionPtrs[0]);

    {
      int_T i;
      for (i = 0; i < 187; i++) {
        Walking_ATRIAS_M->childSfunctions[i] =
          (&Walking_ATRIAS_M->NonInlinedSFcns.childSFunctions[i]);
      }
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 4 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[0];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn0.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn0.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn0.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[0]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[0]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[0]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[0]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn0.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking_ATRIAS_B.EtherCATRxVar4));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 4");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 4");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn0.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar4_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar4_P2_Siz);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar4_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn0.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn0.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar4_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 4 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[1];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn1.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn1.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn1.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[1]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[1]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[1]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[1]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn1.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking_ATRIAS_B.EtherCATRxVar4_l));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 4");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 4");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn1.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar4_P1_S_m);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar4_P2_S_g);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar4_IWORK_j[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn1.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn1.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar4_IWORK_j[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 4 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[2];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn2.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn2.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn2.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[2]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[2]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[2]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[2]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn2.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking_ATRIAS_B.EtherCATRxVar4_o));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 4");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 4");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn2.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar4_P1_S_a);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar4_P2_S_f);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar4_IWORK_g[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn2.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn2.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar4_IWORK_g[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 4 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[3];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn3.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn3.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn3.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[3]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[3]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[3]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[3]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn3.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking_ATRIAS_B.EtherCATRxVar4_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 4");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 4");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn3.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar4_P1_S_c);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar4_P2_S_c);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar4_IWORK_k[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn3.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn3.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar4_IWORK_k[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 8 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[4];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn4.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn4.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn4.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[4]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[4]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[4]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[4]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn4.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking_ATRIAS_B.EtherCATRxVar8));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 8");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 8");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn4.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar8_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar8_P2_Siz);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar8_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn4.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn4.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar8_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 8 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[5];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn5.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn5.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn5.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[5]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[5]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[5]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[5]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn5.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking_ATRIAS_B.EtherCATRxVar8_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 8");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 8");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn5.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar8_P1_S_g);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar8_P2_S_e);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar8_IWORK_g[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn5.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn5.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar8_IWORK_g[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 8 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[6];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn6.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn6.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn6.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[6]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[6]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[6]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[6]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn6.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking_ATRIAS_B.EtherCATRxVar8_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 8");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 8");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn6.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar8_P1_S_j);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar8_P2_S_o);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar8_IWORK_a[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn6.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn6.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar8_IWORK_a[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 8 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[7];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn7.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn7.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn7.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[7]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[7]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[7]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[7]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn7.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking_ATRIAS_B.EtherCATRxVar8_bx));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 8");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 8");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn7.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar8_P1_S_l);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar8_P2_S_b);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar8_IWORK_k[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn7.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn7.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar8_IWORK_k[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S60>/EtherCAT Rx Var 4 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[8];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn8.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn8.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn8.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[8]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[8]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[8]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[8]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn8.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking_ATRIAS_B.EtherCATRxVar4_e));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 4");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 4");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn8.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar4_P1_S_e);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar4_P2_S_m);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar4_IWORK_d[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn8.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn8.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar4_IWORK_d[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S59>/EtherCAT Rx Var 4 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[9];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn9.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn9.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn9.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[9]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[9]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[9]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[9]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn9.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint32_T *)
            &Walking_ATRIAS_B.EtherCATRxVar4_j));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 4");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 4");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn9.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar4_P1_S_o);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar4_P2_S_e);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar4_IWORK_dc[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn9.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn9.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar4_IWORK_dc[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var  (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[10];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn10.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn10.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn10.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[10]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[10]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[10]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[10]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn10.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar_n));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var ");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var ");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn10.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar_P1_Size);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar_P2_Size);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn10.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn10.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var  (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[11];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn11.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn11.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn11.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[11]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[11]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[11]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[11]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn11.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar_k));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var ");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var ");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn11.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar_P1_Si_a);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar_P2_Si_a);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar_IWORK_o[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn11.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn11.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar_IWORK_o[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var  (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[12];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn12.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn12.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn12.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[12]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[12]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[12]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[12]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn12.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar_nk));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var ");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var ");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn12.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar_P1_Si_k);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar_P2_Si_b);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar_IWORK_d[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn12.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn12.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar_IWORK_d[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var  (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[13];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn13.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn13.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn13.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[13]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[13]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[13]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[13]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn13.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar_o));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var ");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var ");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn13.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar_P1_Si_n);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar_P2_Si_m);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar_IWORK_g[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn13.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn13.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar_IWORK_g[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S60>/EtherCAT Rx Var 2 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[14];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn14.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn14.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn14.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[14]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[14]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[14]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[14]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn14.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar2_i));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 2");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 2");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn14.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar2_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar2_P2_Siz);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar2_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn14.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn14.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar2_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S59>/EtherCAT Rx Var 2 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[15];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn15.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn15.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn15.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[15]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[15]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[15]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[15]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn15.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar2_p));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 2");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 2");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn15.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar2_P1_S_i);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar2_P2_S_m);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar2_IWORK_g[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn15.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn15.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar2_IWORK_g[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S61>/EtherCAT Rx Var 6 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[16];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn16.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn16.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn16.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[16]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[16]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[16]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[16]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn16.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real32_T *)
            &Walking_ATRIAS_B.EtherCATRxVar6));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 6");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 6");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn16.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar6_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar6_P2_Siz);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar6_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn16.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn16.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar6_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S61>/EtherCAT Rx Var 1 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[17];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn17.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn17.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn17.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[17]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[17]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[17]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[17]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn17.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real32_T *)
            &Walking_ATRIAS_B.EtherCATRxVar1));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 1");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 1");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn17.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar1_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar1_P2_Siz);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar1_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn17.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn17.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar1_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S61>/EtherCAT Rx Var 2 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[18];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn18.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn18.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn18.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[18]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[18]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[18]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[18]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn18.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real32_T *)
            &Walking_ATRIAS_B.EtherCATRxVar2));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 2");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 2");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn18.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar2_P1_S_n);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar2_P2_S_e);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar2_IWORK_a[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn18.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn18.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar2_IWORK_a[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S61>/EtherCAT Rx Var 9 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[19];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn19.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn19.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn19.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[19]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[19]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[19]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[19]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn19.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real32_T *)
            &Walking_ATRIAS_B.EtherCATRxVar9));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 9");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 9");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn19.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar9_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar9_P2_Siz);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar9_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn19.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn19.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar9_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S61>/EtherCAT Rx Var 11 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[20];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn20.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn20.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn20.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[20]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[20]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[20]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[20]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn20.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real32_T *)
            &Walking_ATRIAS_B.EtherCATRxVar11));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 11");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 11");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn20.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar11_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar11_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar11_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn20.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn20.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar11_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S61>/EtherCAT Rx Var 12 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[21];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn21.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn21.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn21.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[21]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[21]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[21]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[21]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn21.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((real32_T *)
            &Walking_ATRIAS_B.EtherCATRxVar12));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 12");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 12");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn21.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar12_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar12_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled19);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar12_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn21.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn21.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar12_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S61>/EtherCAT Rx Var 18 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[22];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn22.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn22.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn22.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[22]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[22]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[22]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[22]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn22.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar18));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 18");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 18");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn22.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)Walking_ATRIAS_ConstP.pooled21);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled23);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar18_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn22.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn22.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar18_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S61>/EtherCAT Rx Var 5 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[23];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn23.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn23.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn23.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[23]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[23]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[23]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[23]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn23.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar5_hj));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 5");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 5");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn23.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar5_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar5_P2_Siz);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar5_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn23.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn23.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar5_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 6 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[24];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn24.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn24.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn24.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[24]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[24]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[24]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[24]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn24.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar6_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 6");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 6");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn24.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar6_P1_S_m);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar6_P2_S_k);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar6_IWORK_a[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn24.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn24.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar6_IWORK_a[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 7 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[25];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn25.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn25.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn25.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[25]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[25]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[25]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[25]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn25.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar7));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 7");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 7");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn25.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar7_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar7_P2_Siz);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar7_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn25.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn25.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar7_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 6 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[26];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn26.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn26.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn26.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[26]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[26]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[26]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[26]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn26.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar6_j));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 6");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 6");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn26.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar6_P1_S_c);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar6_P2_S_c);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar6_IWORK_b[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn26.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn26.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar6_IWORK_b[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 7 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[27];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn27.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn27.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn27.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[27]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[27]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[27]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[27]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn27.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar7_p));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 7");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 7");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn27.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar7_P1_S_l);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar7_P2_S_b);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar7_IWORK_d[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn27.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn27.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar7_IWORK_d[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S60>/EtherCAT Rx Var  (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[28];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn28.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn28.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn28.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[28]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[28]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[28]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[28]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn28.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var ");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var ");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn28.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar_P1_Si_g);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar_P2_Si_i);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar_IWORK_p[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn28.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn28.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar_IWORK_p[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 6 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[29];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn29.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn29.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn29.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[29]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[29]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[29]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[29]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn29.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar6_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 6");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 6");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn29.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar6_P1_S_f);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar6_P2_S_d);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar6_IWORK_l[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn29.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn29.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar6_IWORK_l[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 7 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[30];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn30.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn30.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn30.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[30]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[30]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[30]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[30]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn30.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar7_g));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 7");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 7");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn30.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar7_P1_S_k);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar7_P2__b3);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar7_IWORK_h[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn30.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn30.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar7_IWORK_h[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 6 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[31];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn31.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn31.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn31.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[31]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[31]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[31]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[31]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn31.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar6_bg));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 6");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 6");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn31.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar6_P1_S_h);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar6_P2_S_p);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar6_IWORK_g[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn31.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn31.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar6_IWORK_g[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 7 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[32];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn32.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn32.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn32.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[32]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[32]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[32]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[32]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn32.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar7_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 7");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 7");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn32.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar7_P1_S_o);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar7_P2_S_k);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar7_IWORK_b[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn32.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn32.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar7_IWORK_b[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S59>/EtherCAT Rx Var  (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[33];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn33.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn33.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn33.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[33]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[33]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[33]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[33]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn33.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var ");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var ");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn33.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar_P1_Si_p);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar_P2_Si_p);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar_IWORK_dh[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn33.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn33.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar_IWORK_dh[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 10 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[34];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn34.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn34.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn34.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[34]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[34]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[34]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[34]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn34.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar10));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 10");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 10");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn34.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar10_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar10_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar10_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn34.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn34.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar10_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 10 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[35];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn35.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn35.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn35.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[35]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[35]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[35]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[35]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn35.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar10_i));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 10");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 10");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn35.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar10_P1__g);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar10_P2__l);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar10_IWORK_f[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn35.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn35.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar10_IWORK_f[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S60>/EtherCAT Rx Var 6 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[36];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn36.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn36.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn36.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[36]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[36]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[36]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[36]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn36.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar6_p));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 6");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 6");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn36.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar6_P1_S_a);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar6_P2_S_m);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar6_IWORK_bw[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn36.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn36.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar6_IWORK_bw[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 10 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[37];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn37.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn37.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn37.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[37]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[37]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[37]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[37]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn37.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar10_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 10");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 10");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn37.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar10_P1__e);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar10_P2__e);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar10_IWORK_g[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn37.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn37.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar10_IWORK_g[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 10 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[38];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn38.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn38.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn38.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[38]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[38]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[38]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[38]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn38.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar10_l));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 10");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 10");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn38.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar10_P1__k);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar10_P2__g);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar10_IWORK_h[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn38.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn38.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar10_IWORK_h[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S59>/EtherCAT Rx Var 6 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[39];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn39.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn39.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn39.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[39]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[39]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[39]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[39]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn39.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar6_n));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 6");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 6");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn39.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar6_P1_S_p);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar6_P2_S_g);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar6_IWORK_l0[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn39.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn39.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar6_IWORK_l0[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 11 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[40];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn40.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn40.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn40.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[40]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[40]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[40]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[40]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn40.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar11_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 11");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 11");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn40.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar11_P1__c);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar11_P2__p);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar11_IWORK_n[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn40.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn40.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar11_IWORK_n[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 11 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[41];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn41.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn41.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn41.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[41]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[41]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[41]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[41]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn41.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar11_e));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 11");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 11");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn41.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar11_P1__e);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar11_P2__k);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar11_IWORK_p[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn41.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn41.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar11_IWORK_p[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S60>/EtherCAT Rx Var 1 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[42];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn42.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn42.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn42.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[42]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[42]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[42]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[42]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn42.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar1_n));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 1");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 1");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn42.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar1_P1_S_c);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar1_P2_S_h);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar1_IWORK_p[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn42.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn42.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar1_IWORK_p[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 11 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[43];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn43.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn43.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn43.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[43]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[43]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[43]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[43]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn43.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar11_k));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 11");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 11");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn43.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar11_P1__m);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar11_P2__j);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar11_IWORK_i[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn43.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn43.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar11_IWORK_i[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 11 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[44];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn44.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn44.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn44.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[44]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[44]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[44]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[44]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn44.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar11_l));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 11");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 11");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn44.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar11_P1_en);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar11_P2_po);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar11_IWORK_f[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn44.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn44.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar11_IWORK_f[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S59>/EtherCAT Rx Var 1 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[45];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn45.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn45.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn45.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[45]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[45]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[45]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[45]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn45.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar1_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 1");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 1");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn45.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar1_P1_S_e);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar1_P2_S_i);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar1_IWORK_i[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn45.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn45.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar1_IWORK_i[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 12 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[46];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn46.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn46.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn46.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[46]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[46]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[46]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[46]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn46.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar12_f));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 12");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 12");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn46.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar12_P1__k);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar12_P2__o);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar12_IWORK_m[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn46.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn46.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar12_IWORK_m[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 13 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[47];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn47.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn47.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn47.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[47]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[47]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[47]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[47]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn47.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar13));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 13");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 13");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn47.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar13_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar13_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar13_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn47.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn47.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar13_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 14 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[48];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn48.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn48.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn48.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[48]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[48]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[48]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[48]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn48.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar14));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 14");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 14");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn48.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar14_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar14_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar14_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn48.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn48.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar14_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 15 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[49];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn49.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn49.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn49.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[49]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[49]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[49]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[49]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn49.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar15));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 15");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 15");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn49.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar15_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar15_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar15_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn49.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn49.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar15_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 16 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[50];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn50.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn50.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn50.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[50]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[50]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[50]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[50]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn50.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar16));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 16");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 16");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn50.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar16_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar16_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar16_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn50.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn50.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar16_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 17 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[51];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn51.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn51.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn51.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[51]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[51]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[51]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[51]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn51.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar17));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 17");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 17");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn51.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar17_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar17_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar17_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn51.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn51.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar17_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 12 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[52];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn52.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn52.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn52.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[52]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[52]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[52]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[52]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn52.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar12_o));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 12");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 12");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn52.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar12_P1__n);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar12_P2__k);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar12_IWORK_f[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn52.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn52.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar12_IWORK_f[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 13 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[53];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn53.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn53.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn53.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[53]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[53]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[53]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[53]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn53.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar13_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 13");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 13");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn53.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar13_P1__o);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar13_P2__k);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar13_IWORK_e[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn53.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn53.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar13_IWORK_e[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 14 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[54];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn54.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn54.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn54.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[54]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[54]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[54]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[54]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn54.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar14_j));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 14");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 14");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn54.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar14_P1__j);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar14_P2__c);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar14_IWORK_c[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn54.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn54.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar14_IWORK_c[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 15 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[55];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn55.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn55.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn55.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[55]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[55]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[55]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[55]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn55.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar15_m));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 15");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 15");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn55.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar15_P1__b);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar15_P2__m);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar15_IWORK_i[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn55.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn55.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar15_IWORK_i[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 16 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[56];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn56.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn56.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn56.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[56]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[56]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[56]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[56]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn56.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar16_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 16");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 16");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn56.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar16_P1__b);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar16_P2__h);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar16_IWORK_e[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn56.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn56.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar16_IWORK_e[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 17 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[57];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn57.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn57.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn57.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[57]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[57]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[57]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[57]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn57.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar17_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 17");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 17");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn57.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar17_P1__m);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar17_P2__n);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar17_IWORK_e[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn57.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn57.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar17_IWORK_e[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S60>/EtherCAT Rx Var 12 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[58];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn58.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn58.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn58.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[58]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[58]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[58]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[58]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn58.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar12_l));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 12");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 12");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn58.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar12_P1__p);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar12_P2_kk);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar12_IWORK_j[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn58.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn58.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar12_IWORK_j[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S60>/EtherCAT Rx Var 13 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[59];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn59.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn59.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn59.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[59]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[59]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[59]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[59]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn59.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar13_f));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 13");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 13");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn59.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar13_P1__e);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar13_P2__f);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar13_IWORK_h[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn59.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn59.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar13_IWORK_h[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S60>/EtherCAT Rx Var 14 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[60];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn60.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn60.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn60.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[60]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[60]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[60]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[60]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn60.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar14_f));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 14");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 14");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn60.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar14_P1__b);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar14_P2_ce);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar14_IWORK_cr[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn60.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn60.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar14_IWORK_cr[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 12 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[61];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn61.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn61.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn61.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[61]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[61]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[61]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[61]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn61.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar12_og));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 12");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 12");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn61.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar12_P1_pv);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar12_P2__c);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar12_IWORK_o[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn61.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn61.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar12_IWORK_o[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 13 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[62];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn62.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn62.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn62.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[62]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[62]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[62]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[62]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn62.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar13_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 13");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 13");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn62.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar13_P1__g);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar13_P2__h);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar13_IWORK_j[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn62.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn62.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar13_IWORK_j[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 14 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[63];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn63.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn63.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn63.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[63]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[63]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[63]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[63]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn63.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar14_l));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 14");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 14");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn63.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar14_P1__p);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar14_P2__b);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar14_IWORK_p[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn63.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn63.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar14_IWORK_p[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 15 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[64];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn64.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn64.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn64.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[64]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[64]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[64]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[64]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn64.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar15_k));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 15");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 15");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn64.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar15_P1_bc);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar15_P2__n);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar15_IWORK_g[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn64.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn64.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar15_IWORK_g[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 16 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[65];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn65.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn65.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn65.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[65]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[65]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[65]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[65]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn65.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar16_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 16");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 16");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn65.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar16_P1__c);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar16_P2__e);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar16_IWORK_l[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn65.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn65.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar16_IWORK_l[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 17 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[66];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn66.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn66.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn66.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[66]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[66]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[66]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[66]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn66.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar17_g));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 17");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 17");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn66.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar17_P1__j);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar17_P2__m);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar17_IWORK_j[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn66.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn66.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar17_IWORK_j[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 12 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[67];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn67.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn67.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn67.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[67]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[67]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[67]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[67]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn67.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar12_m));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 12");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 12");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn67.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar12_P1__o);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar12_P2_kj);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar12_IWORK_b[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn67.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn67.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar12_IWORK_b[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 13 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[68];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn68.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn68.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn68.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[68]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[68]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[68]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[68]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn68.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar13_n));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 13");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 13");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn68.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar13_P1__h);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar13_P2__n);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar13_IWORK_g[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn68.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn68.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar13_IWORK_g[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 14 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[69];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn69.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn69.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn69.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[69]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[69]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[69]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[69]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn69.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar14_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 14");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 14");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn69.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar14_P1__c);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar14_P2_ck);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar14_IWORK_k[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn69.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn69.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar14_IWORK_k[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 15 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[70];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn70.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn70.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn70.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[70]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[70]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[70]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[70]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn70.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar15_mh));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 15");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 15");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn70.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar15_P1__j);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar15_P2__l);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar15_IWORK_b[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn70.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn70.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar15_IWORK_b[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 16 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[71];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn71.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn71.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn71.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[71]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[71]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[71]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[71]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn71.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar16_hz));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 16");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 16");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn71.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar16_P1_c1);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar16_P2__p);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar16_IWORK_h[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn71.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn71.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar16_IWORK_h[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 17 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[72];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn72.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn72.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn72.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[72]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[72]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[72]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[72]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn72.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar17_bq));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 17");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 17");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn72.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar17_P1__l);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar17_P2__h);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar17_IWORK_p[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn72.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn72.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar17_IWORK_p[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S59>/EtherCAT Rx Var 12 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[73];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn73.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn73.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn73.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[73]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[73]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[73]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[73]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn73.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar12_k));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 12");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 12");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn73.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar12_P1_pu);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar12_P2__n);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar12_IWORK_c[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn73.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn73.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar12_IWORK_c[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S59>/EtherCAT Rx Var 13 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[74];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn74.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn74.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn74.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[74]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[74]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[74]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[74]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn74.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar13_g));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 13");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 13");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn74.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar13_P1__f);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar13_P2_fq);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar13_IWORK_b[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn74.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn74.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar13_IWORK_b[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S59>/EtherCAT Rx Var 14 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[75];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn75.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn75.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn75.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[75]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[75]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[75]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[75]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn75.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar14_d));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 14");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 14");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn75.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar14_P1__f);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar14_P2__d);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar14_IWORK_g[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn75.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn75.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar14_IWORK_g[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 5 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[76];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn76.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn76.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn76.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[76]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[76]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[76]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[76]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn76.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar5));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 5");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 5");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn76.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar5_P1_S_l);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar5_P2_S_f);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar5_IWORK_c[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn76.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn76.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar5_IWORK_c[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S60>/EtherCAT Rx Var 19 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[77];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn77.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn77.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn77.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[77]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[77]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[77]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[77]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn77.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar19));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 19");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 19");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn77.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar19_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled33);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar19_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn77.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn77.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar19_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S60>/EtherCAT Rx Var 16 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[78];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn78.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn78.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn78.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[78]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[78]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[78]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[78]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn78.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar16_e));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 16");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 16");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn78.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar16_P1__p);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled35);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar16_IWORK_j[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn78.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn78.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar16_IWORK_j[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S60>/EtherCAT Rx Var 15 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[79];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn79.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn79.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn79.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[79]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[79]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[79]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[79]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn79.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar15_d));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 15");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 15");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn79.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar15_P1__l);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar15_P2__b);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar15_IWORK_bk[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn79.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn79.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar15_IWORK_bk[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S60>/EtherCAT Rx Var 5 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[80];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn80.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn80.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn80.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[80]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[80]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[80]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[80]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn80.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar5_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 5");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 5");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn80.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar5_P1__lt);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar5_P2_S_c);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar5_IWORK_p[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn80.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn80.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar5_IWORK_p[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S60>/EtherCAT Rx Var 3 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[81];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn81.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn81.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn81.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[81]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[81]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[81]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[81]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn81.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar3));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 3");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 3");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn81.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar3_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar3_P2_Siz);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar3_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn81.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn81.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar3_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 9 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[82];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn82.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn82.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn82.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[82]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[82]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[82]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[82]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn82.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar9_p));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 9");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 9");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn82.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar9_P1_S_i);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar9_P2_S_d);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar9_IWORK_a[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn82.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn82.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar9_IWORK_a[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S60>/EtherCAT Rx Var 17 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[83];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn83.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn83.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn83.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[83]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[83]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[83]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[83]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn83.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar17_f));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 17");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 17");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn83.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar17_P1__n);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled37);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar17_IWORK_i[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn83.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn83.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar17_IWORK_i[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S59>/EtherCAT Rx Var 18 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[84];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn84.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn84.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn84.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[84]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[84]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[84]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[84]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn84.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar18_a));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 18");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 18");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn84.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar18_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar18_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar18_IWORK_o[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn84.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn84.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar18_IWORK_o[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 1 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[85];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn85.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn85.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn85.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[85]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[85]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[85]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[85]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn85.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar1_c));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 1");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 1");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn85.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar1_P1_S_j);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar1_P2_S_e);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar1_IWORK_h[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn85.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn85.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar1_IWORK_h[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S59>/EtherCAT Rx Var 19 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[86];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn86.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn86.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn86.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[86]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[86]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[86]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[86]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn86.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar19_p));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 19");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 19");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn86.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar19_P1__h);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled39);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar19_IWORK_o[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn86.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn86.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar19_IWORK_o[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S59>/EtherCAT Rx Var 16 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[87];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn87.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn87.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn87.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[87]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[87]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[87]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[87]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn87.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar16_l));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 16");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 16");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn87.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar16_P1__l);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled41);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar16_IWORK_p[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn87.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn87.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar16_IWORK_p[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S59>/EtherCAT Rx Var 15 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[88];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn88.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn88.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn88.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[88]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[88]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[88]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[88]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn88.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar15_j));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 15");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 15");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn88.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar15_P1__o);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar15_P2_bp);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar15_IWORK_o[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn88.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn88.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar15_IWORK_o[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S59>/EtherCAT Rx Var 5 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[89];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn89.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn89.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn89.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[89]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[89]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[89]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[89]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn89.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar5_f));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 5");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 5");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn89.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar5_P1_S_g);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar5_P2_S_b);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar5_IWORK_g[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn89.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn89.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar5_IWORK_g[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S59>/EtherCAT Rx Var 3 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[90];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn90.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn90.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn90.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[90]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[90]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[90]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[90]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn90.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar3_f));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 3");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 3");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn90.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar3_P1_S_i);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar3_P2_S_b);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar3_IWORK_p[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn90.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn90.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar3_IWORK_p[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S59>/EtherCAT Rx Var 17 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[91];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn91.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn91.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn91.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[91]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[91]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[91]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[91]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn91.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar17_i));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 17");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Rx Var 17");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn91.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar17_P1_nw);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled43);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar17_IWORK_m[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn91.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn91.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar17_IWORK_m[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S60>/EtherCAT Rx Var 18 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[92];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn92.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn92.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn92.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[92]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[92]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[92]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[92]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn92.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar18_n));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 18");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Rx Var 18");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn92.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar18_P1__e);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar18_P2__a);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar18_IWORK_c[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn92.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn92.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar18_IWORK_c[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S61>/EtherCAT Rx Var 16 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[93];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn93.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn93.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn93.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[93]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[93]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[93]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[93]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn93.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar16_e3));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 16");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 16");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn93.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar16_P1__k);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled45);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar16_IWORK_d[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn93.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn93.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar16_IWORK_d[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S61>/EtherCAT Rx Var 17 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[94];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn94.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn94.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn94.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[94]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[94]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[94]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[94]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn94.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar17_n));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 17");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 17");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn94.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar17_P1__b);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar17_P2__p);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar17_IWORK_l[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn94.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn94.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar17_IWORK_l[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S61>/EtherCAT Rx Var 15 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[95];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn95.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn95.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn95.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[95]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[95]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[95]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[95]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn95.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar15_e));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 15");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 15");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn95.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar15_P1__d);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar15_P2__c);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar15_IWORK_c[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn95.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn95.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar15_IWORK_c[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 23 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[96];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn96.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn96.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn96.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[96]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[96]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[96]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[96]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn96.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar23));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 23");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 23");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn96.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar23_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar23_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar23_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn96.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn96.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar23_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 2 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[97];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn97.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn97.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn97.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[97]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[97]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[97]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[97]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn97.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar2_g));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 2");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 2");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn97.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar2_P1_S_f);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar2_P2_S_g);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar2_IWORK_k[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn97.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn97.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar2_IWORK_k[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 3 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[98];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn98.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn98.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn98.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[98]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[98]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[98]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[98]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn98.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar3_e));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 3");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 3");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn98.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar3_P1_S_k);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar3_P2_S_p);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar3_IWORK_i[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn98.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn98.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar3_IWORK_i[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 23 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[99];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn99.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn99.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn99.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[99]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[99]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[99]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[99]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn99.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar23_d));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 23");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 23");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn99.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar23_P1__d);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar23_P2__o);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar23_IWORK_f[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn99.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn99.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar23_IWORK_f[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 21 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[100];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn100.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn100.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn100.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[100]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[100]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[100]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[100]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn100.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar21));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 21");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 21");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn100.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar21_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar21_P2_Si);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar21_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn100.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn100.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar21_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 20 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[101];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn101.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn101.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn101.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[101]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[101]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[101]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[101]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn101.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar20));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 20");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 20");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn101.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar20_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled47);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar20_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn101.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn101.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar20_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 22 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[102];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn102.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn102.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn102.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[102]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[102]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[102]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[102]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn102.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar22));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 22");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 22");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn102.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar22_P1_Si);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled49);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar22_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn102.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn102.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar22_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 18 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[103];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn103.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn103.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn103.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[103]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[103]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[103]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[103]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn103.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar18_d));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 18");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 18");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn103.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar18_P1__d);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar18_P2__b);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar18_IWORK_k[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn103.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn103.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar18_IWORK_k[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 19 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[104];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn104.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn104.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn104.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[104]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[104]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[104]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[104]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn104.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar19_p0));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 19");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 19");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn104.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar19_P1_hi);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled51);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar19_IWORK_i[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn104.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn104.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar19_IWORK_i[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 5 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[105];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn105.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn105.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn105.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[105]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[105]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[105]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[105]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn105.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar5_g));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 5");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 5");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn105.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar5_P1_S_k);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar5_P2_S_a);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar5_IWORK_i[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn105.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn105.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar5_IWORK_i[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 9 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[106];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn106.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn106.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn106.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[106]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[106]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[106]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[106]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn106.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar9_n));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 9");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 9");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn106.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar9_P1_S_a);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar9_P2_S_h);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar9_IWORK_f[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn106.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn106.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar9_IWORK_f[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 1 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[107];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn107.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn107.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn107.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[107]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[107]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[107]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[107]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn107.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar1_g));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 1");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 1");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn107.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar1_P1_S_i);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar1_P2_S_g);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar1_IWORK_d[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn107.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn107.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar1_IWORK_d[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 21 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[108];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn108.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn108.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn108.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[108]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[108]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[108]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[108]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn108.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar21_f));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 21");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 21");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn108.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar21_P1__p);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar21_P2__h);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar21_IWORK_n[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn108.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn108.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar21_IWORK_n[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 2 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[109];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn109.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn109.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn109.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[109]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[109]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[109]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[109]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn109.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar2_iw));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 2");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 2");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn109.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar2_P1_S_m);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar2_P2_S_d);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar2_IWORK_f[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn109.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn109.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar2_IWORK_f[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Rx Var 3 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[110];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn110.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn110.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn110.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[110]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[110]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[110]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[110]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn110.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar3_k));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 3");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Rx Var 3");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn110.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar3_P1__kr);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar3_P2_S_i);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar3_IWORK_j[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn110.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn110.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar3_IWORK_j[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 20 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[111];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn111.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn111.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn111.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[111]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[111]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[111]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[111]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn111.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar20_n));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 20");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 20");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn111.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar20_P1__b);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled53);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar20_IWORK_d[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn111.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn111.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar20_IWORK_d[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 23 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[112];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn112.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn112.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn112.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[112]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[112]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[112]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[112]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn112.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar23_n));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 23");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 23");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn112.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar23_P1__l);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar23_P2__a);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar23_IWORK_b[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn112.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn112.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar23_IWORK_b[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 21 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[113];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn113.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn113.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn113.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[113]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[113]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[113]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[113]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn113.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar21_p));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 21");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 21");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn113.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar21_P1__i);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar21_P2__n);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar21_IWORK_i[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn113.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn113.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar21_IWORK_i[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 20 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[114];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn114.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn114.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn114.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[114]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[114]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[114]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[114]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn114.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar20_h));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 20");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 20");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn114.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)Walking_ATRIAS_ConstP.pooled55);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled57);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar20_IWORK_o[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn114.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn114.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar20_IWORK_o[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 22 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[115];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn115.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn115.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn115.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[115]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[115]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[115]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[115]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn115.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar22_l));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 22");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 22");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn115.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)Walking_ATRIAS_ConstP.pooled55);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled57);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar22_IWORK_i[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn115.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn115.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar22_IWORK_i[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 18 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[116];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn116.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn116.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn116.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[116]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[116]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[116]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[116]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn116.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar18_e));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 18");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 18");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn116.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar18_P1__g);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar18_P2__h);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar18_IWORK_j[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn116.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn116.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar18_IWORK_j[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 19 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[117];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn117.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn117.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn117.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[117]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[117]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[117]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[117]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn117.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar19_m));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 19");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 19");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn117.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar19_P1__e);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled59);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar19_IWORK_p[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn117.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn117.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar19_IWORK_p[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 5 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[118];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn118.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn118.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn118.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[118]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[118]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[118]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[118]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn118.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar5_e));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 5");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 5");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn118.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar5_P1_S_h);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar5_P2_S_g);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar5_IWORK_j[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn118.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn118.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar5_IWORK_j[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 9 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[119];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn119.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn119.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn119.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[119]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[119]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[119]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[119]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn119.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar9_nz));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 9");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 9");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn119.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar9_P1_S_l);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar9_P2_S_a);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar9_IWORK_n[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn119.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn119.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar9_IWORK_n[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 22 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[120];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn120.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn120.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn120.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[120]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[120]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[120]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[120]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn120.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar22_i));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 22");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 22");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn120.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar22_P1__f);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled61);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar22_IWORK_m[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn120.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn120.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar22_IWORK_m[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 1 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[121];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn121.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn121.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn121.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[121]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[121]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[121]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[121]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn121.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar1_m));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 1");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 1");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn121.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar1_P1__c1);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar1_P2_S_o);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar1_IWORK_pv[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn121.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn121.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar1_IWORK_pv[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 18 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[122];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn122.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn122.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn122.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[122]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[122]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[122]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[122]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn122.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar18_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 18");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 18");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn122.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar18_P1__k);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar18_P2__p);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar18_IWORK_b[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn122.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn122.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar18_IWORK_b[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 2 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[123];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn123.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn123.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn123.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[123]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[123]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[123]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[123]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn123.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar2_f));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 2");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 2");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn123.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar2_P1_S_a);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar2_P2__en);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar2_IWORK_h[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn123.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn123.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar2_IWORK_h[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Rx Var 3 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[124];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn124.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn124.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn124.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[124]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[124]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[124]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[124]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn124.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar3_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 3");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Rx Var 3");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn124.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar3_P1__kp);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar3_P2_S_h);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar3_IWORK_o[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn124.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn124.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar3_IWORK_o[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 23 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[125];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn125.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn125.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn125.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[125]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[125]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[125]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[125]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn125.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar23_b));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 23");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 23");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn125.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar23_P1__o);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar23_P2__i);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar23_IWORK_n[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn125.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn125.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar23_IWORK_n[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 21 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[126];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn126.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn126.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn126.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[126]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[126]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[126]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[126]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn126.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar21_l));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 21");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 21");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn126.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar21_P1_if);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar21_P2__d);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar21_IWORK_h[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn126.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn126.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar21_IWORK_h[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 20 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[127];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn127.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn127.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn127.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[127]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[127]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[127]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[127]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn127.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar20_e));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 20");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 20");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn127.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar20_P1__a);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled63);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar20_IWORK_c[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn127.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn127.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar20_IWORK_c[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 22 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[128];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn128.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn128.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn128.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[128]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[128]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[128]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[128]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn128.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar22_a));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 22");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 22");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn128.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar22_P1__d);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled65);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar22_IWORK_j[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn128.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn128.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar22_IWORK_j[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 18 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[129];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn129.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn129.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn129.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[129]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[129]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[129]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[129]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn129.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar18_o));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 18");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 18");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn129.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar18_P1__f);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar18_P2__f);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar18_IWORK_l[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn129.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn129.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar18_IWORK_l[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Rx Var 19 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[130];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn130.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn130.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn130.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[130]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[130]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[130]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[130]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn130.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar19_ma));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 19");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Rx Var 19");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn130.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar19_P1__f);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled67);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar19_IWORK_a[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn130.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn130.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar19_IWORK_a[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 19 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[131];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn131.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn131.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn131.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[131]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[131]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[131]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[131]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn131.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar19_c));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 19");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 19");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn131.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar19_P1__i);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled69);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar19_IWORK_c[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn131.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn131.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar19_IWORK_c[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 5 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[132];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn132.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn132.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn132.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[132]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[132]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[132]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[132]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn132.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar5_gi));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 5");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 5");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn132.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar5_P1__ko);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar5_P2__gf);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar5_IWORK_a[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn132.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn132.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar5_IWORK_a[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 9 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[133];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn133.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn133.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn133.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[133]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[133]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[133]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[133]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn133.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar9_e));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 9");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 9");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn133.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar9_P1_S_m);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar9_P2__db);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar9_IWORK_c[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn133.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn133.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar9_IWORK_c[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 1 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[134];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn134.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn134.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn134.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[134]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[134]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[134]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[134]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn134.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar1_o));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 1");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 1");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn134.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar1_P1_S_f);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar1_P2_S_j);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar1_IWORK_k[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn134.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn134.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar1_IWORK_k[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 2 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[135];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn135.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn135.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn135.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[135]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[135]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[135]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[135]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn135.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar2_d));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 2");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 2");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn135.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar2_P1_S_k);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar2_P2_S_c);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar2_IWORK_m[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn135.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn135.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar2_IWORK_m[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Rx Var 3 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[136];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn136.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn136.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn136.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[136]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[136]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[136]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[136]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn136.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar3_c));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 3");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Rx Var 3");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn136.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar3_P1_S_d);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar3_P2__it);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar3_IWORK_k[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn136.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn136.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar3_IWORK_k[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S59>/EtherCAT Tx Var 3 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[137];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn137.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn137.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn137.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[137]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[137]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[137]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[137]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn137.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.DataTypeConversion3_o);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 3");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Tx Var 3");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn137.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATTxVar3_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled43);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATTxVar3_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn137.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn137.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATTxVar3_IWORK[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S59>/EtherCAT Tx Var 4 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[138];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn138.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn138.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn138.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[138]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[138]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[138]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[138]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn138.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.DataTypeConversion4_d);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 4");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Tx Var 4");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn138.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATTxVar4_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled39);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATTxVar4_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn138.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn138.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATTxVar4_IWORK[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S59>/EtherCAT Tx Var 5 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[139];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn139.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn139.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn139.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[139]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[139]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[139]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[139]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn139.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.DataTypeConversion5_a);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 5");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3L/EtherCAT Tx Var 5");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn139.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATTxVar5_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled41);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled71);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATTxVar5_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn139.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn139.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATTxVar5_IWORK[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S60>/EtherCAT Tx Var 3 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[140];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn140.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn140.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn140.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[140]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[140]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[140]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[140]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn140.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.DataTypeConversion3_m);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 3");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Tx Var 3");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn140.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATTxVar3_P1_S_d);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled37);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATTxVar3_IWORK_g[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn140.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn140.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATTxVar3_IWORK_g[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S60>/EtherCAT Tx Var 4 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[141];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn141.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn141.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn141.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[141]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[141]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[141]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[141]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn141.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.DataTypeConversion4_l);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 4");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Tx Var 4");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn141.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATTxVar4_P1_S_k);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled33);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATTxVar4_IWORK_e[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn141.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn141.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATTxVar4_IWORK_e[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S60>/EtherCAT Tx Var 5 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[142];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn142.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn142.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn142.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[142]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[142]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[142]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[142]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn142.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.DataTypeConversion5_d);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 5");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/HipMedulla_3R/EtherCAT Tx Var 5");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn142.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATTxVar5_P1_S_i);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled35);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled71);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATTxVar5_IWORK_p[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn142.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn142.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATTxVar5_IWORK_p[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S61>/EtherCAT Rx Var 3 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[143];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn143.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn143.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn143.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[143]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[143]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[143]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[143]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn143.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint8_T *)
            &Walking_ATRIAS_B.EtherCATRxVar3_g));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 3");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 3");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn143.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)Walking_ATRIAS_ConstP.pooled21);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled23);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar3_IWORK_f[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn143.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn143.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar3_IWORK_f[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S61>/EtherCAT Rx Var 4 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[144];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn144.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn144.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn144.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[144]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[144]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[144]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[144]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn144.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking_ATRIAS_B.EtherCATRxVar4_d));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Rx Var 4");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Rx Var 4");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn144.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar4_P1_S_h);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATRxVar4_P2_S_b);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATRxVar4_IWORK_l[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn144.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn144.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATRxVar4_IWORK_l[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S61>/EtherCAT Tx Var  (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[145];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn145.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn145.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn145.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[145]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[145]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[145]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[145]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn145.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.DataTypeConversion3_m4);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var ");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Tx Var ");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn145.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATTxVar_P1_Size);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled45);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATTxVar_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn145.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn145.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATTxVar_IWORK[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S61>/EtherCAT Tx Var 1 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[146];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn146.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn146.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn146.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[146]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[146]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[146]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[146]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn146.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.DataTypeConversion4_li);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 1");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/IMU_Medulla/EtherCAT Tx Var 1");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn146.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATTxVar1_P1_Siz);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATTxVar1_P2_Siz);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATTxVar1_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn146.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn146.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATTxVar1_IWORK[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S71>/EtherCAT PDO Receive5 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[147];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn147.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn147.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn147.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[147]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[147]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[147]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[147]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn147.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATPDOReceive5));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive5");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_1L/EtherCATSubsystem/EtherCAT PDO Receive5");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn147.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive5_P);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive5_a);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOReceive5_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn147.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn147.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOReceive5_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S71>/EtherCAT PDO Receive (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[148];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn148.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn148.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn148.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[148]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[148]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[148]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[148]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn148.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking_ATRIAS_B.EtherCATPDOReceive));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_1L/EtherCATSubsystem/EtherCAT PDO Receive");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn148.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive_P1);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled73);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOReceive_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn148.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn148.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOReceive_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S71>/EtherCAT PDO Receive1 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[149];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn149.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn149.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn149.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[149]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[149]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[149]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[149]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn149.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int32_T *)
            &Walking_ATRIAS_B.EtherCATPDOReceive1));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive1");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_1L/EtherCATSubsystem/EtherCAT PDO Receive1");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn149.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive1_P);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled76);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled71);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOReceive1_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn149.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn149.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOReceive1_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S71>/EtherCAT PDO Receive2 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[150];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn150.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn150.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn150.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[150]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[150]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[150]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[150]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn150.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int8_T *)
            &Walking_ATRIAS_B.EtherCATPDOReceive2));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive2");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_1L/EtherCATSubsystem/EtherCAT PDO Receive2");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn150.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive2_P);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive2_e);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOReceive2_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn150.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn150.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOReceive2_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S71>/EtherCAT PDO Transmit (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[151];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn151.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn151.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn151.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[151]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[151]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[151]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[151]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn151.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.Switch_fb);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_1L/EtherCATSubsystem/EtherCAT PDO Transmit");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn151.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOTransmit_P);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled76);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOTransmit_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn151.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn151.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOTransmit_IWORK[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S71>/EtherCAT PDO Transmit1 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[152];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn152.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn152.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn152.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[152]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[152]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[152]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[152]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn152.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.Merge);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit1");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_1L/EtherCATSubsystem/EtherCAT PDO Transmit1");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn152.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOTransmit1_);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOTransmit_d);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOTransmit1_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn152.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn152.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOTransmit1_IWORK[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S71>/EtherCAT PDO Transmit2 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[153];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn153.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn153.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn153.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[153]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[153]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[153]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[153]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn153.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_ConstP.pooled101);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit2");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_1L/EtherCATSubsystem/EtherCAT PDO Transmit2");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn153.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOTransmit2_);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled73);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOTransmit2_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn153.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn153.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOTransmit2_IWORK[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S88>/EtherCAT PDO Receive5 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[154];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn154.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn154.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn154.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[154]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[154]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[154]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[154]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn154.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATPDOReceive5_d));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive5");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_1R/EtherCATSubsystem/EtherCAT PDO Receive5");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn154.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive5_m);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive5_g);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOReceive5_IWORK_o[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn154.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn154.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOReceive5_IWORK_o[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S88>/EtherCAT PDO Receive (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[155];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn155.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn155.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn155.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[155]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[155]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[155]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[155]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn155.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking_ATRIAS_B.EtherCATPDOReceive_d));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_1R/EtherCATSubsystem/EtherCAT PDO Receive");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn155.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive__o);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled78);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOReceive_IWORK_d[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn155.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn155.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOReceive_IWORK_d[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S88>/EtherCAT PDO Receive1 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[156];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn156.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn156.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn156.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[156]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[156]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[156]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[156]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn156.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int32_T *)
            &Walking_ATRIAS_B.EtherCATPDOReceive1_d));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive1");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_1R/EtherCATSubsystem/EtherCAT PDO Receive1");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn156.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive1_h);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled80);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled71);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOReceive1_IWORK_k[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn156.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn156.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOReceive1_IWORK_k[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S88>/EtherCAT PDO Receive2 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[157];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn157.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn157.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn157.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[157]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[157]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[157]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[157]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn157.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int8_T *)
            &Walking_ATRIAS_B.EtherCATPDOReceive2_n));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive2");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_1R/EtherCATSubsystem/EtherCAT PDO Receive2");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn157.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive2_b);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive2_l);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOReceive2_IWORK_j[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn157.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn157.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOReceive2_IWORK_j[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S88>/EtherCAT PDO Transmit (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[158];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn158.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn158.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn158.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[158]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[158]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[158]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[158]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn158.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.Switch_fg);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_1R/EtherCATSubsystem/EtherCAT PDO Transmit");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn158.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOTransmit_p);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled80);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOTransmit_IWORK_b[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn158.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn158.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOTransmit_IWORK_b[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S88>/EtherCAT PDO Transmit1 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[159];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn159.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn159.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn159.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[159]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[159]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[159]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[159]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn159.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.Merge_b);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit1");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_1R/EtherCATSubsystem/EtherCAT PDO Transmit1");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn159.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOTransmit_l);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOTransmit_n);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOTransmit1_IWORK_c
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn159.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn159.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOTransmit1_IWORK_c[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S88>/EtherCAT PDO Transmit2 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[160];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn160.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn160.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn160.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[160]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[160]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[160]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[160]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn160.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_ConstP.pooled101);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit2");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_1R/EtherCATSubsystem/EtherCAT PDO Transmit2");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn160.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOTransmit_k);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled78);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOTransmit2_IWORK_h
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn160.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn160.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOTransmit2_IWORK_h[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S105>/EtherCAT PDO Receive5 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[161];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn161.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn161.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn161.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[161]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[161]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[161]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[161]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn161.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATPDOReceive5_dm));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive5");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_2L/EtherCATSubsystem/EtherCAT PDO Receive5");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn161.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive5_o);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive5_k);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOReceive5_IWORK_p[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn161.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn161.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOReceive5_IWORK_p[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S105>/EtherCAT PDO Receive (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[162];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn162.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn162.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn162.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[162]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[162]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[162]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[162]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn162.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking_ATRIAS_B.EtherCATPDOReceive_p));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_2L/EtherCATSubsystem/EtherCAT PDO Receive");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn162.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive__p);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled82);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOReceive_IWORK_i[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn162.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn162.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOReceive_IWORK_i[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S105>/EtherCAT PDO Receive1 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[163];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn163.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn163.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn163.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[163]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[163]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[163]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[163]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn163.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int32_T *)
            &Walking_ATRIAS_B.EtherCATPDOReceive1_n));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive1");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_2L/EtherCATSubsystem/EtherCAT PDO Receive1");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn163.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive1_o);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled84);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled71);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOReceive1_IWORK_d[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn163.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn163.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOReceive1_IWORK_d[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S105>/EtherCAT PDO Receive2 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[164];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn164.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn164.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn164.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[164]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[164]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[164]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[164]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn164.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int8_T *)
            &Walking_ATRIAS_B.EtherCATPDOReceive2_f));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive2");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_2L/EtherCATSubsystem/EtherCAT PDO Receive2");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn164.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive2_n);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive_nt);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOReceive2_IWORK_h[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn164.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn164.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOReceive2_IWORK_h[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S105>/EtherCAT PDO Transmit (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[165];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn165.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn165.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn165.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[165]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[165]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[165]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[165]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn165.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.Switch_d);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_2L/EtherCATSubsystem/EtherCAT PDO Transmit");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn165.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOTransmit_m);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled84);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOTransmit_IWORK_g[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn165.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn165.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOTransmit_IWORK_g[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S105>/EtherCAT PDO Transmit1 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[166];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn166.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn166.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn166.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[166]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[166]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[166]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[166]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn166.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.Merge_e);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit1");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_2L/EtherCATSubsystem/EtherCAT PDO Transmit1");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn166.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOTransmit_h);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOTransmit_a);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOTransmit1_IWORK_g
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn166.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn166.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOTransmit1_IWORK_g[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S105>/EtherCAT PDO Transmit2 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[167];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn167.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn167.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn167.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[167]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[167]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[167]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[167]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn167.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_ConstP.pooled101);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit2");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_2L/EtherCATSubsystem/EtherCAT PDO Transmit2");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn167.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOTransmit_e);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled82);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking_ATRIAS_DW.EtherCATPDOTransmit2_IWORK_hi[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn167.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn167.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOTransmit2_IWORK_hi[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S122>/EtherCAT PDO Receive5 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[168];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn168.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn168.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn168.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[168]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[168]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[168]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[168]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn168.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((uint16_T *)
            &Walking_ATRIAS_B.EtherCATPDOReceive5_m));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive5");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_2R/EtherCATSubsystem/EtherCAT PDO Receive5");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn168.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive5_p);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive_kx);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOReceive5_IWORK_m[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn168.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn168.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOReceive5_IWORK_m[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S122>/EtherCAT PDO Receive (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[169];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn169.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn169.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn169.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[169]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[169]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[169]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[169]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn169.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int16_T *)
            &Walking_ATRIAS_B.EtherCATPDOReceive_o));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_2R/EtherCATSubsystem/EtherCAT PDO Receive");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn169.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive__f);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled86);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOReceive_IWORK_m[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn169.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn169.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOReceive_IWORK_m[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S122>/EtherCAT PDO Receive1 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[170];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn170.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn170.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn170.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[170]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[170]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[170]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[170]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn170.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int32_T *)
            &Walking_ATRIAS_B.EtherCATPDOReceive1_f));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive1");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_2R/EtherCATSubsystem/EtherCAT PDO Receive1");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn170.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive1_d);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled88);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled71);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOReceive1_IWORK_p[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn170.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn170.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOReceive1_IWORK_p[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S122>/EtherCAT PDO Receive3 (xpcethercatpdorx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[171];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn171.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn171.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn171.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[171]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[171]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[171]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[171]);
      }

      /* outputs */
      {
        ssSetPortInfoForOutputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn171.outputPortInfo[0]);
        _ssSetNumOutputPorts(rts, 1);

        /* port 0 */
        {
          _ssSetOutputPortNumDimensions(rts, 0, 1);
          ssSetOutputPortWidth(rts, 0, 1);
          ssSetOutputPortSignal(rts, 0, ((int8_T *)
            &Walking_ATRIAS_B.EtherCATPDOReceive3));
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Receive3");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_2R/EtherCATSubsystem/EtherCAT PDO Receive3");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn171.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive3_P);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOReceive3_f);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOReceive3_IWORK[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn171.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn171.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOReceive3_IWORK[0]);
      }

      /* registration */
      xpcethercatpdorx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetOutputPortConnected(rts, 0, 1);
      _ssSetOutputPortBeingMerged(rts, 0, 0);

      /* Update the BufferDstPort flags for each input port */
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S122>/EtherCAT PDO Transmit (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[172];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn172.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn172.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn172.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[172]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[172]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[172]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[172]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn172.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.Switch_i);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_2R/EtherCATSubsystem/EtherCAT PDO Transmit");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn172.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOTransmit_g);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled88);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled31);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOTransmit_IWORK_l[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn172.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn172.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOTransmit_IWORK_l[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S122>/EtherCAT PDO Transmit1 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[173];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn173.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn173.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn173.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[173]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[173]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[173]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[173]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn173.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.Merge_k);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit1");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_2R/EtherCATSubsystem/EtherCAT PDO Transmit1");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn173.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOTransmi_mm);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOTransmi_gs);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *)
                 &Walking_ATRIAS_DW.EtherCATPDOTransmit1_IWORK_ci[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn173.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn173.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOTransmit1_IWORK_ci[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S122>/EtherCAT PDO Transmit2 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[174];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn174.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn174.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn174.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[174]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[174]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[174]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[174]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn174.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_ConstP.pooled101);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT PDO Transmit2");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegElmo_2R/EtherCATSubsystem/EtherCAT PDO Transmit2");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn174.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATPDOTransmi_gc);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled86);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATPDOTransmit2_IWORK_o
                 [0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn174.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn174.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATPDOTransmit2_IWORK_o[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Tx Var 3 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[175];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn175.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn175.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn175.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[175]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[175]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[175]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[175]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn175.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.DataTypeConversion3_h);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 3");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Tx Var 3");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn175.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATTxVar3_P1_S_e);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled53);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATTxVar3_IWORK_o[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn175.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn175.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATTxVar3_IWORK_o[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Tx Var 4 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[176];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn176.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn176.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn176.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[176]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[176]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[176]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[176]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn176.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.DataTypeConversion4_g);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 4");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Tx Var 4");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn176.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATTxVar4_P1_S_f);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled61);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATTxVar4_IWORK_a[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn176.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn176.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATTxVar4_IWORK_a[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S66>/EtherCAT Tx Var 5 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[177];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn177.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn177.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn177.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[177]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[177]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[177]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[177]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn177.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.DataTypeConversion5_i);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 5");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1L/EtherCAT Tx Var 5");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn177.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATTxVar5_P1_S_j);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled67);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled71);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATTxVar5_IWORK_k[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn177.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn177.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATTxVar5_IWORK_k[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Tx Var 3 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[178];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn178.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn178.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn178.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[178]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[178]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[178]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[178]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn178.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.DataTypeConversion3_m4p);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 3");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Tx Var 3");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn178.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATTxVar3_P1_S_o);
        ssSetSFcnParam(rts, 1, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATTxVar3_P2_Siz);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATTxVar3_IWORK_i[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn178.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn178.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATTxVar3_IWORK_i[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Tx Var 4 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[179];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn179.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn179.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn179.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[179]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[179]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[179]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[179]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn179.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.DataTypeConversion4_a);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 4");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Tx Var 4");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn179.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATTxVar4_P1_S_p);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled57);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATTxVar4_IWORK_p[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn179.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn179.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATTxVar4_IWORK_p[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S67>/EtherCAT Tx Var 5 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[180];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn180.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn180.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn180.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[180]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[180]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[180]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[180]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn180.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.DataTypeConversion5_p);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 5");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_1R/EtherCAT Tx Var 5");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn180.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATTxVar5_P1_S_o);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled59);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled71);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATTxVar5_IWORK_a[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn180.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn180.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATTxVar5_IWORK_a[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Tx Var 3 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[181];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn181.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn181.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn181.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[181]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[181]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[181]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[181]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn181.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.DataTypeConversion3_f);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 3");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Tx Var 3");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn181.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATTxVar3_P1_S_b);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled47);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATTxVar3_IWORK_a[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn181.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn181.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATTxVar3_IWORK_a[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Tx Var 4 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[182];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn182.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn182.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn182.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[182]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[182]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[182]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[182]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn182.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.DataTypeConversion4_di);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 4");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Tx Var 4");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn182.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATTxVar4_P1_S_b);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled49);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATTxVar4_IWORK_f[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn182.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn182.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATTxVar4_IWORK_f[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S68>/EtherCAT Tx Var 5 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[183];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn183.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn183.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn183.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[183]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[183]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[183]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[183]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn183.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.DataTypeConversion5_h);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 5");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2L/EtherCAT Tx Var 5");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn183.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATTxVar5_P1__og);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled51);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled71);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATTxVar5_IWORK_kq[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn183.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn183.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATTxVar5_IWORK_kq[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Tx Var 3 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[184];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn184.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn184.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn184.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[184]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[184]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[184]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[184]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn184.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.DataTypeConversion3_l);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 3");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Tx Var 3");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn184.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATTxVar3_P1_S_i);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled63);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled25);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled3);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATTxVar3_IWORK_e[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn184.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn184.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATTxVar3_IWORK_e[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Tx Var 4 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[185];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn185.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn185.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn185.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[185]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[185]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[185]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[185]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn185.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.DataTypeConversion4_f);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 4");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Tx Var 4");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn185.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATTxVar4_P1__bt);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled65);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled13);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled15);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATTxVar4_IWORK_d[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn185.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn185.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATTxVar4_IWORK_d[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }

    /* Level2 S-Function Block: Walking_ATRIAS/<S69>/EtherCAT Tx Var 5 (xpcethercatpdotx) */
    {
      SimStruct *rts = Walking_ATRIAS_M->childSfunctions[186];

      /* timing info */
      time_T *sfcnPeriod = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn186.sfcnPeriod;
      time_T *sfcnOffset = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn186.sfcnOffset;
      int_T *sfcnTsMap = Walking_ATRIAS_M->NonInlinedSFcns.Sfcn186.sfcnTsMap;
      (void) memset((void*)sfcnPeriod, 0,
                    sizeof(time_T)*1);
      (void) memset((void*)sfcnOffset, 0,
                    sizeof(time_T)*1);
      ssSetSampleTimePtr(rts, &sfcnPeriod[0]);
      ssSetOffsetTimePtr(rts, &sfcnOffset[0]);
      ssSetSampleTimeTaskIDPtr(rts, sfcnTsMap);

      /* Set up the mdlInfo pointer */
      {
        ssSetBlkInfo2Ptr(rts, &Walking_ATRIAS_M->NonInlinedSFcns.blkInfo2[186]);
      }

      ssSetRTWSfcnInfo(rts, Walking_ATRIAS_M->sfcnInfo);

      /* Allocate memory of model methods 2 */
      {
        ssSetModelMethods2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods2[186]);
      }

      /* Allocate memory of model methods 3 */
      {
        ssSetModelMethods3(rts, &Walking_ATRIAS_M->NonInlinedSFcns.methods3[186]);
      }

      /* Allocate memory for states auxilliary information */
      {
        ssSetStatesInfo2(rts, &Walking_ATRIAS_M->NonInlinedSFcns.statesInfo2[186]);
      }

      /* inputs */
      {
        _ssSetNumInputPorts(rts, 1);
        ssSetPortInfoForInputs(rts,
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn186.inputPortInfo[0]);

        /* port 0 */
        {
          ssSetInputPortRequiredContiguous(rts, 0, 1);
          ssSetInputPortSignal(rts, 0, &Walking_ATRIAS_B.DataTypeConversion5_b);
          _ssSetInputPortNumDimensions(rts, 0, 1);
          ssSetInputPortWidth(rts, 0, 1);
        }
      }

      /* path info */
      ssSetModelName(rts, "EtherCAT Tx Var 5");
      ssSetPath(rts,
                "Walking_ATRIAS/Subsystem1/Subsystem/EtherCATRobotMicrostrain/LegMedulla_2R/EtherCAT Tx Var 5");
      ssSetRTModel(rts,Walking_ATRIAS_M);
      ssSetParentSS(rts, (NULL));
      ssSetRootSS(rts, rts);
      ssSetVersion(rts, SIMSTRUCT_VERSION_LEVEL2);

      /* parameters */
      {
        mxArray **sfcnParams = (mxArray **)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn186.params;
        ssSetSFcnParamsCount(rts, 7);
        ssSetSFcnParamsPtr(rts, &sfcnParams[0]);
        ssSetSFcnParam(rts, 0, (mxArray*)
                       Walking_ATRIAS_ConstP.EtherCATTxVar5_P1_S_k);
        ssSetSFcnParam(rts, 1, (mxArray*)Walking_ATRIAS_ConstP.pooled69);
        ssSetSFcnParam(rts, 2, (mxArray*)Walking_ATRIAS_ConstP.pooled71);
        ssSetSFcnParam(rts, 3, (mxArray*)Walking_ATRIAS_ConstP.pooled5);
        ssSetSFcnParam(rts, 4, (mxArray*)Walking_ATRIAS_ConstP.pooled7);
        ssSetSFcnParam(rts, 5, (mxArray*)Walking_ATRIAS_ConstP.pooled9);
        ssSetSFcnParam(rts, 6, (mxArray*)Walking_ATRIAS_ConstP.pooled11);
      }

      /* work vectors */
      ssSetIWork(rts, (int_T *) &Walking_ATRIAS_DW.EtherCATTxVar5_IWORK_a3[0]);

      {
        struct _ssDWorkRecord *dWorkRecord = (struct _ssDWorkRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn186.dWork;
        struct _ssDWorkAuxRecord *dWorkAuxRecord = (struct _ssDWorkAuxRecord *)
          &Walking_ATRIAS_M->NonInlinedSFcns.Sfcn186.dWorkAux;
        ssSetSFcnDWork(rts, dWorkRecord);
        ssSetSFcnDWorkAux(rts, dWorkAuxRecord);
        _ssSetNumDWork(rts, 1);

        /* IWORK */
        ssSetDWorkWidth(rts, 0, 7);
        ssSetDWorkDataType(rts, 0,SS_INTEGER);
        ssSetDWorkComplexSignal(rts, 0, 0);
        ssSetDWork(rts, 0, &Walking_ATRIAS_DW.EtherCATTxVar5_IWORK_a3[0]);
      }

      /* registration */
      xpcethercatpdotx(rts);
      sfcnInitializeSizes(rts);
      sfcnInitializeSampleTimes(rts);

      /* adjust sample time */
      ssSetSampleTime(rts, 0, 0.001);
      ssSetOffsetTime(rts, 0, 0.0);
      sfcnTsMap[0] = 0;

      /* set compiled values of dynamic vector attributes */
      ssSetNumNonsampledZCs(rts, 0);

      /* Update connectivity flags for each port */
      _ssSetInputPortConnected(rts, 0, 1);

      /* Update the BufferDstPort flags for each input port */
      ssSetInputPortBufferDstPort(rts, 0, -1);
    }
  }

  /* Initialize Sizes */
  Walking_ATRIAS_M->Sizes.numContStates = (0);/* Number of continuous states */
  Walking_ATRIAS_M->Sizes.numY = (143);/* Number of model outputs */
  Walking_ATRIAS_M->Sizes.numU = (0);  /* Number of model inputs */
  Walking_ATRIAS_M->Sizes.sysDirFeedThru = (0);/* The model is not direct feedthrough */
  Walking_ATRIAS_M->Sizes.numSampTimes = (1);/* Number of sample times */
  Walking_ATRIAS_M->Sizes.numBlocks = (652);/* Number of blocks */
  Walking_ATRIAS_M->Sizes.numBlockIO = (466);/* Number of block outputs */
  Walking_ATRIAS_M->Sizes.numBlockPrms = (439);/* Sum of parameter "widths" */
  return Walking_ATRIAS_M;
}

/*========================================================================*
 * End of Classic call interface                                          *
 *========================================================================*/
